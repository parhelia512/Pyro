{===============================================================================
  ___              
 | _ \_  _ _ _ ___ 
 |  _/ || | '_/ _ \
 |_|  \_, |_| \___/
      |__/         
   Game Library™

 Copyright © 2024-present tinyBigGAMES™ LLC
 All Rights Reserved.

 https://github.com/tinyBigGAMES/Pyro

 BSD 3-Clause License

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 3. Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.

-------------------------------------------------------------------------------

 This project uses the following open-source libraries:
 * cimgui       - https://github.com/cimgui/cimgui
 * cute_headers - https://github.com/RandyGaul/cute_headers
 * glfw         - https://github.com/glfw/glfw
 * luajit       - https://github.com/LuaJIT/LuaJIT
 * miniaudio    - https://github.com/mackron/miniaudio
 * pl_mpeg      - https://github.com/phoboslab/pl_mpeg
 * spine-c      - https://github.com/EsotericSoftware/spine-runtimes
 * sqlite       - https://github.com/sqlite/sqlite
 * stb          - https://github.com/nothings/stb
 * zlib         - https://github.com/madler/zlib
 
-------------------------------------------------------------------------------

 >>> CHANGELOG <<<
 =================
 
 Version 0.1.0:
  - Initial release
 
===============================================================================}

unit Pyro;

{$IF CompilerVersion >= 36.0}
  // Code specific to Delphi Athens (12.2) and above
{$ELSE}
  {$MESSAGE ERROR 'This code requires  Delphi Athens (12.2) or later'}
{$IFEND}

{$IFNDEF WIN64}
  // Generates a compile-time error if the target platform is not Win64
  {$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

{$Z4}  // Sets the enumeration size to 4 bytes
{$A8}  // Sets the alignment for record fields to 8 bytes

{$WARN SYMBOL_DEPRECATED OFF}
{$WARN SYMBOL_PLATFORM OFF}

{$WARN UNIT_PLATFORM OFF}
{$WARN UNIT_DEPRECATED OFF}

interface

{$REGION ' Uses '}
uses
  WinApi.Windows,
  WinApi.Messages,
  System.Types,
  System.SysUtils,
  System.Classes,
  System.IOUtils,
  System.Math,
  System.SyncObjs,
  System.Rtti,
  System.TypInfo,
  System.AnsiStrings,
  System.JSON,
  System.Net.HttpClient,
  System.IniFiles,
  System.Generics.Collections;
{$ENDREGION}

{$REGION ' Pyro.OpenGL '}
var
  glVersionMajor, glVersionMinor: integer;

type
  GLVULKANPROCNV = pointer;
  GLbitfield = uint32;
  GLboolean = byte;
  GLbyte = int8;
  GLchar = char;
  GLcharARB = byte;
  GLclampd = double;
  GLclampf = single;
  GLclampx = int32;
  GLdouble = double;
  GLeglClientBufferEXT = pointer;
  GLeglImageOES = pointer;
  GLenum = uint32;
  GLfixed = int32;
  GLfloat = single;
  GLhalf = uint16;
  GLhalfARB = uint16;
  GLhalfNV = uint16;
  GLhandleARB = uint32;
  GLint = int32;
  GLint64 = int64;
  GLint64EXT = int64;
  GLintptr = int32;
  GLintptrARB = int32;
  GLshort = int16;
  GLsizei = int32;
  GLsizeiptr = int32;
  GLsizeiptrARB = int32;
  GLsync = pointer;
  GLubyte = uint8;
  GLuint = uint32;
  GLuint64 = uint64;
  GLuint64EXT = uint64;
  GLushort = uint16;
  GLvdpauSurfaceNV = int32;
  GLvoid = pointer;
  _cl_context = pointer;
  _cl_event = pointer;

  PGLVULKANPROCNV = ^pointer;
  PGLbitfield = ^uint32;
  PGLboolean = ^byte;
  PGLbyte = ^int8;
  PGLchar = ^char;
  PGLcharARB = ^byte;
  PGLclampd = ^double;
  PGLclampf = ^single;
  PGLclampx = ^int32;
  PGLdouble = ^double;
  PGLeglClientBufferEXT = ^pointer;
  PGLeglImageOES = ^pointer;
  PGLenum = ^uint32;
  PGLfixed = ^int32;
  PGLfloat = ^single;
  PGLhalf = ^uint16;
  PGLhalfARB = ^uint16;
  PGLhalfNV = ^uint16;
  PGLhandleARB = ^uint32;
  PGLint = ^int32;
  PGLint64 = ^int64;
  PGLint64EXT = ^int64;
  PGLintptr = ^int32;
  PGLintptrARB = ^int32;
  PGLshort = ^int16;
  PGLsizei = ^int32;
  PGLsizeiptr = ^int32;
  PGLsizeiptrARB = ^int32;
  PGLsync = ^pointer;
  PGLubyte = ^uint8;
  PGLuint = ^uint32;
  PGLuint64 = ^uint64;
  PGLuint64EXT = ^uint64;
  PGLushort = ^uint16;
  PGLvdpauSurfaceNV = ^int32;
  PGLvoid = ^pointer;
  P_cl_context = ^pointer;
  P_cl_event = ^pointer;
  PPGLchar = ^PGLchar;
  PPGLcharARB = ^PGLcharARB;
  PPGLboolean = ^PGLboolean;

  GLdebugProc = procedure (
    source: GLenum;
    typ: GLenum;
    id: GLuint;
    severity: GLenum;
    length: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;
  GLdebugProcArb = GLdebugProc;
  GLdebugProcKhr = GLdebugProc;

  GLdebugProcAmd = procedure (
    id: GLuint;
    category: GLenum;
    severity: GLenum;
    len: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;

const
  GL_FALSE = 0;
  GL_INVALID_INDEX = uint32($FFFFFFFF);
  GL_NONE = 0;
  GL_NONE_OES = 0;
  GL_NO_ERROR = 0;
  GL_ONE = 1;
  GL_TIMEOUT_IGNORED = uint64($FFFFFFFFFFFFFFFF);
  GL_TIMEOUT_IGNORED_APPLE = uint64($FFFFFFFFFFFFFFFF);
  GL_TRUE = 1;
  GL_VERSION_ES_CL_1_0 = 1;
  GL_VERSION_ES_CL_1_1 = 1;
  GL_VERSION_ES_CM_1_1 = 1;
  GL_ZERO = 0;

  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_QUADS = $0007;
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_FRONT_LEFT = $0400;
  GL_FRONT_RIGHT = $0401;
  GL_BACK_LEFT = $0402;
  GL_BACK_RIGHT = $0403;
  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_LEFT = $0406;
  GL_RIGHT = $0407;
  GL_FRONT_AND_BACK = $0408;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_OUT_OF_MEMORY = $0505;
  GL_CW = $0900;
  GL_CCW = $0901;
  GL_POINT_SIZE = $0B11;
  GL_POINT_SIZE_RANGE = $0B12;
  GL_POINT_SIZE_GRANULARITY = $0B13;
  GL_LINE_SMOOTH = $0B20;
  GL_LINE_WIDTH = $0B21;
  GL_LINE_WIDTH_RANGE = $0B22;
  GL_LINE_WIDTH_GRANULARITY = $0B23;
  GL_POLYGON_MODE = $0B40;
  GL_POLYGON_SMOOTH = $0B41;
  GL_CULL_FACE = $0B44;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_TEST = $0B71;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_STENCIL_TEST = $0B90;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_VIEWPORT = $0BA2;
  GL_DITHER = $0BD0;
  GL_BLEND_DST = $0BE0;
  GL_BLEND_SRC = $0BE1;
  GL_BLEND = $0BE2;
  GL_LOGIC_OP_MODE = $0BF0;
  GL_DRAW_BUFFER = $0C01;
  GL_READ_BUFFER = $0C02;
  GL_SCISSOR_BOX = $0C10;
  GL_SCISSOR_TEST = $0C11;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_DOUBLEBUFFER = $0C32;
  GL_STEREO = $0C33;
  GL_LINE_SMOOTH_HINT = $0C52;
  GL_POLYGON_SMOOTH_HINT = $0C53;
  GL_UNPACK_SWAP_BYTES = $0CF0;
  GL_UNPACK_LSB_FIRST = $0CF1;
  GL_UNPACK_ROW_LENGTH = $0CF2;
  GL_UNPACK_SKIP_ROWS = $0CF3;
  GL_UNPACK_SKIP_PIXELS = $0CF4;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_SWAP_BYTES = $0D00;
  GL_PACK_LSB_FIRST = $0D01;
  GL_PACK_ROW_LENGTH = $0D02;
  GL_PACK_SKIP_ROWS = $0D03;
  GL_PACK_SKIP_PIXELS = $0D04;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_SUBPIXEL_BITS = $0D50;
  GL_TEXTURE_1D = $0DE0;
  GL_TEXTURE_2D = $0DE1;
  GL_TEXTURE_WIDTH = $1000;
  GL_TEXTURE_HEIGHT = $1001;
  GL_TEXTURE_BORDER_COLOR = $1004;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_STACK_OVERFLOW = $0503;
  GL_STACK_UNDERFLOW = $0504;
  GL_CLEAR = $1500;
  GL_AND = $1501;
  GL_AND_REVERSE = $1502;
  GL_COPY = $1503;
  GL_AND_INVERTED = $1504;
  GL_NOOP = $1505;
  GL_XOR = $1506;
  GL_OR = $1507;
  GL_NOR = $1508;
  GL_EQUIV = $1509;
  GL_INVERT = $150A;
  GL_OR_REVERSE = $150B;
  GL_COPY_INVERTED = $150C;
  GL_OR_INVERTED = $150D;
  GL_NAND = $150E;
  GL_SET = $150F;
  GL_TEXTURE = $1702;
  GL_COLOR = $1800;
  GL_DEPTH = $1801;
  GL_STENCIL = $1802;
  GL_STENCIL_INDEX = $1901;
  GL_DEPTH_COMPONENT = $1902;
  GL_RED = $1903;
  GL_GREEN = $1904;
  GL_BLUE = $1905;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_POINT = $1B00;
  GL_LINE = $1B01;
  GL_FILL = $1B02;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_REPEAT = $2901;
  GL_CURRENT_BIT = $00000001;
  GL_POINT_BIT = $00000002;
  GL_LINE_BIT = $00000004;
  GL_POLYGON_BIT = $00000008;
  GL_POLYGON_STIPPLE_BIT = $00000010;
  GL_PIXEL_MODE_BIT = $00000020;
  GL_LIGHTING_BIT = $00000040;
  GL_FOG_BIT = $00000080;
  GL_ACCUM_BUFFER_BIT = $00000200;
  GL_VIEWPORT_BIT = $00000800;
  GL_TRANSFORM_BIT = $00001000;
  GL_ENABLE_BIT = $00002000;
  GL_HINT_BIT = $00008000;
  GL_EVAL_BIT = $00010000;
  GL_LIST_BIT = $00020000;
  GL_TEXTURE_BIT = $00040000;
  GL_SCISSOR_BIT = $00080000;
  GL_ALL_ATTRIB_BITS = $FFFFFFFF;
  GL_QUAD_STRIP = $0008;
  GL_POLYGON = $0009;
  GL_ACCUM = $0100;
  GL_LOAD = $0101;
  GL_RETURN = $0102;
  GL_MULT = $0103;
  GL_ADD = $0104;
  GL_AUX0 = $0409;
  GL_AUX1 = $040A;
  GL_AUX2 = $040B;
  GL_AUX3 = $040C;
  GL_2D = $0600;
  GL_3D = $0601;
  GL_3D_COLOR = $0602;
  GL_3D_COLOR_TEXTURE = $0603;
  GL_4D_COLOR_TEXTURE = $0604;
  GL_PASS_THROUGH_TOKEN = $0700;
  GL_POINT_TOKEN = $0701;
  GL_LINE_TOKEN = $0702;
  GL_POLYGON_TOKEN = $0703;
  GL_BITMAP_TOKEN = $0704;
  GL_DRAW_PIXEL_TOKEN = $0705;
  GL_COPY_PIXEL_TOKEN = $0706;
  GL_LINE_RESET_TOKEN = $0707;
  GL_EXP = $0800;
  GL_EXP2 = $0801;
  GL_COEFF = $0A00;
  GL_ORDER = $0A01;
  GL_DOMAIN = $0A02;
  GL_PIXEL_MAP_I_TO_I = $0C70;
  GL_PIXEL_MAP_S_TO_S = $0C71;
  GL_PIXEL_MAP_I_TO_R = $0C72;
  GL_PIXEL_MAP_I_TO_G = $0C73;
  GL_PIXEL_MAP_I_TO_B = $0C74;
  GL_PIXEL_MAP_I_TO_A = $0C75;
  GL_PIXEL_MAP_R_TO_R = $0C76;
  GL_PIXEL_MAP_G_TO_G = $0C77;
  GL_PIXEL_MAP_B_TO_B = $0C78;
  GL_PIXEL_MAP_A_TO_A = $0C79;
  GL_CURRENT_COLOR = $0B00;
  GL_CURRENT_INDEX = $0B01;
  GL_CURRENT_NORMAL = $0B02;
  GL_CURRENT_TEXTURE_COORDS = $0B03;
  GL_CURRENT_RASTER_COLOR = $0B04;
  GL_CURRENT_RASTER_INDEX = $0B05;
  GL_CURRENT_RASTER_TEXTURE_COORDS = $0B06;
  GL_CURRENT_RASTER_POSITION = $0B07;
  GL_CURRENT_RASTER_POSITION_VALID = $0B08;
  GL_CURRENT_RASTER_DISTANCE = $0B09;
  GL_POINT_SMOOTH = $0B10;
  GL_LINE_STIPPLE = $0B24;
  GL_LINE_STIPPLE_PATTERN = $0B25;
  GL_LINE_STIPPLE_REPEAT = $0B26;
  GL_LIST_MODE = $0B30;
  GL_MAX_LIST_NESTING = $0B31;
  GL_LIST_BASE = $0B32;
  GL_LIST_INDEX = $0B33;
  GL_POLYGON_STIPPLE = $0B42;
  GL_EDGE_FLAG = $0B43;
  GL_LIGHTING = $0B50;
  GL_LIGHT_MODEL_LOCAL_VIEWER = $0B51;
  GL_LIGHT_MODEL_TWO_SIDE = $0B52;
  GL_LIGHT_MODEL_AMBIENT = $0B53;
  GL_SHADE_MODEL = $0B54;
  GL_COLOR_MATERIAL_FACE = $0B55;
  GL_COLOR_MATERIAL_PARAMETER = $0B56;
  GL_COLOR_MATERIAL = $0B57;
  GL_FOG = $0B60;
  GL_FOG_INDEX = $0B61;
  GL_FOG_DENSITY = $0B62;
  GL_FOG_START = $0B63;
  GL_FOG_END = $0B64;
  GL_FOG_MODE = $0B65;
  GL_FOG_COLOR = $0B66;
  GL_ACCUM_CLEAR_VALUE = $0B80;
  GL_MATRIX_MODE = $0BA0;
  GL_NORMALIZE = $0BA1;
  GL_MODELVIEW_STACK_DEPTH = $0BA3;
  GL_PROJECTION_STACK_DEPTH = $0BA4;
  GL_TEXTURE_STACK_DEPTH = $0BA5;
  GL_MODELVIEW_MATRIX = $0BA6;
  GL_PROJECTION_MATRIX = $0BA7;
  GL_TEXTURE_MATRIX = $0BA8;
  GL_ATTRIB_STACK_DEPTH = $0BB0;
  GL_ALPHA_TEST = $0BC0;
  GL_ALPHA_TEST_FUNC = $0BC1;
  GL_ALPHA_TEST_REF = $0BC2;
  GL_LOGIC_OP = $0BF1;
  GL_AUX_BUFFERS = $0C00;
  GL_INDEX_CLEAR_VALUE = $0C20;
  GL_INDEX_WRITEMASK = $0C21;
  GL_INDEX_MODE = $0C30;
  GL_RGBA_MODE = $0C31;
  GL_RENDER_MODE = $0C40;
  GL_PERSPECTIVE_CORRECTION_HINT = $0C50;
  GL_POINT_SMOOTH_HINT = $0C51;
  GL_FOG_HINT = $0C54;
  GL_TEXTURE_GEN_S = $0C60;
  GL_TEXTURE_GEN_T = $0C61;
  GL_TEXTURE_GEN_R = $0C62;
  GL_TEXTURE_GEN_Q = $0C63;
  GL_PIXEL_MAP_I_TO_I_SIZE = $0CB0;
  GL_PIXEL_MAP_S_TO_S_SIZE = $0CB1;
  GL_PIXEL_MAP_I_TO_R_SIZE = $0CB2;
  GL_PIXEL_MAP_I_TO_G_SIZE = $0CB3;
  GL_PIXEL_MAP_I_TO_B_SIZE = $0CB4;
  GL_PIXEL_MAP_I_TO_A_SIZE = $0CB5;
  GL_PIXEL_MAP_R_TO_R_SIZE = $0CB6;
  GL_PIXEL_MAP_G_TO_G_SIZE = $0CB7;
  GL_PIXEL_MAP_B_TO_B_SIZE = $0CB8;
  GL_PIXEL_MAP_A_TO_A_SIZE = $0CB9;
  GL_MAP_COLOR = $0D10;
  GL_MAP_STENCIL = $0D11;
  GL_INDEX_SHIFT = $0D12;
  GL_INDEX_OFFSET = $0D13;
  GL_RED_SCALE = $0D14;
  GL_RED_BIAS = $0D15;
  GL_ZOOM_X = $0D16;
  GL_ZOOM_Y = $0D17;
  GL_GREEN_SCALE = $0D18;
  GL_GREEN_BIAS = $0D19;
  GL_BLUE_SCALE = $0D1A;
  GL_BLUE_BIAS = $0D1B;
  GL_ALPHA_SCALE = $0D1C;
  GL_ALPHA_BIAS = $0D1D;
  GL_DEPTH_SCALE = $0D1E;
  GL_DEPTH_BIAS = $0D1F;
  GL_MAX_EVAL_ORDER = $0D30;
  GL_MAX_LIGHTS = $0D31;
  GL_MAX_CLIP_PLANES = $0D32;
  GL_MAX_PIXEL_MAP_TABLE = $0D34;
  GL_MAX_ATTRIB_STACK_DEPTH = $0D35;
  GL_MAX_MODELVIEW_STACK_DEPTH = $0D36;
  GL_MAX_NAME_STACK_DEPTH = $0D37;
  GL_MAX_PROJECTION_STACK_DEPTH = $0D38;
  GL_MAX_TEXTURE_STACK_DEPTH = $0D39;
  GL_INDEX_BITS = $0D51;
  GL_RED_BITS = $0D52;
  GL_GREEN_BITS = $0D53;
  GL_BLUE_BITS = $0D54;
  GL_ALPHA_BITS = $0D55;
  GL_DEPTH_BITS = $0D56;
  GL_STENCIL_BITS = $0D57;
  GL_ACCUM_RED_BITS = $0D58;
  GL_ACCUM_GREEN_BITS = $0D59;
  GL_ACCUM_BLUE_BITS = $0D5A;
  GL_ACCUM_ALPHA_BITS = $0D5B;
  GL_NAME_STACK_DEPTH = $0D70;
  GL_AUTO_NORMAL = $0D80;
  GL_MAP1_COLOR_4 = $0D90;
  GL_MAP1_INDEX = $0D91;
  GL_MAP1_NORMAL = $0D92;
  GL_MAP1_TEXTURE_COORD_1 = $0D93;
  GL_MAP1_TEXTURE_COORD_2 = $0D94;
  GL_MAP1_TEXTURE_COORD_3 = $0D95;
  GL_MAP1_TEXTURE_COORD_4 = $0D96;
  GL_MAP1_VERTEX_3 = $0D97;
  GL_MAP1_VERTEX_4 = $0D98;
  GL_MAP2_COLOR_4 = $0DB0;
  GL_MAP2_INDEX = $0DB1;
  GL_MAP2_NORMAL = $0DB2;
  GL_MAP2_TEXTURE_COORD_1 = $0DB3;
  GL_MAP2_TEXTURE_COORD_2 = $0DB4;
  GL_MAP2_TEXTURE_COORD_3 = $0DB5;
  GL_MAP2_TEXTURE_COORD_4 = $0DB6;
  GL_MAP2_VERTEX_3 = $0DB7;
  GL_MAP2_VERTEX_4 = $0DB8;
  GL_MAP1_GRID_DOMAIN = $0DD0;
  GL_MAP1_GRID_SEGMENTS = $0DD1;
  GL_MAP2_GRID_DOMAIN = $0DD2;
  GL_MAP2_GRID_SEGMENTS = $0DD3;
  GL_TEXTURE_COMPONENTS = $1003;
  GL_TEXTURE_BORDER = $1005;
  GL_AMBIENT = $1200;
  GL_DIFFUSE = $1201;
  GL_SPECULAR = $1202;
  GL_POSITION = $1203;
  GL_SPOT_DIRECTION = $1204;
  GL_SPOT_EXPONENT = $1205;
  GL_SPOT_CUTOFF = $1206;
  GL_CONSTANT_ATTENUATION = $1207;
  GL_LINEAR_ATTENUATION = $1208;
  GL_QUADRATIC_ATTENUATION = $1209;
  GL_COMPILE = $1300;
  GL_COMPILE_AND_EXECUTE = $1301;
  GL_2_BYTES = $1407;
  GL_3_BYTES = $1408;
  GL_4_BYTES = $1409;
  GL_EMISSION = $1600;
  GL_SHININESS = $1601;
  GL_AMBIENT_AND_DIFFUSE = $1602;
  GL_COLOR_INDEXES = $1603;
  GL_MODELVIEW = $1700;
  GL_PROJECTION = $1701;
  GL_COLOR_INDEX = $1900;
  GL_LUMINANCE = $1909;
  GL_LUMINANCE_ALPHA = $190A;
  GL_BITMAP = $1A00;
  GL_RENDER = $1C00;
  GL_FEEDBACK = $1C01;
  GL_SELECT = $1C02;
  GL_FLAT = $1D00;
  GL_SMOOTH = $1D01;
  GL_S = $2000;
  GL_T = $2001;
  GL_R = $2002;
  GL_Q = $2003;
  GL_MODULATE = $2100;
  GL_DECAL = $2101;
  GL_TEXTURE_ENV_MODE = $2200;
  GL_TEXTURE_ENV_COLOR = $2201;
  GL_TEXTURE_ENV = $2300;
  GL_EYE_LINEAR = $2400;
  GL_OBJECT_LINEAR = $2401;
  GL_SPHERE_MAP = $2402;
  GL_TEXTURE_GEN_MODE = $2500;
  GL_OBJECT_PLANE = $2501;
  GL_EYE_PLANE = $2502;
  GL_CLAMP = $2900;
  GL_CLIP_PLANE0 = $3000;
  GL_CLIP_PLANE1 = $3001;
  GL_CLIP_PLANE2 = $3002;
  GL_CLIP_PLANE3 = $3003;
  GL_CLIP_PLANE4 = $3004;
  GL_CLIP_PLANE5 = $3005;
  GL_LIGHT0 = $4000;
  GL_LIGHT1 = $4001;
  GL_LIGHT2 = $4002;
  GL_LIGHT3 = $4003;
  GL_LIGHT4 = $4004;
  GL_LIGHT5 = $4005;
  GL_LIGHT6 = $4006;
  GL_LIGHT7 = $4007;
  GL_COLOR_LOGIC_OP = $0BF2;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_POINT = $2A01;
  GL_POLYGON_OFFSET_LINE = $2A02;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_TEXTURE_BINDING_1D = $8068;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_TEXTURE_INTERNAL_FORMAT = $1003;
  GL_TEXTURE_RED_SIZE = $805C;
  GL_TEXTURE_GREEN_SIZE = $805D;
  GL_TEXTURE_BLUE_SIZE = $805E;
  GL_TEXTURE_ALPHA_SIZE = $805F;
  GL_DOUBLE = $140A;
  GL_PROXY_TEXTURE_1D = $8063;
  GL_PROXY_TEXTURE_2D = $8064;
  GL_R3_G3_B2 = $2A10;
  GL_RGB4 = $804F;
  GL_RGB5 = $8050;
  GL_RGB8 = $8051;
  GL_RGB10 = $8052;
  GL_RGB12 = $8053;
  GL_RGB16 = $8054;
  GL_RGBA2 = $8055;
  GL_RGBA4 = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGBA8 = $8058;
  GL_RGB10_A2 = $8059;
  GL_RGBA12 = $805A;
  GL_RGBA16 = $805B;
  GL_CLIENT_PIXEL_STORE_BIT = $00000001;
  GL_CLIENT_VERTEX_ARRAY_BIT = $00000002;
  GL_CLIENT_ALL_ATTRIB_BITS = $FFFFFFFF;
  GL_VERTEX_ARRAY_POINTER = $808E;
  GL_NORMAL_ARRAY_POINTER = $808F;
  GL_COLOR_ARRAY_POINTER = $8090;
  GL_INDEX_ARRAY_POINTER = $8091;
  GL_TEXTURE_COORD_ARRAY_POINTER = $8092;
  GL_EDGE_FLAG_ARRAY_POINTER = $8093;
  GL_FEEDBACK_BUFFER_POINTER = $0DF0;
  GL_SELECTION_BUFFER_POINTER = $0DF3;
  GL_CLIENT_ATTRIB_STACK_DEPTH = $0BB1;
  GL_INDEX_LOGIC_OP = $0BF1;
  GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = $0D3B;
  GL_FEEDBACK_BUFFER_SIZE = $0DF1;
  GL_FEEDBACK_BUFFER_TYPE = $0DF2;
  GL_SELECTION_BUFFER_SIZE = $0DF4;
  GL_VERTEX_ARRAY = $8074;
  GL_NORMAL_ARRAY = $8075;
  GL_COLOR_ARRAY = $8076;
  GL_INDEX_ARRAY = $8077;
  GL_TEXTURE_COORD_ARRAY = $8078;
  GL_EDGE_FLAG_ARRAY = $8079;
  GL_VERTEX_ARRAY_SIZE = $807A;
  GL_VERTEX_ARRAY_TYPE = $807B;
  GL_VERTEX_ARRAY_STRIDE = $807C;
  GL_NORMAL_ARRAY_TYPE = $807E;
  GL_NORMAL_ARRAY_STRIDE = $807F;
  GL_COLOR_ARRAY_SIZE = $8081;
  GL_COLOR_ARRAY_TYPE = $8082;
  GL_COLOR_ARRAY_STRIDE = $8083;
  GL_INDEX_ARRAY_TYPE = $8085;
  GL_INDEX_ARRAY_STRIDE = $8086;
  GL_TEXTURE_COORD_ARRAY_SIZE = $8088;
  GL_TEXTURE_COORD_ARRAY_TYPE = $8089;
  GL_TEXTURE_COORD_ARRAY_STRIDE = $808A;
  GL_EDGE_FLAG_ARRAY_STRIDE = $808C;
  GL_TEXTURE_LUMINANCE_SIZE = $8060;
  GL_TEXTURE_INTENSITY_SIZE = $8061;
  GL_TEXTURE_PRIORITY = $8066;
  GL_TEXTURE_RESIDENT = $8067;
  GL_ALPHA4 = $803B;
  GL_ALPHA8 = $803C;
  GL_ALPHA12 = $803D;
  GL_ALPHA16 = $803E;
  GL_LUMINANCE4 = $803F;
  GL_LUMINANCE8 = $8040;
  GL_LUMINANCE12 = $8041;
  GL_LUMINANCE16 = $8042;
  GL_LUMINANCE4_ALPHA4 = $8043;
  GL_LUMINANCE6_ALPHA2 = $8044;
  GL_LUMINANCE8_ALPHA8 = $8045;
  GL_LUMINANCE12_ALPHA4 = $8046;
  GL_LUMINANCE12_ALPHA12 = $8047;
  GL_LUMINANCE16_ALPHA16 = $8048;
  GL_INTENSITY = $8049;
  GL_INTENSITY4 = $804A;
  GL_INTENSITY8 = $804B;
  GL_INTENSITY12 = $804C;
  GL_INTENSITY16 = $804D;
  GL_V2F = $2A20;
  GL_V3F = $2A21;
  GL_C4UB_V2F = $2A22;
  GL_C4UB_V3F = $2A23;
  GL_C3F_V3F = $2A24;
  GL_N3F_V3F = $2A25;
  GL_C4F_N3F_V3F = $2A26;
  GL_T2F_V3F = $2A27;
  GL_T4F_V4F = $2A28;
  GL_T2F_C4UB_V3F = $2A29;
  GL_T2F_C3F_V3F = $2A2A;
  GL_T2F_N3F_V3F = $2A2B;
  GL_T2F_C4F_N3F_V3F = $2A2C;
  GL_T4F_C4F_N3F_V4F = $2A2D;
  GL_UNSIGNED_BYTE_3_3_2 = $8032;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_INT_8_8_8_8 = $8035;
  GL_UNSIGNED_INT_10_10_10_2 = $8036;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_PACK_SKIP_IMAGES = $806B;
  GL_PACK_IMAGE_HEIGHT = $806C;
  GL_UNPACK_SKIP_IMAGES = $806D;
  GL_UNPACK_IMAGE_HEIGHT = $806E;
  GL_TEXTURE_3D = $806F;
  GL_PROXY_TEXTURE_3D = $8070;
  GL_TEXTURE_DEPTH = $8071;
  GL_TEXTURE_WRAP_R = $8072;
  GL_MAX_3D_TEXTURE_SIZE = $8073;
  GL_UNSIGNED_BYTE_2_3_3_REV = $8362;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_UNSIGNED_SHORT_5_6_5_REV = $8364;
  GL_UNSIGNED_SHORT_4_4_4_4_REV = $8365;
  GL_UNSIGNED_SHORT_1_5_5_5_REV = $8366;
  GL_UNSIGNED_INT_8_8_8_8_REV = $8367;
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_BGR = $80E0;
  GL_BGRA = $80E1;
  GL_MAX_ELEMENTS_VERTICES = $80E8;
  GL_MAX_ELEMENTS_INDICES = $80E9;
  GL_CLAMP_TO_EDGE = $812F;
  GL_TEXTURE_MIN_LOD = $813A;
  GL_TEXTURE_MAX_LOD = $813B;
  GL_TEXTURE_BASE_LEVEL = $813C;
  GL_TEXTURE_MAX_LEVEL = $813D;
  GL_SMOOTH_POINT_SIZE_RANGE = $0B12;
  GL_SMOOTH_POINT_SIZE_GRANULARITY = $0B13;
  GL_SMOOTH_LINE_WIDTH_RANGE = $0B22;
  GL_SMOOTH_LINE_WIDTH_GRANULARITY = $0B23;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  GL_RESCALE_NORMAL = $803A;
  GL_LIGHT_MODEL_COLOR_CONTROL = $81F8;
  GL_SINGLE_COLOR = $81F9;
  GL_SEPARATE_SPECULAR_COLOR = $81FA;
  GL_ALIASED_POINT_SIZE_RANGE = $846D;
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_MULTISAMPLE = $809D;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_ALPHA_TO_ONE = $809F;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_COMPRESSED_RGB = $84ED;
  GL_COMPRESSED_RGBA = $84EE;
  GL_TEXTURE_COMPRESSION_HINT = $84EF;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE = $86A0;
  GL_TEXTURE_COMPRESSED = $86A1;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_CLAMP_TO_BORDER = $812D;
  GL_CLIENT_ACTIVE_TEXTURE = $84E1;
  GL_MAX_TEXTURE_UNITS = $84E2;
  GL_TRANSPOSE_MODELVIEW_MATRIX = $84E3;
  GL_TRANSPOSE_PROJECTION_MATRIX = $84E4;
  GL_TRANSPOSE_TEXTURE_MATRIX = $84E5;
  GL_TRANSPOSE_COLOR_MATRIX = $84E6;
  GL_MULTISAMPLE_BIT = $20000000;
  GL_NORMAL_MAP = $8511;
  GL_REFLECTION_MAP = $8512;
  GL_COMPRESSED_ALPHA = $84E9;
  GL_COMPRESSED_LUMINANCE = $84EA;
  GL_COMPRESSED_LUMINANCE_ALPHA = $84EB;
  GL_COMPRESSED_INTENSITY = $84EC;
  GL_COMBINE = $8570;
  GL_COMBINE_RGB = $8571;
  GL_COMBINE_ALPHA = $8572;
  GL_SOURCE0_RGB = $8580;
  GL_SOURCE1_RGB = $8581;
  GL_SOURCE2_RGB = $8582;
  GL_SOURCE0_ALPHA = $8588;
  GL_SOURCE1_ALPHA = $8589;
  GL_SOURCE2_ALPHA = $858A;
  GL_OPERAND0_RGB = $8590;
  GL_OPERAND1_RGB = $8591;
  GL_OPERAND2_RGB = $8592;
  GL_OPERAND0_ALPHA = $8598;
  GL_OPERAND1_ALPHA = $8599;
  GL_OPERAND2_ALPHA = $859A;
  GL_RGB_SCALE = $8573;
  GL_ADD_SIGNED = $8574;
  GL_INTERPOLATE = $8575;
  GL_SUBTRACT = $84E7;
  GL_CONSTANT = $8576;
  GL_PRIMARY_COLOR = $8577;
  GL_PREVIOUS = $8578;
  GL_DOT3_RGB = $86AE;
  GL_DOT3_RGBA = $86AF;
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_POINT_FADE_THRESHOLD_SIZE = $8128;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_DEPTH_COMPONENT24 = $81A6;
  GL_DEPTH_COMPONENT32 = $81A7;
  GL_MIRRORED_REPEAT = $8370;
  GL_MAX_TEXTURE_LOD_BIAS = $84FD;
  GL_TEXTURE_LOD_BIAS = $8501;
  GL_INCR_WRAP = $8507;
  GL_DECR_WRAP = $8508;
  GL_TEXTURE_DEPTH_SIZE = $884A;
  GL_TEXTURE_COMPARE_MODE = $884C;
  GL_TEXTURE_COMPARE_FUNC = $884D;
  GL_POINT_SIZE_MIN = $8126;
  GL_POINT_SIZE_MAX = $8127;
  GL_POINT_DISTANCE_ATTENUATION = $8129;
  GL_GENERATE_MIPMAP = $8191;
  GL_GENERATE_MIPMAP_HINT = $8192;
  GL_FOG_COORDINATE_SOURCE = $8450;
  GL_FOG_COORDINATE = $8451;
  GL_FRAGMENT_DEPTH = $8452;
  GL_CURRENT_FOG_COORDINATE = $8453;
  GL_FOG_COORDINATE_ARRAY_TYPE = $8454;
  GL_FOG_COORDINATE_ARRAY_STRIDE = $8455;
  GL_FOG_COORDINATE_ARRAY_POINTER = $8456;
  GL_FOG_COORDINATE_ARRAY = $8457;
  GL_COLOR_SUM = $8458;
  GL_CURRENT_SECONDARY_COLOR = $8459;
  GL_SECONDARY_COLOR_ARRAY_SIZE = $845A;
  GL_SECONDARY_COLOR_ARRAY_TYPE = $845B;
  GL_SECONDARY_COLOR_ARRAY_STRIDE = $845C;
  GL_SECONDARY_COLOR_ARRAY_POINTER = $845D;
  GL_SECONDARY_COLOR_ARRAY = $845E;
  GL_TEXTURE_FILTER_CONTROL = $8500;
  GL_DEPTH_TEXTURE_MODE = $884B;
  GL_COMPARE_R_TO_TEXTURE = $884E;
  GL_BLEND_COLOR = $8005;
  GL_BLEND_EQUATION = $8009;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_FUNC_ADD = $8006;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_FUNC_SUBTRACT = $800A;
  GL_MIN = $8007;
  GL_MAX = $8008;
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_QUERY_COUNTER_BITS = $8864;
  GL_CURRENT_QUERY = $8865;
  GL_QUERY_RESULT = $8866;
  GL_QUERY_RESULT_AVAILABLE = $8867;
  GL_ARRAY_BUFFER = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_READ_ONLY = $88B8;
  GL_WRITE_ONLY = $88B9;
  GL_READ_WRITE = $88BA;
  GL_BUFFER_ACCESS = $88BB;
  GL_BUFFER_MAPPED = $88BC;
  GL_BUFFER_MAP_POINTER = $88BD;
  GL_STREAM_DRAW = $88E0;
  GL_STREAM_READ = $88E1;
  GL_STREAM_COPY = $88E2;
  GL_STATIC_DRAW = $88E4;
  GL_STATIC_READ = $88E5;
  GL_STATIC_COPY = $88E6;
  GL_DYNAMIC_DRAW = $88E8;
  GL_DYNAMIC_READ = $88E9;
  GL_DYNAMIC_COPY = $88EA;
  GL_SAMPLES_PASSED = $8914;
  GL_SRC1_ALPHA = $8589;
  GL_VERTEX_ARRAY_BUFFER_BINDING = $8896;
  GL_NORMAL_ARRAY_BUFFER_BINDING = $8897;
  GL_COLOR_ARRAY_BUFFER_BINDING = $8898;
  GL_INDEX_ARRAY_BUFFER_BINDING = $8899;
  GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = $889A;
  GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = $889B;
  GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = $889C;
  GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = $889D;
  GL_WEIGHT_ARRAY_BUFFER_BINDING = $889E;
  GL_FOG_COORD_SRC = $8450;
  GL_FOG_COORD = $8451;
  GL_CURRENT_FOG_COORD = $8453;
  GL_FOG_COORD_ARRAY_TYPE = $8454;
  GL_FOG_COORD_ARRAY_STRIDE = $8455;
  GL_FOG_COORD_ARRAY_POINTER = $8456;
  GL_FOG_COORD_ARRAY = $8457;
  GL_FOG_COORD_ARRAY_BUFFER_BINDING = $889D;
  GL_SRC0_RGB = $8580;
  GL_SRC1_RGB = $8581;
  GL_SRC2_RGB = $8582;
  GL_SRC0_ALPHA = $8588;
  GL_SRC2_ALPHA = $858A;
  GL_BLEND_EQUATION_RGB = $8009;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_VERTEX_PROGRAM_POINT_SIZE = $8642;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_MAX_DRAW_BUFFERS = $8824;
  GL_DRAW_BUFFER0 = $8825;
  GL_DRAW_BUFFER1 = $8826;
  GL_DRAW_BUFFER2 = $8827;
  GL_DRAW_BUFFER3 = $8828;
  GL_DRAW_BUFFER4 = $8829;
  GL_DRAW_BUFFER5 = $882A;
  GL_DRAW_BUFFER6 = $882B;
  GL_DRAW_BUFFER7 = $882C;
  GL_DRAW_BUFFER8 = $882D;
  GL_DRAW_BUFFER9 = $882E;
  GL_DRAW_BUFFER10 = $882F;
  GL_DRAW_BUFFER11 = $8830;
  GL_DRAW_BUFFER12 = $8831;
  GL_DRAW_BUFFER13 = $8832;
  GL_DRAW_BUFFER14 = $8833;
  GL_DRAW_BUFFER15 = $8834;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_FRAGMENT_SHADER = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = $8B49;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS = $8B4A;
  GL_MAX_VARYING_FLOATS = $8B4B;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_SHADER_TYPE = $8B4F;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_SAMPLER_1D = $8B5D;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_3D = $8B5F;
  GL_SAMPLER_CUBE = $8B60;
  GL_SAMPLER_1D_SHADOW = $8B61;
  GL_SAMPLER_2D_SHADOW = $8B62;
  GL_DELETE_STATUS = $8B80;
  GL_COMPILE_STATUS = $8B81;
  GL_LINK_STATUS = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_ATTACHED_SHADERS = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT = $8B8B;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  GL_POINT_SPRITE_COORD_ORIGIN = $8CA0;
  GL_LOWER_LEFT = $8CA1;
  GL_UPPER_LEFT = $8CA2;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  GL_VERTEX_PROGRAM_TWO_SIDE = $8643;
  GL_POINT_SPRITE = $8861;
  GL_COORD_REPLACE = $8862;
  GL_MAX_TEXTURE_COORDS = $8871;
  GL_PIXEL_PACK_BUFFER = $88EB;
  GL_PIXEL_UNPACK_BUFFER = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING = $88EF;
  GL_FLOAT_MAT2x3 = $8B65;
  GL_FLOAT_MAT2x4 = $8B66;
  GL_FLOAT_MAT3x2 = $8B67;
  GL_FLOAT_MAT3x4 = $8B68;
  GL_FLOAT_MAT4x2 = $8B69;
  GL_FLOAT_MAT4x3 = $8B6A;
  GL_SRGB = $8C40;
  GL_SRGB8 = $8C41;
  GL_SRGB_ALPHA = $8C42;
  GL_SRGB8_ALPHA8 = $8C43;
  GL_COMPRESSED_SRGB = $8C48;
  GL_COMPRESSED_SRGB_ALPHA = $8C49;
  GL_CURRENT_RASTER_SECONDARY_COLOR = $845F;
  GL_SLUMINANCE_ALPHA = $8C44;
  GL_SLUMINANCE8_ALPHA8 = $8C45;
  GL_SLUMINANCE = $8C46;
  GL_SLUMINANCE8 = $8C47;
  GL_COMPRESSED_SLUMINANCE = $8C4A;
  GL_COMPRESSED_SLUMINANCE_ALPHA = $8C4B;

var
  GLAD_GL_VERSION_1_0: boolean;
  GLAD_GL_VERSION_1_1: boolean;
  GLAD_GL_VERSION_1_2: boolean;
  GLAD_GL_VERSION_1_3: boolean;
  GLAD_GL_VERSION_1_4: boolean;
  GLAD_GL_VERSION_1_5: boolean;
  GLAD_GL_VERSION_2_0: boolean;
  GLAD_GL_VERSION_2_1: boolean;

var
  glCullFace: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrontFace: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glHint: procedure (target: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLineWidth: procedure (width: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointSize: procedure (size: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonMode: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissor: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterf: procedure (target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameteri: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage1D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffer: procedure (buf: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClear: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearStencil: procedure (s: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepth: procedure (depth: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilMask: procedure (mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMask: procedure (red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthMask: procedure (flag: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisable: procedure (cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnable: procedure (cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinish: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlush: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFunc: procedure (sfactor: GLenum; dfactor: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLogicOp: procedure (opcode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFunc: procedure (func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOp: procedure (fail: GLenum; zfail: GLenum; zpass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthFunc: procedure (func: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelStoref: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelStorei: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadBuffer: procedure (src: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBooleanv: procedure (pname: GLenum; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDoublev: procedure (pname: GLenum; data: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetError: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloatv: procedure (pname: GLenum; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegerv: procedure (pname: GLenum; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetString: function (name: GLenum): PGLubyte; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexImage: procedure (target: GLenum; level: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexLevelParameterfv: procedure (target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexLevelParameteriv: procedure (target: GLenum; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnabled: function (cap: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRange: procedure (n: GLdouble; f: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewport: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNewList: procedure (list: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndList: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCallList: procedure (list: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCallLists: procedure (n: GLsizei; type_: GLenum; lists: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteLists: procedure (list: GLuint; range: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenLists: function (range: GLsizei): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glListBase: procedure (base: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBegin: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBitmap: procedure (width: GLsizei; height: GLsizei; xorig: GLfloat; yorig: GLfloat; xmove: GLfloat; ymove: GLfloat; bitmap: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3b: procedure (red: GLbyte; green: GLbyte; blue: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3bv: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3d: procedure (red: GLdouble; green: GLdouble; blue: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3f: procedure (red: GLfloat; green: GLfloat; blue: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3i: procedure (red: GLint; green: GLint; blue: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3s: procedure (red: GLshort; green: GLshort; blue: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3ub: procedure (red: GLubyte; green: GLubyte; blue: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3ubv: procedure (v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3ui: procedure (red: GLuint; green: GLuint; blue: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3uiv: procedure (v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3us: procedure (red: GLushort; green: GLushort; blue: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor3usv: procedure (v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4b: procedure (red: GLbyte; green: GLbyte; blue: GLbyte; alpha: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4bv: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4d: procedure (red: GLdouble; green: GLdouble; blue: GLdouble; alpha: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4f: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4i: procedure (red: GLint; green: GLint; blue: GLint; alpha: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4s: procedure (red: GLshort; green: GLshort; blue: GLshort; alpha: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ub: procedure (red: GLubyte; green: GLubyte; blue: GLubyte; alpha: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ubv: procedure (v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4ui: procedure (red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4uiv: procedure (v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4us: procedure (red: GLushort; green: GLushort; blue: GLushort; alpha: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColor4usv: procedure (v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlag: procedure (flag: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlagv: procedure (flag: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnd: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexd: procedure (c: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexdv: procedure (c: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexf: procedure (c: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexfv: procedure (c: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexi: procedure (c: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexiv: procedure (c: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexs: procedure (c: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexsv: procedure (c: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3b: procedure (nx: GLbyte; ny: GLbyte; nz: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3bv: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3d: procedure (nx: GLdouble; ny: GLdouble; nz: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3f: procedure (nx: GLfloat; ny: GLfloat; nz: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3i: procedure (nx: GLint; ny: GLint; nz: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3s: procedure (nx: GLshort; ny: GLshort; nz: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormal3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2d: procedure (x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2f: procedure (x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2i: procedure (x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2s: procedure (x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos2sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3d: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3f: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3i: procedure (x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3s: procedure (x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4d: procedure (x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4f: procedure (x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4i: procedure (x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4s: procedure (x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterPos4sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectd: procedure (x1: GLdouble; y1: GLdouble; x2: GLdouble; y2: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectdv: procedure (v1: PGLdouble; v2: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectf: procedure (x1: GLfloat; y1: GLfloat; x2: GLfloat; y2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectfv: procedure (v1: PGLfloat; v2: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRecti: procedure (x1: GLint; y1: GLint; x2: GLint; y2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectiv: procedure (v1: PGLint; v2: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRects: procedure (x1: GLshort; y1: GLshort; x2: GLshort; y2: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRectsv: procedure (v1: PGLshort; v2: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1d: procedure (s: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1f: procedure (s: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1i: procedure (s: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1s: procedure (s: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord1sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2d: procedure (s: GLdouble; t: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2f: procedure (s: GLfloat; t: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2i: procedure (s: GLint; t: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2s: procedure (s: GLshort; t: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord2sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3d: procedure (s: GLdouble; t: GLdouble; r: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3f: procedure (s: GLfloat; t: GLfloat; r: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3i: procedure (s: GLint; t: GLint; r: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3s: procedure (s: GLshort; t: GLshort; r: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4d: procedure (s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4f: procedure (s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4i: procedure (s: GLint; t: GLint; r: GLint; q: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4s: procedure (s: GLshort; t: GLshort; r: GLshort; q: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoord4sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2d: procedure (x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2f: procedure (x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2i: procedure (x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2s: procedure (x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex2sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3d: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3f: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3i: procedure (x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3s: procedure (x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4d: procedure (x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4f: procedure (x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4i: procedure (x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4s: procedure (x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertex4sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClipPlane: procedure (plane: GLenum; equation: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMaterial: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogf: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogfv: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogi: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogiv: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightf: procedure (light: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightfv: procedure (light: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLighti: procedure (light: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightiv: procedure (light: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModelf: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModelfv: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModeli: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLightModeliv: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLineStipple: procedure (factor: GLint; pattern: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaterialf: procedure (face: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaterialfv: procedure (face: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMateriali: procedure (face: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaterialiv: procedure (face: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonStipple: procedure (mask: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadeModel: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnvf: procedure (target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnvfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnvi: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEnviv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGend: procedure (coord: GLenum; pname: GLenum; param: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGendv: procedure (coord: GLenum; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGenf: procedure (coord: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGenfv: procedure (coord: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGeni: procedure (coord: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexGeniv: procedure (coord: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFeedbackBuffer: procedure (size: GLsizei; type_: GLenum; buffer: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSelectBuffer: procedure (size: GLsizei; buffer: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderMode: function (mode: GLenum): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInitNames: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadName: procedure (name: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPassThrough: procedure (token: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopName: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushName: procedure (name: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearAccum: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearIndex: procedure (c: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexMask: procedure (mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAccum: procedure (op: GLenum; value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopAttrib: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushAttrib: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap1d: procedure (target: GLenum; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; points: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap1f: procedure (target: GLenum; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap2d: procedure (target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; points: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMap2f: procedure (target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; points: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid1d: procedure (un: GLint; u1: GLdouble; u2: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid1f: procedure (un: GLint; u1: GLfloat; u2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid2d: procedure (un: GLint; u1: GLdouble; u2: GLdouble; vn: GLint; v1: GLdouble; v2: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapGrid2f: procedure (un: GLint; u1: GLfloat; u2: GLfloat; vn: GLint; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1d: procedure (u: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1dv: procedure (u: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1f: procedure (u: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord1fv: procedure (u: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2d: procedure (u: GLdouble; v: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2dv: procedure (u: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2f: procedure (u: GLfloat; v: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalCoord2fv: procedure (u: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalMesh1: procedure (mode: GLenum; i1: GLint; i2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalPoint1: procedure (i: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalMesh2: procedure (mode: GLenum; i1: GLint; i2: GLint; j1: GLint; j2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEvalPoint2: procedure (i: GLint; j: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFunc: procedure (func: GLenum; ref: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelZoom: procedure (xfactor: GLfloat; yfactor: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransferf: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelTransferi: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelMapfv: procedure (map: GLenum; mapsize: GLsizei; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelMapuiv: procedure (map: GLenum; mapsize: GLsizei; values: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelMapusv: procedure (map: GLenum; mapsize: GLsizei; values: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; type_: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawPixels: procedure (width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetClipPlane: procedure (plane: GLenum; equation: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLightfv: procedure (light: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetLightiv: procedure (light: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapdv: procedure (target: GLenum; query: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapfv: procedure (target: GLenum; query: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMapiv: procedure (target: GLenum; query: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMaterialfv: procedure (face: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMaterialiv: procedure (face: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelMapfv: procedure (map: GLenum; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelMapuiv: procedure (map: GLenum; values: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPixelMapusv: procedure (map: GLenum; values: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPolygonStipple: procedure (mask: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexEnvfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexEnviv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexGendv: procedure (coord: GLenum; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexGenfv: procedure (coord: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexGeniv: procedure (coord: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsList: function (list: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrustum: procedure (left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadIdentity: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadMatrixf: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadMatrixd: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMode: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultMatrixf: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultMatrixd: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glOrtho: procedure (left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopMatrix: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushMatrix: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRotated: procedure (angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRotatef: procedure (angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScaled: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScalef: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTranslated: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTranslatef: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArrays: procedure (mode: GLenum; first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElements: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointerv: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffset: procedure (factor: GLfloat; units: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexImage1D: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage1D: procedure (target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage1D: procedure (target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTexture: procedure (target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTextures: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTextures: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTexture: function (texture: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glArrayElement: procedure (i: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorPointer: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableClientState: procedure (array_: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEdgeFlagPointer: procedure (stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableClientState: procedure (array_: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexPointer: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInterleavedArrays: procedure (format: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNormalPointer: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexCoordPointer: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexPointer: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAreTexturesResident: function (n: GLsizei; textures: PGLuint; residences: PGLboolean): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrioritizeTextures: procedure (n: GLsizei; textures: PGLuint; priorities: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexub: procedure (c: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIndexubv: procedure (c: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopClientAttrib: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushClientAttrib: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElements: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveTexture: procedure (texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleCoverage: procedure (value: GLfloat; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage3D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage1D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage1D: procedure (target: GLenum; level: GLint; xoffset: GLint; width: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCompressedTexImage: procedure (target: GLenum; level: GLint; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientActiveTexture: procedure (texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1d: procedure (target: GLenum; s: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1dv: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1f: procedure (target: GLenum; s: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1fv: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1i: procedure (target: GLenum; s: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1iv: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1s: procedure (target: GLenum; s: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord1sv: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2d: procedure (target: GLenum; s: GLdouble; t: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2dv: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2f: procedure (target: GLenum; s: GLfloat; t: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2fv: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2i: procedure (target: GLenum; s: GLint; t: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2iv: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2s: procedure (target: GLenum; s: GLshort; t: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord2sv: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3d: procedure (target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3dv: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3f: procedure (target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3fv: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3i: procedure (target: GLenum; s: GLint; t: GLint; r: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3iv: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3s: procedure (target: GLenum; s: GLshort; t: GLshort; r: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord3sv: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4d: procedure (target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4dv: procedure (target: GLenum; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4f: procedure (target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4fv: procedure (target: GLenum; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4i: procedure (target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4iv: procedure (target: GLenum; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4s: procedure (target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiTexCoord4sv: procedure (target: GLenum; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadTransposeMatrixf: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLoadTransposeMatrixd: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultTransposeMatrixf: procedure (m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultTransposeMatrixd: procedure (m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparate: procedure (sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArrays: procedure (mode: GLenum; first: PGLint; count: PGLsizei; drawcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElements: procedure (mode: GLenum; count: PGLsizei; type_: GLenum; indices: PPointer; drawcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterf: procedure (pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameterfv: procedure (pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameteri: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointParameteriv: procedure (pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordf: procedure (coord: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordfv: procedure (coord: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordd: procedure (coord: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoorddv: procedure (coord: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFogCoordPointer: procedure (type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3b: procedure (red: GLbyte; green: GLbyte; blue: GLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3bv: procedure (v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3d: procedure (red: GLdouble; green: GLdouble; blue: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3f: procedure (red: GLfloat; green: GLfloat; blue: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3i: procedure (red: GLint; green: GLint; blue: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3s: procedure (red: GLshort; green: GLshort; blue: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ub: procedure (red: GLubyte; green: GLubyte; blue: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ubv: procedure (v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3ui: procedure (red: GLuint; green: GLuint; blue: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3uiv: procedure (v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3us: procedure (red: GLushort; green: GLushort; blue: GLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColor3usv: procedure (v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSecondaryColorPointer: procedure (size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2d: procedure (x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2f: procedure (x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2i: procedure (x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2s: procedure (x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos2sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3d: procedure (x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3dv: procedure (v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3f: procedure (x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3fv: procedure (v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3i: procedure (x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3iv: procedure (v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3s: procedure (x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowPos3sv: procedure (v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquation: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenQueries: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteQueries: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsQuery: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginQuery: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndQuery: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryiv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectiv: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectuiv: procedure (id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBuffer: procedure (target: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteBuffers: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenBuffers: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsBuffer: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferData: procedure (target: GLenum; size: GLsizeiptr; data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferSubData: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferSubData: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBuffer: function (target: GLenum; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapBuffer: function (target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferPointerv: procedure (target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparate: procedure (modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffers: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOpSeparate: procedure (face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFuncSeparate: procedure (face: GLenum; func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilMaskSeparate: procedure (face: GLenum; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAttachShader: procedure (program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindAttribLocation: procedure (program_: GLuint; index: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompileShader: procedure (shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateProgram: function (): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShader: function (type_: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteShader: procedure (shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDetachShader: procedure (program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexAttribArray: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexAttribArray: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveAttrib: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniform: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttachedShaders: procedure (program_: GLuint; maxCount: GLsizei; count: PGLsizei; shaders: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttribLocation: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramiv: procedure (program_: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramInfoLog: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderiv: procedure (shader: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderInfoLog: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderSource: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; source: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformLocation: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformfv: procedure (program_: GLuint; location: GLint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformiv: procedure (program_: GLuint; location: GLint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribdv: procedure (index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribfv: procedure (index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribiv: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribPointerv: procedure (index: GLuint; pname: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgram: function (program_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsShader: function (shader: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLinkProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderSource: procedure (shader: GLuint; count: GLsizei; string_: PPGLchar; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1f: procedure (location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2f: procedure (location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i: procedure (location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i: procedure (location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1d: procedure (index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1f: procedure (index: GLuint; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1s: procedure (index: GLuint; x: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1sv: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2d: procedure (index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2f: procedure (index: GLuint; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2s: procedure (index: GLuint; x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2sv: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3d: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3s: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3sv: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nbv: procedure (index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Niv: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nsv: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nub: procedure (index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nubv: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nuiv: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4Nusv: procedure (index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4bv: procedure (index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4d: procedure (index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4dv: procedure (index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4iv: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4s: procedure (index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4sv: procedure (index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4ubv: procedure (index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4uiv: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4usv: procedure (index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribPointer: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}

function LoadOpenGL(): Boolean;

{$ENDREGION}

{$REGION ' Pyro.CLibs '}
const
  GLFW_EXPOSE_NATIVE_WIN32 = 1;
  SQLITE_CORE = 1;
  SQLITE_OMIT_LOAD_EXTENSION = 1;
  SQLITE_ENABLE_COLUMN_METADATA = 1;
  CIMGUI_DEFINE_ENUMS_AND_STRUCTS = 1;
  NK_INCLUDE_FIXED_TYPES = 1;
  NK_INCLUDE_STANDARD_IO = 1;
  NK_INCLUDE_STANDARD_VARARGS = 1;
  NK_INCLUDE_DEFAULT_ALLOCATOR = 1;
  NK_INCLUDE_VERTEX_BUFFER_OUTPUT = 1;
  NK_INCLUDE_FONT_BAKING = 1;
  NK_INCLUDE_DEFAULT_FONT = 1;
  NK_KEYSTATE_BASED_INPUT = 1;
  PLM_NO_STDIO = 1;
  WINVER = $0501;
  LUA_LDIR = '!\lua\';
  LUA_CDIR = '!\';
  LUA_PATH_DEFAULT = '.\?.lua;' + LUA_LDIR + '?.lua;' + LUA_LDIR + '?\init.lua;';
  LUA_CPATH_DEFAULT = '.\?.dll;' + LUA_CDIR + '?.dll;' + LUA_CDIR + 'loadall.dll';
  LUA_PATH = 'LUA_PATH';
  LUA_CPATH = 'LUA_CPATH';
  LUA_INIT = 'LUA_INIT';
  LUA_DIRSEP = '\';
  LUA_PATHSEP = ';';
  LUA_PATH_MARK = '?';
  LUA_EXECDIR = '!';
  LUA_IGMARK = '-';
  LUA_PATH_CONFIG = LUA_DIRSEP + #10 + LUA_PATHSEP + #10 + LUA_PATH_MARK + #10 + LUA_EXECDIR + #10 + LUA_IGMARK + #10;
  LUAI_MAXSTACK = 65500;
  LUAI_MAXCSTACK = 8000;
  LUAI_GCPAUSE = 200;
  LUAI_GCMUL = 200;
  LUA_MAXCAPTURES = 32;
  LUA_IDSIZE = 60;
  BUFSIZ = 512;
  LUA_NUMBER_SCAN = '%lf';
  LUA_NUMBER_FMT = '%.14g';
  LUAI_MAXNUMBER2STR = 32;
  LUA_INTFRMLEN = 'l';
  LUA_VERSION_ = 'Lua 5.1';
  LUA_RELEASE = 'Lua 5.1.4';
  LUA_VERSION_NUM = 501;
  LUA_COPYRIGHT = 'Copyright (C) 1994-2008 Lua.org, PUC-Rio';
  LUA_AUTHORS = 'R. Ierusalimschy, L. H. de Figueiredo & W. Celes';
  LUA_SIGNATURE = #27'Lua';
  LUA_MULTRET = (-1);
  LUA_REGISTRYINDEX = (-10000);
  LUA_ENVIRONINDEX = (-10001);
  LUA_GLOBALSINDEX = (-10002);
  LUA_OK = 0;
  LUA_YIELD_ = 1;
  LUA_ERRRUN = 2;
  LUA_ERRSYNTAX = 3;
  LUA_ERRMEM = 4;
  LUA_ERRERR = 5;
  LUA_TNONE = (-1);
  LUA_TNIL = 0;
  LUA_TBOOLEAN = 1;
  LUA_TLIGHTUSERDATA = 2;
  LUA_TNUMBER = 3;
  LUA_TSTRING = 4;
  LUA_TTABLE = 5;
  LUA_TFUNCTION = 6;
  LUA_TUSERDATA = 7;
  LUA_TTHREAD = 8;
  LUA_MINSTACK = 20;
  LUA_GCSTOP = 0;
  LUA_GCRESTART = 1;
  LUA_GCCOLLECT = 2;
  LUA_GCCOUNT = 3;
  LUA_GCCOUNTB = 4;
  LUA_GCSTEP = 5;
  LUA_GCSETPAUSE = 6;
  LUA_GCSETSTEPMUL = 7;
  LUA_GCISRUNNING = 9;
  LUA_HOOKCALL = 0;
  LUA_HOOKRET = 1;
  LUA_HOOKLINE = 2;
  LUA_HOOKCOUNT = 3;
  LUA_HOOKTAILRET = 4;
  LUA_MASKCALL = (1 shl LUA_HOOKCALL);
  LUA_MASKRET = (1 shl LUA_HOOKRET);
  LUA_MASKLINE = (1 shl LUA_HOOKLINE);
  LUA_MASKCOUNT = (1 shl LUA_HOOKCOUNT);
  LUA_FILEHANDLE = 'FILE*';
  LUA_COLIBNAME = 'coroutine';
  LUA_MATHLIBNAME = 'math';
  LUA_STRLIBNAME = 'string';
  LUA_TABLIBNAME = 'table';
  LUA_IOLIBNAME = 'io';
  LUA_OSLIBNAME = 'os';
  LUA_LOADLIBNAME = 'package';
  LUA_DBLIBNAME = 'debug';
  LUA_BITLIBNAME = 'bit';
  LUA_JITLIBNAME = 'jit';
  LUA_FFILIBNAME = 'ffi';
  LUA_ERRFILE = (LUA_ERRERR+1);
  LUA_NOREF = (-2);
  LUA_REFNIL = (-1);
  LUAJIT_VERSION = 'LuaJIT 2.1.1736781742';
  LUAJIT_VERSION_NUM = 20199;
  LUAJIT_COPYRIGHT = 'Copyright (C) 2005-2025 Mike Pall';
  LUAJIT_URL = 'https://luajit.org/';
  LUAJIT_MODE_MASK = $00ff;
  LUAJIT_MODE_OFF = $0000;
  LUAJIT_MODE_ON = $0100;
  LUAJIT_MODE_FLUSH = $0200;
  SP_SEQUENCE_MODE_HOLD = 0;
  SP_SEQUENCE_MODE_ONCE = 1;
  SP_SEQUENCE_MODE_LOOP = 2;
  SP_SEQUENCE_MODE_PINGPONG = 3;
  SP_SEQUENCE_MODE_ONCEREVERSE = 4;
  SP_SEQUENCE_MODE_LOOPREVERSE = 5;
  SP_SEQUENCE_MODE_PINGPONGREVERSE = 6;
  SP_MAX_PROPERTY_IDS = 3;
  SKIN_ENTRIES_HASH_TABLE_SIZE = 100;
  GLFW_VERSION_MAJOR = 3;
  GLFW_VERSION_MINOR = 5;
  GLFW_VERSION_REVISION = 0;
  GLFW_TRUE = 1;
  GLFW_FALSE = 0;
  GLFW_RELEASE = 0;
  GLFW_PRESS = 1;
  GLFW_REPEAT = 2;
  GLFW_HAT_CENTERED = 0;
  GLFW_HAT_UP = 1;
  GLFW_HAT_RIGHT = 2;
  GLFW_HAT_DOWN = 4;
  GLFW_HAT_LEFT = 8;
  GLFW_HAT_RIGHT_UP = (GLFW_HAT_RIGHT or GLFW_HAT_UP);
  GLFW_HAT_RIGHT_DOWN = (GLFW_HAT_RIGHT or GLFW_HAT_DOWN);
  GLFW_HAT_LEFT_UP = (GLFW_HAT_LEFT or GLFW_HAT_UP);
  GLFW_HAT_LEFT_DOWN = (GLFW_HAT_LEFT or GLFW_HAT_DOWN);
  GLFW_KEY_UNKNOWN = -1;
  GLFW_KEY_SPACE = 32;
  GLFW_KEY_APOSTROPHE = 39;
  GLFW_KEY_COMMA = 44;
  GLFW_KEY_MINUS = 45;
  GLFW_KEY_PERIOD = 46;
  GLFW_KEY_SLASH = 47;
  GLFW_KEY_0 = 48;
  GLFW_KEY_1 = 49;
  GLFW_KEY_2 = 50;
  GLFW_KEY_3 = 51;
  GLFW_KEY_4 = 52;
  GLFW_KEY_5 = 53;
  GLFW_KEY_6 = 54;
  GLFW_KEY_7 = 55;
  GLFW_KEY_8 = 56;
  GLFW_KEY_9 = 57;
  GLFW_KEY_SEMICOLON = 59;
  GLFW_KEY_EQUAL = 61;
  GLFW_KEY_A = 65;
  GLFW_KEY_B = 66;
  GLFW_KEY_C = 67;
  GLFW_KEY_D = 68;
  GLFW_KEY_E = 69;
  GLFW_KEY_F = 70;
  GLFW_KEY_G = 71;
  GLFW_KEY_H = 72;
  GLFW_KEY_I = 73;
  GLFW_KEY_J = 74;
  GLFW_KEY_K = 75;
  GLFW_KEY_L = 76;
  GLFW_KEY_M = 77;
  GLFW_KEY_N = 78;
  GLFW_KEY_O = 79;
  GLFW_KEY_P = 80;
  GLFW_KEY_Q = 81;
  GLFW_KEY_R = 82;
  GLFW_KEY_S = 83;
  GLFW_KEY_T = 84;
  GLFW_KEY_U = 85;
  GLFW_KEY_V = 86;
  GLFW_KEY_W = 87;
  GLFW_KEY_X = 88;
  GLFW_KEY_Y = 89;
  GLFW_KEY_Z = 90;
  GLFW_KEY_LEFT_BRACKET = 91;
  GLFW_KEY_BACKSLASH = 92;
  GLFW_KEY_RIGHT_BRACKET = 93;
  GLFW_KEY_GRAVE_ACCENT = 96;
  GLFW_KEY_WORLD_1 = 161;
  GLFW_KEY_WORLD_2 = 162;
  GLFW_KEY_ESCAPE = 256;
  GLFW_KEY_ENTER = 257;
  GLFW_KEY_TAB = 258;
  GLFW_KEY_BACKSPACE = 259;
  GLFW_KEY_INSERT = 260;
  GLFW_KEY_DELETE = 261;
  GLFW_KEY_RIGHT = 262;
  GLFW_KEY_LEFT = 263;
  GLFW_KEY_DOWN = 264;
  GLFW_KEY_UP = 265;
  GLFW_KEY_PAGE_UP = 266;
  GLFW_KEY_PAGE_DOWN = 267;
  GLFW_KEY_HOME = 268;
  GLFW_KEY_END = 269;
  GLFW_KEY_CAPS_LOCK = 280;
  GLFW_KEY_SCROLL_LOCK = 281;
  GLFW_KEY_NUM_LOCK = 282;
  GLFW_KEY_PRINT_SCREEN = 283;
  GLFW_KEY_PAUSE = 284;
  GLFW_KEY_F1 = 290;
  GLFW_KEY_F2 = 291;
  GLFW_KEY_F3 = 292;
  GLFW_KEY_F4 = 293;
  GLFW_KEY_F5 = 294;
  GLFW_KEY_F6 = 295;
  GLFW_KEY_F7 = 296;
  GLFW_KEY_F8 = 297;
  GLFW_KEY_F9 = 298;
  GLFW_KEY_F10 = 299;
  GLFW_KEY_F11 = 300;
  GLFW_KEY_F12 = 301;
  GLFW_KEY_F13 = 302;
  GLFW_KEY_F14 = 303;
  GLFW_KEY_F15 = 304;
  GLFW_KEY_F16 = 305;
  GLFW_KEY_F17 = 306;
  GLFW_KEY_F18 = 307;
  GLFW_KEY_F19 = 308;
  GLFW_KEY_F20 = 309;
  GLFW_KEY_F21 = 310;
  GLFW_KEY_F22 = 311;
  GLFW_KEY_F23 = 312;
  GLFW_KEY_F24 = 313;
  GLFW_KEY_F25 = 314;
  GLFW_KEY_KP_0 = 320;
  GLFW_KEY_KP_1 = 321;
  GLFW_KEY_KP_2 = 322;
  GLFW_KEY_KP_3 = 323;
  GLFW_KEY_KP_4 = 324;
  GLFW_KEY_KP_5 = 325;
  GLFW_KEY_KP_6 = 326;
  GLFW_KEY_KP_7 = 327;
  GLFW_KEY_KP_8 = 328;
  GLFW_KEY_KP_9 = 329;
  GLFW_KEY_KP_DECIMAL = 330;
  GLFW_KEY_KP_DIVIDE = 331;
  GLFW_KEY_KP_MULTIPLY = 332;
  GLFW_KEY_KP_SUBTRACT = 333;
  GLFW_KEY_KP_ADD = 334;
  GLFW_KEY_KP_ENTER = 335;
  GLFW_KEY_KP_EQUAL = 336;
  GLFW_KEY_LEFT_SHIFT = 340;
  GLFW_KEY_LEFT_CONTROL = 341;
  GLFW_KEY_LEFT_ALT = 342;
  GLFW_KEY_LEFT_SUPER = 343;
  GLFW_KEY_RIGHT_SHIFT = 344;
  GLFW_KEY_RIGHT_CONTROL = 345;
  GLFW_KEY_RIGHT_ALT = 346;
  GLFW_KEY_RIGHT_SUPER = 347;
  GLFW_KEY_MENU = 348;
  GLFW_KEY_LAST = GLFW_KEY_MENU;
  GLFW_MOD_SHIFT = $0001;
  GLFW_MOD_CONTROL = $0002;
  GLFW_MOD_ALT = $0004;
  GLFW_MOD_SUPER = $0008;
  GLFW_MOD_CAPS_LOCK = $0010;
  GLFW_MOD_NUM_LOCK = $0020;
  GLFW_MOUSE_BUTTON_1 = 0;
  GLFW_MOUSE_BUTTON_2 = 1;
  GLFW_MOUSE_BUTTON_3 = 2;
  GLFW_MOUSE_BUTTON_4 = 3;
  GLFW_MOUSE_BUTTON_5 = 4;
  GLFW_MOUSE_BUTTON_6 = 5;
  GLFW_MOUSE_BUTTON_7 = 6;
  GLFW_MOUSE_BUTTON_8 = 7;
  GLFW_MOUSE_BUTTON_LAST = GLFW_MOUSE_BUTTON_8;
  GLFW_MOUSE_BUTTON_LEFT = GLFW_MOUSE_BUTTON_1;
  GLFW_MOUSE_BUTTON_RIGHT = GLFW_MOUSE_BUTTON_2;
  GLFW_MOUSE_BUTTON_MIDDLE = GLFW_MOUSE_BUTTON_3;
  GLFW_JOYSTICK_1 = 0;
  GLFW_JOYSTICK_2 = 1;
  GLFW_JOYSTICK_3 = 2;
  GLFW_JOYSTICK_4 = 3;
  GLFW_JOYSTICK_5 = 4;
  GLFW_JOYSTICK_6 = 5;
  GLFW_JOYSTICK_7 = 6;
  GLFW_JOYSTICK_8 = 7;
  GLFW_JOYSTICK_9 = 8;
  GLFW_JOYSTICK_10 = 9;
  GLFW_JOYSTICK_11 = 10;
  GLFW_JOYSTICK_12 = 11;
  GLFW_JOYSTICK_13 = 12;
  GLFW_JOYSTICK_14 = 13;
  GLFW_JOYSTICK_15 = 14;
  GLFW_JOYSTICK_16 = 15;
  GLFW_JOYSTICK_LAST = GLFW_JOYSTICK_16;
  GLFW_GAMEPAD_BUTTON_A = 0;
  GLFW_GAMEPAD_BUTTON_B = 1;
  GLFW_GAMEPAD_BUTTON_X = 2;
  GLFW_GAMEPAD_BUTTON_Y = 3;
  GLFW_GAMEPAD_BUTTON_LEFT_BUMPER = 4;
  GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER = 5;
  GLFW_GAMEPAD_BUTTON_BACK = 6;
  GLFW_GAMEPAD_BUTTON_START = 7;
  GLFW_GAMEPAD_BUTTON_GUIDE = 8;
  GLFW_GAMEPAD_BUTTON_LEFT_THUMB = 9;
  GLFW_GAMEPAD_BUTTON_RIGHT_THUMB = 10;
  GLFW_GAMEPAD_BUTTON_DPAD_UP = 11;
  GLFW_GAMEPAD_BUTTON_DPAD_RIGHT = 12;
  GLFW_GAMEPAD_BUTTON_DPAD_DOWN = 13;
  GLFW_GAMEPAD_BUTTON_DPAD_LEFT = 14;
  GLFW_GAMEPAD_BUTTON_LAST = GLFW_GAMEPAD_BUTTON_DPAD_LEFT;
  GLFW_GAMEPAD_BUTTON_CROSS = GLFW_GAMEPAD_BUTTON_A;
  GLFW_GAMEPAD_BUTTON_CIRCLE = GLFW_GAMEPAD_BUTTON_B;
  GLFW_GAMEPAD_BUTTON_SQUARE = GLFW_GAMEPAD_BUTTON_X;
  GLFW_GAMEPAD_BUTTON_TRIANGLE = GLFW_GAMEPAD_BUTTON_Y;
  GLFW_GAMEPAD_AXIS_LEFT_X = 0;
  GLFW_GAMEPAD_AXIS_LEFT_Y = 1;
  GLFW_GAMEPAD_AXIS_RIGHT_X = 2;
  GLFW_GAMEPAD_AXIS_RIGHT_Y = 3;
  GLFW_GAMEPAD_AXIS_LEFT_TRIGGER = 4;
  GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER = 5;
  GLFW_GAMEPAD_AXIS_LAST = GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER;
  GLFW_NO_ERROR = 0;
  GLFW_NOT_INITIALIZED = $00010001;
  GLFW_NO_CURRENT_CONTEXT = $00010002;
  GLFW_INVALID_ENUM = $00010003;
  GLFW_INVALID_VALUE = $00010004;
  GLFW_OUT_OF_MEMORY = $00010005;
  GLFW_API_UNAVAILABLE = $00010006;
  GLFW_VERSION_UNAVAILABLE = $00010007;
  GLFW_PLATFORM_ERROR = $00010008;
  GLFW_FORMAT_UNAVAILABLE = $00010009;
  GLFW_NO_WINDOW_CONTEXT = $0001000A;
  GLFW_CURSOR_UNAVAILABLE = $0001000B;
  GLFW_FEATURE_UNAVAILABLE = $0001000C;
  GLFW_FEATURE_UNIMPLEMENTED = $0001000D;
  GLFW_PLATFORM_UNAVAILABLE = $0001000E;
  GLFW_FOCUSED = $00020001;
  GLFW_ICONIFIED = $00020002;
  GLFW_RESIZABLE = $00020003;
  GLFW_VISIBLE = $00020004;
  GLFW_DECORATED = $00020005;
  GLFW_AUTO_ICONIFY = $00020006;
  GLFW_FLOATING = $00020007;
  GLFW_MAXIMIZED = $00020008;
  GLFW_CENTER_CURSOR = $00020009;
  GLFW_TRANSPARENT_FRAMEBUFFER = $0002000A;
  GLFW_HOVERED = $0002000B;
  GLFW_FOCUS_ON_SHOW = $0002000C;
  GLFW_MOUSE_PASSTHROUGH = $0002000D;
  GLFW_POSITION_X = $0002000E;
  GLFW_POSITION_Y = $0002000F;
  GLFW_RED_BITS = $00021001;
  GLFW_GREEN_BITS = $00021002;
  GLFW_BLUE_BITS = $00021003;
  GLFW_ALPHA_BITS = $00021004;
  GLFW_DEPTH_BITS = $00021005;
  GLFW_STENCIL_BITS = $00021006;
  GLFW_ACCUM_RED_BITS = $00021007;
  GLFW_ACCUM_GREEN_BITS = $00021008;
  GLFW_ACCUM_BLUE_BITS = $00021009;
  GLFW_ACCUM_ALPHA_BITS = $0002100A;
  GLFW_AUX_BUFFERS = $0002100B;
  GLFW_STEREO = $0002100C;
  GLFW_SAMPLES = $0002100D;
  GLFW_SRGB_CAPABLE = $0002100E;
  GLFW_REFRESH_RATE = $0002100F;
  GLFW_DOUBLEBUFFER = $00021010;
  GLFW_CLIENT_API = $00022001;
  GLFW_CONTEXT_VERSION_MAJOR = $00022002;
  GLFW_CONTEXT_VERSION_MINOR = $00022003;
  GLFW_CONTEXT_REVISION = $00022004;
  GLFW_CONTEXT_ROBUSTNESS = $00022005;
  GLFW_OPENGL_FORWARD_COMPAT = $00022006;
  GLFW_CONTEXT_DEBUG = $00022007;
  GLFW_OPENGL_DEBUG_CONTEXT = GLFW_CONTEXT_DEBUG;
  GLFW_OPENGL_PROFILE = $00022008;
  GLFW_CONTEXT_RELEASE_BEHAVIOR = $00022009;
  GLFW_CONTEXT_NO_ERROR = $0002200A;
  GLFW_CONTEXT_CREATION_API = $0002200B;
  GLFW_SCALE_TO_MONITOR = $0002200C;
  GLFW_SCALE_FRAMEBUFFER = $0002200D;
  GLFW_COCOA_RETINA_FRAMEBUFFER = $00023001;
  GLFW_COCOA_FRAME_NAME = $00023002;
  GLFW_COCOA_GRAPHICS_SWITCHING = $00023003;
  GLFW_X11_CLASS_NAME = $00024001;
  GLFW_X11_INSTANCE_NAME = $00024002;
  GLFW_WIN32_KEYBOARD_MENU = $00025001;
  GLFW_WIN32_SHOWDEFAULT = $00025002;
  GLFW_WAYLAND_APP_ID = $00026001;
  GLFW_NO_API = 0;
  GLFW_OPENGL_API = $00030001;
  GLFW_OPENGL_ES_API = $00030002;
  GLFW_NO_ROBUSTNESS = 0;
  GLFW_NO_RESET_NOTIFICATION = $00031001;
  GLFW_LOSE_CONTEXT_ON_RESET = $00031002;
  GLFW_OPENGL_ANY_PROFILE = 0;
  GLFW_OPENGL_CORE_PROFILE = $00032001;
  GLFW_OPENGL_COMPAT_PROFILE = $00032002;
  GLFW_CURSOR = $00033001;
  GLFW_STICKY_KEYS = $00033002;
  GLFW_STICKY_MOUSE_BUTTONS = $00033003;
  GLFW_LOCK_KEY_MODS = $00033004;
  GLFW_RAW_MOUSE_MOTION = $00033005;
  GLFW_UNLIMITED_MOUSE_BUTTONS = $00033006;
  GLFW_CURSOR_NORMAL = $00034001;
  GLFW_CURSOR_HIDDEN = $00034002;
  GLFW_CURSOR_DISABLED = $00034003;
  GLFW_CURSOR_CAPTURED = $00034004;
  GLFW_ANY_RELEASE_BEHAVIOR = 0;
  GLFW_RELEASE_BEHAVIOR_FLUSH = $00035001;
  GLFW_RELEASE_BEHAVIOR_NONE = $00035002;
  GLFW_NATIVE_CONTEXT_API = $00036001;
  GLFW_EGL_CONTEXT_API = $00036002;
  GLFW_OSMESA_CONTEXT_API = $00036003;
  GLFW_ANGLE_PLATFORM_TYPE_NONE = $00037001;
  GLFW_ANGLE_PLATFORM_TYPE_OPENGL = $00037002;
  GLFW_ANGLE_PLATFORM_TYPE_OPENGLES = $00037003;
  GLFW_ANGLE_PLATFORM_TYPE_D3D9 = $00037004;
  GLFW_ANGLE_PLATFORM_TYPE_D3D11 = $00037005;
  GLFW_ANGLE_PLATFORM_TYPE_VULKAN = $00037007;
  GLFW_ANGLE_PLATFORM_TYPE_METAL = $00037008;
  GLFW_WAYLAND_PREFER_LIBDECOR = $00038001;
  GLFW_WAYLAND_DISABLE_LIBDECOR = $00038002;
  GLFW_ANY_POSITION = $80000000;
  GLFW_ARROW_CURSOR = $00036001;
  GLFW_IBEAM_CURSOR = $00036002;
  GLFW_CROSSHAIR_CURSOR = $00036003;
  GLFW_POINTING_HAND_CURSOR = $00036004;
  GLFW_RESIZE_EW_CURSOR = $00036005;
  GLFW_RESIZE_NS_CURSOR = $00036006;
  GLFW_RESIZE_NWSE_CURSOR = $00036007;
  GLFW_RESIZE_NESW_CURSOR = $00036008;
  GLFW_RESIZE_ALL_CURSOR = $00036009;
  GLFW_NOT_ALLOWED_CURSOR = $0003600A;
  GLFW_HRESIZE_CURSOR = GLFW_RESIZE_EW_CURSOR;
  GLFW_VRESIZE_CURSOR = GLFW_RESIZE_NS_CURSOR;
  GLFW_HAND_CURSOR = GLFW_POINTING_HAND_CURSOR;
  GLFW_CONNECTED = $00040001;
  GLFW_DISCONNECTED = $00040002;
  GLFW_JOYSTICK_HAT_BUTTONS = $00050001;
  GLFW_ANGLE_PLATFORM_TYPE = $00050002;
  GLFW_PLATFORM = $00050003;
  GLFW_COCOA_CHDIR_RESOURCES = $00051001;
  GLFW_COCOA_MENUBAR = $00051002;
  GLFW_X11_XCB_VULKAN_SURFACE = $00052001;
  GLFW_WAYLAND_LIBDECOR = $00053001;
  GLFW_ANY_PLATFORM = $00060000;
  GLFW_PLATFORM_WIN32 = $00060001;
  GLFW_PLATFORM_COCOA = $00060002;
  GLFW_PLATFORM_WAYLAND = $00060003;
  GLFW_PLATFORM_X11 = $00060004;
  GLFW_PLATFORM_NULL = $00060005;
  GLFW_DONT_CARE = -1;
  STBI_VERSION = 1;
  STB_RECT_PACK_VERSION = 1;
  STBRP__MAXVAL = $7fffffff;
  STBTT_MACSTYLE_DONTCARE = 0;
  STBTT_MACSTYLE_BOLD = 1;
  STBTT_MACSTYLE_ITALIC = 2;
  STBTT_MACSTYLE_UNDERSCORE = 4;
  STBTT_MACSTYLE_NONE = 8;
  C2_MAX_POLYGON_VERTS = 8;
  PLM_PACKET_INVALID_TS = -1;
  PLM_AUDIO_SAMPLES_PER_FRAME = 1152;
  PLM_BUFFER_DEFAULT_SIZE = (128*1024);
  MA_VERSION_MAJOR = 0;
  MA_VERSION_MINOR = 11;
  MA_VERSION_REVISION = 21;
  MA_SIZEOF_PTR = 8;
  MA_TRUE = 1;
  MA_FALSE = 0;
  SIZE_MAX = $ffffffffffffffff;
  MA_SIZE_MAX = SIZE_MAX;
  MA_SIMD_ALIGNMENT = 32;
  MA_MIN_CHANNELS = 1;
  MA_MAX_CHANNELS = 254;
  MA_MAX_FILTER_ORDER = 8;
  MA_MAX_LOG_CALLBACKS = 4;
  MA_CHANNEL_INDEX_NULL = 255;
  MA_DATA_SOURCE_SELF_MANAGED_RANGE_AND_LOOP_POINT = $00000001;
  MA_DATA_FORMAT_FLAG_EXCLUSIVE_MODE = (1 shl 1);
  MA_MAX_DEVICE_NAME_LENGTH = 255;
  MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT = 64;
  MA_MAX_NODE_BUS_COUNT = 254;
  MA_MAX_NODE_LOCAL_BUS_COUNT = 2;
  MA_NODE_BUS_COUNT_UNKNOWN = 255;
  MA_ENGINE_MAX_LISTENERS = 4;
  MA_SOUND_SOURCE_CHANNEL_COUNT = $FFFFFFFF;
  Z_ERRNO = -1;
  Z_OK = 0;
  Z_DEFLATED = 8;
  Z_DEFAULT_STRATEGY = 0;
  ZIP_OK = (0);
  ZIP_EOF = (0);
  ZIP_ERRNO = (Z_ERRNO);
  ZIP_PARAMERROR = (-102);
  ZIP_BADZIPFILE = (-103);
  ZIP_INTERNALERROR = (-104);
  UNZ_OK = (0);
  UNZ_END_OF_LIST_OF_FILE = (-100);
  UNZ_ERRNO = (Z_ERRNO);
  UNZ_EOF = (0);
  UNZ_PARAMERROR = (-102);
  UNZ_BADZIPFILE = (-103);
  UNZ_INTERNALERROR = (-104);
  UNZ_CRCERROR = (-105);
  APPEND_STATUS_CREATE = (0);
  APPEND_STATUS_CREATEAFTER = (1);
  APPEND_STATUS_ADDINZIP = (2);
  SQLITE_VERSION = '3.49.1';
  SQLITE_VERSION_NUMBER = 3049001;
  SQLITE_SOURCE_ID = '2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70';
  SQLITE_OK = 0;
  SQLITE_ERROR = 1;
  SQLITE_INTERNAL = 2;
  SQLITE_PERM = 3;
  SQLITE_ABORT = 4;
  SQLITE_BUSY = 5;
  SQLITE_LOCKED = 6;
  SQLITE_NOMEM = 7;
  SQLITE_READONLY = 8;
  SQLITE_INTERRUPT = 9;
  SQLITE_IOERR = 10;
  SQLITE_CORRUPT = 11;
  SQLITE_NOTFOUND = 12;
  SQLITE_FULL = 13;
  SQLITE_CANTOPEN = 14;
  SQLITE_PROTOCOL = 15;
  SQLITE_EMPTY = 16;
  SQLITE_SCHEMA = 17;
  SQLITE_TOOBIG = 18;
  SQLITE_CONSTRAINT = 19;
  SQLITE_MISMATCH = 20;
  SQLITE_MISUSE = 21;
  SQLITE_NOLFS = 22;
  SQLITE_AUTH = 23;
  SQLITE_FORMAT = 24;
  SQLITE_RANGE = 25;
  SQLITE_NOTADB = 26;
  SQLITE_NOTICE = 27;
  SQLITE_WARNING = 28;
  SQLITE_ROW = 100;
  SQLITE_DONE = 101;
  SQLITE_ERROR_MISSING_COLLSEQ = (SQLITE_ERROR or (1 shl 8));
  SQLITE_ERROR_RETRY = (SQLITE_ERROR or (2 shl 8));
  SQLITE_ERROR_SNAPSHOT = (SQLITE_ERROR or (3 shl 8));
  SQLITE_IOERR_READ = (SQLITE_IOERR or (1 shl 8));
  SQLITE_IOERR_SHORT_READ = (SQLITE_IOERR or (2 shl 8));
  SQLITE_IOERR_WRITE = (SQLITE_IOERR or (3 shl 8));
  SQLITE_IOERR_FSYNC = (SQLITE_IOERR or (4 shl 8));
  SQLITE_IOERR_DIR_FSYNC = (SQLITE_IOERR or (5 shl 8));
  SQLITE_IOERR_TRUNCATE = (SQLITE_IOERR or (6 shl 8));
  SQLITE_IOERR_FSTAT = (SQLITE_IOERR or (7 shl 8));
  SQLITE_IOERR_UNLOCK = (SQLITE_IOERR or (8 shl 8));
  SQLITE_IOERR_RDLOCK = (SQLITE_IOERR or (9 shl 8));
  SQLITE_IOERR_DELETE = (SQLITE_IOERR or (10 shl 8));
  SQLITE_IOERR_BLOCKED = (SQLITE_IOERR or (11 shl 8));
  SQLITE_IOERR_NOMEM = (SQLITE_IOERR or (12 shl 8));
  SQLITE_IOERR_ACCESS = (SQLITE_IOERR or (13 shl 8));
  SQLITE_IOERR_CHECKRESERVEDLOCK = (SQLITE_IOERR or (14 shl 8));
  SQLITE_IOERR_LOCK = (SQLITE_IOERR or (15 shl 8));
  SQLITE_IOERR_CLOSE = (SQLITE_IOERR or (16 shl 8));
  SQLITE_IOERR_DIR_CLOSE = (SQLITE_IOERR or (17 shl 8));
  SQLITE_IOERR_SHMOPEN = (SQLITE_IOERR or (18 shl 8));
  SQLITE_IOERR_SHMSIZE = (SQLITE_IOERR or (19 shl 8));
  SQLITE_IOERR_SHMLOCK = (SQLITE_IOERR or (20 shl 8));
  SQLITE_IOERR_SHMMAP = (SQLITE_IOERR or (21 shl 8));
  SQLITE_IOERR_SEEK = (SQLITE_IOERR or (22 shl 8));
  SQLITE_IOERR_DELETE_NOENT = (SQLITE_IOERR or (23 shl 8));
  SQLITE_IOERR_MMAP = (SQLITE_IOERR or (24 shl 8));
  SQLITE_IOERR_GETTEMPPATH = (SQLITE_IOERR or (25 shl 8));
  SQLITE_IOERR_CONVPATH = (SQLITE_IOERR or (26 shl 8));
  SQLITE_IOERR_VNODE = (SQLITE_IOERR or (27 shl 8));
  SQLITE_IOERR_AUTH = (SQLITE_IOERR or (28 shl 8));
  SQLITE_IOERR_BEGIN_ATOMIC = (SQLITE_IOERR or (29 shl 8));
  SQLITE_IOERR_COMMIT_ATOMIC = (SQLITE_IOERR or (30 shl 8));
  SQLITE_IOERR_ROLLBACK_ATOMIC = (SQLITE_IOERR or (31 shl 8));
  SQLITE_IOERR_DATA = (SQLITE_IOERR or (32 shl 8));
  SQLITE_IOERR_CORRUPTFS = (SQLITE_IOERR or (33 shl 8));
  SQLITE_IOERR_IN_PAGE = (SQLITE_IOERR or (34 shl 8));
  SQLITE_LOCKED_SHAREDCACHE = (SQLITE_LOCKED or (1 shl 8));
  SQLITE_LOCKED_VTAB = (SQLITE_LOCKED or (2 shl 8));
  SQLITE_BUSY_RECOVERY = (SQLITE_BUSY or (1 shl 8));
  SQLITE_BUSY_SNAPSHOT = (SQLITE_BUSY or (2 shl 8));
  SQLITE_BUSY_TIMEOUT = (SQLITE_BUSY or (3 shl 8));
  SQLITE_CANTOPEN_NOTEMPDIR = (SQLITE_CANTOPEN or (1 shl 8));
  SQLITE_CANTOPEN_ISDIR = (SQLITE_CANTOPEN or (2 shl 8));
  SQLITE_CANTOPEN_FULLPATH = (SQLITE_CANTOPEN or (3 shl 8));
  SQLITE_CANTOPEN_CONVPATH = (SQLITE_CANTOPEN or (4 shl 8));
  SQLITE_CANTOPEN_DIRTYWAL = (SQLITE_CANTOPEN or (5 shl 8));
  SQLITE_CANTOPEN_SYMLINK = (SQLITE_CANTOPEN or (6 shl 8));
  SQLITE_CORRUPT_VTAB = (SQLITE_CORRUPT or (1 shl 8));
  SQLITE_CORRUPT_SEQUENCE = (SQLITE_CORRUPT or (2 shl 8));
  SQLITE_CORRUPT_INDEX = (SQLITE_CORRUPT or (3 shl 8));
  SQLITE_READONLY_RECOVERY = (SQLITE_READONLY or (1 shl 8));
  SQLITE_READONLY_CANTLOCK = (SQLITE_READONLY or (2 shl 8));
  SQLITE_READONLY_ROLLBACK = (SQLITE_READONLY or (3 shl 8));
  SQLITE_READONLY_DBMOVED = (SQLITE_READONLY or (4 shl 8));
  SQLITE_READONLY_CANTINIT = (SQLITE_READONLY or (5 shl 8));
  SQLITE_READONLY_DIRECTORY = (SQLITE_READONLY or (6 shl 8));
  SQLITE_ABORT_ROLLBACK = (SQLITE_ABORT or (2 shl 8));
  SQLITE_CONSTRAINT_CHECK = (SQLITE_CONSTRAINT or (1 shl 8));
  SQLITE_CONSTRAINT_COMMITHOOK = (SQLITE_CONSTRAINT or (2 shl 8));
  SQLITE_CONSTRAINT_FOREIGNKEY = (SQLITE_CONSTRAINT or (3 shl 8));
  SQLITE_CONSTRAINT_FUNCTION = (SQLITE_CONSTRAINT or (4 shl 8));
  SQLITE_CONSTRAINT_NOTNULL = (SQLITE_CONSTRAINT or (5 shl 8));
  SQLITE_CONSTRAINT_PRIMARYKEY = (SQLITE_CONSTRAINT or (6 shl 8));
  SQLITE_CONSTRAINT_TRIGGER = (SQLITE_CONSTRAINT or (7 shl 8));
  SQLITE_CONSTRAINT_UNIQUE = (SQLITE_CONSTRAINT or (8 shl 8));
  SQLITE_CONSTRAINT_VTAB = (SQLITE_CONSTRAINT or (9 shl 8));
  SQLITE_CONSTRAINT_ROWID = (SQLITE_CONSTRAINT or (10 shl 8));
  SQLITE_CONSTRAINT_PINNED = (SQLITE_CONSTRAINT or (11 shl 8));
  SQLITE_CONSTRAINT_DATATYPE = (SQLITE_CONSTRAINT or (12 shl 8));
  SQLITE_NOTICE_RECOVER_WAL = (SQLITE_NOTICE or (1 shl 8));
  SQLITE_NOTICE_RECOVER_ROLLBACK = (SQLITE_NOTICE or (2 shl 8));
  SQLITE_NOTICE_RBU = (SQLITE_NOTICE or (3 shl 8));
  SQLITE_WARNING_AUTOINDEX = (SQLITE_WARNING or (1 shl 8));
  SQLITE_AUTH_USER = (SQLITE_AUTH or (1 shl 8));
  SQLITE_OK_LOAD_PERMANENTLY = (SQLITE_OK or (1 shl 8));
  SQLITE_OK_SYMLINK = (SQLITE_OK or (2 shl 8));
  SQLITE_OPEN_READONLY = $00000001;
  SQLITE_OPEN_READWRITE = $00000002;
  SQLITE_OPEN_CREATE = $00000004;
  SQLITE_OPEN_DELETEONCLOSE = $00000008;
  SQLITE_OPEN_EXCLUSIVE = $00000010;
  SQLITE_OPEN_AUTOPROXY = $00000020;
  SQLITE_OPEN_URI = $00000040;
  SQLITE_OPEN_MEMORY = $00000080;
  SQLITE_OPEN_MAIN_DB = $00000100;
  SQLITE_OPEN_TEMP_DB = $00000200;
  SQLITE_OPEN_TRANSIENT_DB = $00000400;
  SQLITE_OPEN_MAIN_JOURNAL = $00000800;
  SQLITE_OPEN_TEMP_JOURNAL = $00001000;
  SQLITE_OPEN_SUBJOURNAL = $00002000;
  SQLITE_OPEN_SUPER_JOURNAL = $00004000;
  SQLITE_OPEN_NOMUTEX = $00008000;
  SQLITE_OPEN_FULLMUTEX = $00010000;
  SQLITE_OPEN_SHAREDCACHE = $00020000;
  SQLITE_OPEN_PRIVATECACHE = $00040000;
  SQLITE_OPEN_WAL = $00080000;
  SQLITE_OPEN_NOFOLLOW = $01000000;
  SQLITE_OPEN_EXRESCODE = $02000000;
  SQLITE_OPEN_MASTER_JOURNAL = $00004000;
  SQLITE_IOCAP_ATOMIC = $00000001;
  SQLITE_IOCAP_ATOMIC512 = $00000002;
  SQLITE_IOCAP_ATOMIC1K = $00000004;
  SQLITE_IOCAP_ATOMIC2K = $00000008;
  SQLITE_IOCAP_ATOMIC4K = $00000010;
  SQLITE_IOCAP_ATOMIC8K = $00000020;
  SQLITE_IOCAP_ATOMIC16K = $00000040;
  SQLITE_IOCAP_ATOMIC32K = $00000080;
  SQLITE_IOCAP_ATOMIC64K = $00000100;
  SQLITE_IOCAP_SAFE_APPEND = $00000200;
  SQLITE_IOCAP_SEQUENTIAL = $00000400;
  SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = $00000800;
  SQLITE_IOCAP_POWERSAFE_OVERWRITE = $00001000;
  SQLITE_IOCAP_IMMUTABLE = $00002000;
  SQLITE_IOCAP_BATCH_ATOMIC = $00004000;
  SQLITE_IOCAP_SUBPAGE_READ = $00008000;
  SQLITE_LOCK_NONE = 0;
  SQLITE_LOCK_SHARED = 1;
  SQLITE_LOCK_RESERVED = 2;
  SQLITE_LOCK_PENDING = 3;
  SQLITE_LOCK_EXCLUSIVE = 4;
  SQLITE_SYNC_NORMAL = $00002;
  SQLITE_SYNC_FULL = $00003;
  SQLITE_SYNC_DATAONLY = $00010;
  SQLITE_FCNTL_LOCKSTATE = 1;
  SQLITE_FCNTL_GET_LOCKPROXYFILE = 2;
  SQLITE_FCNTL_SET_LOCKPROXYFILE = 3;
  SQLITE_FCNTL_LAST_ERRNO = 4;
  SQLITE_FCNTL_SIZE_HINT = 5;
  SQLITE_FCNTL_CHUNK_SIZE = 6;
  SQLITE_FCNTL_FILE_POINTER = 7;
  SQLITE_FCNTL_SYNC_OMITTED = 8;
  SQLITE_FCNTL_WIN32_AV_RETRY = 9;
  SQLITE_FCNTL_PERSIST_WAL = 10;
  SQLITE_FCNTL_OVERWRITE = 11;
  SQLITE_FCNTL_VFSNAME = 12;
  SQLITE_FCNTL_POWERSAFE_OVERWRITE = 13;
  SQLITE_FCNTL_PRAGMA = 14;
  SQLITE_FCNTL_BUSYHANDLER = 15;
  SQLITE_FCNTL_TEMPFILENAME = 16;
  SQLITE_FCNTL_MMAP_SIZE = 18;
  SQLITE_FCNTL_TRACE = 19;
  SQLITE_FCNTL_HAS_MOVED = 20;
  SQLITE_FCNTL_SYNC = 21;
  SQLITE_FCNTL_COMMIT_PHASETWO = 22;
  SQLITE_FCNTL_WIN32_SET_HANDLE = 23;
  SQLITE_FCNTL_WAL_BLOCK = 24;
  SQLITE_FCNTL_ZIPVFS = 25;
  SQLITE_FCNTL_RBU = 26;
  SQLITE_FCNTL_VFS_POINTER = 27;
  SQLITE_FCNTL_JOURNAL_POINTER = 28;
  SQLITE_FCNTL_WIN32_GET_HANDLE = 29;
  SQLITE_FCNTL_PDB = 30;
  SQLITE_FCNTL_BEGIN_ATOMIC_WRITE = 31;
  SQLITE_FCNTL_COMMIT_ATOMIC_WRITE = 32;
  SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = 33;
  SQLITE_FCNTL_LOCK_TIMEOUT = 34;
  SQLITE_FCNTL_DATA_VERSION = 35;
  SQLITE_FCNTL_SIZE_LIMIT = 36;
  SQLITE_FCNTL_CKPT_DONE = 37;
  SQLITE_FCNTL_RESERVE_BYTES = 38;
  SQLITE_FCNTL_CKPT_START = 39;
  SQLITE_FCNTL_EXTERNAL_READER = 40;
  SQLITE_FCNTL_CKSM_FILE = 41;
  SQLITE_FCNTL_RESET_CACHE = 42;
  SQLITE_FCNTL_NULL_IO = 43;
  SQLITE_GET_LOCKPROXYFILE = SQLITE_FCNTL_GET_LOCKPROXYFILE;
  SQLITE_SET_LOCKPROXYFILE = SQLITE_FCNTL_SET_LOCKPROXYFILE;
  SQLITE_LAST_ERRNO = SQLITE_FCNTL_LAST_ERRNO;
  SQLITE_ACCESS_EXISTS = 0;
  SQLITE_ACCESS_READWRITE = 1;
  SQLITE_ACCESS_READ = 2;
  SQLITE_SHM_UNLOCK = 1;
  SQLITE_SHM_LOCK = 2;
  SQLITE_SHM_SHARED = 4;
  SQLITE_SHM_EXCLUSIVE = 8;
  SQLITE_SHM_NLOCK = 8;
  SQLITE_CONFIG_SINGLETHREAD = 1;
  SQLITE_CONFIG_MULTITHREAD = 2;
  SQLITE_CONFIG_SERIALIZED = 3;
  SQLITE_CONFIG_MALLOC = 4;
  SQLITE_CONFIG_GETMALLOC = 5;
  SQLITE_CONFIG_SCRATCH = 6;
  SQLITE_CONFIG_PAGECACHE = 7;
  SQLITE_CONFIG_HEAP = 8;
  SQLITE_CONFIG_MEMSTATUS = 9;
  SQLITE_CONFIG_MUTEX = 10;
  SQLITE_CONFIG_GETMUTEX = 11;
  SQLITE_CONFIG_LOOKASIDE = 13;
  SQLITE_CONFIG_PCACHE = 14;
  SQLITE_CONFIG_GETPCACHE = 15;
  SQLITE_CONFIG_LOG = 16;
  SQLITE_CONFIG_URI = 17;
  SQLITE_CONFIG_PCACHE2 = 18;
  SQLITE_CONFIG_GETPCACHE2 = 19;
  SQLITE_CONFIG_COVERING_INDEX_SCAN = 20;
  SQLITE_CONFIG_SQLLOG = 21;
  SQLITE_CONFIG_MMAP_SIZE = 22;
  SQLITE_CONFIG_WIN32_HEAPSIZE = 23;
  SQLITE_CONFIG_PCACHE_HDRSZ = 24;
  SQLITE_CONFIG_PMASZ = 25;
  SQLITE_CONFIG_STMTJRNL_SPILL = 26;
  SQLITE_CONFIG_SMALL_MALLOC = 27;
  SQLITE_CONFIG_SORTERREF_SIZE = 28;
  SQLITE_CONFIG_MEMDB_MAXSIZE = 29;
  SQLITE_CONFIG_ROWID_IN_VIEW = 30;
  SQLITE_DBCONFIG_MAINDBNAME = 1000;
  SQLITE_DBCONFIG_LOOKASIDE = 1001;
  SQLITE_DBCONFIG_ENABLE_FKEY = 1002;
  SQLITE_DBCONFIG_ENABLE_TRIGGER = 1003;
  SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004;
  SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005;
  SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE = 1006;
  SQLITE_DBCONFIG_ENABLE_QPSG = 1007;
  SQLITE_DBCONFIG_TRIGGER_EQP = 1008;
  SQLITE_DBCONFIG_RESET_DATABASE = 1009;
  SQLITE_DBCONFIG_DEFENSIVE = 1010;
  SQLITE_DBCONFIG_WRITABLE_SCHEMA = 1011;
  SQLITE_DBCONFIG_LEGACY_ALTER_TABLE = 1012;
  SQLITE_DBCONFIG_DQS_DML = 1013;
  SQLITE_DBCONFIG_DQS_DDL = 1014;
  SQLITE_DBCONFIG_ENABLE_VIEW = 1015;
  SQLITE_DBCONFIG_LEGACY_FILE_FORMAT = 1016;
  SQLITE_DBCONFIG_TRUSTED_SCHEMA = 1017;
  SQLITE_DBCONFIG_STMT_SCANSTATUS = 1018;
  SQLITE_DBCONFIG_REVERSE_SCANORDER = 1019;
  SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE = 1020;
  SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE = 1021;
  SQLITE_DBCONFIG_ENABLE_COMMENTS = 1022;
  SQLITE_DBCONFIG_MAX = 1022;
  SQLITE_DENY = 1;
  SQLITE_IGNORE = 2;
  SQLITE_CREATE_INDEX = 1;
  SQLITE_CREATE_TABLE = 2;
  SQLITE_CREATE_TEMP_INDEX = 3;
  SQLITE_CREATE_TEMP_TABLE = 4;
  SQLITE_CREATE_TEMP_TRIGGER = 5;
  SQLITE_CREATE_TEMP_VIEW = 6;
  SQLITE_CREATE_TRIGGER = 7;
  SQLITE_CREATE_VIEW = 8;
  SQLITE_DELETE = 9;
  SQLITE_DROP_INDEX = 10;
  SQLITE_DROP_TABLE = 11;
  SQLITE_DROP_TEMP_INDEX = 12;
  SQLITE_DROP_TEMP_TABLE = 13;
  SQLITE_DROP_TEMP_TRIGGER = 14;
  SQLITE_DROP_TEMP_VIEW = 15;
  SQLITE_DROP_TRIGGER = 16;
  SQLITE_DROP_VIEW = 17;
  SQLITE_INSERT = 18;
  SQLITE_PRAGMA = 19;
  SQLITE_READ = 20;
  SQLITE_SELECT = 21;
  SQLITE_TRANSACTION = 22;
  SQLITE_UPDATE = 23;
  SQLITE_ATTACH = 24;
  SQLITE_DETACH = 25;
  SQLITE_ALTER_TABLE = 26;
  SQLITE_REINDEX = 27;
  SQLITE_ANALYZE = 28;
  SQLITE_CREATE_VTABLE = 29;
  SQLITE_DROP_VTABLE = 30;
  SQLITE_FUNCTION = 31;
  SQLITE_SAVEPOINT = 32;
  SQLITE_COPY = 0;
  SQLITE_RECURSIVE = 33;
  SQLITE_TRACE_STMT = $01;
  SQLITE_TRACE_PROFILE = $02;
  SQLITE_TRACE_ROW = $04;
  SQLITE_TRACE_CLOSE = $08;
  SQLITE_LIMIT_LENGTH = 0;
  SQLITE_LIMIT_SQL_LENGTH = 1;
  SQLITE_LIMIT_COLUMN = 2;
  SQLITE_LIMIT_EXPR_DEPTH = 3;
  SQLITE_LIMIT_COMPOUND_SELECT = 4;
  SQLITE_LIMIT_VDBE_OP = 5;
  SQLITE_LIMIT_FUNCTION_ARG = 6;
  SQLITE_LIMIT_ATTACHED = 7;
  SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8;
  SQLITE_LIMIT_VARIABLE_NUMBER = 9;
  SQLITE_LIMIT_TRIGGER_DEPTH = 10;
  SQLITE_LIMIT_WORKER_THREADS = 11;
  SQLITE_PREPARE_PERSISTENT = $01;
  SQLITE_PREPARE_NORMALIZE = $02;
  SQLITE_PREPARE_NO_VTAB = $04;
  SQLITE_PREPARE_DONT_LOG = $10;
  SQLITE_INTEGER = 1;
  SQLITE_FLOAT = 2;
  SQLITE_BLOB = 4;
  SQLITE_NULL = 5;
  SQLITE_TEXT = 3;
  SQLITE3_TEXT = 3;
  SQLITE_UTF8 = 1;
  SQLITE_UTF16LE = 2;
  SQLITE_UTF16BE = 3;
  SQLITE_UTF16 = 4;
  SQLITE_ANY = 5;
  SQLITE_UTF16_ALIGNED = 8;
  SQLITE_DETERMINISTIC = $000000800;
  SQLITE_DIRECTONLY = $000080000;
  SQLITE_SUBTYPE = $000100000;
  SQLITE_INNOCUOUS = $000200000;
  SQLITE_RESULT_SUBTYPE = $001000000;
  SQLITE_SELFORDER1 = $002000000;
  SQLITE_WIN32_DATA_DIRECTORY_TYPE = 1;
  SQLITE_WIN32_TEMP_DIRECTORY_TYPE = 2;
  SQLITE_TXN_NONE = 0;
  SQLITE_TXN_READ = 1;
  SQLITE_TXN_WRITE = 2;
  SQLITE_INDEX_SCAN_UNIQUE = $00000001;
  SQLITE_INDEX_SCAN_HEX = $00000002;
  SQLITE_INDEX_CONSTRAINT_EQ = 2;
  SQLITE_INDEX_CONSTRAINT_GT = 4;
  SQLITE_INDEX_CONSTRAINT_LE = 8;
  SQLITE_INDEX_CONSTRAINT_LT = 16;
  SQLITE_INDEX_CONSTRAINT_GE = 32;
  SQLITE_INDEX_CONSTRAINT_MATCH = 64;
  SQLITE_INDEX_CONSTRAINT_LIKE = 65;
  SQLITE_INDEX_CONSTRAINT_GLOB = 66;
  SQLITE_INDEX_CONSTRAINT_REGEXP = 67;
  SQLITE_INDEX_CONSTRAINT_NE = 68;
  SQLITE_INDEX_CONSTRAINT_ISNOT = 69;
  SQLITE_INDEX_CONSTRAINT_ISNOTNULL = 70;
  SQLITE_INDEX_CONSTRAINT_ISNULL = 71;
  SQLITE_INDEX_CONSTRAINT_IS = 72;
  SQLITE_INDEX_CONSTRAINT_LIMIT = 73;
  SQLITE_INDEX_CONSTRAINT_OFFSET = 74;
  SQLITE_INDEX_CONSTRAINT_FUNCTION = 150;
  SQLITE_MUTEX_FAST = 0;
  SQLITE_MUTEX_RECURSIVE = 1;
  SQLITE_MUTEX_STATIC_MAIN = 2;
  SQLITE_MUTEX_STATIC_MEM = 3;
  SQLITE_MUTEX_STATIC_MEM2 = 4;
  SQLITE_MUTEX_STATIC_OPEN = 4;
  SQLITE_MUTEX_STATIC_PRNG = 5;
  SQLITE_MUTEX_STATIC_LRU = 6;
  SQLITE_MUTEX_STATIC_LRU2 = 7;
  SQLITE_MUTEX_STATIC_PMEM = 7;
  SQLITE_MUTEX_STATIC_APP1 = 8;
  SQLITE_MUTEX_STATIC_APP2 = 9;
  SQLITE_MUTEX_STATIC_APP3 = 10;
  SQLITE_MUTEX_STATIC_VFS1 = 11;
  SQLITE_MUTEX_STATIC_VFS2 = 12;
  SQLITE_MUTEX_STATIC_VFS3 = 13;
  SQLITE_MUTEX_STATIC_MASTER = 2;
  SQLITE_TESTCTRL_FIRST = 5;
  SQLITE_TESTCTRL_PRNG_SAVE = 5;
  SQLITE_TESTCTRL_PRNG_RESTORE = 6;
  SQLITE_TESTCTRL_PRNG_RESET = 7;
  SQLITE_TESTCTRL_FK_NO_ACTION = 7;
  SQLITE_TESTCTRL_BITVEC_TEST = 8;
  SQLITE_TESTCTRL_FAULT_INSTALL = 9;
  SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS = 10;
  SQLITE_TESTCTRL_PENDING_BYTE = 11;
  SQLITE_TESTCTRL_ASSERT = 12;
  SQLITE_TESTCTRL_ALWAYS = 13;
  SQLITE_TESTCTRL_RESERVE = 14;
  SQLITE_TESTCTRL_JSON_SELFCHECK = 14;
  SQLITE_TESTCTRL_OPTIMIZATIONS = 15;
  SQLITE_TESTCTRL_ISKEYWORD = 16;
  SQLITE_TESTCTRL_GETOPT = 16;
  SQLITE_TESTCTRL_SCRATCHMALLOC = 17;
  SQLITE_TESTCTRL_INTERNAL_FUNCTIONS = 17;
  SQLITE_TESTCTRL_LOCALTIME_FAULT = 18;
  SQLITE_TESTCTRL_EXPLAIN_STMT = 19;
  SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD = 19;
  SQLITE_TESTCTRL_NEVER_CORRUPT = 20;
  SQLITE_TESTCTRL_VDBE_COVERAGE = 21;
  SQLITE_TESTCTRL_BYTEORDER = 22;
  SQLITE_TESTCTRL_ISINIT = 23;
  SQLITE_TESTCTRL_SORTER_MMAP = 24;
  SQLITE_TESTCTRL_IMPOSTER = 25;
  SQLITE_TESTCTRL_PARSER_COVERAGE = 26;
  SQLITE_TESTCTRL_RESULT_INTREAL = 27;
  SQLITE_TESTCTRL_PRNG_SEED = 28;
  SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS = 29;
  SQLITE_TESTCTRL_SEEK_COUNT = 30;
  SQLITE_TESTCTRL_TRACEFLAGS = 31;
  SQLITE_TESTCTRL_TUNE = 32;
  SQLITE_TESTCTRL_LOGEST = 33;
  SQLITE_TESTCTRL_USELONGDOUBLE = 34;
  SQLITE_TESTCTRL_LAST = 34;
  SQLITE_STATUS_MEMORY_USED = 0;
  SQLITE_STATUS_PAGECACHE_USED = 1;
  SQLITE_STATUS_PAGECACHE_OVERFLOW = 2;
  SQLITE_STATUS_SCRATCH_USED = 3;
  SQLITE_STATUS_SCRATCH_OVERFLOW = 4;
  SQLITE_STATUS_MALLOC_SIZE = 5;
  SQLITE_STATUS_PARSER_STACK = 6;
  SQLITE_STATUS_PAGECACHE_SIZE = 7;
  SQLITE_STATUS_SCRATCH_SIZE = 8;
  SQLITE_STATUS_MALLOC_COUNT = 9;
  SQLITE_DBSTATUS_LOOKASIDE_USED = 0;
  SQLITE_DBSTATUS_CACHE_USED = 1;
  SQLITE_DBSTATUS_SCHEMA_USED = 2;
  SQLITE_DBSTATUS_STMT_USED = 3;
  SQLITE_DBSTATUS_LOOKASIDE_HIT = 4;
  SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE = 5;
  SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL = 6;
  SQLITE_DBSTATUS_CACHE_HIT = 7;
  SQLITE_DBSTATUS_CACHE_MISS = 8;
  SQLITE_DBSTATUS_CACHE_WRITE = 9;
  SQLITE_DBSTATUS_DEFERRED_FKS = 10;
  SQLITE_DBSTATUS_CACHE_USED_SHARED = 11;
  SQLITE_DBSTATUS_CACHE_SPILL = 12;
  SQLITE_DBSTATUS_MAX = 12;
  SQLITE_STMTSTATUS_FULLSCAN_STEP = 1;
  SQLITE_STMTSTATUS_SORT = 2;
  SQLITE_STMTSTATUS_AUTOINDEX = 3;
  SQLITE_STMTSTATUS_VM_STEP = 4;
  SQLITE_STMTSTATUS_REPREPARE = 5;
  SQLITE_STMTSTATUS_RUN = 6;
  SQLITE_STMTSTATUS_FILTER_MISS = 7;
  SQLITE_STMTSTATUS_FILTER_HIT = 8;
  SQLITE_STMTSTATUS_MEMUSED = 99;
  SQLITE_CHECKPOINT_PASSIVE = 0;
  SQLITE_CHECKPOINT_FULL = 1;
  SQLITE_CHECKPOINT_RESTART = 2;
  SQLITE_CHECKPOINT_TRUNCATE = 3;
  SQLITE_VTAB_CONSTRAINT_SUPPORT = 1;
  SQLITE_VTAB_INNOCUOUS = 2;
  SQLITE_VTAB_DIRECTONLY = 3;
  SQLITE_VTAB_USES_ALL_SCHEMAS = 4;
  SQLITE_ROLLBACK = 1;
  SQLITE_FAIL = 3;
  SQLITE_REPLACE = 5;
  SQLITE_SCANSTAT_NLOOP = 0;
  SQLITE_SCANSTAT_NVISIT = 1;
  SQLITE_SCANSTAT_EST = 2;
  SQLITE_SCANSTAT_NAME = 3;
  SQLITE_SCANSTAT_EXPLAIN = 4;
  SQLITE_SCANSTAT_SELECTID = 5;
  SQLITE_SCANSTAT_PARENTID = 6;
  SQLITE_SCANSTAT_NCYCLE = 7;
  SQLITE_SCANSTAT_COMPLEX = $0001;
  SQLITE_SERIALIZE_NOCOPY = $001;
  SQLITE_DESERIALIZE_FREEONCLOSE = 1;
  SQLITE_DESERIALIZE_RESIZEABLE = 2;
  SQLITE_DESERIALIZE_READONLY = 4;
  NOT_WITHIN = 0;
  PARTLY_WITHIN = 1;
  FULLY_WITHIN = 2;
  FTS5_TOKENIZE_QUERY = $0001;
  FTS5_TOKENIZE_PREFIX = $0002;
  FTS5_TOKENIZE_DOCUMENT = $0004;
  FTS5_TOKENIZE_AUX = $0008;
  FTS5_TOKEN_COLOCATED = $0001;
  IM_UNICODE_CODEPOINT_MAX = $FFFF;
  IMGUI_HAS_DOCK = 1;
  ImDrawCallback_ResetRenderState = -8;

const
  LUAJIT_MODE_ENGINE = 0;
  LUAJIT_MODE_DEBUG = 1;
  LUAJIT_MODE_FUNC = 2;
  LUAJIT_MODE_ALLFUNC = 3;
  LUAJIT_MODE_ALLSUBFUNC = 4;
  LUAJIT_MODE_TRACE = 5;
  LUAJIT_MODE_WRAPCFUNC = 16;
  LUAJIT_MODE_MAX = 17;

type
  spAttachmentType = Integer;
  PspAttachmentType = ^spAttachmentType;

const
  SP_ATTACHMENT_REGION = 0;
  SP_ATTACHMENT_BOUNDING_BOX = 1;
  SP_ATTACHMENT_MESH = 2;
  SP_ATTACHMENT_LINKED_MESH = 3;
  SP_ATTACHMENT_PATH = 4;
  SP_ATTACHMENT_POINT = 5;
  SP_ATTACHMENT_CLIPPING = 6;

type
  spInherit = Integer;
  PspInherit = ^spInherit;

const
  SP_INHERIT_NORMAL = 0;
  SP_INHERIT_ONLYTRANSLATION = 1;
  SP_INHERIT_NOROTATIONORREFLECTION = 2;
  SP_INHERIT_NOSCALE = 3;
  SP_INHERIT_NOSCALEORREFLECTION = 4;

type
  spPhysics = Integer;
  PspPhysics = ^spPhysics;

const
  SP_PHYSICS_NONE = 0;
  SP_PHYSICS_RESET = 1;
  SP_PHYSICS_UPDATE = 2;
  SP_PHYSICS_POSE = 3;

type
  spBlendMode = Integer;
  PspBlendMode = ^spBlendMode;

const
  SP_BLEND_MODE_NORMAL = 0;
  SP_BLEND_MODE_ADDITIVE = 1;
  SP_BLEND_MODE_MULTIPLY = 2;
  SP_BLEND_MODE_SCREEN = 3;

type
  spAtlasFormat = Integer;
  PspAtlasFormat = ^spAtlasFormat;

const
  SP_ATLAS_UNKNOWN_FORMAT = 0;
  SP_ATLAS_ALPHA = 1;
  SP_ATLAS_INTENSITY = 2;
  SP_ATLAS_LUMINANCE_ALPHA = 3;
  SP_ATLAS_RGB565 = 4;
  SP_ATLAS_RGBA4444 = 5;
  SP_ATLAS_RGB888 = 6;
  SP_ATLAS_RGBA8888 = 7;

type
  spAtlasFilter = Integer;
  PspAtlasFilter = ^spAtlasFilter;

const
  SP_ATLAS_UNKNOWN_FILTER = 0;
  SP_ATLAS_NEAREST = 1;
  SP_ATLAS_LINEAR = 2;
  SP_ATLAS_MIPMAP = 3;
  SP_ATLAS_MIPMAP_NEAREST_NEAREST = 4;
  SP_ATLAS_MIPMAP_LINEAR_NEAREST = 5;
  SP_ATLAS_MIPMAP_NEAREST_LINEAR = 6;
  SP_ATLAS_MIPMAP_LINEAR_LINEAR = 7;

type
  spAtlasWrap = Integer;
  PspAtlasWrap = ^spAtlasWrap;

const
  SP_ATLAS_MIRROREDREPEAT = 0;
  SP_ATLAS_CLAMPTOEDGE = 1;
  SP_ATLAS_REPEAT = 2;

type
  spMixBlend = Integer;
  PspMixBlend = ^spMixBlend;

const
  SP_MIX_BLEND_SETUP = 0;
  SP_MIX_BLEND_FIRST = 1;
  SP_MIX_BLEND_REPLACE = 2;
  SP_MIX_BLEND_ADD = 3;

type
  spMixDirection = Integer;
  PspMixDirection = ^spMixDirection;

const
  SP_MIX_DIRECTION_IN = 0;
  SP_MIX_DIRECTION_OUT = 1;

type
  spTimelineType = Integer;
  PspTimelineType = ^spTimelineType;

const
  SP_TIMELINE_ATTACHMENT = 0;
  SP_TIMELINE_ALPHA = 1;
  SP_TIMELINE_PATHCONSTRAINTPOSITION = 2;
  SP_TIMELINE_PATHCONSTRAINTSPACING = 3;
  SP_TIMELINE_ROTATE = 4;
  SP_TIMELINE_SCALEX = 5;
  SP_TIMELINE_SCALEY = 6;
  SP_TIMELINE_SHEARX = 7;
  SP_TIMELINE_SHEARY = 8;
  SP_TIMELINE_TRANSLATEX = 9;
  SP_TIMELINE_TRANSLATEY = 10;
  SP_TIMELINE_SCALE = 11;
  SP_TIMELINE_SHEAR = 12;
  SP_TIMELINE_TRANSLATE = 13;
  SP_TIMELINE_DEFORM = 14;
  SP_TIMELINE_SEQUENCE = 15;
  SP_TIMELINE_INHERIT = 16;
  SP_TIMELINE_IKCONSTRAINT = 17;
  SP_TIMELINE_PATHCONSTRAINTMIX = 18;
  SP_TIMELINE_PHYSICSCONSTRAINT_INERTIA = 19;
  SP_TIMELINE_PHYSICSCONSTRAINT_STRENGTH = 20;
  SP_TIMELINE_PHYSICSCONSTRAINT_DAMPING = 21;
  SP_TIMELINE_PHYSICSCONSTRAINT_MASS = 22;
  SP_TIMELINE_PHYSICSCONSTRAINT_WIND = 23;
  SP_TIMELINE_PHYSICSCONSTRAINT_GRAVITY = 24;
  SP_TIMELINE_PHYSICSCONSTRAINT_MIX = 25;
  SP_TIMELINE_PHYSICSCONSTRAINT_RESET = 26;
  SP_TIMELINE_RGB2 = 27;
  SP_TIMELINE_RGBA2 = 28;
  SP_TIMELINE_RGBA = 29;
  SP_TIMELINE_RGB = 30;
  SP_TIMELINE_TRANSFORMCONSTRAINT = 31;
  SP_TIMELINE_DRAWORDER = 32;
  SP_TIMELINE_EVENT = 33;

type
  spProperty = Integer;
  PspProperty = ^spProperty;

const
  SP_PROPERTY_ROTATE = 1;
  SP_PROPERTY_X = 2;
  SP_PROPERTY_Y = 4;
  SP_PROPERTY_SCALEX = 8;
  SP_PROPERTY_SCALEY = 16;
  SP_PROPERTY_SHEARX = 32;
  SP_PROPERTY_SHEARY = 64;
  SP_PROPERTY_INHERIT = 128;
  SP_PROPERTY_RGB = 256;
  SP_PROPERTY_ALPHA = 512;
  SP_PROPERTY_RGB2 = 1024;
  SP_PROPERTY_ATTACHMENT = 2048;
  SP_PROPERTY_DEFORM = 4096;
  SP_PROPERTY_EVENT = 8192;
  SP_PROPERTY_DRAWORDER = 16384;
  SP_PROPERTY_IKCONSTRAINT = 32768;
  SP_PROPERTY_TRANSFORMCONSTRAINT = 65536;
  SP_PROPERTY_PATHCONSTRAINT_POSITION = 131072;
  SP_PROPERTY_PATHCONSTRAINT_SPACING = 262144;
  SP_PROPERTY_PATHCONSTRAINT_MIX = 524288;
  SP_PROPERTY_PHYSICSCONSTRAINT_INERTIA = 1048576;
  SP_PROPERTY_PHYSICSCONSTRAINT_STRENGTH = 2097152;
  SP_PROPERTY_PHYSICSCONSTRAINT_DAMPING = 4194304;
  SP_PROPERTY_PHYSICSCONSTRAINT_MASS = 8388608;
  SP_PROPERTY_PHYSICSCONSTRAINT_WIND = 16777216;
  SP_PROPERTY_PHYSICSCONSTRAINT_GRAVITY = 33554432;
  SP_PROPERTY_PHYSICSCONSTRAINT_MIX = 67108864;
  SP_PROPERTY_PHYSICSCONSTRAINT_RESET = 134217728;
  SP_PROPERTY_SEQUENCE = 268435456;

type
  spPositionMode = Integer;
  PspPositionMode = ^spPositionMode;

const
  SP_POSITION_MODE_FIXED = 0;
  SP_POSITION_MODE_PERCENT = 1;

type
  spSpacingMode = Integer;
  PspSpacingMode = ^spSpacingMode;

const
  SP_SPACING_MODE_LENGTH = 0;
  SP_SPACING_MODE_FIXED = 1;
  SP_SPACING_MODE_PERCENT = 2;
  SP_SPACING_MODE_PROPORTIONAL = 3;

type
  spRotateMode = Integer;
  PspRotateMode = ^spRotateMode;

const
  SP_ROTATE_MODE_TANGENT = 0;
  SP_ROTATE_MODE_CHAIN = 1;
  SP_ROTATE_MODE_CHAIN_SCALE = 2;

type
  spEventType = Integer;
  PspEventType = ^spEventType;

const
  SP_ANIMATION_START = 0;
  SP_ANIMATION_INTERRUPT = 1;
  SP_ANIMATION_END = 2;
  SP_ANIMATION_COMPLETE = 3;
  SP_ANIMATION_DISPOSE = 4;
  SP_ANIMATION_EVENT = 5;

const
  STBI_default = 0;
  STBI_grey = 1;
  STBI_grey_alpha = 2;
  STBI_rgb = 3;
  STBI_rgb_alpha = 4;

const
  STBRP_HEURISTIC_Skyline_default = 0;
  STBRP_HEURISTIC_Skyline_BL_sortHeight = 0;
  STBRP_HEURISTIC_Skyline_BF_sortHeight = 1;

const
  STBTT_vmove = 1;
  STBTT_vline = 2;
  STBTT_vcurve = 3;
  STBTT_vcubic = 4;

const
  STBTT_PLATFORM_ID_UNICODE = 0;
  STBTT_PLATFORM_ID_MAC = 1;
  STBTT_PLATFORM_ID_ISO = 2;
  STBTT_PLATFORM_ID_MICROSOFT = 3;

const
  STBTT_UNICODE_EID_UNICODE_1_0 = 0;
  STBTT_UNICODE_EID_UNICODE_1_1 = 1;
  STBTT_UNICODE_EID_ISO_10646 = 2;
  STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3;
  STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4;

const
  STBTT_MS_EID_SYMBOL = 0;
  STBTT_MS_EID_UNICODE_BMP = 1;
  STBTT_MS_EID_SHIFTJIS = 2;
  STBTT_MS_EID_UNICODE_FULL = 10;

const
  STBTT_MAC_EID_ROMAN = 0;
  STBTT_MAC_EID_ARABIC = 4;
  STBTT_MAC_EID_JAPANESE = 1;
  STBTT_MAC_EID_HEBREW = 5;
  STBTT_MAC_EID_CHINESE_TRAD = 2;
  STBTT_MAC_EID_GREEK = 6;
  STBTT_MAC_EID_KOREAN = 3;
  STBTT_MAC_EID_RUSSIAN = 7;

const
  STBTT_MS_LANG_ENGLISH = 1033;
  STBTT_MS_LANG_ITALIAN = 1040;
  STBTT_MS_LANG_CHINESE = 2052;
  STBTT_MS_LANG_JAPANESE = 1041;
  STBTT_MS_LANG_DUTCH = 1043;
  STBTT_MS_LANG_KOREAN = 1042;
  STBTT_MS_LANG_FRENCH = 1036;
  STBTT_MS_LANG_RUSSIAN = 1049;
  STBTT_MS_LANG_GERMAN = 1031;
  STBTT_MS_LANG_SPANISH = 1033;
  STBTT_MS_LANG_HEBREW = 1037;
  STBTT_MS_LANG_SWEDISH = 1053;

const
  STBTT_MAC_LANG_ENGLISH = 0;
  STBTT_MAC_LANG_JAPANESE = 11;
  STBTT_MAC_LANG_ARABIC = 12;
  STBTT_MAC_LANG_KOREAN = 23;
  STBTT_MAC_LANG_DUTCH = 4;
  STBTT_MAC_LANG_RUSSIAN = 32;
  STBTT_MAC_LANG_FRENCH = 1;
  STBTT_MAC_LANG_SPANISH = 6;
  STBTT_MAC_LANG_GERMAN = 2;
  STBTT_MAC_LANG_SWEDISH = 5;
  STBTT_MAC_LANG_HEBREW = 10;
  STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33;
  STBTT_MAC_LANG_ITALIAN = 3;
  STBTT_MAC_LANG_CHINESE_TRAD = 19;

type
  C2_TYPE = Integer;
  PC2_TYPE = ^C2_TYPE;

const
  C2_TYPE_NONE = 0;
  C2_TYPE_CIRCLE = 1;
  C2_TYPE_AABB = 2;
  C2_TYPE_CAPSULE = 3;
  C2_TYPE_POLY = 4;

type
  ma_log_level = Integer;
  Pma_log_level = ^ma_log_level;

const
  MA_LOG_LEVEL_DEBUG = 4;
  MA_LOG_LEVEL_INFO = 3;
  MA_LOG_LEVEL_WARNING = 2;
  MA_LOG_LEVEL_ERROR = 1;

type
  _ma_channel_position = Integer;
  P_ma_channel_position = ^_ma_channel_position;

const
  MA_CHANNEL_NONE = 0;
  MA_CHANNEL_MONO = 1;
  MA_CHANNEL_FRONT_LEFT = 2;
  MA_CHANNEL_FRONT_RIGHT = 3;
  MA_CHANNEL_FRONT_CENTER = 4;
  MA_CHANNEL_LFE = 5;
  MA_CHANNEL_BACK_LEFT = 6;
  MA_CHANNEL_BACK_RIGHT = 7;
  MA_CHANNEL_FRONT_LEFT_CENTER = 8;
  MA_CHANNEL_FRONT_RIGHT_CENTER = 9;
  MA_CHANNEL_BACK_CENTER = 10;
  MA_CHANNEL_SIDE_LEFT = 11;
  MA_CHANNEL_SIDE_RIGHT = 12;
  MA_CHANNEL_TOP_CENTER = 13;
  MA_CHANNEL_TOP_FRONT_LEFT = 14;
  MA_CHANNEL_TOP_FRONT_CENTER = 15;
  MA_CHANNEL_TOP_FRONT_RIGHT = 16;
  MA_CHANNEL_TOP_BACK_LEFT = 17;
  MA_CHANNEL_TOP_BACK_CENTER = 18;
  MA_CHANNEL_TOP_BACK_RIGHT = 19;
  MA_CHANNEL_AUX_0 = 20;
  MA_CHANNEL_AUX_1 = 21;
  MA_CHANNEL_AUX_2 = 22;
  MA_CHANNEL_AUX_3 = 23;
  MA_CHANNEL_AUX_4 = 24;
  MA_CHANNEL_AUX_5 = 25;
  MA_CHANNEL_AUX_6 = 26;
  MA_CHANNEL_AUX_7 = 27;
  MA_CHANNEL_AUX_8 = 28;
  MA_CHANNEL_AUX_9 = 29;
  MA_CHANNEL_AUX_10 = 30;
  MA_CHANNEL_AUX_11 = 31;
  MA_CHANNEL_AUX_12 = 32;
  MA_CHANNEL_AUX_13 = 33;
  MA_CHANNEL_AUX_14 = 34;
  MA_CHANNEL_AUX_15 = 35;
  MA_CHANNEL_AUX_16 = 36;
  MA_CHANNEL_AUX_17 = 37;
  MA_CHANNEL_AUX_18 = 38;
  MA_CHANNEL_AUX_19 = 39;
  MA_CHANNEL_AUX_20 = 40;
  MA_CHANNEL_AUX_21 = 41;
  MA_CHANNEL_AUX_22 = 42;
  MA_CHANNEL_AUX_23 = 43;
  MA_CHANNEL_AUX_24 = 44;
  MA_CHANNEL_AUX_25 = 45;
  MA_CHANNEL_AUX_26 = 46;
  MA_CHANNEL_AUX_27 = 47;
  MA_CHANNEL_AUX_28 = 48;
  MA_CHANNEL_AUX_29 = 49;
  MA_CHANNEL_AUX_30 = 50;
  MA_CHANNEL_AUX_31 = 51;
  MA_CHANNEL_LEFT = 2;
  MA_CHANNEL_RIGHT = 3;
  MA_CHANNEL_POSITION_COUNT = 52;

type
  ma_result = Integer;
  Pma_result = ^ma_result;

const
  MA_SUCCESS = 0;
  MA_ERROR = -1;
  MA_INVALID_ARGS = -2;
  MA_INVALID_OPERATION = -3;
  MA_OUT_OF_MEMORY = -4;
  MA_OUT_OF_RANGE = -5;
  MA_ACCESS_DENIED = -6;
  MA_DOES_NOT_EXIST = -7;
  MA_ALREADY_EXISTS = -8;
  MA_TOO_MANY_OPEN_FILES = -9;
  MA_INVALID_FILE = -10;
  MA_TOO_BIG = -11;
  MA_PATH_TOO_LONG = -12;
  MA_NAME_TOO_LONG = -13;
  MA_NOT_DIRECTORY = -14;
  MA_IS_DIRECTORY = -15;
  MA_DIRECTORY_NOT_EMPTY = -16;
  MA_AT_END = -17;
  MA_NO_SPACE = -18;
  MA_BUSY = -19;
  MA_IO_ERROR = -20;
  MA_INTERRUPT = -21;
  MA_UNAVAILABLE = -22;
  MA_ALREADY_IN_USE = -23;
  MA_BAD_ADDRESS = -24;
  MA_BAD_SEEK = -25;
  MA_BAD_PIPE = -26;
  MA_DEADLOCK = -27;
  MA_TOO_MANY_LINKS = -28;
  MA_NOT_IMPLEMENTED = -29;
  MA_NO_MESSAGE = -30;
  MA_BAD_MESSAGE = -31;
  MA_NO_DATA_AVAILABLE = -32;
  MA_INVALID_DATA = -33;
  MA_TIMEOUT = -34;
  MA_NO_NETWORK = -35;
  MA_NOT_UNIQUE = -36;
  MA_NOT_SOCKET = -37;
  MA_NO_ADDRESS = -38;
  MA_BAD_PROTOCOL = -39;
  MA_PROTOCOL_UNAVAILABLE = -40;
  MA_PROTOCOL_NOT_SUPPORTED = -41;
  MA_PROTOCOL_FAMILY_NOT_SUPPORTED = -42;
  MA_ADDRESS_FAMILY_NOT_SUPPORTED = -43;
  MA_SOCKET_NOT_SUPPORTED = -44;
  MA_CONNECTION_RESET = -45;
  MA_ALREADY_CONNECTED = -46;
  MA_NOT_CONNECTED = -47;
  MA_CONNECTION_REFUSED = -48;
  MA_NO_HOST = -49;
  MA_IN_PROGRESS = -50;
  MA_CANCELLED = -51;
  MA_MEMORY_ALREADY_MAPPED = -52;
  MA_CRC_MISMATCH = -100;
  MA_FORMAT_NOT_SUPPORTED = -200;
  MA_DEVICE_TYPE_NOT_SUPPORTED = -201;
  MA_SHARE_MODE_NOT_SUPPORTED = -202;
  MA_NO_BACKEND = -203;
  MA_NO_DEVICE = -204;
  MA_API_NOT_FOUND = -205;
  MA_INVALID_DEVICE_CONFIG = -206;
  MA_LOOP = -207;
  MA_BACKEND_NOT_ENABLED = -208;
  MA_DEVICE_NOT_INITIALIZED = -300;
  MA_DEVICE_ALREADY_INITIALIZED = -301;
  MA_DEVICE_NOT_STARTED = -302;
  MA_DEVICE_NOT_STOPPED = -303;
  MA_FAILED_TO_INIT_BACKEND = -400;
  MA_FAILED_TO_OPEN_BACKEND_DEVICE = -401;
  MA_FAILED_TO_START_BACKEND_DEVICE = -402;
  MA_FAILED_TO_STOP_BACKEND_DEVICE = -403;

type
  ma_stream_format = Integer;
  Pma_stream_format = ^ma_stream_format;

const
  ma_stream_format_pcm = 0;

type
  ma_stream_layout = Integer;
  Pma_stream_layout = ^ma_stream_layout;

const
  ma_stream_layout_interleaved = 0;
  ma_stream_layout_deinterleaved = 1;

type
  ma_dither_mode = Integer;
  Pma_dither_mode = ^ma_dither_mode;

const
  ma_dither_mode_none = 0;
  ma_dither_mode_rectangle = 1;
  ma_dither_mode_triangle = 2;

type
  ma_format = Integer;
  Pma_format = ^ma_format;

const
  ma_format_unknown = 0;
  ma_format_u8 = 1;
  ma_format_s16 = 2;
  ma_format_s24 = 3;
  ma_format_s32 = 4;
  ma_format_f32 = 5;
  ma_format_count = 6;

type
  ma_standard_sample_rate = Integer;
  Pma_standard_sample_rate = ^ma_standard_sample_rate;

const
  ma_standard_sample_rate_48000 = 48000;
  ma_standard_sample_rate_44100 = 44100;
  ma_standard_sample_rate_32000 = 32000;
  ma_standard_sample_rate_24000 = 24000;
  ma_standard_sample_rate_22050 = 22050;
  ma_standard_sample_rate_88200 = 88200;
  ma_standard_sample_rate_96000 = 96000;
  ma_standard_sample_rate_176400 = 176400;
  ma_standard_sample_rate_192000 = 192000;
  ma_standard_sample_rate_16000 = 16000;
  ma_standard_sample_rate_11025 = 11025;
  ma_standard_sample_rate_8000 = 8000;
  ma_standard_sample_rate_352800 = 352800;
  ma_standard_sample_rate_384000 = 384000;
  ma_standard_sample_rate_min = 8000;
  ma_standard_sample_rate_max = 384000;
  ma_standard_sample_rate_count = 14;

type
  ma_channel_mix_mode = Integer;
  Pma_channel_mix_mode = ^ma_channel_mix_mode;

const
  ma_channel_mix_mode_rectangular = 0;
  ma_channel_mix_mode_simple = 1;
  ma_channel_mix_mode_custom_weights = 2;
  ma_channel_mix_mode_default = 0;

type
  ma_standard_channel_map = Integer;
  Pma_standard_channel_map = ^ma_standard_channel_map;

const
  ma_standard_channel_map_microsoft = 0;
  ma_standard_channel_map_alsa = 1;
  ma_standard_channel_map_rfc3551 = 2;
  ma_standard_channel_map_flac = 3;
  ma_standard_channel_map_vorbis = 4;
  ma_standard_channel_map_sound4 = 5;
  ma_standard_channel_map_sndio = 6;
  ma_standard_channel_map_webaudio = 3;
  ma_standard_channel_map_default = 0;

type
  ma_performance_profile = Integer;
  Pma_performance_profile = ^ma_performance_profile;

const
  ma_performance_profile_low_latency = 0;
  ma_performance_profile_conservative = 1;

type
  ma_thread_priority = Integer;
  Pma_thread_priority = ^ma_thread_priority;

const
  ma_thread_priority_idle = -5;
  ma_thread_priority_lowest = -4;
  ma_thread_priority_low = -3;
  ma_thread_priority_normal = -2;
  ma_thread_priority_high = -1;
  ma_thread_priority_highest = 0;
  ma_thread_priority_realtime = 1;
  ma_thread_priority_default = 0;

type
  ma_pan_mode = Integer;
  Pma_pan_mode = ^ma_pan_mode;

const
  ma_pan_mode_balance = 0;
  ma_pan_mode_pan = 1;

type
  ma_attenuation_model = Integer;
  Pma_attenuation_model = ^ma_attenuation_model;

const
  ma_attenuation_model_none = 0;
  ma_attenuation_model_inverse = 1;
  ma_attenuation_model_linear = 2;
  ma_attenuation_model_exponential = 3;

type
  ma_positioning = Integer;
  Pma_positioning = ^ma_positioning;

const
  ma_positioning_absolute = 0;
  ma_positioning_relative = 1;

type
  ma_handedness = Integer;
  Pma_handedness = ^ma_handedness;

const
  ma_handedness_right = 0;
  ma_handedness_left = 1;

type
  ma_resample_algorithm = Integer;
  Pma_resample_algorithm = ^ma_resample_algorithm;

const
  ma_resample_algorithm_linear = 0;
  ma_resample_algorithm_custom = 1;

type
  ma_channel_conversion_path = Integer;
  Pma_channel_conversion_path = ^ma_channel_conversion_path;

const
  ma_channel_conversion_path_unknown = 0;
  ma_channel_conversion_path_passthrough = 1;
  ma_channel_conversion_path_mono_out = 2;
  ma_channel_conversion_path_mono_in = 3;
  ma_channel_conversion_path_shuffle = 4;
  ma_channel_conversion_path_weights = 5;

type
  ma_mono_expansion_mode = Integer;
  Pma_mono_expansion_mode = ^ma_mono_expansion_mode;

const
  ma_mono_expansion_mode_duplicate = 0;
  ma_mono_expansion_mode_average = 1;
  ma_mono_expansion_mode_stereo_only = 2;
  ma_mono_expansion_mode_default = 0;

type
  ma_data_converter_execution_path = Integer;
  Pma_data_converter_execution_path = ^ma_data_converter_execution_path;

const
  ma_data_converter_execution_path_passthrough = 0;
  ma_data_converter_execution_path_format_only = 1;
  ma_data_converter_execution_path_channels_only = 2;
  ma_data_converter_execution_path_resample_only = 3;
  ma_data_converter_execution_path_resample_first = 4;
  ma_data_converter_execution_path_channels_first = 5;

type
  ma_job_type = Integer;
  Pma_job_type = ^ma_job_type;

const
  MA_JOB_TYPE_QUIT = 0;
  MA_JOB_TYPE_CUSTOM = 1;
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE = 2;
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE = 3;
  MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE = 4;
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER = 5;
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER = 6;
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM = 7;
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM = 8;
  MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM = 9;
  MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM = 10;
  MA_JOB_TYPE_DEVICE_AAUDIO_REROUTE = 11;
  MA_JOB_TYPE_COUNT = 12;

type
  ma_job_queue_flags = Integer;
  Pma_job_queue_flags = ^ma_job_queue_flags;

const
  MA_JOB_QUEUE_FLAG_NON_BLOCKING = 1;

const
  MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_FLAG_NON_BLOCKING = MA_JOB_QUEUE_FLAG_NON_BLOCKING;

type
  ma_device_state = Integer;
  Pma_device_state = ^ma_device_state;

const
  ma_device_state_uninitialized = 0;
  ma_device_state_stopped = 1;
  ma_device_state_started = 2;
  ma_device_state_starting = 3;
  ma_device_state_stopping = 4;

type
  ma_backend = Integer;
  Pma_backend = ^ma_backend;

const
  ma_backend_wasapi = 0;
  ma_backend_dsound = 1;
  ma_backend_winmm = 2;
  ma_backend_coreaudio = 3;
  ma_backend_sndio = 4;
  ma_backend_audio4 = 5;
  ma_backend_oss = 6;
  ma_backend_pulseaudio = 7;
  ma_backend_alsa = 8;
  ma_backend_jack = 9;
  ma_backend_aaudio = 10;
  ma_backend_opensl = 11;
  ma_backend_webaudio = 12;
  ma_backend_custom = 13;
  ma_backend_null = 14;

type
  ma_device_notification_type = Integer;
  Pma_device_notification_type = ^ma_device_notification_type;

const
  ma_device_notification_type_started = 0;
  ma_device_notification_type_stopped = 1;
  ma_device_notification_type_rerouted = 2;
  ma_device_notification_type_interruption_began = 3;
  ma_device_notification_type_interruption_ended = 4;
  ma_device_notification_type_unlocked = 5;

type
  ma_device_type = Integer;
  Pma_device_type = ^ma_device_type;

const
  ma_device_type_playback = 1;
  ma_device_type_capture = 2;
  ma_device_type_duplex = 3;
  ma_device_type_loopback = 4;

type
  ma_share_mode = Integer;
  Pma_share_mode = ^ma_share_mode;

const
  ma_share_mode_shared = 0;
  ma_share_mode_exclusive = 1;

type
  ma_ios_session_category = Integer;
  Pma_ios_session_category = ^ma_ios_session_category;

const
  ma_ios_session_category_default = 0;
  ma_ios_session_category_none = 1;
  ma_ios_session_category_ambient = 2;
  ma_ios_session_category_solo_ambient = 3;
  ma_ios_session_category_playback = 4;
  ma_ios_session_category_record = 5;
  ma_ios_session_category_play_and_record = 6;
  ma_ios_session_category_multi_route = 7;

type
  ma_ios_session_category_option = Integer;
  Pma_ios_session_category_option = ^ma_ios_session_category_option;

const
  ma_ios_session_category_option_mix_with_others = 1;
  ma_ios_session_category_option_duck_others = 2;
  ma_ios_session_category_option_allow_bluetooth = 4;
  ma_ios_session_category_option_default_to_speaker = 8;
  ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others = 17;
  ma_ios_session_category_option_allow_bluetooth_a2dp = 32;
  ma_ios_session_category_option_allow_air_play = 64;

type
  ma_opensl_stream_type = Integer;
  Pma_opensl_stream_type = ^ma_opensl_stream_type;

const
  ma_opensl_stream_type_default = 0;
  ma_opensl_stream_type_voice = 1;
  ma_opensl_stream_type_system = 2;
  ma_opensl_stream_type_ring = 3;
  ma_opensl_stream_type_media = 4;
  ma_opensl_stream_type_alarm = 5;
  ma_opensl_stream_type_notification = 6;

type
  ma_opensl_recording_preset = Integer;
  Pma_opensl_recording_preset = ^ma_opensl_recording_preset;

const
  ma_opensl_recording_preset_default = 0;
  ma_opensl_recording_preset_generic = 1;
  ma_opensl_recording_preset_camcorder = 2;
  ma_opensl_recording_preset_voice_recognition = 3;
  ma_opensl_recording_preset_voice_communication = 4;
  ma_opensl_recording_preset_voice_unprocessed = 5;

type
  ma_wasapi_usage = Integer;
  Pma_wasapi_usage = ^ma_wasapi_usage;

const
  ma_wasapi_usage_default = 0;
  ma_wasapi_usage_games = 1;
  ma_wasapi_usage_pro_audio = 2;

type
  ma_aaudio_usage = Integer;
  Pma_aaudio_usage = ^ma_aaudio_usage;

const
  ma_aaudio_usage_default = 0;
  ma_aaudio_usage_media = 1;
  ma_aaudio_usage_voice_communication = 2;
  ma_aaudio_usage_voice_communication_signalling = 3;
  ma_aaudio_usage_alarm = 4;
  ma_aaudio_usage_notification = 5;
  ma_aaudio_usage_notification_ringtone = 6;
  ma_aaudio_usage_notification_event = 7;
  ma_aaudio_usage_assistance_accessibility = 8;
  ma_aaudio_usage_assistance_navigation_guidance = 9;
  ma_aaudio_usage_assistance_sonification = 10;
  ma_aaudio_usage_game = 11;
  ma_aaudio_usage_assitant = 12;
  ma_aaudio_usage_emergency = 13;
  ma_aaudio_usage_safety = 14;
  ma_aaudio_usage_vehicle_status = 15;
  ma_aaudio_usage_announcement = 16;

type
  ma_aaudio_content_type = Integer;
  Pma_aaudio_content_type = ^ma_aaudio_content_type;

const
  ma_aaudio_content_type_default = 0;
  ma_aaudio_content_type_speech = 1;
  ma_aaudio_content_type_music = 2;
  ma_aaudio_content_type_movie = 3;
  ma_aaudio_content_type_sonification = 4;

type
  ma_aaudio_input_preset = Integer;
  Pma_aaudio_input_preset = ^ma_aaudio_input_preset;

const
  ma_aaudio_input_preset_default = 0;
  ma_aaudio_input_preset_generic = 1;
  ma_aaudio_input_preset_camcorder = 2;
  ma_aaudio_input_preset_voice_recognition = 3;
  ma_aaudio_input_preset_voice_communication = 4;
  ma_aaudio_input_preset_unprocessed = 5;
  ma_aaudio_input_preset_voice_performance = 6;

type
  ma_aaudio_allowed_capture_policy = Integer;
  Pma_aaudio_allowed_capture_policy = ^ma_aaudio_allowed_capture_policy;

const
  ma_aaudio_allow_capture_default = 0;
  ma_aaudio_allow_capture_by_all = 1;
  ma_aaudio_allow_capture_by_system = 2;
  ma_aaudio_allow_capture_by_none = 3;

type
  ma_open_mode_flags = Integer;
  Pma_open_mode_flags = ^ma_open_mode_flags;

const
  MA_OPEN_MODE_READ = 1;
  MA_OPEN_MODE_WRITE = 2;

type
  ma_seek_origin = Integer;
  Pma_seek_origin = ^ma_seek_origin;

const
  ma_seek_origin_start = 0;
  ma_seek_origin_current = 1;
  ma_seek_origin_end = 2;

type
  ma_encoding_format = Integer;
  Pma_encoding_format = ^ma_encoding_format;

const
  ma_encoding_format_unknown = 0;
  ma_encoding_format_wav = 1;
  ma_encoding_format_flac = 2;
  ma_encoding_format_mp3 = 3;
  ma_encoding_format_vorbis = 4;

type
  ma_waveform_type = Integer;
  Pma_waveform_type = ^ma_waveform_type;

const
  ma_waveform_type_sine = 0;
  ma_waveform_type_square = 1;
  ma_waveform_type_triangle = 2;
  ma_waveform_type_sawtooth = 3;

type
  ma_noise_type = Integer;
  Pma_noise_type = ^ma_noise_type;

const
  ma_noise_type_white = 0;
  ma_noise_type_pink = 1;
  ma_noise_type_brownian = 2;

type
  ma_resource_manager_data_source_flags = Integer;
  Pma_resource_manager_data_source_flags = ^ma_resource_manager_data_source_flags;

const
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM = 1;
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE = 2;
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC = 4;
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT = 8;
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH = 16;

type
  ma_resource_manager_flags = Integer;
  Pma_resource_manager_flags = ^ma_resource_manager_flags;

const
  MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING = 1;
  MA_RESOURCE_MANAGER_FLAG_NO_THREADING = 2;

type
  ma_resource_manager_data_supply_type = Integer;
  Pma_resource_manager_data_supply_type = ^ma_resource_manager_data_supply_type;

const
  ma_resource_manager_data_supply_type_unknown = 0;
  ma_resource_manager_data_supply_type_encoded = 1;
  ma_resource_manager_data_supply_type_decoded = 2;
  ma_resource_manager_data_supply_type_decoded_paged = 3;

type
  ma_node_flags = Integer;
  Pma_node_flags = ^ma_node_flags;

const
  MA_NODE_FLAG_PASSTHROUGH = 1;
  MA_NODE_FLAG_CONTINUOUS_PROCESSING = 2;
  MA_NODE_FLAG_ALLOW_NULL_INPUT = 4;
  MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES = 8;
  MA_NODE_FLAG_SILENT_OUTPUT = 16;

type
  ma_node_state = Integer;
  Pma_node_state = ^ma_node_state;

const
  ma_node_state_started = 0;
  ma_node_state_stopped = 1;

type
  ma_sound_flags = Integer;
  Pma_sound_flags = ^ma_sound_flags;

const
  MA_SOUND_FLAG_STREAM = 1;
  MA_SOUND_FLAG_DECODE = 2;
  MA_SOUND_FLAG_ASYNC = 4;
  MA_SOUND_FLAG_WAIT_INIT = 8;
  MA_SOUND_FLAG_UNKNOWN_LENGTH = 16;
  MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT = 4096;
  MA_SOUND_FLAG_NO_PITCH = 8192;
  MA_SOUND_FLAG_NO_SPATIALIZATION = 16384;

type
  ma_engine_node_type = Integer;
  Pma_engine_node_type = ^ma_engine_node_type;

const
  ma_engine_node_type_sound = 0;
  ma_engine_node_type_group = 1;

type
  ImGuiWindowFlags_ = Integer;
  PImGuiWindowFlags_ = ^ImGuiWindowFlags_;

const
  ImGuiWindowFlags_None = 0;
  ImGuiWindowFlags_NoTitleBar = 1;
  ImGuiWindowFlags_NoResize = 2;
  ImGuiWindowFlags_NoMove = 4;
  ImGuiWindowFlags_NoScrollbar = 8;
  ImGuiWindowFlags_NoScrollWithMouse = 16;
  ImGuiWindowFlags_NoCollapse = 32;
  ImGuiWindowFlags_AlwaysAutoResize = 64;
  ImGuiWindowFlags_NoBackground = 128;
  ImGuiWindowFlags_NoSavedSettings = 256;
  ImGuiWindowFlags_NoMouseInputs = 512;
  ImGuiWindowFlags_MenuBar = 1024;
  ImGuiWindowFlags_HorizontalScrollbar = 2048;
  ImGuiWindowFlags_NoFocusOnAppearing = 4096;
  ImGuiWindowFlags_NoBringToFrontOnFocus = 8192;
  ImGuiWindowFlags_AlwaysVerticalScrollbar = 16384;
  ImGuiWindowFlags_AlwaysHorizontalScrollbar = 32768;
  ImGuiWindowFlags_NoNavInputs = 65536;
  ImGuiWindowFlags_NoNavFocus = 131072;
  ImGuiWindowFlags_UnsavedDocument = 262144;
  ImGuiWindowFlags_NoDocking = 524288;
  ImGuiWindowFlags_NoNav = 196608;
  ImGuiWindowFlags_NoDecoration = 43;
  ImGuiWindowFlags_NoInputs = 197120;
  ImGuiWindowFlags_DockNodeHost = 8388608;
  ImGuiWindowFlags_ChildWindow = 16777216;
  ImGuiWindowFlags_Tooltip = 33554432;
  ImGuiWindowFlags_Popup = 67108864;
  ImGuiWindowFlags_Modal = 134217728;
  ImGuiWindowFlags_ChildMenu = 268435456;

type
  ImGuiChildFlags_ = Integer;
  PImGuiChildFlags_ = ^ImGuiChildFlags_;

const
  ImGuiChildFlags_None = 0;
  ImGuiChildFlags_Borders = 1;
  ImGuiChildFlags_AlwaysUseWindowPadding = 2;
  ImGuiChildFlags_ResizeX = 4;
  ImGuiChildFlags_ResizeY = 8;
  ImGuiChildFlags_AutoResizeX = 16;
  ImGuiChildFlags_AutoResizeY = 32;
  ImGuiChildFlags_AlwaysAutoResize = 64;
  ImGuiChildFlags_FrameStyle = 128;
  ImGuiChildFlags_NavFlattened = 256;

type
  ImGuiItemFlags_ = Integer;
  PImGuiItemFlags_ = ^ImGuiItemFlags_;

const
  ImGuiItemFlags_None = 0;
  ImGuiItemFlags_NoTabStop = 1;
  ImGuiItemFlags_NoNav = 2;
  ImGuiItemFlags_NoNavDefaultFocus = 4;
  ImGuiItemFlags_ButtonRepeat = 8;
  ImGuiItemFlags_AutoClosePopups = 16;
  ImGuiItemFlags_AllowDuplicateId = 32;

type
  ImGuiInputTextFlags_ = Integer;
  PImGuiInputTextFlags_ = ^ImGuiInputTextFlags_;

const
  ImGuiInputTextFlags_None = 0;
  ImGuiInputTextFlags_CharsDecimal = 1;
  ImGuiInputTextFlags_CharsHexadecimal = 2;
  ImGuiInputTextFlags_CharsScientific = 4;
  ImGuiInputTextFlags_CharsUppercase = 8;
  ImGuiInputTextFlags_CharsNoBlank = 16;
  ImGuiInputTextFlags_AllowTabInput = 32;
  ImGuiInputTextFlags_EnterReturnsTrue = 64;
  ImGuiInputTextFlags_EscapeClearsAll = 128;
  ImGuiInputTextFlags_CtrlEnterForNewLine = 256;
  ImGuiInputTextFlags_ReadOnly = 512;
  ImGuiInputTextFlags_Password = 1024;
  ImGuiInputTextFlags_AlwaysOverwrite = 2048;
  ImGuiInputTextFlags_AutoSelectAll = 4096;
  ImGuiInputTextFlags_ParseEmptyRefVal = 8192;
  ImGuiInputTextFlags_DisplayEmptyRefVal = 16384;
  ImGuiInputTextFlags_NoHorizontalScroll = 32768;
  ImGuiInputTextFlags_NoUndoRedo = 65536;
  ImGuiInputTextFlags_ElideLeft = 131072;
  ImGuiInputTextFlags_CallbackCompletion = 262144;
  ImGuiInputTextFlags_CallbackHistory = 524288;
  ImGuiInputTextFlags_CallbackAlways = 1048576;
  ImGuiInputTextFlags_CallbackCharFilter = 2097152;
  ImGuiInputTextFlags_CallbackResize = 4194304;
  ImGuiInputTextFlags_CallbackEdit = 8388608;

type
  ImGuiTreeNodeFlags_ = Integer;
  PImGuiTreeNodeFlags_ = ^ImGuiTreeNodeFlags_;

const
  ImGuiTreeNodeFlags_None = 0;
  ImGuiTreeNodeFlags_Selected = 1;
  ImGuiTreeNodeFlags_Framed = 2;
  ImGuiTreeNodeFlags_AllowOverlap = 4;
  ImGuiTreeNodeFlags_NoTreePushOnOpen = 8;
  ImGuiTreeNodeFlags_NoAutoOpenOnLog = 16;
  ImGuiTreeNodeFlags_DefaultOpen = 32;
  ImGuiTreeNodeFlags_OpenOnDoubleClick = 64;
  ImGuiTreeNodeFlags_OpenOnArrow = 128;
  ImGuiTreeNodeFlags_Leaf = 256;
  ImGuiTreeNodeFlags_Bullet = 512;
  ImGuiTreeNodeFlags_FramePadding = 1024;
  ImGuiTreeNodeFlags_SpanAvailWidth = 2048;
  ImGuiTreeNodeFlags_SpanFullWidth = 4096;
  ImGuiTreeNodeFlags_SpanLabelWidth = 8192;
  ImGuiTreeNodeFlags_SpanAllColumns = 16384;
  ImGuiTreeNodeFlags_LabelSpanAllColumns = 32768;
  ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 131072;
  ImGuiTreeNodeFlags_CollapsingHeader = 26;

type
  ImGuiPopupFlags_ = Integer;
  PImGuiPopupFlags_ = ^ImGuiPopupFlags_;

const
  ImGuiPopupFlags_None = 0;
  ImGuiPopupFlags_MouseButtonLeft = 0;
  ImGuiPopupFlags_MouseButtonRight = 1;
  ImGuiPopupFlags_MouseButtonMiddle = 2;
  ImGuiPopupFlags_MouseButtonMask_ = 31;
  ImGuiPopupFlags_MouseButtonDefault_ = 1;
  ImGuiPopupFlags_NoReopen = 32;
  ImGuiPopupFlags_NoOpenOverExistingPopup = 128;
  ImGuiPopupFlags_NoOpenOverItems = 256;
  ImGuiPopupFlags_AnyPopupId = 1024;
  ImGuiPopupFlags_AnyPopupLevel = 2048;
  ImGuiPopupFlags_AnyPopup = 3072;

type
  ImGuiSelectableFlags_ = Integer;
  PImGuiSelectableFlags_ = ^ImGuiSelectableFlags_;

const
  ImGuiSelectableFlags_None = 0;
  ImGuiSelectableFlags_NoAutoClosePopups = 1;
  ImGuiSelectableFlags_SpanAllColumns = 2;
  ImGuiSelectableFlags_AllowDoubleClick = 4;
  ImGuiSelectableFlags_Disabled = 8;
  ImGuiSelectableFlags_AllowOverlap = 16;
  ImGuiSelectableFlags_Highlight = 32;

type
  ImGuiComboFlags_ = Integer;
  PImGuiComboFlags_ = ^ImGuiComboFlags_;

const
  ImGuiComboFlags_None = 0;
  ImGuiComboFlags_PopupAlignLeft = 1;
  ImGuiComboFlags_HeightSmall = 2;
  ImGuiComboFlags_HeightRegular = 4;
  ImGuiComboFlags_HeightLarge = 8;
  ImGuiComboFlags_HeightLargest = 16;
  ImGuiComboFlags_NoArrowButton = 32;
  ImGuiComboFlags_NoPreview = 64;
  ImGuiComboFlags_WidthFitPreview = 128;
  ImGuiComboFlags_HeightMask_ = 30;

type
  ImGuiTabBarFlags_ = Integer;
  PImGuiTabBarFlags_ = ^ImGuiTabBarFlags_;

const
  ImGuiTabBarFlags_None = 0;
  ImGuiTabBarFlags_Reorderable = 1;
  ImGuiTabBarFlags_AutoSelectNewTabs = 2;
  ImGuiTabBarFlags_TabListPopupButton = 4;
  ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 8;
  ImGuiTabBarFlags_NoTabListScrollingButtons = 16;
  ImGuiTabBarFlags_NoTooltip = 32;
  ImGuiTabBarFlags_DrawSelectedOverline = 64;
  ImGuiTabBarFlags_FittingPolicyResizeDown = 128;
  ImGuiTabBarFlags_FittingPolicyScroll = 256;
  ImGuiTabBarFlags_FittingPolicyMask_ = 384;
  ImGuiTabBarFlags_FittingPolicyDefault_ = 128;

type
  ImGuiTabItemFlags_ = Integer;
  PImGuiTabItemFlags_ = ^ImGuiTabItemFlags_;

const
  ImGuiTabItemFlags_None = 0;
  ImGuiTabItemFlags_UnsavedDocument = 1;
  ImGuiTabItemFlags_SetSelected = 2;
  ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 4;
  ImGuiTabItemFlags_NoPushId = 8;
  ImGuiTabItemFlags_NoTooltip = 16;
  ImGuiTabItemFlags_NoReorder = 32;
  ImGuiTabItemFlags_Leading = 64;
  ImGuiTabItemFlags_Trailing = 128;
  ImGuiTabItemFlags_NoAssumedClosure = 256;

type
  ImGuiFocusedFlags_ = Integer;
  PImGuiFocusedFlags_ = ^ImGuiFocusedFlags_;

const
  ImGuiFocusedFlags_None = 0;
  ImGuiFocusedFlags_ChildWindows = 1;
  ImGuiFocusedFlags_RootWindow = 2;
  ImGuiFocusedFlags_AnyWindow = 4;
  ImGuiFocusedFlags_NoPopupHierarchy = 8;
  ImGuiFocusedFlags_DockHierarchy = 16;
  ImGuiFocusedFlags_RootAndChildWindows = 3;

type
  ImGuiHoveredFlags_ = Integer;
  PImGuiHoveredFlags_ = ^ImGuiHoveredFlags_;

const
  ImGuiHoveredFlags_None = 0;
  ImGuiHoveredFlags_ChildWindows = 1;
  ImGuiHoveredFlags_RootWindow = 2;
  ImGuiHoveredFlags_AnyWindow = 4;
  ImGuiHoveredFlags_NoPopupHierarchy = 8;
  ImGuiHoveredFlags_DockHierarchy = 16;
  ImGuiHoveredFlags_AllowWhenBlockedByPopup = 32;
  ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 128;
  ImGuiHoveredFlags_AllowWhenOverlappedByItem = 256;
  ImGuiHoveredFlags_AllowWhenOverlappedByWindow = 512;
  ImGuiHoveredFlags_AllowWhenDisabled = 1024;
  ImGuiHoveredFlags_NoNavOverride = 2048;
  ImGuiHoveredFlags_AllowWhenOverlapped = 768;
  ImGuiHoveredFlags_RectOnly = 928;
  ImGuiHoveredFlags_RootAndChildWindows = 3;
  ImGuiHoveredFlags_ForTooltip = 4096;
  ImGuiHoveredFlags_Stationary = 8192;
  ImGuiHoveredFlags_DelayNone = 16384;
  ImGuiHoveredFlags_DelayShort = 32768;
  ImGuiHoveredFlags_DelayNormal = 65536;
  ImGuiHoveredFlags_NoSharedDelay = 131072;

type
  ImGuiDockNodeFlags_ = Integer;
  PImGuiDockNodeFlags_ = ^ImGuiDockNodeFlags_;

const
  ImGuiDockNodeFlags_None = 0;
  ImGuiDockNodeFlags_KeepAliveOnly = 1;
  ImGuiDockNodeFlags_NoDockingOverCentralNode = 4;
  ImGuiDockNodeFlags_PassthruCentralNode = 8;
  ImGuiDockNodeFlags_NoDockingSplit = 16;
  ImGuiDockNodeFlags_NoResize = 32;
  ImGuiDockNodeFlags_AutoHideTabBar = 64;
  ImGuiDockNodeFlags_NoUndocking = 128;

type
  ImGuiDragDropFlags_ = Integer;
  PImGuiDragDropFlags_ = ^ImGuiDragDropFlags_;

const
  ImGuiDragDropFlags_None = 0;
  ImGuiDragDropFlags_SourceNoPreviewTooltip = 1;
  ImGuiDragDropFlags_SourceNoDisableHover = 2;
  ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 4;
  ImGuiDragDropFlags_SourceAllowNullID = 8;
  ImGuiDragDropFlags_SourceExtern = 16;
  ImGuiDragDropFlags_PayloadAutoExpire = 32;
  ImGuiDragDropFlags_PayloadNoCrossContext = 64;
  ImGuiDragDropFlags_PayloadNoCrossProcess = 128;
  ImGuiDragDropFlags_AcceptBeforeDelivery = 1024;
  ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 2048;
  ImGuiDragDropFlags_AcceptNoPreviewTooltip = 4096;
  ImGuiDragDropFlags_AcceptPeekOnly = 3072;

type
  ImGuiDataType_ = Integer;
  PImGuiDataType_ = ^ImGuiDataType_;

const
  ImGuiDataType_S8 = 0;
  ImGuiDataType_U8 = 1;
  ImGuiDataType_S16 = 2;
  ImGuiDataType_U16 = 3;
  ImGuiDataType_S32 = 4;
  ImGuiDataType_U32 = 5;
  ImGuiDataType_S64 = 6;
  ImGuiDataType_U64 = 7;
  ImGuiDataType_Float = 8;
  ImGuiDataType_Double = 9;
  ImGuiDataType_Bool = 10;
  ImGuiDataType_String = 11;
  ImGuiDataType_COUNT = 12;

type
  ImGuiDir = Integer;
  PImGuiDir = ^ImGuiDir;

const
  ImGuiDir_None = -1;
  ImGuiDir_Left = 0;
  ImGuiDir_Right = 1;
  ImGuiDir_Up = 2;
  ImGuiDir_Down = 3;
  ImGuiDir_COUNT = 4;

type
  ImGuiSortDirection = Integer;
  PImGuiSortDirection = ^ImGuiSortDirection;

const
  ImGuiSortDirection_None = 0;
  ImGuiSortDirection_Ascending = 1;
  ImGuiSortDirection_Descending = 2;

type
  ImGuiKey = Integer;
  PImGuiKey = ^ImGuiKey;

const
  ImGuiKey_None = 0;
  ImGuiKey_NamedKey_BEGIN = 512;
  ImGuiKey_Tab = 512;
  ImGuiKey_LeftArrow = 513;
  ImGuiKey_RightArrow = 514;
  ImGuiKey_UpArrow = 515;
  ImGuiKey_DownArrow = 516;
  ImGuiKey_PageUp = 517;
  ImGuiKey_PageDown = 518;
  ImGuiKey_Home = 519;
  ImGuiKey_End = 520;
  ImGuiKey_Insert = 521;
  ImGuiKey_Delete = 522;
  ImGuiKey_Backspace = 523;
  ImGuiKey_Space = 524;
  ImGuiKey_Enter = 525;
  ImGuiKey_Escape = 526;
  ImGuiKey_LeftCtrl = 527;
  ImGuiKey_LeftShift = 528;
  ImGuiKey_LeftAlt = 529;
  ImGuiKey_LeftSuper = 530;
  ImGuiKey_RightCtrl = 531;
  ImGuiKey_RightShift = 532;
  ImGuiKey_RightAlt = 533;
  ImGuiKey_RightSuper = 534;
  ImGuiKey_Menu = 535;
  ImGuiKey_0 = 536;
  ImGuiKey_1 = 537;
  ImGuiKey_2 = 538;
  ImGuiKey_3 = 539;
  ImGuiKey_4 = 540;
  ImGuiKey_5 = 541;
  ImGuiKey_6 = 542;
  ImGuiKey_7 = 543;
  ImGuiKey_8 = 544;
  ImGuiKey_9 = 545;
  ImGuiKey_A = 546;
  ImGuiKey_B = 547;
  ImGuiKey_C = 548;
  ImGuiKey_D = 549;
  ImGuiKey_E = 550;
  ImGuiKey_F = 551;
  ImGuiKey_G = 552;
  ImGuiKey_H = 553;
  ImGuiKey_I = 554;
  ImGuiKey_J = 555;
  ImGuiKey_K = 556;
  ImGuiKey_L = 557;
  ImGuiKey_M = 558;
  ImGuiKey_N = 559;
  ImGuiKey_O = 560;
  ImGuiKey_P = 561;
  ImGuiKey_Q = 562;
  ImGuiKey_R = 563;
  ImGuiKey_S = 564;
  ImGuiKey_T = 565;
  ImGuiKey_U = 566;
  ImGuiKey_V = 567;
  ImGuiKey_W = 568;
  ImGuiKey_X = 569;
  ImGuiKey_Y = 570;
  ImGuiKey_Z = 571;
  ImGuiKey_F1 = 572;
  ImGuiKey_F2 = 573;
  ImGuiKey_F3 = 574;
  ImGuiKey_F4 = 575;
  ImGuiKey_F5 = 576;
  ImGuiKey_F6 = 577;
  ImGuiKey_F7 = 578;
  ImGuiKey_F8 = 579;
  ImGuiKey_F9 = 580;
  ImGuiKey_F10 = 581;
  ImGuiKey_F11 = 582;
  ImGuiKey_F12 = 583;
  ImGuiKey_F13 = 584;
  ImGuiKey_F14 = 585;
  ImGuiKey_F15 = 586;
  ImGuiKey_F16 = 587;
  ImGuiKey_F17 = 588;
  ImGuiKey_F18 = 589;
  ImGuiKey_F19 = 590;
  ImGuiKey_F20 = 591;
  ImGuiKey_F21 = 592;
  ImGuiKey_F22 = 593;
  ImGuiKey_F23 = 594;
  ImGuiKey_F24 = 595;
  ImGuiKey_Apostrophe = 596;
  ImGuiKey_Comma = 597;
  ImGuiKey_Minus = 598;
  ImGuiKey_Period = 599;
  ImGuiKey_Slash = 600;
  ImGuiKey_Semicolon = 601;
  ImGuiKey_Equal = 602;
  ImGuiKey_LeftBracket = 603;
  ImGuiKey_Backslash = 604;
  ImGuiKey_RightBracket = 605;
  ImGuiKey_GraveAccent = 606;
  ImGuiKey_CapsLock = 607;
  ImGuiKey_ScrollLock = 608;
  ImGuiKey_NumLock = 609;
  ImGuiKey_PrintScreen = 610;
  ImGuiKey_Pause = 611;
  ImGuiKey_Keypad0 = 612;
  ImGuiKey_Keypad1 = 613;
  ImGuiKey_Keypad2 = 614;
  ImGuiKey_Keypad3 = 615;
  ImGuiKey_Keypad4 = 616;
  ImGuiKey_Keypad5 = 617;
  ImGuiKey_Keypad6 = 618;
  ImGuiKey_Keypad7 = 619;
  ImGuiKey_Keypad8 = 620;
  ImGuiKey_Keypad9 = 621;
  ImGuiKey_KeypadDecimal = 622;
  ImGuiKey_KeypadDivide = 623;
  ImGuiKey_KeypadMultiply = 624;
  ImGuiKey_KeypadSubtract = 625;
  ImGuiKey_KeypadAdd = 626;
  ImGuiKey_KeypadEnter = 627;
  ImGuiKey_KeypadEqual = 628;
  ImGuiKey_AppBack = 629;
  ImGuiKey_AppForward = 630;
  ImGuiKey_GamepadStart = 631;
  ImGuiKey_GamepadBack = 632;
  ImGuiKey_GamepadFaceLeft = 633;
  ImGuiKey_GamepadFaceRight = 634;
  ImGuiKey_GamepadFaceUp = 635;
  ImGuiKey_GamepadFaceDown = 636;
  ImGuiKey_GamepadDpadLeft = 637;
  ImGuiKey_GamepadDpadRight = 638;
  ImGuiKey_GamepadDpadUp = 639;
  ImGuiKey_GamepadDpadDown = 640;
  ImGuiKey_GamepadL1 = 641;
  ImGuiKey_GamepadR1 = 642;
  ImGuiKey_GamepadL2 = 643;
  ImGuiKey_GamepadR2 = 644;
  ImGuiKey_GamepadL3 = 645;
  ImGuiKey_GamepadR3 = 646;
  ImGuiKey_GamepadLStickLeft = 647;
  ImGuiKey_GamepadLStickRight = 648;
  ImGuiKey_GamepadLStickUp = 649;
  ImGuiKey_GamepadLStickDown = 650;
  ImGuiKey_GamepadRStickLeft = 651;
  ImGuiKey_GamepadRStickRight = 652;
  ImGuiKey_GamepadRStickUp = 653;
  ImGuiKey_GamepadRStickDown = 654;
  ImGuiKey_MouseLeft = 655;
  ImGuiKey_MouseRight = 656;
  ImGuiKey_MouseMiddle = 657;
  ImGuiKey_MouseX1 = 658;
  ImGuiKey_MouseX2 = 659;
  ImGuiKey_MouseWheelX = 660;
  ImGuiKey_MouseWheelY = 661;
  ImGuiKey_ReservedForModCtrl = 662;
  ImGuiKey_ReservedForModShift = 663;
  ImGuiKey_ReservedForModAlt = 664;
  ImGuiKey_ReservedForModSuper = 665;
  ImGuiKey_NamedKey_END = 666;
  ImGuiMod_None = 0;
  ImGuiMod_Ctrl = 4096;
  ImGuiMod_Shift = 8192;
  ImGuiMod_Alt = 16384;
  ImGuiMod_Super = 32768;
  ImGuiMod_Mask_ = 61440;
  ImGuiKey_NamedKey_COUNT = 154;

type
  ImGuiInputFlags_ = Integer;
  PImGuiInputFlags_ = ^ImGuiInputFlags_;

const
  ImGuiInputFlags_None = 0;
  ImGuiInputFlags_Repeat = 1;
  ImGuiInputFlags_RouteActive = 1024;
  ImGuiInputFlags_RouteFocused = 2048;
  ImGuiInputFlags_RouteGlobal = 4096;
  ImGuiInputFlags_RouteAlways = 8192;
  ImGuiInputFlags_RouteOverFocused = 16384;
  ImGuiInputFlags_RouteOverActive = 32768;
  ImGuiInputFlags_RouteUnlessBgFocused = 65536;
  ImGuiInputFlags_RouteFromRootWindow = 131072;
  ImGuiInputFlags_Tooltip = 262144;

type
  ImGuiConfigFlags_ = Integer;
  PImGuiConfigFlags_ = ^ImGuiConfigFlags_;

const
  ImGuiConfigFlags_None = 0;
  ImGuiConfigFlags_NavEnableKeyboard = 1;
  ImGuiConfigFlags_NavEnableGamepad = 2;
  ImGuiConfigFlags_NoMouse = 16;
  ImGuiConfigFlags_NoMouseCursorChange = 32;
  ImGuiConfigFlags_NoKeyboard = 64;
  ImGuiConfigFlags_DockingEnable = 128;
  ImGuiConfigFlags_ViewportsEnable = 1024;
  ImGuiConfigFlags_DpiEnableScaleViewports = 16384;
  ImGuiConfigFlags_DpiEnableScaleFonts = 32768;
  ImGuiConfigFlags_IsSRGB = 1048576;
  ImGuiConfigFlags_IsTouchScreen = 2097152;

type
  ImGuiBackendFlags_ = Integer;
  PImGuiBackendFlags_ = ^ImGuiBackendFlags_;

const
  ImGuiBackendFlags_None = 0;
  ImGuiBackendFlags_HasGamepad = 1;
  ImGuiBackendFlags_HasMouseCursors = 2;
  ImGuiBackendFlags_HasSetMousePos = 4;
  ImGuiBackendFlags_RendererHasVtxOffset = 8;
  ImGuiBackendFlags_PlatformHasViewports = 1024;
  ImGuiBackendFlags_HasMouseHoveredViewport = 2048;
  ImGuiBackendFlags_RendererHasViewports = 4096;

type
  ImGuiCol_ = Integer;
  PImGuiCol_ = ^ImGuiCol_;

const
  ImGuiCol_Text = 0;
  ImGuiCol_TextDisabled = 1;
  ImGuiCol_WindowBg = 2;
  ImGuiCol_ChildBg = 3;
  ImGuiCol_PopupBg = 4;
  ImGuiCol_Border = 5;
  ImGuiCol_BorderShadow = 6;
  ImGuiCol_FrameBg = 7;
  ImGuiCol_FrameBgHovered = 8;
  ImGuiCol_FrameBgActive = 9;
  ImGuiCol_TitleBg = 10;
  ImGuiCol_TitleBgActive = 11;
  ImGuiCol_TitleBgCollapsed = 12;
  ImGuiCol_MenuBarBg = 13;
  ImGuiCol_ScrollbarBg = 14;
  ImGuiCol_ScrollbarGrab = 15;
  ImGuiCol_ScrollbarGrabHovered = 16;
  ImGuiCol_ScrollbarGrabActive = 17;
  ImGuiCol_CheckMark = 18;
  ImGuiCol_SliderGrab = 19;
  ImGuiCol_SliderGrabActive = 20;
  ImGuiCol_Button = 21;
  ImGuiCol_ButtonHovered = 22;
  ImGuiCol_ButtonActive = 23;
  ImGuiCol_Header = 24;
  ImGuiCol_HeaderHovered = 25;
  ImGuiCol_HeaderActive = 26;
  ImGuiCol_Separator = 27;
  ImGuiCol_SeparatorHovered = 28;
  ImGuiCol_SeparatorActive = 29;
  ImGuiCol_ResizeGrip = 30;
  ImGuiCol_ResizeGripHovered = 31;
  ImGuiCol_ResizeGripActive = 32;
  ImGuiCol_TabHovered = 33;
  ImGuiCol_Tab = 34;
  ImGuiCol_TabSelected = 35;
  ImGuiCol_TabSelectedOverline = 36;
  ImGuiCol_TabDimmed = 37;
  ImGuiCol_TabDimmedSelected = 38;
  ImGuiCol_TabDimmedSelectedOverline = 39;
  ImGuiCol_DockingPreview = 40;
  ImGuiCol_DockingEmptyBg = 41;
  ImGuiCol_PlotLines = 42;
  ImGuiCol_PlotLinesHovered = 43;
  ImGuiCol_PlotHistogram = 44;
  ImGuiCol_PlotHistogramHovered = 45;
  ImGuiCol_TableHeaderBg = 46;
  ImGuiCol_TableBorderStrong = 47;
  ImGuiCol_TableBorderLight = 48;
  ImGuiCol_TableRowBg = 49;
  ImGuiCol_TableRowBgAlt = 50;
  ImGuiCol_TextLink = 51;
  ImGuiCol_TextSelectedBg = 52;
  ImGuiCol_DragDropTarget = 53;
  ImGuiCol_NavCursor = 54;
  ImGuiCol_NavWindowingHighlight = 55;
  ImGuiCol_NavWindowingDimBg = 56;
  ImGuiCol_ModalWindowDimBg = 57;
  ImGuiCol_COUNT = 58;

type
  ImGuiStyleVar_ = Integer;
  PImGuiStyleVar_ = ^ImGuiStyleVar_;

const
  ImGuiStyleVar_Alpha = 0;
  ImGuiStyleVar_DisabledAlpha = 1;
  ImGuiStyleVar_WindowPadding = 2;
  ImGuiStyleVar_WindowRounding = 3;
  ImGuiStyleVar_WindowBorderSize = 4;
  ImGuiStyleVar_WindowMinSize = 5;
  ImGuiStyleVar_WindowTitleAlign = 6;
  ImGuiStyleVar_ChildRounding = 7;
  ImGuiStyleVar_ChildBorderSize = 8;
  ImGuiStyleVar_PopupRounding = 9;
  ImGuiStyleVar_PopupBorderSize = 10;
  ImGuiStyleVar_FramePadding = 11;
  ImGuiStyleVar_FrameRounding = 12;
  ImGuiStyleVar_FrameBorderSize = 13;
  ImGuiStyleVar_ItemSpacing = 14;
  ImGuiStyleVar_ItemInnerSpacing = 15;
  ImGuiStyleVar_IndentSpacing = 16;
  ImGuiStyleVar_CellPadding = 17;
  ImGuiStyleVar_ScrollbarSize = 18;
  ImGuiStyleVar_ScrollbarRounding = 19;
  ImGuiStyleVar_GrabMinSize = 20;
  ImGuiStyleVar_GrabRounding = 21;
  ImGuiStyleVar_TabRounding = 22;
  ImGuiStyleVar_TabBorderSize = 23;
  ImGuiStyleVar_TabBarBorderSize = 24;
  ImGuiStyleVar_TabBarOverlineSize = 25;
  ImGuiStyleVar_TableAngledHeadersAngle = 26;
  ImGuiStyleVar_TableAngledHeadersTextAlign = 27;
  ImGuiStyleVar_ButtonTextAlign = 28;
  ImGuiStyleVar_SelectableTextAlign = 29;
  ImGuiStyleVar_SeparatorTextBorderSize = 30;
  ImGuiStyleVar_SeparatorTextAlign = 31;
  ImGuiStyleVar_SeparatorTextPadding = 32;
  ImGuiStyleVar_DockingSeparatorSize = 33;
  ImGuiStyleVar_COUNT = 34;

type
  ImGuiButtonFlags_ = Integer;
  PImGuiButtonFlags_ = ^ImGuiButtonFlags_;

const
  ImGuiButtonFlags_None = 0;
  ImGuiButtonFlags_MouseButtonLeft = 1;
  ImGuiButtonFlags_MouseButtonRight = 2;
  ImGuiButtonFlags_MouseButtonMiddle = 4;
  ImGuiButtonFlags_MouseButtonMask_ = 7;
  ImGuiButtonFlags_EnableNav = 8;

type
  ImGuiColorEditFlags_ = Integer;
  PImGuiColorEditFlags_ = ^ImGuiColorEditFlags_;

const
  ImGuiColorEditFlags_None = 0;
  ImGuiColorEditFlags_NoAlpha = 2;
  ImGuiColorEditFlags_NoPicker = 4;
  ImGuiColorEditFlags_NoOptions = 8;
  ImGuiColorEditFlags_NoSmallPreview = 16;
  ImGuiColorEditFlags_NoInputs = 32;
  ImGuiColorEditFlags_NoTooltip = 64;
  ImGuiColorEditFlags_NoLabel = 128;
  ImGuiColorEditFlags_NoSidePreview = 256;
  ImGuiColorEditFlags_NoDragDrop = 512;
  ImGuiColorEditFlags_NoBorder = 1024;
  ImGuiColorEditFlags_AlphaOpaque = 2048;
  ImGuiColorEditFlags_AlphaNoBg = 4096;
  ImGuiColorEditFlags_AlphaPreviewHalf = 8192;
  ImGuiColorEditFlags_AlphaBar = 65536;
  ImGuiColorEditFlags_HDR = 524288;
  ImGuiColorEditFlags_DisplayRGB = 1048576;
  ImGuiColorEditFlags_DisplayHSV = 2097152;
  ImGuiColorEditFlags_DisplayHex = 4194304;
  ImGuiColorEditFlags_Uint8 = 8388608;
  ImGuiColorEditFlags_Float = 16777216;
  ImGuiColorEditFlags_PickerHueBar = 33554432;
  ImGuiColorEditFlags_PickerHueWheel = 67108864;
  ImGuiColorEditFlags_InputRGB = 134217728;
  ImGuiColorEditFlags_InputHSV = 268435456;
  ImGuiColorEditFlags_DefaultOptions_ = 177209344;
  ImGuiColorEditFlags_AlphaMask_ = 14338;
  ImGuiColorEditFlags_DisplayMask_ = 7340032;
  ImGuiColorEditFlags_DataTypeMask_ = 25165824;
  ImGuiColorEditFlags_PickerMask_ = 100663296;
  ImGuiColorEditFlags_InputMask_ = 402653184;

type
  ImGuiSliderFlags_ = Integer;
  PImGuiSliderFlags_ = ^ImGuiSliderFlags_;

const
  ImGuiSliderFlags_None = 0;
  ImGuiSliderFlags_Logarithmic = 32;
  ImGuiSliderFlags_NoRoundToFormat = 64;
  ImGuiSliderFlags_NoInput = 128;
  ImGuiSliderFlags_WrapAround = 256;
  ImGuiSliderFlags_ClampOnInput = 512;
  ImGuiSliderFlags_ClampZeroRange = 1024;
  ImGuiSliderFlags_NoSpeedTweaks = 2048;
  ImGuiSliderFlags_AlwaysClamp = 1536;
  ImGuiSliderFlags_InvalidMask_ = 1879048207;

type
  ImGuiMouseButton_ = Integer;
  PImGuiMouseButton_ = ^ImGuiMouseButton_;

const
  ImGuiMouseButton_Left = 0;
  ImGuiMouseButton_Right = 1;
  ImGuiMouseButton_Middle = 2;
  ImGuiMouseButton_COUNT = 5;

type
  ImGuiMouseCursor_ = Integer;
  PImGuiMouseCursor_ = ^ImGuiMouseCursor_;

const
  ImGuiMouseCursor_None = -1;
  ImGuiMouseCursor_Arrow = 0;
  ImGuiMouseCursor_TextInput = 1;
  ImGuiMouseCursor_ResizeAll = 2;
  ImGuiMouseCursor_ResizeNS = 3;
  ImGuiMouseCursor_ResizeEW = 4;
  ImGuiMouseCursor_ResizeNESW = 5;
  ImGuiMouseCursor_ResizeNWSE = 6;
  ImGuiMouseCursor_Hand = 7;
  ImGuiMouseCursor_NotAllowed = 8;
  ImGuiMouseCursor_COUNT = 9;

type
  ImGuiMouseSource = Integer;
  PImGuiMouseSource = ^ImGuiMouseSource;

const
  ImGuiMouseSource_Mouse = 0;
  ImGuiMouseSource_TouchScreen = 1;
  ImGuiMouseSource_Pen = 2;
  ImGuiMouseSource_COUNT = 3;

type
  ImGuiCond_ = Integer;
  PImGuiCond_ = ^ImGuiCond_;

const
  ImGuiCond_None = 0;
  ImGuiCond_Always = 1;
  ImGuiCond_Once = 2;
  ImGuiCond_FirstUseEver = 4;
  ImGuiCond_Appearing = 8;

type
  ImGuiTableFlags_ = Integer;
  PImGuiTableFlags_ = ^ImGuiTableFlags_;

const
  ImGuiTableFlags_None = 0;
  ImGuiTableFlags_Resizable = 1;
  ImGuiTableFlags_Reorderable = 2;
  ImGuiTableFlags_Hideable = 4;
  ImGuiTableFlags_Sortable = 8;
  ImGuiTableFlags_NoSavedSettings = 16;
  ImGuiTableFlags_ContextMenuInBody = 32;
  ImGuiTableFlags_RowBg = 64;
  ImGuiTableFlags_BordersInnerH = 128;
  ImGuiTableFlags_BordersOuterH = 256;
  ImGuiTableFlags_BordersInnerV = 512;
  ImGuiTableFlags_BordersOuterV = 1024;
  ImGuiTableFlags_BordersH = 384;
  ImGuiTableFlags_BordersV = 1536;
  ImGuiTableFlags_BordersInner = 640;
  ImGuiTableFlags_BordersOuter = 1280;
  ImGuiTableFlags_Borders = 1920;
  ImGuiTableFlags_NoBordersInBody = 2048;
  ImGuiTableFlags_NoBordersInBodyUntilResize = 4096;
  ImGuiTableFlags_SizingFixedFit = 8192;
  ImGuiTableFlags_SizingFixedSame = 16384;
  ImGuiTableFlags_SizingStretchProp = 24576;
  ImGuiTableFlags_SizingStretchSame = 32768;
  ImGuiTableFlags_NoHostExtendX = 65536;
  ImGuiTableFlags_NoHostExtendY = 131072;
  ImGuiTableFlags_NoKeepColumnsVisible = 262144;
  ImGuiTableFlags_PreciseWidths = 524288;
  ImGuiTableFlags_NoClip = 1048576;
  ImGuiTableFlags_PadOuterX = 2097152;
  ImGuiTableFlags_NoPadOuterX = 4194304;
  ImGuiTableFlags_NoPadInnerX = 8388608;
  ImGuiTableFlags_ScrollX = 16777216;
  ImGuiTableFlags_ScrollY = 33554432;
  ImGuiTableFlags_SortMulti = 67108864;
  ImGuiTableFlags_SortTristate = 134217728;
  ImGuiTableFlags_HighlightHoveredColumn = 268435456;
  ImGuiTableFlags_SizingMask_ = 57344;

type
  ImGuiTableColumnFlags_ = Integer;
  PImGuiTableColumnFlags_ = ^ImGuiTableColumnFlags_;

const
  ImGuiTableColumnFlags_None = 0;
  ImGuiTableColumnFlags_Disabled = 1;
  ImGuiTableColumnFlags_DefaultHide = 2;
  ImGuiTableColumnFlags_DefaultSort = 4;
  ImGuiTableColumnFlags_WidthStretch = 8;
  ImGuiTableColumnFlags_WidthFixed = 16;
  ImGuiTableColumnFlags_NoResize = 32;
  ImGuiTableColumnFlags_NoReorder = 64;
  ImGuiTableColumnFlags_NoHide = 128;
  ImGuiTableColumnFlags_NoClip = 256;
  ImGuiTableColumnFlags_NoSort = 512;
  ImGuiTableColumnFlags_NoSortAscending = 1024;
  ImGuiTableColumnFlags_NoSortDescending = 2048;
  ImGuiTableColumnFlags_NoHeaderLabel = 4096;
  ImGuiTableColumnFlags_NoHeaderWidth = 8192;
  ImGuiTableColumnFlags_PreferSortAscending = 16384;
  ImGuiTableColumnFlags_PreferSortDescending = 32768;
  ImGuiTableColumnFlags_IndentEnable = 65536;
  ImGuiTableColumnFlags_IndentDisable = 131072;
  ImGuiTableColumnFlags_AngledHeader = 262144;
  ImGuiTableColumnFlags_IsEnabled = 16777216;
  ImGuiTableColumnFlags_IsVisible = 33554432;
  ImGuiTableColumnFlags_IsSorted = 67108864;
  ImGuiTableColumnFlags_IsHovered = 134217728;
  ImGuiTableColumnFlags_WidthMask_ = 24;
  ImGuiTableColumnFlags_IndentMask_ = 196608;
  ImGuiTableColumnFlags_StatusMask_ = 251658240;
  ImGuiTableColumnFlags_NoDirectResize_ = 1073741824;

type
  ImGuiTableRowFlags_ = Integer;
  PImGuiTableRowFlags_ = ^ImGuiTableRowFlags_;

const
  ImGuiTableRowFlags_None = 0;
  ImGuiTableRowFlags_Headers = 1;

type
  ImGuiTableBgTarget_ = Integer;
  PImGuiTableBgTarget_ = ^ImGuiTableBgTarget_;

const
  ImGuiTableBgTarget_None = 0;
  ImGuiTableBgTarget_RowBg0 = 1;
  ImGuiTableBgTarget_RowBg1 = 2;
  ImGuiTableBgTarget_CellBg = 3;

type
  ImGuiMultiSelectFlags_ = Integer;
  PImGuiMultiSelectFlags_ = ^ImGuiMultiSelectFlags_;

const
  ImGuiMultiSelectFlags_None = 0;
  ImGuiMultiSelectFlags_SingleSelect = 1;
  ImGuiMultiSelectFlags_NoSelectAll = 2;
  ImGuiMultiSelectFlags_NoRangeSelect = 4;
  ImGuiMultiSelectFlags_NoAutoSelect = 8;
  ImGuiMultiSelectFlags_NoAutoClear = 16;
  ImGuiMultiSelectFlags_NoAutoClearOnReselect = 32;
  ImGuiMultiSelectFlags_BoxSelect1d = 64;
  ImGuiMultiSelectFlags_BoxSelect2d = 128;
  ImGuiMultiSelectFlags_BoxSelectNoScroll = 256;
  ImGuiMultiSelectFlags_ClearOnEscape = 512;
  ImGuiMultiSelectFlags_ClearOnClickVoid = 1024;
  ImGuiMultiSelectFlags_ScopeWindow = 2048;
  ImGuiMultiSelectFlags_ScopeRect = 4096;
  ImGuiMultiSelectFlags_SelectOnClick = 8192;
  ImGuiMultiSelectFlags_SelectOnClickRelease = 16384;
  ImGuiMultiSelectFlags_NavWrapX = 65536;

type
  ImGuiSelectionRequestType = Integer;
  PImGuiSelectionRequestType = ^ImGuiSelectionRequestType;

const
  ImGuiSelectionRequestType_None = 0;
  ImGuiSelectionRequestType_SetAll = 1;
  ImGuiSelectionRequestType_SetRange = 2;

type
  ImDrawFlags_ = Integer;
  PImDrawFlags_ = ^ImDrawFlags_;

const
  ImDrawFlags_None = 0;
  ImDrawFlags_Closed = 1;
  ImDrawFlags_RoundCornersTopLeft = 16;
  ImDrawFlags_RoundCornersTopRight = 32;
  ImDrawFlags_RoundCornersBottomLeft = 64;
  ImDrawFlags_RoundCornersBottomRight = 128;
  ImDrawFlags_RoundCornersNone = 256;
  ImDrawFlags_RoundCornersTop = 48;
  ImDrawFlags_RoundCornersBottom = 192;
  ImDrawFlags_RoundCornersLeft = 80;
  ImDrawFlags_RoundCornersRight = 160;
  ImDrawFlags_RoundCornersAll = 240;
  ImDrawFlags_RoundCornersDefault_ = 240;
  ImDrawFlags_RoundCornersMask_ = 496;

type
  ImDrawListFlags_ = Integer;
  PImDrawListFlags_ = ^ImDrawListFlags_;

const
  ImDrawListFlags_None = 0;
  ImDrawListFlags_AntiAliasedLines = 1;
  ImDrawListFlags_AntiAliasedLinesUseTex = 2;
  ImDrawListFlags_AntiAliasedFill = 4;
  ImDrawListFlags_AllowVtxOffset = 8;

type
  ImFontAtlasFlags_ = Integer;
  PImFontAtlasFlags_ = ^ImFontAtlasFlags_;

const
  ImFontAtlasFlags_None = 0;
  ImFontAtlasFlags_NoPowerOfTwoHeight = 1;
  ImFontAtlasFlags_NoMouseCursors = 2;
  ImFontAtlasFlags_NoBakedLines = 4;

type
  ImGuiViewportFlags_ = Integer;
  PImGuiViewportFlags_ = ^ImGuiViewportFlags_;

const
  ImGuiViewportFlags_None = 0;
  ImGuiViewportFlags_IsPlatformWindow = 1;
  ImGuiViewportFlags_IsPlatformMonitor = 2;
  ImGuiViewportFlags_OwnedByApp = 4;
  ImGuiViewportFlags_NoDecoration = 8;
  ImGuiViewportFlags_NoTaskBarIcon = 16;
  ImGuiViewportFlags_NoFocusOnAppearing = 32;
  ImGuiViewportFlags_NoFocusOnClick = 64;
  ImGuiViewportFlags_NoInputs = 128;
  ImGuiViewportFlags_NoRendererClear = 256;
  ImGuiViewportFlags_NoAutoMerge = 512;
  ImGuiViewportFlags_TopMost = 1024;
  ImGuiViewportFlags_CanHostOtherWindows = 2048;
  ImGuiViewportFlags_IsMinimized = 4096;
  ImGuiViewportFlags_IsFocused = 8192;

type
  ImGuiDataTypePrivate_ = Integer;
  PImGuiDataTypePrivate_ = ^ImGuiDataTypePrivate_;

const
  ImGuiDataType_Pointer = 13;
  ImGuiDataType_ID = 14;

type
  ImGuiItemFlagsPrivate_ = Integer;
  PImGuiItemFlagsPrivate_ = ^ImGuiItemFlagsPrivate_;

const
  ImGuiItemFlags_Disabled = 1024;
  ImGuiItemFlags_ReadOnly = 2048;
  ImGuiItemFlags_MixedValue = 4096;
  ImGuiItemFlags_NoWindowHoverableCheck = 8192;
  ImGuiItemFlags_AllowOverlap = 16384;
  ImGuiItemFlags_NoNavDisableMouseHover = 32768;
  ImGuiItemFlags_NoMarkEdited = 65536;
  ImGuiItemFlags_Inputable = 1048576;
  ImGuiItemFlags_HasSelectionUserData = 2097152;
  ImGuiItemFlags_IsMultiSelect = 4194304;
  ImGuiItemFlags_Default_ = 16;

type
  ImGuiItemStatusFlags_ = Integer;
  PImGuiItemStatusFlags_ = ^ImGuiItemStatusFlags_;

const
  ImGuiItemStatusFlags_None = 0;
  ImGuiItemStatusFlags_HoveredRect = 1;
  ImGuiItemStatusFlags_HasDisplayRect = 2;
  ImGuiItemStatusFlags_Edited = 4;
  ImGuiItemStatusFlags_ToggledSelection = 8;
  ImGuiItemStatusFlags_ToggledOpen = 16;
  ImGuiItemStatusFlags_HasDeactivated = 32;
  ImGuiItemStatusFlags_Deactivated = 64;
  ImGuiItemStatusFlags_HoveredWindow = 128;
  ImGuiItemStatusFlags_Visible = 256;
  ImGuiItemStatusFlags_HasClipRect = 512;
  ImGuiItemStatusFlags_HasShortcut = 1024;

type
  ImGuiHoveredFlagsPrivate_ = Integer;
  PImGuiHoveredFlagsPrivate_ = ^ImGuiHoveredFlagsPrivate_;

const
  ImGuiHoveredFlags_DelayMask_ = 245760;
  ImGuiHoveredFlags_AllowedMaskForIsWindowHovered = 12479;
  ImGuiHoveredFlags_AllowedMaskForIsItemHovered = 262048;

type
  ImGuiInputTextFlagsPrivate_ = Integer;
  PImGuiInputTextFlagsPrivate_ = ^ImGuiInputTextFlagsPrivate_;

const
  ImGuiInputTextFlags_Multiline = 67108864;
  ImGuiInputTextFlags_MergedItem = 134217728;
  ImGuiInputTextFlags_LocalizeDecimalPoint = 268435456;

type
  ImGuiButtonFlagsPrivate_ = Integer;
  PImGuiButtonFlagsPrivate_ = ^ImGuiButtonFlagsPrivate_;

const
  ImGuiButtonFlags_PressedOnClick = 16;
  ImGuiButtonFlags_PressedOnClickRelease = 32;
  ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 64;
  ImGuiButtonFlags_PressedOnRelease = 128;
  ImGuiButtonFlags_PressedOnDoubleClick = 256;
  ImGuiButtonFlags_PressedOnDragDropHold = 512;
  ImGuiButtonFlags_FlattenChildren = 2048;
  ImGuiButtonFlags_AllowOverlap = 4096;
  ImGuiButtonFlags_AlignTextBaseLine = 32768;
  ImGuiButtonFlags_NoKeyModsAllowed = 65536;
  ImGuiButtonFlags_NoHoldingActiveId = 131072;
  ImGuiButtonFlags_NoNavFocus = 262144;
  ImGuiButtonFlags_NoHoveredOnFocus = 524288;
  ImGuiButtonFlags_NoSetKeyOwner = 1048576;
  ImGuiButtonFlags_NoTestKeyOwner = 2097152;
  ImGuiButtonFlags_PressedOnMask_ = 1008;
  ImGuiButtonFlags_PressedOnDefault_ = 32;

type
  ImGuiComboFlagsPrivate_ = Integer;
  PImGuiComboFlagsPrivate_ = ^ImGuiComboFlagsPrivate_;

const
  ImGuiComboFlags_CustomPreview = 1048576;

type
  ImGuiSliderFlagsPrivate_ = Integer;
  PImGuiSliderFlagsPrivate_ = ^ImGuiSliderFlagsPrivate_;

const
  ImGuiSliderFlags_Vertical = 1048576;
  ImGuiSliderFlags_ReadOnly = 2097152;

type
  ImGuiSelectableFlagsPrivate_ = Integer;
  PImGuiSelectableFlagsPrivate_ = ^ImGuiSelectableFlagsPrivate_;

const
  ImGuiSelectableFlags_NoHoldingActiveID = 1048576;
  ImGuiSelectableFlags_SelectOnNav = 2097152;
  ImGuiSelectableFlags_SelectOnClick = 4194304;
  ImGuiSelectableFlags_SelectOnRelease = 8388608;
  ImGuiSelectableFlags_SpanAvailWidth = 16777216;
  ImGuiSelectableFlags_SetNavIdOnHover = 33554432;
  ImGuiSelectableFlags_NoPadWithHalfSpacing = 67108864;
  ImGuiSelectableFlags_NoSetKeyOwner = 134217728;

type
  ImGuiTreeNodeFlagsPrivate_ = Integer;
  PImGuiTreeNodeFlagsPrivate_ = ^ImGuiTreeNodeFlagsPrivate_;

const
  ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 268435456;
  ImGuiTreeNodeFlags_UpsideDownArrow = 536870912;
  ImGuiTreeNodeFlags_OpenOnMask_ = 192;

type
  ImGuiSeparatorFlags_ = Integer;
  PImGuiSeparatorFlags_ = ^ImGuiSeparatorFlags_;

const
  ImGuiSeparatorFlags_None = 0;
  ImGuiSeparatorFlags_Horizontal = 1;
  ImGuiSeparatorFlags_Vertical = 2;
  ImGuiSeparatorFlags_SpanAllColumns = 4;

type
  ImGuiFocusRequestFlags_ = Integer;
  PImGuiFocusRequestFlags_ = ^ImGuiFocusRequestFlags_;

const
  ImGuiFocusRequestFlags_None = 0;
  ImGuiFocusRequestFlags_RestoreFocusedChild = 1;
  ImGuiFocusRequestFlags_UnlessBelowModal = 2;

type
  ImGuiTextFlags_ = Integer;
  PImGuiTextFlags_ = ^ImGuiTextFlags_;

const
  ImGuiTextFlags_None = 0;
  ImGuiTextFlags_NoWidthForLargeClippedText = 1;

type
  ImGuiTooltipFlags_ = Integer;
  PImGuiTooltipFlags_ = ^ImGuiTooltipFlags_;

const
  ImGuiTooltipFlags_None = 0;
  ImGuiTooltipFlags_OverridePrevious = 2;

type
  ImGuiLayoutType_ = Integer;
  PImGuiLayoutType_ = ^ImGuiLayoutType_;

const
  ImGuiLayoutType_Horizontal = 0;
  ImGuiLayoutType_Vertical = 1;

type
  ImGuiLogFlags_ = Integer;
  PImGuiLogFlags_ = ^ImGuiLogFlags_;

const
  ImGuiLogFlags_None = 0;
  ImGuiLogFlags_OutputTTY = 1;
  ImGuiLogFlags_OutputFile = 2;
  ImGuiLogFlags_OutputBuffer = 4;
  ImGuiLogFlags_OutputClipboard = 8;
  ImGuiLogFlags_OutputMask_ = 15;

type
  ImGuiAxis = Integer;
  PImGuiAxis = ^ImGuiAxis;

const
  ImGuiAxis_None = -1;
  ImGuiAxis_X = 0;
  ImGuiAxis_Y = 1;

type
  ImGuiPlotType = Integer;
  PImGuiPlotType = ^ImGuiPlotType;

const
  ImGuiPlotType_Lines = 0;
  ImGuiPlotType_Histogram = 1;

type
  ImGuiWindowRefreshFlags_ = Integer;
  PImGuiWindowRefreshFlags_ = ^ImGuiWindowRefreshFlags_;

const
  ImGuiWindowRefreshFlags_None = 0;
  ImGuiWindowRefreshFlags_TryToAvoidRefresh = 1;
  ImGuiWindowRefreshFlags_RefreshOnHover = 2;
  ImGuiWindowRefreshFlags_RefreshOnFocus = 4;

type
  ImGuiNextWindowDataFlags_ = Integer;
  PImGuiNextWindowDataFlags_ = ^ImGuiNextWindowDataFlags_;

const
  ImGuiNextWindowDataFlags_None = 0;
  ImGuiNextWindowDataFlags_HasPos = 1;
  ImGuiNextWindowDataFlags_HasSize = 2;
  ImGuiNextWindowDataFlags_HasContentSize = 4;
  ImGuiNextWindowDataFlags_HasCollapsed = 8;
  ImGuiNextWindowDataFlags_HasSizeConstraint = 16;
  ImGuiNextWindowDataFlags_HasFocus = 32;
  ImGuiNextWindowDataFlags_HasBgAlpha = 64;
  ImGuiNextWindowDataFlags_HasScroll = 128;
  ImGuiNextWindowDataFlags_HasChildFlags = 256;
  ImGuiNextWindowDataFlags_HasRefreshPolicy = 512;
  ImGuiNextWindowDataFlags_HasViewport = 1024;
  ImGuiNextWindowDataFlags_HasDock = 2048;
  ImGuiNextWindowDataFlags_HasWindowClass = 4096;

type
  ImGuiNextItemDataFlags_ = Integer;
  PImGuiNextItemDataFlags_ = ^ImGuiNextItemDataFlags_;

const
  ImGuiNextItemDataFlags_None = 0;
  ImGuiNextItemDataFlags_HasWidth = 1;
  ImGuiNextItemDataFlags_HasOpen = 2;
  ImGuiNextItemDataFlags_HasShortcut = 4;
  ImGuiNextItemDataFlags_HasRefVal = 8;
  ImGuiNextItemDataFlags_HasStorageID = 16;

type
  ImGuiPopupPositionPolicy = Integer;
  PImGuiPopupPositionPolicy = ^ImGuiPopupPositionPolicy;

const
  ImGuiPopupPositionPolicy_Default = 0;
  ImGuiPopupPositionPolicy_ComboBox = 1;
  ImGuiPopupPositionPolicy_Tooltip = 2;

type
  ImGuiInputEventType = Integer;
  PImGuiInputEventType = ^ImGuiInputEventType;

const
  ImGuiInputEventType_None = 0;
  ImGuiInputEventType_MousePos = 1;
  ImGuiInputEventType_MouseWheel = 2;
  ImGuiInputEventType_MouseButton = 3;
  ImGuiInputEventType_MouseViewport = 4;
  ImGuiInputEventType_Key = 5;
  ImGuiInputEventType_Text = 6;
  ImGuiInputEventType_Focus = 7;
  ImGuiInputEventType_COUNT = 8;

type
  ImGuiInputSource = Integer;
  PImGuiInputSource = ^ImGuiInputSource;

const
  ImGuiInputSource_None = 0;
  ImGuiInputSource_Mouse = 1;
  ImGuiInputSource_Keyboard = 2;
  ImGuiInputSource_Gamepad = 3;
  ImGuiInputSource_COUNT = 4;

type
  ImGuiInputFlagsPrivate_ = Integer;
  PImGuiInputFlagsPrivate_ = ^ImGuiInputFlagsPrivate_;

const
  ImGuiInputFlags_RepeatRateDefault = 2;
  ImGuiInputFlags_RepeatRateNavMove = 4;
  ImGuiInputFlags_RepeatRateNavTweak = 8;
  ImGuiInputFlags_RepeatUntilRelease = 16;
  ImGuiInputFlags_RepeatUntilKeyModsChange = 32;
  ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone = 64;
  ImGuiInputFlags_RepeatUntilOtherKeyPress = 128;
  ImGuiInputFlags_LockThisFrame = 1048576;
  ImGuiInputFlags_LockUntilRelease = 2097152;
  ImGuiInputFlags_CondHovered = 4194304;
  ImGuiInputFlags_CondActive = 8388608;
  ImGuiInputFlags_CondDefault_ = 12582912;
  ImGuiInputFlags_RepeatRateMask_ = 14;
  ImGuiInputFlags_RepeatUntilMask_ = 240;
  ImGuiInputFlags_RepeatMask_ = 255;
  ImGuiInputFlags_CondMask_ = 12582912;
  ImGuiInputFlags_RouteTypeMask_ = 15360;
  ImGuiInputFlags_RouteOptionsMask_ = 245760;
  ImGuiInputFlags_SupportedByIsKeyPressed = 255;
  ImGuiInputFlags_SupportedByIsMouseClicked = 1;
  ImGuiInputFlags_SupportedByShortcut = 261375;
  ImGuiInputFlags_SupportedBySetNextItemShortcut = 523519;
  ImGuiInputFlags_SupportedBySetKeyOwner = 3145728;
  ImGuiInputFlags_SupportedBySetItemKeyOwner = 15728640;

type
  ImGuiActivateFlags_ = Integer;
  PImGuiActivateFlags_ = ^ImGuiActivateFlags_;

const
  ImGuiActivateFlags_None = 0;
  ImGuiActivateFlags_PreferInput = 1;
  ImGuiActivateFlags_PreferTweak = 2;
  ImGuiActivateFlags_TryToPreserveState = 4;
  ImGuiActivateFlags_FromTabbing = 8;
  ImGuiActivateFlags_FromShortcut = 16;

type
  ImGuiScrollFlags_ = Integer;
  PImGuiScrollFlags_ = ^ImGuiScrollFlags_;

const
  ImGuiScrollFlags_None = 0;
  ImGuiScrollFlags_KeepVisibleEdgeX = 1;
  ImGuiScrollFlags_KeepVisibleEdgeY = 2;
  ImGuiScrollFlags_KeepVisibleCenterX = 4;
  ImGuiScrollFlags_KeepVisibleCenterY = 8;
  ImGuiScrollFlags_AlwaysCenterX = 16;
  ImGuiScrollFlags_AlwaysCenterY = 32;
  ImGuiScrollFlags_NoScrollParent = 64;
  ImGuiScrollFlags_MaskX_ = 21;
  ImGuiScrollFlags_MaskY_ = 42;

type
  ImGuiNavRenderCursorFlags_ = Integer;
  PImGuiNavRenderCursorFlags_ = ^ImGuiNavRenderCursorFlags_;

const
  ImGuiNavRenderCursorFlags_None = 0;
  ImGuiNavRenderCursorFlags_Compact = 2;
  ImGuiNavRenderCursorFlags_AlwaysDraw = 4;
  ImGuiNavRenderCursorFlags_NoRounding = 8;

type
  ImGuiNavMoveFlags_ = Integer;
  PImGuiNavMoveFlags_ = ^ImGuiNavMoveFlags_;

const
  ImGuiNavMoveFlags_None = 0;
  ImGuiNavMoveFlags_LoopX = 1;
  ImGuiNavMoveFlags_LoopY = 2;
  ImGuiNavMoveFlags_WrapX = 4;
  ImGuiNavMoveFlags_WrapY = 8;
  ImGuiNavMoveFlags_WrapMask_ = 15;
  ImGuiNavMoveFlags_AllowCurrentNavId = 16;
  ImGuiNavMoveFlags_AlsoScoreVisibleSet = 32;
  ImGuiNavMoveFlags_ScrollToEdgeY = 64;
  ImGuiNavMoveFlags_Forwarded = 128;
  ImGuiNavMoveFlags_DebugNoResult = 256;
  ImGuiNavMoveFlags_FocusApi = 512;
  ImGuiNavMoveFlags_IsTabbing = 1024;
  ImGuiNavMoveFlags_IsPageMove = 2048;
  ImGuiNavMoveFlags_Activate = 4096;
  ImGuiNavMoveFlags_NoSelect = 8192;
  ImGuiNavMoveFlags_NoSetNavCursorVisible = 16384;
  ImGuiNavMoveFlags_NoClearActiveId = 32768;

type
  ImGuiNavLayer = Integer;
  PImGuiNavLayer = ^ImGuiNavLayer;

const
  ImGuiNavLayer_Main = 0;
  ImGuiNavLayer_Menu = 1;
  ImGuiNavLayer_COUNT = 2;

type
  ImGuiTypingSelectFlags_ = Integer;
  PImGuiTypingSelectFlags_ = ^ImGuiTypingSelectFlags_;

const
  ImGuiTypingSelectFlags_None = 0;
  ImGuiTypingSelectFlags_AllowBackspace = 1;
  ImGuiTypingSelectFlags_AllowSingleCharMode = 2;

type
  ImGuiOldColumnFlags_ = Integer;
  PImGuiOldColumnFlags_ = ^ImGuiOldColumnFlags_;

const
  ImGuiOldColumnFlags_None = 0;
  ImGuiOldColumnFlags_NoBorder = 1;
  ImGuiOldColumnFlags_NoResize = 2;
  ImGuiOldColumnFlags_NoPreserveWidths = 4;
  ImGuiOldColumnFlags_NoForceWithinWindow = 8;
  ImGuiOldColumnFlags_GrowParentContentsSize = 16;

type
  ImGuiDockNodeFlagsPrivate_ = Integer;
  PImGuiDockNodeFlagsPrivate_ = ^ImGuiDockNodeFlagsPrivate_;

const
  ImGuiDockNodeFlags_DockSpace = 1024;
  ImGuiDockNodeFlags_CentralNode = 2048;
  ImGuiDockNodeFlags_NoTabBar = 4096;
  ImGuiDockNodeFlags_HiddenTabBar = 8192;
  ImGuiDockNodeFlags_NoWindowMenuButton = 16384;
  ImGuiDockNodeFlags_NoCloseButton = 32768;
  ImGuiDockNodeFlags_NoResizeX = 65536;
  ImGuiDockNodeFlags_NoResizeY = 131072;
  ImGuiDockNodeFlags_DockedWindowsInFocusRoute = 262144;
  ImGuiDockNodeFlags_NoDockingSplitOther = 524288;
  ImGuiDockNodeFlags_NoDockingOverMe = 1048576;
  ImGuiDockNodeFlags_NoDockingOverOther = 2097152;
  ImGuiDockNodeFlags_NoDockingOverEmpty = 4194304;
  ImGuiDockNodeFlags_NoDocking = 7864336;
  ImGuiDockNodeFlags_SharedFlagsInheritMask_ = -1;
  ImGuiDockNodeFlags_NoResizeFlagsMask_ = 196640;
  ImGuiDockNodeFlags_LocalFlagsTransferMask_ = 260208;
  ImGuiDockNodeFlags_SavedFlagsMask_ = 261152;

type
  ImGuiDataAuthority_ = Integer;
  PImGuiDataAuthority_ = ^ImGuiDataAuthority_;

const
  ImGuiDataAuthority_Auto = 0;
  ImGuiDataAuthority_DockNode = 1;
  ImGuiDataAuthority_Window = 2;

type
  ImGuiDockNodeState = Integer;
  PImGuiDockNodeState = ^ImGuiDockNodeState;

const
  ImGuiDockNodeState_Unknown = 0;
  ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow = 1;
  ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing = 2;
  ImGuiDockNodeState_HostWindowVisible = 3;

type
  ImGuiWindowDockStyleCol = Integer;
  PImGuiWindowDockStyleCol = ^ImGuiWindowDockStyleCol;

const
  ImGuiWindowDockStyleCol_Text = 0;
  ImGuiWindowDockStyleCol_TabHovered = 1;
  ImGuiWindowDockStyleCol_TabFocused = 2;
  ImGuiWindowDockStyleCol_TabSelected = 3;
  ImGuiWindowDockStyleCol_TabSelectedOverline = 4;
  ImGuiWindowDockStyleCol_TabDimmed = 5;
  ImGuiWindowDockStyleCol_TabDimmedSelected = 6;
  ImGuiWindowDockStyleCol_TabDimmedSelectedOverline = 7;
  ImGuiWindowDockStyleCol_COUNT = 8;

type
  ImGuiLocKey = Integer;
  PImGuiLocKey = ^ImGuiLocKey;

const
  ImGuiLocKey_VersionStr = 0;
  ImGuiLocKey_TableSizeOne = 1;
  ImGuiLocKey_TableSizeAllFit = 2;
  ImGuiLocKey_TableSizeAllDefault = 3;
  ImGuiLocKey_TableResetOrder = 4;
  ImGuiLocKey_WindowingMainMenuBar = 5;
  ImGuiLocKey_WindowingPopup = 6;
  ImGuiLocKey_WindowingUntitled = 7;
  ImGuiLocKey_OpenLink_s = 8;
  ImGuiLocKey_CopyLink = 9;
  ImGuiLocKey_DockingHideTabBar = 10;
  ImGuiLocKey_DockingHoldShiftToDock = 11;
  ImGuiLocKey_DockingDragToUndockOrMoveNode = 12;
  ImGuiLocKey_COUNT = 13;

type
  ImGuiDebugLogFlags_ = Integer;
  PImGuiDebugLogFlags_ = ^ImGuiDebugLogFlags_;

const
  ImGuiDebugLogFlags_None = 0;
  ImGuiDebugLogFlags_EventError = 1;
  ImGuiDebugLogFlags_EventActiveId = 2;
  ImGuiDebugLogFlags_EventFocus = 4;
  ImGuiDebugLogFlags_EventPopup = 8;
  ImGuiDebugLogFlags_EventNav = 16;
  ImGuiDebugLogFlags_EventClipper = 32;
  ImGuiDebugLogFlags_EventSelection = 64;
  ImGuiDebugLogFlags_EventIO = 128;
  ImGuiDebugLogFlags_EventFont = 256;
  ImGuiDebugLogFlags_EventInputRouting = 512;
  ImGuiDebugLogFlags_EventDocking = 1024;
  ImGuiDebugLogFlags_EventViewport = 2048;
  ImGuiDebugLogFlags_EventMask_ = 4095;
  ImGuiDebugLogFlags_OutputToTTY = 1048576;
  ImGuiDebugLogFlags_OutputToTestEngine = 2097152;

type
  ImGuiContextHookType = Integer;
  PImGuiContextHookType = ^ImGuiContextHookType;

const
  ImGuiContextHookType_NewFramePre = 0;
  ImGuiContextHookType_NewFramePost = 1;
  ImGuiContextHookType_EndFramePre = 2;
  ImGuiContextHookType_EndFramePost = 3;
  ImGuiContextHookType_RenderPre = 4;
  ImGuiContextHookType_RenderPost = 5;
  ImGuiContextHookType_Shutdown = 6;
  ImGuiContextHookType_PendingRemoval_ = 7;

type
  ImGuiTabBarFlagsPrivate_ = Integer;
  PImGuiTabBarFlagsPrivate_ = ^ImGuiTabBarFlagsPrivate_;

const
  ImGuiTabBarFlags_DockNode = 1048576;
  ImGuiTabBarFlags_IsFocused = 2097152;
  ImGuiTabBarFlags_SaveSettings = 4194304;

type
  ImGuiTabItemFlagsPrivate_ = Integer;
  PImGuiTabItemFlagsPrivate_ = ^ImGuiTabItemFlagsPrivate_;

const
  ImGuiTabItemFlags_SectionMask_ = 192;
  ImGuiTabItemFlags_NoCloseButton = 1048576;
  ImGuiTabItemFlags_Button = 2097152;
  ImGuiTabItemFlags_Invisible = 4194304;
  ImGuiTabItemFlags_Unsorted = 8388608;

type
  // Forward declarations
  PPUTF8Char = ^PUTF8Char;
  PPPUTF8Char = ^PPUTF8Char;
  PPByte = ^PByte;
  PPInteger = ^PInteger;
  PPSingle = ^PSingle;
  PPDouble = ^PDouble;
  PUInt32 = ^UInt32;
  PNativeUInt = ^NativeUInt;
  PUInt8 = ^UInt8;
  PPointer = ^Pointer;
  Plua_Debug = ^lua_Debug;
  PluaL_Reg = ^luaL_Reg;
  PluaL_Buffer = ^luaL_Buffer;
  PspFloatArray = ^spFloatArray;
  PPspFloatArray = ^PspFloatArray;
  PspIntArray = ^spIntArray;
  PspShortArray = ^spShortArray;
  PPspShortArray = ^PspShortArray;
  PspUnsignedShortArray = ^spUnsignedShortArray;
  PspArrayFloatArray = ^spArrayFloatArray;
  PspArrayShortArray = ^spArrayShortArray;
  PspEventData = ^spEventData;
  PPspEventData = ^PspEventData;
  PspEvent = ^spEvent;
  PPspEvent = ^PspEvent;
  PspAttachment = ^spAttachment;
  PspColor = ^spColor;
  PspBoneData = ^spBoneData;
  PPspBoneData = ^PspBoneData;
  PspBone = ^spBone;
  PPspBone = ^PspBone;
  PspSlotData = ^spSlotData;
  PPspSlotData = ^PspSlotData;
  PspSlot = ^spSlot;
  PPspSlot = ^PspSlot;
  PspVertexAttachment = ^spVertexAttachment;
  PspTextureRegion = ^spTextureRegion;
  PPspTextureRegion = ^PspTextureRegion;
  PspAtlasPage = ^spAtlasPage;
  PspKeyValue = ^spKeyValue;
  PspKeyValueArray = ^spKeyValueArray;
  PspAtlasRegion = ^spAtlasRegion;
  PspAtlas = ^spAtlas;
  PspTextureRegionArray = ^spTextureRegionArray;
  PspSequence = ^spSequence;
  PspPropertyIdArray = ^spPropertyIdArray;
  PspTimelineArray = ^spTimelineArray;
  PspAnimation = ^spAnimation;
  PPspAnimation = ^PspAnimation;
  P_spTimelineVtable = ^_spTimelineVtable;
  PspTimeline = ^spTimeline;
  PPspTimeline = ^PspTimeline;
  PspCurveTimeline = ^spCurveTimeline;
  PspRotateTimeline = ^spRotateTimeline;
  PspTranslateTimeline = ^spTranslateTimeline;
  PspTranslateXTimeline = ^spTranslateXTimeline;
  PspTranslateYTimeline = ^spTranslateYTimeline;
  PspScaleTimeline = ^spScaleTimeline;
  PspScaleXTimeline = ^spScaleXTimeline;
  PspScaleYTimeline = ^spScaleYTimeline;
  PspShearTimeline = ^spShearTimeline;
  PspShearXTimeline = ^spShearXTimeline;
  PspShearYTimeline = ^spShearYTimeline;
  PspRGBATimeline = ^spRGBATimeline;
  PspRGBTimeline = ^spRGBTimeline;
  PspAlphaTimeline = ^spAlphaTimeline;
  PspRGBA2Timeline = ^spRGBA2Timeline;
  PspRGB2Timeline = ^spRGB2Timeline;
  PspAttachmentTimeline = ^spAttachmentTimeline;
  PspDeformTimeline = ^spDeformTimeline;
  PspSequenceTimeline = ^spSequenceTimeline;
  PspEventTimeline = ^spEventTimeline;
  PspDrawOrderTimeline = ^spDrawOrderTimeline;
  PspInheritTimeline = ^spInheritTimeline;
  PspIkConstraintTimeline = ^spIkConstraintTimeline;
  PspTransformConstraintTimeline = ^spTransformConstraintTimeline;
  PspPathConstraintPositionTimeline = ^spPathConstraintPositionTimeline;
  PspPathConstraintSpacingTimeline = ^spPathConstraintSpacingTimeline;
  PspPathConstraintMixTimeline = ^spPathConstraintMixTimeline;
  PspPhysicsConstraintTimeline = ^spPhysicsConstraintTimeline;
  PspPhysicsConstraintResetTimeline = ^spPhysicsConstraintResetTimeline;
  PspIkConstraintData = ^spIkConstraintData;
  PPspIkConstraintData = ^PspIkConstraintData;
  PspTransformConstraintData = ^spTransformConstraintData;
  PPspTransformConstraintData = ^PspTransformConstraintData;
  PspPathConstraintData = ^spPathConstraintData;
  PPspPathConstraintData = ^PspPathConstraintData;
  PspPhysicsConstraintData = ^spPhysicsConstraintData;
  PPspPhysicsConstraintData = ^PspPhysicsConstraintData;
  PspBoneDataArray = ^spBoneDataArray;
  PspIkConstraintDataArray = ^spIkConstraintDataArray;
  PspTransformConstraintDataArray = ^spTransformConstraintDataArray;
  PspPathConstraintDataArray = ^spPathConstraintDataArray;
  PspPhysicsConstraintDataArray = ^spPhysicsConstraintDataArray;
  PspSkin = ^spSkin;
  PPspSkin = ^PspSkin;
  P_Entry = ^_Entry;
  P_SkinHashTableEntry = ^_SkinHashTableEntry;
  P_spSkin = ^_spSkin;
  PspSkeletonData = ^spSkeletonData;
  PspAnimationStateData = ^spAnimationStateData;
  PspTrackEntryArray = ^spTrackEntryArray;
  PspTrackEntry = ^spTrackEntry;
  PPspTrackEntry = ^PspTrackEntry;
  PspAnimationState = ^spAnimationState;
  PspAttachmentLoader = ^spAttachmentLoader;
  PspAtlasAttachmentLoader = ^spAtlasAttachmentLoader;
  PspRegionAttachment = ^spRegionAttachment;
  PspMeshAttachment = ^spMeshAttachment;
  PspBoundingBoxAttachment = ^spBoundingBoxAttachment;
  PPspBoundingBoxAttachment = ^PspBoundingBoxAttachment;
  PspClippingAttachment = ^spClippingAttachment;
  PspPointAttachment = ^spPointAttachment;
  PspIkConstraint = ^spIkConstraint;
  PPspIkConstraint = ^PspIkConstraint;
  PspTransformConstraint = ^spTransformConstraint;
  PPspTransformConstraint = ^PspTransformConstraint;
  PspPathAttachment = ^spPathAttachment;
  PspPathConstraint = ^spPathConstraint;
  PPspPathConstraint = ^PspPathConstraint;
  PspPhysicsConstraint = ^spPhysicsConstraint;
  PPspPhysicsConstraint = ^PspPhysicsConstraint;
  PspSkeleton = ^spSkeleton;
  PspPolygon = ^spPolygon;
  PPspPolygon = ^PspPolygon;
  PspSkeletonBounds = ^spSkeletonBounds;
  PspSkeletonBinary = ^spSkeletonBinary;
  PspSkeletonJson = ^spSkeletonJson;
  PspTriangulator = ^spTriangulator;
  PspSkeletonClipping = ^spSkeletonClipping;
  PGLFWvidmode = ^GLFWvidmode;
  PGLFWgammaramp = ^GLFWgammaramp;
  PGLFWimage = ^GLFWimage;
  PGLFWgamepadstate = ^GLFWgamepadstate;
  PGLFWallocator = ^GLFWallocator;
  PspGlfwVertexArray = ^spGlfwVertexArray;
  PspSkeletonDrawable = ^spSkeletonDrawable;
  Pstbi_io_callbacks = ^stbi_io_callbacks;
  Pstbrp_rect = ^stbrp_rect;
  Pstbrp_node = ^stbrp_node;
  Pstbrp_context = ^stbrp_context;
  Pstbtt__buf = ^stbtt__buf;
  Pstbtt_bakedchar = ^stbtt_bakedchar;
  Pstbtt_aligned_quad = ^stbtt_aligned_quad;
  Pstbtt_packedchar = ^stbtt_packedchar;
  Pstbtt_pack_range = ^stbtt_pack_range;
  Pstbtt_pack_context = ^stbtt_pack_context;
  Pstbtt_fontinfo = ^stbtt_fontinfo;
  Pstbtt_kerningentry = ^stbtt_kerningentry;
  Pstbtt_vertex = ^stbtt_vertex;
  PPstbtt_vertex = ^Pstbtt_vertex;
  Pstbtt__bitmap = ^stbtt__bitmap;
  Pc2v = ^c2v;
  Pc2r = ^c2r;
  Pc2m = ^c2m;
  Pc2x = ^c2x;
  Pc2h = ^c2h;
  Pc2Circle = ^c2Circle;
  Pc2AABB = ^c2AABB;
  Pc2Capsule = ^c2Capsule;
  Pc2Poly = ^c2Poly;
  Pc2Ray = ^c2Ray;
  Pc2Raycast = ^c2Raycast;
  Pc2Manifold = ^c2Manifold;
  Pc2GJKCache = ^c2GJKCache;
  Pc2TOIResult = ^c2TOIResult;
  Pplm_packet_t = ^plm_packet_t;
  Pplm_plane_t = ^plm_plane_t;
  Pplm_frame_t = ^plm_frame_t;
  Pplm_samples_t = ^plm_samples_t;
  Pma_allocation_callbacks = ^ma_allocation_callbacks;
  Pma_lcg = ^ma_lcg;
  Pma_atomic_uint32 = ^ma_atomic_uint32;
  Pma_atomic_int32 = ^ma_atomic_int32;
  Pma_atomic_uint64 = ^ma_atomic_uint64;
  Pma_atomic_float = ^ma_atomic_float;
  Pma_atomic_bool32 = ^ma_atomic_bool32;
  Pma_log_callback = ^ma_log_callback;
  Pma_log = ^ma_log;
  Pma_biquad_config = ^ma_biquad_config;
  Pma_biquad = ^ma_biquad;
  Pma_lpf1_config = ^ma_lpf1_config;
  Pma_lpf1 = ^ma_lpf1;
  Pma_lpf2 = ^ma_lpf2;
  Pma_lpf_config = ^ma_lpf_config;
  Pma_lpf = ^ma_lpf;
  Pma_hpf1_config = ^ma_hpf1_config;
  Pma_hpf1 = ^ma_hpf1;
  Pma_hpf2 = ^ma_hpf2;
  Pma_hpf_config = ^ma_hpf_config;
  Pma_hpf = ^ma_hpf;
  Pma_bpf2_config = ^ma_bpf2_config;
  Pma_bpf2 = ^ma_bpf2;
  Pma_bpf_config = ^ma_bpf_config;
  Pma_bpf = ^ma_bpf;
  Pma_notch2_config = ^ma_notch2_config;
  Pma_notch2 = ^ma_notch2;
  Pma_peak2_config = ^ma_peak2_config;
  Pma_peak2 = ^ma_peak2;
  Pma_loshelf2_config = ^ma_loshelf2_config;
  Pma_loshelf2 = ^ma_loshelf2;
  Pma_hishelf2_config = ^ma_hishelf2_config;
  Pma_hishelf2 = ^ma_hishelf2;
  Pma_delay_config = ^ma_delay_config;
  Pma_delay = ^ma_delay;
  Pma_gainer_config = ^ma_gainer_config;
  Pma_gainer = ^ma_gainer;
  Pma_panner_config = ^ma_panner_config;
  Pma_panner = ^ma_panner;
  Pma_fader_config = ^ma_fader_config;
  Pma_fader = ^ma_fader;
  Pma_vec3f = ^ma_vec3f;
  Pma_atomic_vec3f = ^ma_atomic_vec3f;
  Pma_spatializer_listener_config = ^ma_spatializer_listener_config;
  Pma_spatializer_listener = ^ma_spatializer_listener;
  Pma_spatializer_config = ^ma_spatializer_config;
  Pma_spatializer = ^ma_spatializer;
  Pma_linear_resampler_config = ^ma_linear_resampler_config;
  Pma_linear_resampler = ^ma_linear_resampler;
  Pma_resampling_backend_vtable = ^ma_resampling_backend_vtable;
  Pma_resampler_config = ^ma_resampler_config;
  Pma_resampler = ^ma_resampler;
  Pma_channel_converter_config = ^ma_channel_converter_config;
  Pma_channel_converter = ^ma_channel_converter;
  Pma_data_converter_config = ^ma_data_converter_config;
  Pma_data_converter = ^ma_data_converter;
  Pma_data_source_vtable = ^ma_data_source_vtable;
  Pma_data_source_config = ^ma_data_source_config;
  Pma_data_source_base = ^ma_data_source_base;
  Pma_audio_buffer_ref = ^ma_audio_buffer_ref;
  Pma_audio_buffer_config = ^ma_audio_buffer_config;
  Pma_audio_buffer = ^ma_audio_buffer;
  PPma_audio_buffer = ^Pma_audio_buffer;
  Pma_paged_audio_buffer_page = ^ma_paged_audio_buffer_page;
  PPma_paged_audio_buffer_page = ^Pma_paged_audio_buffer_page;
  Pma_paged_audio_buffer_data = ^ma_paged_audio_buffer_data;
  Pma_paged_audio_buffer_config = ^ma_paged_audio_buffer_config;
  Pma_paged_audio_buffer = ^ma_paged_audio_buffer;
  Pma_rb = ^ma_rb;
  Pma_pcm_rb = ^ma_pcm_rb;
  Pma_duplex_rb = ^ma_duplex_rb;
  Pma_fence = ^ma_fence;
  Pma_async_notification_callbacks = ^ma_async_notification_callbacks;
  Pma_async_notification_poll = ^ma_async_notification_poll;
  Pma_async_notification_event = ^ma_async_notification_event;
  Pma_slot_allocator_config = ^ma_slot_allocator_config;
  Pma_slot_allocator_group = ^ma_slot_allocator_group;
  Pma_slot_allocator = ^ma_slot_allocator;
  Pma_job = ^ma_job;
  Pma_job_queue_config = ^ma_job_queue_config;
  Pma_job_queue = ^ma_job_queue;
  Pma_atomic_device_state = ^ma_atomic_device_state;
  Pma_IMMNotificationClient = ^ma_IMMNotificationClient;
  Pma_device_job_thread_config = ^ma_device_job_thread_config;
  Pma_device_job_thread = ^ma_device_job_thread;
  Pma_device_notification = ^ma_device_notification;
  Pma_device_info = ^ma_device_info;
  PPma_device_info = ^Pma_device_info;
  Pma_device_config = ^ma_device_config;
  Pma_device_descriptor = ^ma_device_descriptor;
  Pma_backend_callbacks = ^ma_backend_callbacks;
  Pma_context_config = ^ma_context_config;
  Pma_context_command__wasapi = ^ma_context_command__wasapi;
  Pma_context = ^ma_context;
  Pma_device = ^ma_device;
  Pma_file_info = ^ma_file_info;
  Pma_vfs_callbacks = ^ma_vfs_callbacks;
  Pma_default_vfs = ^ma_default_vfs;
  Pma_decoding_backend_config = ^ma_decoding_backend_config;
  Pma_decoding_backend_vtable = ^ma_decoding_backend_vtable;
  PPma_decoding_backend_vtable = ^Pma_decoding_backend_vtable;
  Pma_decoder_config = ^ma_decoder_config;
  Pma_decoder = ^ma_decoder;
  Pma_encoder_config = ^ma_encoder_config;
  Pma_encoder = ^ma_encoder;
  Pma_waveform_config = ^ma_waveform_config;
  Pma_waveform = ^ma_waveform;
  Pma_pulsewave_config = ^ma_pulsewave_config;
  Pma_pulsewave = ^ma_pulsewave;
  Pma_noise_config = ^ma_noise_config;
  Pma_noise = ^ma_noise;
  Pma_resource_manager_pipeline_stage_notification = ^ma_resource_manager_pipeline_stage_notification;
  Pma_resource_manager_pipeline_notifications = ^ma_resource_manager_pipeline_notifications;
  Pma_resource_manager_data_source_config = ^ma_resource_manager_data_source_config;
  Pma_resource_manager_data_supply = ^ma_resource_manager_data_supply;
  Pma_resource_manager_data_buffer_node = ^ma_resource_manager_data_buffer_node;
  Pma_resource_manager_data_buffer = ^ma_resource_manager_data_buffer;
  Pma_resource_manager_data_stream = ^ma_resource_manager_data_stream;
  Pma_resource_manager_data_source = ^ma_resource_manager_data_source;
  Pma_resource_manager_config = ^ma_resource_manager_config;
  Pma_resource_manager = ^ma_resource_manager;
  Pma_node_vtable = ^ma_node_vtable;
  Pma_node_config = ^ma_node_config;
  Pma_node_output_bus = ^ma_node_output_bus;
  Pma_node_input_bus = ^ma_node_input_bus;
  Pma_node_base = ^ma_node_base;
  Pma_node_graph_config = ^ma_node_graph_config;
  Pma_node_graph = ^ma_node_graph;
  Pma_data_source_node_config = ^ma_data_source_node_config;
  Pma_data_source_node = ^ma_data_source_node;
  Pma_splitter_node_config = ^ma_splitter_node_config;
  Pma_splitter_node = ^ma_splitter_node;
  Pma_biquad_node_config = ^ma_biquad_node_config;
  Pma_biquad_node = ^ma_biquad_node;
  Pma_lpf_node_config = ^ma_lpf_node_config;
  Pma_lpf_node = ^ma_lpf_node;
  Pma_hpf_node_config = ^ma_hpf_node_config;
  Pma_hpf_node = ^ma_hpf_node;
  Pma_bpf_node_config = ^ma_bpf_node_config;
  Pma_bpf_node = ^ma_bpf_node;
  Pma_notch_node_config = ^ma_notch_node_config;
  Pma_notch_node = ^ma_notch_node;
  Pma_peak_node_config = ^ma_peak_node_config;
  Pma_peak_node = ^ma_peak_node;
  Pma_loshelf_node_config = ^ma_loshelf_node_config;
  Pma_loshelf_node = ^ma_loshelf_node;
  Pma_hishelf_node_config = ^ma_hishelf_node_config;
  Pma_hishelf_node = ^ma_hishelf_node;
  Pma_delay_node_config = ^ma_delay_node_config;
  Pma_delay_node = ^ma_delay_node;
  Pma_engine_node_config = ^ma_engine_node_config;
  Pma_engine_node = ^ma_engine_node;
  Pma_sound_config = ^ma_sound_config;
  Pma_sound = ^ma_sound;
  Pma_sound_inlined = ^ma_sound_inlined;
  Pma_engine_config = ^ma_engine_config;
  Pma_engine = ^ma_engine;
  Ptm_zip_s = ^tm_zip_s;
  Pzip_fileinfo = ^zip_fileinfo;
  Ptm_unz_s = ^tm_unz_s;
  Punz_file_info64_s = ^unz_file_info64_s;
  Psqlite3_file = ^sqlite3_file;
  Psqlite3_io_methods = ^sqlite3_io_methods;
  Psqlite3_vfs = ^sqlite3_vfs;
  Psqlite3_mem_methods = ^sqlite3_mem_methods;
  Psqlite3_module = ^sqlite3_module;
  Psqlite3_index_constraint = ^sqlite3_index_constraint;
  Psqlite3_index_orderby = ^sqlite3_index_orderby;
  Psqlite3_index_constraint_usage = ^sqlite3_index_constraint_usage;
  Psqlite3_index_info = ^sqlite3_index_info;
  Psqlite3_vtab = ^sqlite3_vtab;
  PPsqlite3_vtab = ^Psqlite3_vtab;
  Psqlite3_vtab_cursor = ^sqlite3_vtab_cursor;
  PPsqlite3_vtab_cursor = ^Psqlite3_vtab_cursor;
  Psqlite3_mutex_methods = ^sqlite3_mutex_methods;
  Psqlite3_pcache_page = ^sqlite3_pcache_page;
  Psqlite3_pcache_methods2 = ^sqlite3_pcache_methods2;
  Psqlite3_pcache_methods = ^sqlite3_pcache_methods;
  Psqlite3_snapshot = ^sqlite3_snapshot;
  PPsqlite3_snapshot = ^Psqlite3_snapshot;
  Psqlite3_rtree_geometry = ^sqlite3_rtree_geometry;
  Psqlite3_rtree_query_info = ^sqlite3_rtree_query_info;
  PFts5PhraseIter = ^Fts5PhraseIter;
  PFts5ExtensionApi = ^Fts5ExtensionApi;
  Pfts5_tokenizer_v2 = ^fts5_tokenizer_v2;
  PPfts5_tokenizer_v2 = ^Pfts5_tokenizer_v2;
  Pfts5_tokenizer = ^fts5_tokenizer;
  Pfts5_api = ^fts5_api;
  Psqlite3_api_routines = ^sqlite3_api_routines;
  PImVector_const_charPtr = ^ImVector_const_charPtr;
  PImVec2 = ^ImVec2;
  PImVec4 = ^ImVec4;
  PImGuiTableSortSpecs = ^ImGuiTableSortSpecs;
  PImGuiTableColumnSortSpecs = ^ImGuiTableColumnSortSpecs;
  PImGuiStyle = ^ImGuiStyle;
  PImGuiKeyData = ^ImGuiKeyData;
  PImVector_ImWchar = ^ImVector_ImWchar;
  PImGuiIO = ^ImGuiIO;
  PImGuiInputTextCallbackData = ^ImGuiInputTextCallbackData;
  PImGuiSizeCallbackData = ^ImGuiSizeCallbackData;
  PImGuiWindowClass = ^ImGuiWindowClass;
  PImGuiPayload = ^ImGuiPayload;
  PImGuiOnceUponAFrame = ^ImGuiOnceUponAFrame;
  PImGuiTextRange = ^ImGuiTextRange;
  PImVector_ImGuiTextRange = ^ImVector_ImGuiTextRange;
  PImGuiTextFilter = ^ImGuiTextFilter;
  PImVector_char = ^ImVector_char;
  PImGuiTextBuffer = ^ImGuiTextBuffer;
  PImGuiStoragePair = ^ImGuiStoragePair;
  PImVector_ImGuiStoragePair = ^ImVector_ImGuiStoragePair;
  PImGuiStorage = ^ImGuiStorage;
  PImGuiListClipper = ^ImGuiListClipper;
  PImColor = ^ImColor;
  PImVector_ImGuiSelectionRequest = ^ImVector_ImGuiSelectionRequest;
  PImGuiMultiSelectIO = ^ImGuiMultiSelectIO;
  PImGuiSelectionRequest = ^ImGuiSelectionRequest;
  PImGuiSelectionBasicStorage = ^ImGuiSelectionBasicStorage;
  PImGuiSelectionExternalStorage = ^ImGuiSelectionExternalStorage;
  PImDrawCmd = ^ImDrawCmd;
  PImDrawVert = ^ImDrawVert;
  PImDrawCmdHeader = ^ImDrawCmdHeader;
  PImVector_ImDrawCmd = ^ImVector_ImDrawCmd;
  PImVector_ImDrawIdx = ^ImVector_ImDrawIdx;
  PImDrawChannel = ^ImDrawChannel;
  PImVector_ImDrawChannel = ^ImVector_ImDrawChannel;
  PImDrawListSplitter = ^ImDrawListSplitter;
  PImVector_ImDrawVert = ^ImVector_ImDrawVert;
  PImVector_ImVec2 = ^ImVector_ImVec2;
  PImVector_ImVec4 = ^ImVector_ImVec4;
  PImVector_ImTextureID = ^ImVector_ImTextureID;
  PImVector_ImU8 = ^ImVector_ImU8;
  PImDrawList = ^ImDrawList;
  PPImDrawList = ^PImDrawList;
  PImVector_ImDrawListPtr = ^ImVector_ImDrawListPtr;
  PImDrawData = ^ImDrawData;
  PImFontConfig = ^ImFontConfig;
  PImFontGlyph = ^ImFontGlyph;
  PImVector_ImU32 = ^ImVector_ImU32;
  PImFontGlyphRangesBuilder = ^ImFontGlyphRangesBuilder;
  PImFontAtlasCustomRect = ^ImFontAtlasCustomRect;
  PImVector_ImFontPtr = ^ImVector_ImFontPtr;
  PImVector_ImFontAtlasCustomRect = ^ImVector_ImFontAtlasCustomRect;
  PImVector_ImFontConfig = ^ImVector_ImFontConfig;
  PImFontAtlas = ^ImFontAtlas;
  PImVector_float = ^ImVector_float;
  PImVector_ImU16 = ^ImVector_ImU16;
  PImVector_ImFontGlyph = ^ImVector_ImFontGlyph;
  PImFont = ^ImFont;
  PPImFont = ^PImFont;
  PImGuiViewport = ^ImGuiViewport;
  PPImGuiViewport = ^PImGuiViewport;
  PImVector_ImGuiPlatformMonitor = ^ImVector_ImGuiPlatformMonitor;
  PImVector_ImGuiViewportPtr = ^ImVector_ImGuiViewportPtr;
  PImGuiPlatformIO = ^ImGuiPlatformIO;
  PImGuiPlatformMonitor = ^ImGuiPlatformMonitor;
  PImGuiPlatformImeData = ^ImGuiPlatformImeData;
  PImVec1 = ^ImVec1;
  PImVec2ih = ^ImVec2ih;
  PImRect = ^ImRect;
  PImBitVector = ^ImBitVector;
  PImVector_int = ^ImVector_int;
  PImGuiTextIndex = ^ImGuiTextIndex;
  PImDrawListSharedData = ^ImDrawListSharedData;
  PImDrawDataBuilder = ^ImDrawDataBuilder;
  PImGuiDataVarInfo = ^ImGuiDataVarInfo;
  PImGuiDataTypeStorage = ^ImGuiDataTypeStorage;
  PImGuiDataTypeInfo = ^ImGuiDataTypeInfo;
  PImGuiColorMod = ^ImGuiColorMod;
  PImGuiStyleMod = ^ImGuiStyleMod;
  PImGuiComboPreviewData = ^ImGuiComboPreviewData;
  PImGuiGroupData = ^ImGuiGroupData;
  PImGuiMenuColumns = ^ImGuiMenuColumns;
  PImGuiInputTextDeactivatedState = ^ImGuiInputTextDeactivatedState;
  PImGuiInputTextState = ^ImGuiInputTextState;
  PImGuiNextWindowData = ^ImGuiNextWindowData;
  PImGuiNextItemData = ^ImGuiNextItemData;
  PImGuiLastItemData = ^ImGuiLastItemData;
  PImGuiTreeNodeStackData = ^ImGuiTreeNodeStackData;
  PImGuiErrorRecoveryState = ^ImGuiErrorRecoveryState;
  PImGuiWindowStackData = ^ImGuiWindowStackData;
  PImGuiShrinkWidthItem = ^ImGuiShrinkWidthItem;
  PImGuiPtrOrIndex = ^ImGuiPtrOrIndex;
  PImGuiDeactivatedItemData = ^ImGuiDeactivatedItemData;
  PImGuiPopupData = ^ImGuiPopupData;
  PImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN = ^ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN;
  PImGuiInputEventMousePos = ^ImGuiInputEventMousePos;
  PImGuiInputEventMouseWheel = ^ImGuiInputEventMouseWheel;
  PImGuiInputEventMouseButton = ^ImGuiInputEventMouseButton;
  PImGuiInputEventMouseViewport = ^ImGuiInputEventMouseViewport;
  PImGuiInputEventKey = ^ImGuiInputEventKey;
  PImGuiInputEventText = ^ImGuiInputEventText;
  PImGuiInputEventAppFocused = ^ImGuiInputEventAppFocused;
  PImGuiInputEvent = ^ImGuiInputEvent;
  PImGuiKeyRoutingData = ^ImGuiKeyRoutingData;
  PImVector_ImGuiKeyRoutingData = ^ImVector_ImGuiKeyRoutingData;
  PImGuiKeyRoutingTable = ^ImGuiKeyRoutingTable;
  PImGuiKeyOwnerData = ^ImGuiKeyOwnerData;
  PImGuiListClipperRange = ^ImGuiListClipperRange;
  PImVector_ImGuiListClipperRange = ^ImVector_ImGuiListClipperRange;
  PImGuiListClipperData = ^ImGuiListClipperData;
  PImGuiNavItemData = ^ImGuiNavItemData;
  PImGuiFocusScopeData = ^ImGuiFocusScopeData;
  PImGuiTypingSelectRequest = ^ImGuiTypingSelectRequest;
  PImGuiTypingSelectState = ^ImGuiTypingSelectState;
  PImGuiOldColumnData = ^ImGuiOldColumnData;
  PImVector_ImGuiOldColumnData = ^ImVector_ImGuiOldColumnData;
  PImGuiOldColumns = ^ImGuiOldColumns;
  PImGuiBoxSelectState = ^ImGuiBoxSelectState;
  PImGuiMultiSelectTempData = ^ImGuiMultiSelectTempData;
  PImGuiMultiSelectState = ^ImGuiMultiSelectState;
  PImVector_ImGuiWindowPtr = ^ImVector_ImGuiWindowPtr;
  PImGuiDockNode = ^ImGuiDockNode;
  PImGuiWindowDockStyle = ^ImGuiWindowDockStyle;
  PImVector_ImGuiDockRequest = ^ImVector_ImGuiDockRequest;
  PImVector_ImGuiDockNodeSettings = ^ImVector_ImGuiDockNodeSettings;
  PImGuiDockContext = ^ImGuiDockContext;
  PImGuiViewportP = ^ImGuiViewportP;
  PPImGuiViewportP = ^PImGuiViewportP;
  PImGuiWindowSettings = ^ImGuiWindowSettings;
  PImGuiSettingsHandler = ^ImGuiSettingsHandler;
  PImGuiLocEntry = ^ImGuiLocEntry;
  PImGuiDebugAllocEntry = ^ImGuiDebugAllocEntry;
  PImGuiDebugAllocInfo = ^ImGuiDebugAllocInfo;
  PImGuiMetricsConfig = ^ImGuiMetricsConfig;
  PImGuiStackLevelInfo = ^ImGuiStackLevelInfo;
  PImVector_ImGuiStackLevelInfo = ^ImVector_ImGuiStackLevelInfo;
  PImGuiIDStackTool = ^ImGuiIDStackTool;
  PImGuiContextHook = ^ImGuiContextHook;
  PImVector_ImGuiInputEvent = ^ImVector_ImGuiInputEvent;
  PImVector_ImGuiWindowStackData = ^ImVector_ImGuiWindowStackData;
  PImVector_ImGuiColorMod = ^ImVector_ImGuiColorMod;
  PImVector_ImGuiStyleMod = ^ImVector_ImGuiStyleMod;
  PImVector_ImGuiFocusScopeData = ^ImVector_ImGuiFocusScopeData;
  PImVector_ImGuiItemFlags = ^ImVector_ImGuiItemFlags;
  PImVector_ImGuiGroupData = ^ImVector_ImGuiGroupData;
  PImVector_ImGuiPopupData = ^ImVector_ImGuiPopupData;
  PImVector_ImGuiTreeNodeStackData = ^ImVector_ImGuiTreeNodeStackData;
  PImVector_ImGuiViewportPPtr = ^ImVector_ImGuiViewportPPtr;
  PImVector_unsigned_char = ^ImVector_unsigned_char;
  PImVector_ImGuiListClipperData = ^ImVector_ImGuiListClipperData;
  PImVector_ImGuiTableTempData = ^ImVector_ImGuiTableTempData;
  PImVector_ImGuiTable = ^ImVector_ImGuiTable;
  PImPool_ImGuiTable = ^ImPool_ImGuiTable;
  PImVector_ImGuiTabBar = ^ImVector_ImGuiTabBar;
  PImPool_ImGuiTabBar = ^ImPool_ImGuiTabBar;
  PImVector_ImGuiPtrOrIndex = ^ImVector_ImGuiPtrOrIndex;
  PImVector_ImGuiShrinkWidthItem = ^ImVector_ImGuiShrinkWidthItem;
  PImVector_ImGuiMultiSelectTempData = ^ImVector_ImGuiMultiSelectTempData;
  PImVector_ImGuiMultiSelectState = ^ImVector_ImGuiMultiSelectState;
  PImPool_ImGuiMultiSelectState = ^ImPool_ImGuiMultiSelectState;
  PImVector_ImGuiID = ^ImVector_ImGuiID;
  PImVector_ImGuiSettingsHandler = ^ImVector_ImGuiSettingsHandler;
  PImChunkStream_ImGuiWindowSettings = ^ImChunkStream_ImGuiWindowSettings;
  PImChunkStream_ImGuiTableSettings = ^ImChunkStream_ImGuiTableSettings;
  PImVector_ImGuiContextHook = ^ImVector_ImGuiContextHook;
  PImGuiContext = ^ImGuiContext;
  PImGuiWindowTempData = ^ImGuiWindowTempData;
  PImVector_ImGuiOldColumns = ^ImVector_ImGuiOldColumns;
  PImGuiWindow = ^ImGuiWindow;
  PPImGuiWindow = ^PImGuiWindow;
  PImGuiTabItem = ^ImGuiTabItem;
  PImVector_ImGuiTabItem = ^ImVector_ImGuiTabItem;
  PImGuiTabBar = ^ImGuiTabBar;
  PImGuiTableColumn = ^ImGuiTableColumn;
  PImGuiTableCellData = ^ImGuiTableCellData;
  PImGuiTableHeaderData = ^ImGuiTableHeaderData;
  PImGuiTableInstanceData = ^ImGuiTableInstanceData;
  PImSpan_ImGuiTableColumn = ^ImSpan_ImGuiTableColumn;
  PImSpan_ImGuiTableColumnIdx = ^ImSpan_ImGuiTableColumnIdx;
  PImSpan_ImGuiTableCellData = ^ImSpan_ImGuiTableCellData;
  PImVector_ImGuiTableInstanceData = ^ImVector_ImGuiTableInstanceData;
  PImVector_ImGuiTableColumnSortSpecs = ^ImVector_ImGuiTableColumnSortSpecs;
  PImGuiTable = ^ImGuiTable;
  PImVector_ImGuiTableHeaderData = ^ImVector_ImGuiTableHeaderData;
  PImGuiTableTempData = ^ImGuiTableTempData;
  PImGuiTableColumnSettings = ^ImGuiTableColumnSettings;
  PImGuiTableSettings = ^ImGuiTableSettings;
  PImFontBuilderIO = ^ImFontBuilderIO;

  Plua_State = Pointer;
  PPlua_State = ^Plua_State;

  lua_CFunction = function(L: Plua_State): Integer; cdecl;
  lua_Reader = function(L: Plua_State; ud: Pointer; sz: PNativeUInt): PUTF8Char; cdecl;
  lua_Writer = function(L: Plua_State; const p: Pointer; sz: NativeUInt; ud: Pointer): Integer; cdecl;
  lua_Alloc = function(ud: Pointer; ptr: Pointer; osize: NativeUInt; nsize: NativeUInt): Pointer; cdecl;
  lua_Number = Double;
  Plua_Number = ^lua_Number;
  lua_Integer = NativeInt;

  lua_Hook = procedure(L: Plua_State; ar: Plua_Debug); cdecl;

  lua_Debug = record
    event: Integer;
    name: PUTF8Char;
    namewhat: PUTF8Char;
    what: PUTF8Char;
    source: PUTF8Char;
    currentline: Integer;
    nups: Integer;
    linedefined: Integer;
    lastlinedefined: Integer;
    short_src: array [0..59] of UTF8Char;
    i_ci: Integer;
  end;

  luaL_Reg = record
    name: PUTF8Char;
    func: lua_CFunction;
  end;

  luaL_Buffer = record
    p: PUTF8Char;
    lvl: Integer;
    L: Plua_State;
    buffer: array [0..511] of UTF8Char;
  end;

  luaJIT_profile_callback = procedure(data: Pointer; L: Plua_State; samples: Integer; vmstate: Integer); cdecl;

  spFloatArray = record
    size: Integer;
    capacity: Integer;
    items: PSingle;
  end;

  spIntArray = record
    size: Integer;
    capacity: Integer;
    items: PInteger;
  end;

  spShortArray = record
    size: Integer;
    capacity: Integer;
    items: PSmallint;
  end;

  spUnsignedShortArray = record
    size: Integer;
    capacity: Integer;
    items: PWord;
  end;

  spArrayFloatArray = record
    size: Integer;
    capacity: Integer;
    items: PPspFloatArray;
  end;

  spArrayShortArray = record
    size: Integer;
    capacity: Integer;
    items: PPspShortArray;
  end;

  spEventData = record
    name: PUTF8Char;
    intValue: Integer;
    floatValue: Single;
    stringValue: PUTF8Char;
    audioPath: PUTF8Char;
    volume: Single;
    balance: Single;
  end;

  spEvent = record
    data: PspEventData;
    time: Single;
    intValue: Integer;
    floatValue: Single;
    stringValue: PUTF8Char;
    volume: Single;
    balance: Single;
  end;

  spAttachment = record
    name: PUTF8Char;
    &type: spAttachmentType;
    vtable: Pointer;
    refCount: Integer;
    attachmentLoader: PspAttachmentLoader;
  end;

  spColor = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  spBoneData = record
    index: Integer;
    name: PUTF8Char;
    parent: PspBoneData;
    length: Single;
    x: Single;
    y: Single;
    rotation: Single;
    scaleX: Single;
    scaleY: Single;
    shearX: Single;
    shearY: Single;
    inherit: spInherit;
    skinRequired: Integer;
    color: spColor;
    icon: PUTF8Char;
    visible: Integer;
  end;

  spBone = record
    data: PspBoneData;
    skeleton: PspSkeleton;
    parent: PspBone;
    childrenCount: Integer;
    children: PPspBone;
    x: Single;
    y: Single;
    rotation: Single;
    scaleX: Single;
    scaleY: Single;
    shearX: Single;
    shearY: Single;
    ax: Single;
    ay: Single;
    arotation: Single;
    ascaleX: Single;
    ascaleY: Single;
    ashearX: Single;
    ashearY: Single;
    a: Single;
    b: Single;
    worldX: Single;
    c: Single;
    d: Single;
    worldY: Single;
    sorted: Integer;
    active: Integer;
    inherit: spInherit;
  end;

  spSlotData = record
    index: Integer;
    name: PUTF8Char;
    boneData: PspBoneData;
    attachmentName: PUTF8Char;
    color: spColor;
    darkColor: PspColor;
    blendMode: spBlendMode;
    visible: Integer;
  end;

  spSlot = record
    data: PspSlotData;
    bone: PspBone;
    color: spColor;
    darkColor: PspColor;
    attachment: PspAttachment;
    attachmentState: Integer;
    deformCapacity: Integer;
    deformCount: Integer;
    deform: PSingle;
    sequenceIndex: Integer;
  end;

  spVertexAttachment = record
    super: spAttachment;
    bonesCount: Integer;
    bones: PInteger;
    verticesCount: Integer;
    vertices: PSingle;
    worldVerticesLength: Integer;
    timelineAttachment: PspAttachment;
    id: Integer;
  end;

  spTextureRegion = record
    rendererObject: Pointer;
    u: Single;
    v: Single;
    u2: Single;
    v2: Single;
    degrees: Integer;
    offsetX: Single;
    offsetY: Single;
    width: Integer;
    height: Integer;
    originalWidth: Integer;
    originalHeight: Integer;
  end;

  spAtlasPage = record
    atlas: PspAtlas;
    name: PUTF8Char;
    format: spAtlasFormat;
    minFilter: spAtlasFilter;
    magFilter: spAtlasFilter;
    uWrap: spAtlasWrap;
    vWrap: spAtlasWrap;
    rendererObject: Pointer;
    width: Integer;
    height: Integer;
    pma: Integer;
    next: PspAtlasPage;
  end;

  spKeyValue = record
    name: PUTF8Char;
    values: array [0..4] of Single;
  end;

  spKeyValueArray = record
    size: Integer;
    capacity: Integer;
    items: PspKeyValue;
  end;

  spAtlasRegion = record
    super: spTextureRegion;
    name: PUTF8Char;
    x: Integer;
    y: Integer;
    index: Integer;
    splits: PInteger;
    pads: PInteger;
    keyValues: PspKeyValueArray;
    page: PspAtlasPage;
    next: PspAtlasRegion;
  end;

  spAtlas = record
    pages: PspAtlasPage;
    regions: PspAtlasRegion;
    rendererObject: Pointer;
  end;

  spTextureRegionArray = record
    size: Integer;
    capacity: Integer;
    items: PPspTextureRegion;
  end;

  spSequence = record
    id: Integer;
    start: Integer;
    digits: Integer;
    setupIndex: Integer;
    regions: PspTextureRegionArray;
  end;

  spPropertyId = UInt64;
  PspPropertyId = ^spPropertyId;

  spPropertyIdArray = record
    size: Integer;
    capacity: Integer;
    items: PspPropertyId;
  end;

  spTimelineArray = record
    size: Integer;
    capacity: Integer;
    items: PPspTimeline;
  end;

  spAnimation = record
    name: PUTF8Char;
    duration: Single;
    timelines: PspTimelineArray;
    timelineIds: PspPropertyIdArray;
  end;

  _spTimelineVtable = record
    apply: procedure(self: PspTimeline; skeleton: PspSkeleton; lastTime: Single; time: Single; firedEvents: PPspEvent; eventsCount: PInteger; alpha: Single; blend: spMixBlend; direction: spMixDirection); cdecl;
    dispose: procedure(self: PspTimeline); cdecl;
    setBezier: procedure(self: PspTimeline; bezier: Integer; frame: Integer; value: Single; time1: Single; value1: Single; cx1: Single; cy1: Single; cx2: Single; cy2: Single; time2: Single; value2: Single); cdecl;
  end;

  spTimeline = record
    vtable: _spTimelineVtable;
    propertyIds: array [0..2] of spPropertyId;
    propertyIdsCount: Integer;
    frames: PspFloatArray;
    frameCount: Integer;
    frameEntries: Integer;
    &type: spTimelineType;
  end;

  spCurveTimeline = record
    super: spTimeline;
    curves: PspFloatArray;
  end;

  spCurveTimeline1 = spCurveTimeline;
  PspCurveTimeline1 = ^spCurveTimeline1;
  spCurveTimeline2 = spCurveTimeline;

  spRotateTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spTranslateTimeline = record
    super: spCurveTimeline2;
    boneIndex: Integer;
  end;

  spTranslateXTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spTranslateYTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spScaleTimeline = record
    super: spCurveTimeline2;
    boneIndex: Integer;
  end;

  spScaleXTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spScaleYTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spShearTimeline = record
    super: spCurveTimeline2;
    boneIndex: Integer;
  end;

  spShearXTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spShearYTimeline = record
    super: spCurveTimeline1;
    boneIndex: Integer;
  end;

  spRGBATimeline = record
    super: spCurveTimeline2;
    slotIndex: Integer;
  end;

  spRGBTimeline = record
    super: spCurveTimeline2;
    slotIndex: Integer;
  end;

  spAlphaTimeline = record
    super: spCurveTimeline1;
    slotIndex: Integer;
  end;

  spRGBA2Timeline = record
    super: spCurveTimeline;
    slotIndex: Integer;
  end;

  spRGB2Timeline = record
    super: spCurveTimeline;
    slotIndex: Integer;
  end;

  spAttachmentTimeline = record
    super: spTimeline;
    slotIndex: Integer;
    attachmentNames: PPUTF8Char;
  end;

  spDeformTimeline = record
    super: spCurveTimeline;
    frameVerticesCount: Integer;
    frameVertices: PPSingle;
    slotIndex: Integer;
    attachment: PspAttachment;
  end;

  spSequenceTimeline = record
    super: spTimeline;
    slotIndex: Integer;
    attachment: PspAttachment;
  end;

  spEventTimeline = record
    super: spTimeline;
    events: PPspEvent;
  end;

  spDrawOrderTimeline = record
    super: spTimeline;
    drawOrders: PPInteger;
    slotsCount: Integer;
  end;

  spInheritTimeline = record
    super: spTimeline;
    boneIndex: Integer;
  end;

  spIkConstraintTimeline = record
    super: spCurveTimeline;
    ikConstraintIndex: Integer;
  end;

  spTransformConstraintTimeline = record
    super: spCurveTimeline;
    transformConstraintIndex: Integer;
  end;

  spPathConstraintPositionTimeline = record
    super: spCurveTimeline;
    pathConstraintIndex: Integer;
  end;

  spPathConstraintSpacingTimeline = record
    super: spCurveTimeline;
    pathConstraintIndex: Integer;
  end;

  spPathConstraintMixTimeline = record
    super: spCurveTimeline;
    pathConstraintIndex: Integer;
  end;

  spPhysicsConstraintTimeline = record
    super: spCurveTimeline;
    physicsConstraintIndex: Integer;
  end;

  spPhysicsConstraintResetTimeline = record
    super: spTimeline;
    physicsConstraintIndex: Integer;
  end;

  spIkConstraintData = record
    name: PUTF8Char;
    order: Integer;
    skinRequired: Integer;
    bonesCount: Integer;
    bones: PPspBoneData;
    target: PspBoneData;
    bendDirection: Integer;
    compress: Integer;
    stretch: Integer;
    uniform: Integer;
    mix: Single;
    softness: Single;
  end;

  spTransformConstraintData = record
    name: PUTF8Char;
    order: Integer;
    skinRequired: Integer;
    bonesCount: Integer;
    bones: PPspBoneData;
    target: PspBoneData;
    mixRotate: Single;
    mixX: Single;
    mixY: Single;
    mixScaleX: Single;
    mixScaleY: Single;
    mixShearY: Single;
    offsetRotation: Single;
    offsetX: Single;
    offsetY: Single;
    offsetScaleX: Single;
    offsetScaleY: Single;
    offsetShearY: Single;
    relative: Integer;
    local: Integer;
  end;

  spPathConstraintData = record
    name: PUTF8Char;
    order: Integer;
    skinRequired: Integer;
    bonesCount: Integer;
    bones: PPspBoneData;
    target: PspSlotData;
    positionMode: spPositionMode;
    spacingMode: spSpacingMode;
    rotateMode: spRotateMode;
    offsetRotation: Single;
    position: Single;
    spacing: Single;
    mixRotate: Single;
    mixX: Single;
    mixY: Single;
  end;

  spPhysicsConstraintData = record
    name: PUTF8Char;
    order: Integer;
    skinRequired: Integer;
    bone: PspBoneData;
    x: Single;
    y: Single;
    rotate: Single;
    scaleX: Single;
    shearX: Single;
    limit: Single;
    step: Single;
    inertia: Single;
    strength: Single;
    damping: Single;
    massInverse: Single;
    wind: Single;
    gravity: Single;
    mix: Single;
    inertiaGlobal: Integer;
    strengthGlobal: Integer;
    dampingGlobal: Integer;
    massGlobal: Integer;
    windGlobal: Integer;
    gravityGlobal: Integer;
    mixGlobal: Integer;
  end;

  spBoneDataArray = record
    size: Integer;
    capacity: Integer;
    items: PPspBoneData;
  end;

  spIkConstraintDataArray = record
    size: Integer;
    capacity: Integer;
    items: PPspIkConstraintData;
  end;

  spTransformConstraintDataArray = record
    size: Integer;
    capacity: Integer;
    items: PPspTransformConstraintData;
  end;

  spPathConstraintDataArray = record
    size: Integer;
    capacity: Integer;
    items: PPspPathConstraintData;
  end;

  spPhysicsConstraintDataArray = record
    size: Integer;
    capacity: Integer;
    items: PPspPhysicsConstraintData;
  end;

  spSkin = record
    name: PUTF8Char;
    bones: PspBoneDataArray;
    ikConstraints: PspIkConstraintDataArray;
    transformConstraints: PspTransformConstraintDataArray;
    pathConstraints: PspPathConstraintDataArray;
    physicsConstraints: PspPhysicsConstraintDataArray;
    color: spColor;
  end;

  _Entry = record
    slotIndex: Integer;
    name: PUTF8Char;
    attachment: PspAttachment;
    next: P_Entry;
  end;

  spSkinEntry = _Entry;
  PspSkinEntry = ^spSkinEntry;

  _SkinHashTableEntry = record
    entry: P_Entry;
    next: P_SkinHashTableEntry;
  end;

  _spSkin = record
    super: spSkin;
    entries: P_Entry;
    entriesHashTable: array [0..99] of P_SkinHashTableEntry;
  end;

  spSkeletonData = record
    version: PUTF8Char;
    hash: PUTF8Char;
    x: Single;
    y: Single;
    width: Single;
    height: Single;
    referenceScale: Single;
    fps: Single;
    imagesPath: PUTF8Char;
    audioPath: PUTF8Char;
    stringsCount: Integer;
    strings: PPUTF8Char;
    bonesCount: Integer;
    bones: PPspBoneData;
    slotsCount: Integer;
    slots: PPspSlotData;
    skinsCount: Integer;
    skins: PPspSkin;
    defaultSkin: PspSkin;
    eventsCount: Integer;
    events: PPspEventData;
    animationsCount: Integer;
    animations: PPspAnimation;
    ikConstraintsCount: Integer;
    ikConstraints: PPspIkConstraintData;
    transformConstraintsCount: Integer;
    transformConstraints: PPspTransformConstraintData;
    pathConstraintsCount: Integer;
    pathConstraints: PPspPathConstraintData;
    physicsConstraintsCount: Integer;
    physicsConstraints: PPspPhysicsConstraintData;
  end;

  spAnimationStateData = record
    skeletonData: PspSkeletonData;
    defaultMix: Single;
    entries: Pointer;
  end;

  spAnimationStateListener = procedure(state: PspAnimationState; &type: spEventType; entry: PspTrackEntry; event: PspEvent); cdecl;

  spTrackEntryArray = record
    size: Integer;
    capacity: Integer;
    items: PPspTrackEntry;
  end;

  spTrackEntry = record
    animation: PspAnimation;
    previous: PspTrackEntry;
    next: PspTrackEntry;
    mixingFrom: PspTrackEntry;
    mixingTo: PspTrackEntry;
    listener: spAnimationStateListener;
    trackIndex: Integer;
    loop: Integer;
    holdPrevious: Integer;
    reverse: Integer;
    shortestRotation: Integer;
    eventThreshold: Single;
    mixAttachmentThreshold: Single;
    alphaAttachmentThreshold: Single;
    mixDrawOrderThreshold: Single;
    animationStart: Single;
    animationEnd: Single;
    animationLast: Single;
    nextAnimationLast: Single;
    delay: Single;
    trackTime: Single;
    trackLast: Single;
    nextTrackLast: Single;
    trackEnd: Single;
    timeScale: Single;
    alpha: Single;
    mixTime: Single;
    mixDuration: Single;
    interruptAlpha: Single;
    totalAlpha: Single;
    mixBlend: spMixBlend;
    timelineMode: PspIntArray;
    timelineHoldMix: PspTrackEntryArray;
    timelinesRotation: PSingle;
    timelinesRotationCount: Integer;
    rendererObject: Pointer;
    userData: Pointer;
  end;

  spAnimationState = record
    data: PspAnimationStateData;
    tracksCount: Integer;
    tracks: PPspTrackEntry;
    listener: spAnimationStateListener;
    timeScale: Single;
    rendererObject: Pointer;
    userData: Pointer;
    unkeyedState: Integer;
  end;

  spAttachmentLoader = record
    error1: PUTF8Char;
    error2: PUTF8Char;
    vtable: Pointer;
  end;

  spAtlasAttachmentLoader = record
    super: spAttachmentLoader;
    atlas: PspAtlas;
  end;

  spRegionAttachment = record
    super: spAttachment;
    path: PUTF8Char;
    x: Single;
    y: Single;
    scaleX: Single;
    scaleY: Single;
    rotation: Single;
    width: Single;
    height: Single;
    color: spColor;
    rendererObject: Pointer;
    region: PspTextureRegion;
    sequence: PspSequence;
    offset: array [0..7] of Single;
    uvs: array [0..7] of Single;
  end;

  spMeshAttachment = record
    super: spVertexAttachment;
    rendererObject: Pointer;
    region: PspTextureRegion;
    sequence: PspSequence;
    path: PUTF8Char;
    regionUVs: PSingle;
    uvs: PSingle;
    trianglesCount: Integer;
    triangles: PWord;
    color: spColor;
    hullLength: Integer;
    parentMesh: PspMeshAttachment;
    edgesCount: Integer;
    edges: PWord;
    width: Single;
    height: Single;
  end;

  spBoundingBoxAttachment = record
    super: spVertexAttachment;
    color: spColor;
  end;

  spClippingAttachment = record
    super: spVertexAttachment;
    endSlot: PspSlotData;
    color: spColor;
  end;

  spPointAttachment = record
    super: spAttachment;
    x: Single;
    y: Single;
    rotation: Single;
    color: spColor;
  end;

  spIkConstraint = record
    data: PspIkConstraintData;
    bonesCount: Integer;
    bones: PPspBone;
    target: PspBone;
    bendDirection: Integer;
    compress: Integer;
    stretch: Integer;
    mix: Single;
    softness: Single;
    active: Integer;
  end;

  spTransformConstraint = record
    data: PspTransformConstraintData;
    bonesCount: Integer;
    bones: PPspBone;
    target: PspBone;
    mixRotate: Single;
    mixX: Single;
    mixY: Single;
    mixScaleX: Single;
    mixScaleY: Single;
    mixShearY: Single;
    active: Integer;
  end;

  spPathAttachment = record
    super: spVertexAttachment;
    lengthsLength: Integer;
    lengths: PSingle;
    closed: Integer;
    constantSpeed: Integer;
    color: spColor;
  end;

  spPathConstraint = record
    data: PspPathConstraintData;
    bonesCount: Integer;
    bones: PPspBone;
    target: PspSlot;
    position: Single;
    spacing: Single;
    mixRotate: Single;
    mixX: Single;
    mixY: Single;
    spacesCount: Integer;
    spaces: PSingle;
    positionsCount: Integer;
    positions: PSingle;
    worldCount: Integer;
    world: PSingle;
    curvesCount: Integer;
    curves: PSingle;
    lengthsCount: Integer;
    lengths: PSingle;
    segments: array [0..9] of Single;
    active: Integer;
  end;

  spPhysicsConstraint = record
    data: PspPhysicsConstraintData;
    bone: PspBone;
    inertia: Single;
    strength: Single;
    damping: Single;
    massInverse: Single;
    wind: Single;
    gravity: Single;
    mix: Single;
    reset: Integer;
    ux: Single;
    uy: Single;
    cx: Single;
    cy: Single;
    tx: Single;
    ty: Single;
    xOffset: Single;
    xVelocity: Single;
    yOffset: Single;
    yVelocity: Single;
    rotateOffset: Single;
    rotateVelocity: Single;
    scaleOffset: Single;
    scaleVelocity: Single;
    active: Integer;
    skeleton: PspSkeleton;
    remaining: Single;
    lastTime: Single;
  end;

  spSkeleton = record
    data: PspSkeletonData;
    bonesCount: Integer;
    bones: PPspBone;
    root: PspBone;
    slotsCount: Integer;
    slots: PPspSlot;
    drawOrder: PPspSlot;
    ikConstraintsCount: Integer;
    ikConstraints: PPspIkConstraint;
    transformConstraintsCount: Integer;
    transformConstraints: PPspTransformConstraint;
    pathConstraintsCount: Integer;
    pathConstraints: PPspPathConstraint;
    physicsConstraintsCount: Integer;
    physicsConstraints: PPspPhysicsConstraint;
    skin: PspSkin;
    color: spColor;
    scaleX: Single;
    scaleY: Single;
    x: Single;
    y: Single;
    time: Single;
  end;

  spPolygon = record
    vertices: PSingle;
    count: Integer;
    capacity: Integer;
  end;

  spSkeletonBounds = record
    count: Integer;
    boundingBoxes: PPspBoundingBoxAttachment;
    polygons: PPspPolygon;
    minX: Single;
    minY: Single;
    maxX: Single;
    maxY: Single;
  end;

  spSkeletonBinary = record
    scale: Single;
    attachmentLoader: PspAttachmentLoader;
    error: PUTF8Char;
  end;

  spSkeletonJson = record
    scale: Single;
    attachmentLoader: PspAttachmentLoader;
    error: PUTF8Char;
  end;

  spTriangulator = record
    convexPolygons: PspArrayFloatArray;
    convexPolygonsIndices: PspArrayShortArray;
    indicesArray: PspShortArray;
    isConcaveArray: PspIntArray;
    triangles: PspShortArray;
    polygonPool: PspArrayFloatArray;
    polygonIndicesPool: PspArrayShortArray;
  end;

  spSkeletonClipping = record
    triangulator: PspTriangulator;
    clippingPolygon: PspFloatArray;
    clipOutput: PspFloatArray;
    clippedVertices: PspFloatArray;
    clippedUVs: PspFloatArray;
    clippedTriangles: PspUnsignedShortArray;
    scratch: PspFloatArray;
    clipAttachment: PspClippingAttachment;
    clippingPolygons: PspArrayFloatArray;
  end;

  GLFWglproc = procedure(); cdecl;
  GLFWvkproc = procedure(); cdecl;
  PGLFWmonitor = Pointer;
  PPGLFWmonitor = ^PGLFWmonitor;
  PGLFWwindow = Pointer;
  PPGLFWwindow = ^PGLFWwindow;
  PGLFWcursor = Pointer;
  PPGLFWcursor = ^PGLFWcursor;

  GLFWallocatefun = function(size: NativeUInt; user: Pointer): Pointer; cdecl;
  GLFWreallocatefun = function(block: Pointer; size: NativeUInt; user: Pointer): Pointer; cdecl;
  GLFWdeallocatefun = procedure(block: Pointer; user: Pointer); cdecl;
  GLFWerrorfun = procedure(error_code: Integer; const description: PUTF8Char); cdecl;
  GLFWwindowposfun = procedure(window: PGLFWwindow; xpos: Integer; ypos: Integer); cdecl;
  GLFWwindowsizefun = procedure(window: PGLFWwindow; width: Integer; height: Integer); cdecl;
  GLFWwindowclosefun = procedure(window: PGLFWwindow); cdecl;
  GLFWwindowrefreshfun = procedure(window: PGLFWwindow); cdecl;
  GLFWwindowfocusfun = procedure(window: PGLFWwindow; focused: Integer); cdecl;
  GLFWwindowiconifyfun = procedure(window: PGLFWwindow; iconified: Integer); cdecl;
  GLFWwindowmaximizefun = procedure(window: PGLFWwindow; maximized: Integer); cdecl;
  GLFWframebuffersizefun = procedure(window: PGLFWwindow; width: Integer; height: Integer); cdecl;
  GLFWwindowcontentscalefun = procedure(window: PGLFWwindow; xscale: Single; yscale: Single); cdecl;
  GLFWmousebuttonfun = procedure(window: PGLFWwindow; button: Integer; action: Integer; mods: Integer); cdecl;
  GLFWcursorposfun = procedure(window: PGLFWwindow; xpos: Double; ypos: Double); cdecl;
  GLFWcursorenterfun = procedure(window: PGLFWwindow; entered: Integer); cdecl;
  GLFWscrollfun = procedure(window: PGLFWwindow; xoffset: Double; yoffset: Double); cdecl;
  GLFWkeyfun = procedure(window: PGLFWwindow; key: Integer; scancode: Integer; action: Integer; mods: Integer); cdecl;
  GLFWcharfun = procedure(window: PGLFWwindow; codepoint: Cardinal); cdecl;
  GLFWcharmodsfun = procedure(window: PGLFWwindow; codepoint: Cardinal; mods: Integer); cdecl;
  GLFWdropfun = procedure(window: PGLFWwindow; path_count: Integer; paths: PPUTF8Char); cdecl;
  GLFWmonitorfun = procedure(monitor: PGLFWmonitor; event: Integer); cdecl;
  GLFWjoystickfun = procedure(jid: Integer; event: Integer); cdecl;

  GLFWvidmode = record
    width: Integer;
    height: Integer;
    redBits: Integer;
    greenBits: Integer;
    blueBits: Integer;
    refreshRate: Integer;
  end;

  GLFWgammaramp = record
    red: PWord;
    green: PWord;
    blue: PWord;
    size: Cardinal;
  end;

  GLFWimage = record
    width: Integer;
    height: Integer;
    pixels: PByte;
  end;

  GLFWgamepadstate = record
    buttons: array [0..14] of Byte;
    axes: array [0..5] of Single;
  end;

  GLFWallocator = record
    allocate: GLFWallocatefun;
    reallocate: GLFWreallocatefun;
    deallocate: GLFWdeallocatefun;
    user: Pointer;
  end;

  spGlfwVertexArray = record
    size: Integer;
    capacity: Integer;
    items: PSingle;
  end;

  spSkeletonDrawable = record
    skeleton: PspSkeleton;
    animationState: PspAnimationState;
    usePremultipliedAlpha: Integer;
    clipper: PspSkeletonClipping;
    worldVertices: PspFloatArray;
    vertices: PspGlfwVertexArray;
    indices: PspIntArray;
  end;

  spAtlasPage_createTexture_cb = function(const path: PUTF8Char; userData: Pointer): GLuint; cdecl;
  spAtlasPage_disposeTexture_cb = procedure(texture: GLuint; userData: Pointer); cdecl;
  stbi_uc = Byte;
  Pstbi_uc = ^stbi_uc;
  stbi_us = Word;
  Pstbi_us = ^stbi_us;

  stbi_io_callbacks = record
    read: function(user: Pointer; data: PUTF8Char; size: Integer): Integer; cdecl;
    skip: procedure(user: Pointer; n: Integer); cdecl;
    eof: function(user: Pointer): Integer; cdecl;
  end;

  Pstbi_write_func = procedure(context: Pointer; data: Pointer; size: Integer); cdecl;
  stbrp_coord = Integer;

  stbrp_rect = record
    id: Integer;
    w: stbrp_coord;
    h: stbrp_coord;
    x: stbrp_coord;
    y: stbrp_coord;
    was_packed: Integer;
  end;

  stbrp_node = record
    x: stbrp_coord;
    y: stbrp_coord;
    next: Pstbrp_node;
  end;

  stbrp_context = record
    width: Integer;
    height: Integer;
    align: Integer;
    init_mode: Integer;
    heuristic: Integer;
    num_nodes: Integer;
    active_head: Pstbrp_node;
    free_head: Pstbrp_node;
    extra: array [0..1] of stbrp_node;
  end;

  stbtt__buf = record
    data: PByte;
    cursor: Integer;
    size: Integer;
  end;

  stbtt_bakedchar = record
    x0: Word;
    y0: Word;
    x1: Word;
    y1: Word;
    xoff: Single;
    yoff: Single;
    xadvance: Single;
  end;

  stbtt_aligned_quad = record
    x0: Single;
    y0: Single;
    s0: Single;
    t0: Single;
    x1: Single;
    y1: Single;
    s1: Single;
    t1: Single;
  end;

  stbtt_packedchar = record
    x0: Word;
    y0: Word;
    x1: Word;
    y1: Word;
    xoff: Single;
    yoff: Single;
    xadvance: Single;
    xoff2: Single;
    yoff2: Single;
  end;

  stbtt_pack_range = record
    font_size: Single;
    first_unicode_codepoint_in_range: Integer;
    array_of_unicode_codepoints: PInteger;
    num_chars: Integer;
    chardata_for_range: Pstbtt_packedchar;
    h_oversample: Byte;
    v_oversample: Byte;
  end;

  stbtt_pack_context = record
    user_allocator_context: Pointer;
    pack_info: Pointer;
    width: Integer;
    height: Integer;
    stride_in_bytes: Integer;
    padding: Integer;
    skip_missing: Integer;
    h_oversample: Cardinal;
    v_oversample: Cardinal;
    pixels: PByte;
    nodes: Pointer;
  end;

  stbtt_fontinfo = record
    userdata: Pointer;
    data: PByte;
    fontstart: Integer;
    numGlyphs: Integer;
    loca: Integer;
    head: Integer;
    glyf: Integer;
    hhea: Integer;
    hmtx: Integer;
    kern: Integer;
    gpos: Integer;
    svg: Integer;
    index_map: Integer;
    indexToLocFormat: Integer;
    cff: stbtt__buf;
    charstrings: stbtt__buf;
    gsubrs: stbtt__buf;
    subrs: stbtt__buf;
    fontdicts: stbtt__buf;
    fdselect: stbtt__buf;
  end;

  stbtt_kerningentry = record
    glyph1: Integer;
    glyph2: Integer;
    advance: Integer;
  end;

  stbtt_vertex = record
    x: Smallint;
    y: Smallint;
    cx: Smallint;
    cy: Smallint;
    cx1: Smallint;
    cy1: Smallint;
    &type: Byte;
    padding: Byte;
  end;

  stbtt__bitmap = record
    w: Integer;
    h: Integer;
    stride: Integer;
    pixels: PByte;
  end;

  c2v = record
    x: Single;
    y: Single;
  end;

  c2r = record
    c: Single;
    s: Single;
  end;

  c2m = record
    x: c2v;
    y: c2v;
  end;

  c2x = record
    p: c2v;
    r: c2r;
  end;

  c2h = record
    n: c2v;
    d: Single;
  end;

  c2Circle = record
    p: c2v;
    r: Single;
  end;

  c2AABB = record
    min: c2v;
    max: c2v;
  end;

  c2Capsule = record
    a: c2v;
    b: c2v;
    r: Single;
  end;

  c2Poly = record
    count: Integer;
    verts: array [0..7] of c2v;
    norms: array [0..7] of c2v;
  end;

  c2Ray = record
    p: c2v;
    d: c2v;
    t: Single;
  end;

  c2Raycast = record
    t: Single;
    n: c2v;
  end;

  c2Manifold = record
    count: Integer;
    depths: array [0..1] of Single;
    contact_points: array [0..1] of c2v;
    n: c2v;
  end;

  c2GJKCache = record
    metric: Single;
    count: Integer;
    iA: array [0..2] of Integer;
    iB: array [0..2] of Integer;
    &div: Single;
  end;

  c2TOIResult = record
    hit: Integer;
    toi: Single;
    n: c2v;
    p: c2v;
    iterations: Integer;
  end;

  Pplm_t = Pointer;
  PPplm_t = ^Pplm_t;
  Pplm_buffer_t = Pointer;
  PPplm_buffer_t = ^Pplm_buffer_t;
  Pplm_demux_t = Pointer;
  PPplm_demux_t = ^Pplm_demux_t;
  Pplm_video_t = Pointer;
  PPplm_video_t = ^Pplm_video_t;
  Pplm_audio_t = Pointer;
  PPplm_audio_t = ^Pplm_audio_t;

  plm_packet_t = record
    &type: Integer;
    pts: Double;
    length: NativeUInt;
    data: PUInt8;
  end;

  plm_plane_t = record
    width: Cardinal;
    height: Cardinal;
    data: PUInt8;
  end;

  plm_frame_t = record
    time: Double;
    width: Cardinal;
    height: Cardinal;
    y: plm_plane_t;
    cr: plm_plane_t;
    cb: plm_plane_t;
  end;

  plm_video_decode_callback = procedure(self: Pplm_t; frame: Pplm_frame_t; user: Pointer); cdecl;

  plm_samples_t = record
    time: Double;
    count: Cardinal;
    interleaved: array [0..2303] of Single;
  end;

  plm_audio_decode_callback = procedure(self: Pplm_t; samples: Pplm_samples_t; user: Pointer); cdecl;
  plm_buffer_load_callback = procedure(self: Pplm_buffer_t; user: Pointer); cdecl;
  plm_buffer_seek_callback = procedure(self: Pplm_buffer_t; offset: NativeUInt; user: Pointer); cdecl;
  plm_buffer_tell_callback = function(self: Pplm_buffer_t; user: Pointer): NativeUInt; cdecl;
  ma_int8 = UTF8Char;
  ma_uint8 = Byte;
  Pma_uint8 = ^ma_uint8;
  ma_int16 = Smallint;
  Pma_int16 = ^ma_int16;
  ma_uint16 = Word;
  ma_int32 = Integer;
  Pma_int32 = ^ma_int32;
  PPma_int32 = ^Pma_int32;
  ma_uint32 = Cardinal;
  Pma_uint32 = ^ma_uint32;
  ma_int64 = Int64;
  Pma_int64 = ^ma_int64;
  ma_uint64 = UInt64;
  Pma_uint64 = ^ma_uint64;
  ma_uintptr = ma_uint64;
  ma_bool8 = ma_uint8;
  ma_bool32 = ma_uint32;
  ma_float = Single;
  ma_double = Double;
  ma_handle = Pointer;
  ma_ptr = Pointer;
  Pma_ptr = ^ma_ptr;
  ma_proc = Pointer;
  ma_wchar_win32 = WideChar;
  ma_channel = ma_uint8;
  Pma_channel = ^ma_channel;

  ma_allocation_callbacks = record
    pUserData: Pointer;
    onMalloc: function(sz: NativeUInt; pUserData: Pointer): Pointer; cdecl;
    onRealloc: function(p: Pointer; sz: NativeUInt; pUserData: Pointer): Pointer; cdecl;
    onFree: procedure(p: Pointer; pUserData: Pointer); cdecl;
  end;

  ma_lcg = record
    state: ma_int32;
  end;

  ma_atomic_uint32 = record
    value: ma_uint32;
  end;

  ma_atomic_int32 = record
    value: ma_int32;
  end;

  ma_atomic_uint64 = record
    value: ma_uint64;
  end;

  ma_atomic_float = record
    value: ma_float;
  end;

  ma_atomic_bool32 = record
    value: ma_bool32;
  end;

  ma_spinlock = ma_uint32;
  Pma_spinlock = ^ma_spinlock;
  ma_thread = ma_handle;
  ma_mutex = ma_handle;
  Pma_mutex = ^ma_mutex;
  ma_event = ma_handle;
  Pma_event = ^ma_event;
  ma_semaphore = ma_handle;

  ma_log_callback_proc = procedure(pUserData: Pointer; level: ma_uint32; const pMessage: PUTF8Char); cdecl;

  ma_log_callback = record
    onLog: ma_log_callback_proc;
    pUserData: Pointer;
  end;

  ma_log = record
    callbacks: array [0..3] of ma_log_callback;
    callbackCount: ma_uint32;
    allocationCallbacks: ma_allocation_callbacks;
    lock: ma_mutex;
  end;

  Pma_biquad_coefficient = ^ma_biquad_coefficient;
  ma_biquad_coefficient = record
    case Integer of
      0: (f32: Single);
      1: (s32: ma_int32);
  end;

  ma_biquad_config = record
    format: ma_format;
    channels: ma_uint32;
    b0: Double;
    b1: Double;
    b2: Double;
    a0: Double;
    a1: Double;
    a2: Double;
  end;

  ma_biquad = record
    format: ma_format;
    channels: ma_uint32;
    b0: ma_biquad_coefficient;
    b1: ma_biquad_coefficient;
    b2: ma_biquad_coefficient;
    a1: ma_biquad_coefficient;
    a2: ma_biquad_coefficient;
    pR1: Pma_biquad_coefficient;
    pR2: Pma_biquad_coefficient;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_lpf1_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    q: Double;
  end;

  ma_lpf2_config = ma_lpf1_config;
  Pma_lpf2_config = ^ma_lpf2_config;

  ma_lpf1 = record
    format: ma_format;
    channels: ma_uint32;
    a: ma_biquad_coefficient;
    pR1: Pma_biquad_coefficient;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_lpf2 = record
    bq: ma_biquad;
  end;

  ma_lpf_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    order: ma_uint32;
  end;

  ma_lpf = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    lpf1Count: ma_uint32;
    lpf2Count: ma_uint32;
    pLPF1: Pma_lpf1;
    pLPF2: Pma_lpf2;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_hpf1_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    q: Double;
  end;

  ma_hpf2_config = ma_hpf1_config;
  Pma_hpf2_config = ^ma_hpf2_config;

  ma_hpf1 = record
    format: ma_format;
    channels: ma_uint32;
    a: ma_biquad_coefficient;
    pR1: Pma_biquad_coefficient;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_hpf2 = record
    bq: ma_biquad;
  end;

  ma_hpf_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    order: ma_uint32;
  end;

  ma_hpf = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    hpf1Count: ma_uint32;
    hpf2Count: ma_uint32;
    pHPF1: Pma_hpf1;
    pHPF2: Pma_hpf2;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_bpf2_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    q: Double;
  end;

  ma_bpf2 = record
    bq: ma_biquad;
  end;

  ma_bpf_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cutoffFrequency: Double;
    order: ma_uint32;
  end;

  ma_bpf = record
    format: ma_format;
    channels: ma_uint32;
    bpf2Count: ma_uint32;
    pBPF2: Pma_bpf2;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_notch2_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    q: Double;
    frequency: Double;
  end;

  ma_notch_config = ma_notch2_config;
  Pma_notch_config = ^ma_notch_config;

  ma_notch2 = record
    bq: ma_biquad;
  end;

  ma_peak2_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    gainDB: Double;
    q: Double;
    frequency: Double;
  end;

  ma_peak_config = ma_peak2_config;
  Pma_peak_config = ^ma_peak_config;

  ma_peak2 = record
    bq: ma_biquad;
  end;

  ma_loshelf2_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    gainDB: Double;
    shelfSlope: Double;
    frequency: Double;
  end;

  ma_loshelf_config = ma_loshelf2_config;
  Pma_loshelf_config = ^ma_loshelf_config;

  ma_loshelf2 = record
    bq: ma_biquad;
  end;

  ma_hishelf2_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    gainDB: Double;
    shelfSlope: Double;
    frequency: Double;
  end;

  ma_hishelf_config = ma_hishelf2_config;
  Pma_hishelf_config = ^ma_hishelf_config;

  ma_hishelf2 = record
    bq: ma_biquad;
  end;

  ma_delay_config = record
    channels: ma_uint32;
    sampleRate: ma_uint32;
    delayInFrames: ma_uint32;
    delayStart: ma_bool32;
    wet: Single;
    dry: Single;
    decay: Single;
  end;

  ma_delay = record
    config: ma_delay_config;
    cursor: ma_uint32;
    bufferSizeInFrames: ma_uint32;
    pBuffer: PSingle;
  end;

  ma_gainer_config = record
    channels: ma_uint32;
    smoothTimeInFrames: ma_uint32;
  end;

  ma_gainer = record
    config: ma_gainer_config;
    t: ma_uint32;
    masterVolume: Single;
    pOldGains: PSingle;
    pNewGains: PSingle;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_panner_config = record
    format: ma_format;
    channels: ma_uint32;
    mode: ma_pan_mode;
    pan: Single;
  end;

  ma_panner = record
    format: ma_format;
    channels: ma_uint32;
    mode: ma_pan_mode;
    pan: Single;
  end;

  ma_fader_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
  end;

  ma_fader = record
    config: ma_fader_config;
    volumeBeg: Single;
    volumeEnd: Single;
    lengthInFrames: ma_uint64;
    cursorInFrames: ma_int64;
  end;

  ma_vec3f = record
    x: Single;
    y: Single;
    z: Single;
  end;

  ma_atomic_vec3f = record
    v: ma_vec3f;
    lock: ma_spinlock;
  end;

  ma_spatializer_listener_config = record
    channelsOut: ma_uint32;
    pChannelMapOut: Pma_channel;
    handedness: ma_handedness;
    coneInnerAngleInRadians: Single;
    coneOuterAngleInRadians: Single;
    coneOuterGain: Single;
    speedOfSound: Single;
    worldUp: ma_vec3f;
  end;

  ma_spatializer_listener = record
    config: ma_spatializer_listener_config;
    position: ma_atomic_vec3f;
    direction: ma_atomic_vec3f;
    velocity: ma_atomic_vec3f;
    isEnabled: ma_bool32;
    _ownsHeap: ma_bool32;
    _pHeap: Pointer;
  end;

  ma_spatializer_config = record
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    pChannelMapIn: Pma_channel;
    attenuationModel: ma_attenuation_model;
    positioning: ma_positioning;
    handedness: ma_handedness;
    minGain: Single;
    maxGain: Single;
    minDistance: Single;
    maxDistance: Single;
    rolloff: Single;
    coneInnerAngleInRadians: Single;
    coneOuterAngleInRadians: Single;
    coneOuterGain: Single;
    dopplerFactor: Single;
    directionalAttenuationFactor: Single;
    minSpatializationChannelGain: Single;
    gainSmoothTimeInFrames: ma_uint32;
  end;

  ma_spatializer = record
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    pChannelMapIn: Pma_channel;
    attenuationModel: ma_attenuation_model;
    positioning: ma_positioning;
    handedness: ma_handedness;
    minGain: Single;
    maxGain: Single;
    minDistance: Single;
    maxDistance: Single;
    rolloff: Single;
    coneInnerAngleInRadians: Single;
    coneOuterAngleInRadians: Single;
    coneOuterGain: Single;
    dopplerFactor: Single;
    directionalAttenuationFactor: Single;
    gainSmoothTimeInFrames: ma_uint32;
    position: ma_atomic_vec3f;
    direction: ma_atomic_vec3f;
    velocity: ma_atomic_vec3f;
    dopplerPitch: Single;
    minSpatializationChannelGain: Single;
    gainer: ma_gainer;
    pNewChannelGainsOut: PSingle;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_linear_resampler_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    lpfOrder: ma_uint32;
    lpfNyquistFactor: Double;
  end;

  P_anonymous_type_11 = ^_anonymous_type_11;
  _anonymous_type_11 = record
    case Integer of
      0: (f32: PSingle);
      1: (s16: Pma_int16);
  end;

  P_anonymous_type_12 = ^_anonymous_type_12;
  _anonymous_type_12 = record
    case Integer of
      0: (f32: PSingle);
      1: (s16: Pma_int16);
  end;

  ma_linear_resampler = record
    config: ma_linear_resampler_config;
    inAdvanceInt: ma_uint32;
    inAdvanceFrac: ma_uint32;
    inTimeInt: ma_uint32;
    inTimeFrac: ma_uint32;
    x0: _anonymous_type_11;
    x1: _anonymous_type_12;
    lpf: ma_lpf;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  Pma_resampling_backend = Pointer;
  PPma_resampling_backend = ^Pma_resampling_backend;

  ma_resampling_backend_vtable = record
    onGetHeapSize: function(pUserData: Pointer; const pConfig: Pma_resampler_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
    onInit: function(pUserData: Pointer; const pConfig: Pma_resampler_config; pHeap: Pointer; ppBackend: PPma_resampling_backend): ma_result; cdecl;
    onUninit: procedure(pUserData: Pointer; pBackend: Pma_resampling_backend; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
    onProcess: function(pUserData: Pointer; pBackend: Pma_resampling_backend; const pFramesIn: Pointer; pFrameCountIn: Pma_uint64; pFramesOut: Pointer; pFrameCountOut: Pma_uint64): ma_result; cdecl;
    onSetRate: function(pUserData: Pointer; pBackend: Pma_resampling_backend; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_result; cdecl;
    onGetInputLatency: function(pUserData: Pointer; const pBackend: Pma_resampling_backend): ma_uint64; cdecl;
    onGetOutputLatency: function(pUserData: Pointer; const pBackend: Pma_resampling_backend): ma_uint64; cdecl;
    onGetRequiredInputFrameCount: function(pUserData: Pointer; const pBackend: Pma_resampling_backend; outputFrameCount: ma_uint64; pInputFrameCount: Pma_uint64): ma_result; cdecl;
    onGetExpectedOutputFrameCount: function(pUserData: Pointer; const pBackend: Pma_resampling_backend; inputFrameCount: ma_uint64; pOutputFrameCount: Pma_uint64): ma_result; cdecl;
    onReset: function(pUserData: Pointer; pBackend: Pma_resampling_backend): ma_result; cdecl;
  end;

  P_anonymous_type_13 = ^_anonymous_type_13;
  _anonymous_type_13 = record
    lpfOrder: ma_uint32;
  end;

  ma_resampler_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    algorithm: ma_resample_algorithm;
    pBackendVTable: Pma_resampling_backend_vtable;
    pBackendUserData: Pointer;
    linear: _anonymous_type_13;
  end;

  P_anonymous_type_14 = ^_anonymous_type_14;
  _anonymous_type_14 = record
    case Integer of
      0: (linear: ma_linear_resampler);
  end;

  ma_resampler = record
    pBackend: Pma_resampling_backend;
    pBackendVTable: Pma_resampling_backend_vtable;
    pBackendUserData: Pointer;
    format: ma_format;
    channels: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    state: _anonymous_type_14;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_channel_converter_config = record
    format: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    pChannelMapIn: Pma_channel;
    pChannelMapOut: Pma_channel;
    mixingMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    ppWeights: PPSingle;
  end;

  P_anonymous_type_15 = ^_anonymous_type_15;
  _anonymous_type_15 = record
    case Integer of
      0: (f32: PPSingle);
      1: (s16: PPma_int32);
  end;

  ma_channel_converter = record
    format: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    mixingMode: ma_channel_mix_mode;
    conversionPath: ma_channel_conversion_path;
    pChannelMapIn: Pma_channel;
    pChannelMapOut: Pma_channel;
    pShuffleTable: Pma_uint8;
    weights: _anonymous_type_15;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_data_converter_config = record
    formatIn: ma_format;
    formatOut: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    pChannelMapIn: Pma_channel;
    pChannelMapOut: Pma_channel;
    ditherMode: ma_dither_mode;
    channelMixMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    ppChannelWeights: PPSingle;
    allowDynamicSampleRate: ma_bool32;
    resampling: ma_resampler_config;
  end;

  ma_data_converter = record
    formatIn: ma_format;
    formatOut: ma_format;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    sampleRateIn: ma_uint32;
    sampleRateOut: ma_uint32;
    ditherMode: ma_dither_mode;
    executionPath: ma_data_converter_execution_path;
    channelConverter: ma_channel_converter;
    resampler: ma_resampler;
    hasPreFormatConversion: ma_bool8;
    hasPostFormatConversion: ma_bool8;
    hasChannelConverter: ma_bool8;
    hasResampler: ma_bool8;
    isPassthrough: ma_bool8;
    _ownsHeap: ma_bool8;
    _pHeap: Pointer;
  end;

  Pma_data_source = Pointer;
  PPma_data_source = ^Pma_data_source;

  ma_data_source_vtable = record
    onRead: function(pDataSource: Pma_data_source; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
    onSeek: function(pDataSource: Pma_data_source; frameIndex: ma_uint64): ma_result; cdecl;
    onGetDataFormat: function(pDataSource: Pma_data_source; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
    onGetCursor: function(pDataSource: Pma_data_source; pCursor: Pma_uint64): ma_result; cdecl;
    onGetLength: function(pDataSource: Pma_data_source; pLength: Pma_uint64): ma_result; cdecl;
    onSetLooping: function(pDataSource: Pma_data_source; isLooping: ma_bool32): ma_result; cdecl;
    flags: ma_uint32;
  end;

  ma_data_source_get_next_proc = function(pDataSource: Pma_data_source): Pma_data_source; cdecl;

  ma_data_source_config = record
    vtable: Pma_data_source_vtable;
  end;

  ma_data_source_base = record
    vtable: Pma_data_source_vtable;
    rangeBegInFrames: ma_uint64;
    rangeEndInFrames: ma_uint64;
    loopBegInFrames: ma_uint64;
    loopEndInFrames: ma_uint64;
    pCurrent: Pma_data_source;
    pNext: Pma_data_source;
    onGetNext: ma_data_source_get_next_proc;
    isLooping: ma_bool32;
  end;

  ma_audio_buffer_ref = record
    ds: ma_data_source_base;
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    cursor: ma_uint64;
    sizeInFrames: ma_uint64;
    pData: Pointer;
  end;

  ma_audio_buffer_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    sizeInFrames: ma_uint64;
    pData: Pointer;
    allocationCallbacks: ma_allocation_callbacks;
  end;

  ma_audio_buffer = record
    ref: ma_audio_buffer_ref;
    allocationCallbacks: ma_allocation_callbacks;
    ownsData: ma_bool32;
    _pExtraData: array [0..0] of ma_uint8;
  end;

  ma_paged_audio_buffer_page = record
    pNext: Pma_paged_audio_buffer_page;
    sizeInFrames: ma_uint64;
    pAudioData: array [0..0] of ma_uint8;
  end;

  ma_paged_audio_buffer_data = record
    format: ma_format;
    channels: ma_uint32;
    head: ma_paged_audio_buffer_page;
    pTail: Pma_paged_audio_buffer_page;
  end;

  ma_paged_audio_buffer_config = record
    pData: Pma_paged_audio_buffer_data;
  end;

  ma_paged_audio_buffer = record
    ds: ma_data_source_base;
    pData: Pma_paged_audio_buffer_data;
    pCurrent: Pma_paged_audio_buffer_page;
    relativeCursor: ma_uint64;
    absoluteCursor: ma_uint64;
  end;

  ma_rb = record
    pBuffer: Pointer;
    subbufferSizeInBytes: ma_uint32;
    subbufferCount: ma_uint32;
    subbufferStrideInBytes: ma_uint32;
    encodedReadOffset: ma_uint32;
    encodedWriteOffset: ma_uint32;
    ownsBuffer: ma_bool8;
    clearOnWriteAcquire: ma_bool8;
    allocationCallbacks: ma_allocation_callbacks;
  end;

  ma_pcm_rb = record
    ds: ma_data_source_base;
    rb: ma_rb;
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
  end;

  ma_duplex_rb = record
    rb: ma_pcm_rb;
  end;

  ma_fence = record
    e: ma_event;
    counter: ma_uint32;
  end;

  Pma_async_notification = Pointer;
  PPma_async_notification = ^Pma_async_notification;

  ma_async_notification_callbacks = record
    onSignal: procedure(pNotification: Pma_async_notification); cdecl;
  end;

  ma_async_notification_poll = record
    cb: ma_async_notification_callbacks;
    signalled: ma_bool32;
  end;

  ma_async_notification_event = record
    cb: ma_async_notification_callbacks;
    e: ma_event;
  end;

  ma_slot_allocator_config = record
    capacity: ma_uint32;
  end;

  ma_slot_allocator_group = record
    bitfield: ma_uint32;
  end;

  ma_slot_allocator = record
    pGroups: Pma_slot_allocator_group;
    pSlots: Pma_uint32;
    count: ma_uint32;
    capacity: ma_uint32;
    _ownsHeap: ma_bool32;
    _pHeap: Pointer;
  end;

  ma_job_proc = function(pJob: Pma_job): ma_result; cdecl;

  P_anonymous_type_16 = ^_anonymous_type_16;
  _anonymous_type_16 = record
    code: ma_uint16;
    slot: ma_uint16;
    refcount: ma_uint32;
  end;

  P_anonymous_type_17 = ^_anonymous_type_17;
  _anonymous_type_17 = record
    case Integer of
      0: (breakup: _anonymous_type_16);
      1: (allocation: ma_uint64);
  end;

  P_anonymous_type_18 = ^_anonymous_type_18;
  _anonymous_type_18 = record
    proc: ma_job_proc;
    data0: ma_uintptr;
    data1: ma_uintptr;
  end;

  P_anonymous_type_19 = ^_anonymous_type_19;
  _anonymous_type_19 = record
    pResourceManager: Pointer;
    pDataBufferNode: Pointer;
    pFilePath: PUTF8Char;
    pFilePathW: PWideChar;
    flags: ma_uint32;
    pInitNotification: Pma_async_notification;
    pDoneNotification: Pma_async_notification;
    pInitFence: Pma_fence;
    pDoneFence: Pma_fence;
  end;

  P_anonymous_type_20 = ^_anonymous_type_20;
  _anonymous_type_20 = record
    pResourceManager: Pointer;
    pDataBufferNode: Pointer;
    pDoneNotification: Pma_async_notification;
    pDoneFence: Pma_fence;
  end;

  P_anonymous_type_21 = ^_anonymous_type_21;
  _anonymous_type_21 = record
    pResourceManager: Pointer;
    pDataBufferNode: Pointer;
    pDecoder: Pointer;
    pDoneNotification: Pma_async_notification;
    pDoneFence: Pma_fence;
  end;

  P_anonymous_type_22 = ^_anonymous_type_22;
  _anonymous_type_22 = record
    pDataBuffer: Pointer;
    pInitNotification: Pma_async_notification;
    pDoneNotification: Pma_async_notification;
    pInitFence: Pma_fence;
    pDoneFence: Pma_fence;
    rangeBegInPCMFrames: ma_uint64;
    rangeEndInPCMFrames: ma_uint64;
    loopPointBegInPCMFrames: ma_uint64;
    loopPointEndInPCMFrames: ma_uint64;
    isLooping: ma_uint32;
  end;

  P_anonymous_type_23 = ^_anonymous_type_23;
  _anonymous_type_23 = record
    pDataBuffer: Pointer;
    pDoneNotification: Pma_async_notification;
    pDoneFence: Pma_fence;
  end;

  P_anonymous_type_24 = ^_anonymous_type_24;
  _anonymous_type_24 = record
    pDataStream: Pointer;
    pFilePath: PUTF8Char;
    pFilePathW: PWideChar;
    initialSeekPoint: ma_uint64;
    pInitNotification: Pma_async_notification;
    pInitFence: Pma_fence;
  end;

  P_anonymous_type_25 = ^_anonymous_type_25;
  _anonymous_type_25 = record
    pDataStream: Pointer;
    pDoneNotification: Pma_async_notification;
    pDoneFence: Pma_fence;
  end;

  P_anonymous_type_26 = ^_anonymous_type_26;
  _anonymous_type_26 = record
    pDataStream: Pointer;
    pageIndex: ma_uint32;
  end;

  P_anonymous_type_27 = ^_anonymous_type_27;
  _anonymous_type_27 = record
    pDataStream: Pointer;
    frameIndex: ma_uint64;
  end;

  P_anonymous_type_28 = ^_anonymous_type_28;
  _anonymous_type_28 = record
    case Integer of
      0: (loadDataBufferNode: _anonymous_type_19);
      1: (freeDataBufferNode: _anonymous_type_20);
      2: (pageDataBufferNode: _anonymous_type_21);
      3: (loadDataBuffer: _anonymous_type_22);
      4: (freeDataBuffer: _anonymous_type_23);
      5: (loadDataStream: _anonymous_type_24);
      6: (freeDataStream: _anonymous_type_25);
      7: (pageDataStream: _anonymous_type_26);
      8: (seekDataStream: _anonymous_type_27);
  end;

  P_anonymous_type_29 = ^_anonymous_type_29;
  _anonymous_type_29 = record
    pDevice: Pointer;
    deviceType: ma_uint32;
  end;

  P_anonymous_type_30 = ^_anonymous_type_30;
  _anonymous_type_30 = record
    case Integer of
      0: (reroute: _anonymous_type_29);
  end;

  P_anonymous_type_31 = ^_anonymous_type_31;
  _anonymous_type_31 = record
    case Integer of
      0: (aaudio: _anonymous_type_30);
  end;

  P_anonymous_type_32 = ^_anonymous_type_32;
  _anonymous_type_32 = record
    case Integer of
      0: (custom: _anonymous_type_18);
      1: (resourceManager: _anonymous_type_28);
      2: (device: _anonymous_type_31);
  end;

  ma_job = record
    toc: _anonymous_type_17;
    next: ma_uint64;
    order: ma_uint32;
    data: _anonymous_type_32;
  end;

  ma_job_queue_config = record
    flags: ma_uint32;
    capacity: ma_uint32;
  end;

  ma_job_queue = record
    flags: ma_uint32;
    capacity: ma_uint32;
    head: ma_uint64;
    tail: ma_uint64;
    sem: ma_semaphore;
    allocator: ma_slot_allocator;
    pJobs: Pma_job;
    lock: ma_spinlock;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_atomic_device_state = record
    value: ma_device_state;
  end;

  ma_IMMNotificationClient = record
    lpVtbl: Pointer;
    counter: ma_uint32;
    pDevice: Pma_device;
  end;

  ma_device_job_thread_config = record
    noThread: ma_bool32;
    jobQueueCapacity: ma_uint32;
    jobQueueFlags: ma_uint32;
  end;

  ma_device_job_thread = record
    thread: ma_thread;
    jobQueue: ma_job_queue;
    _hasThread: ma_bool32;
  end;

  P_anonymous_type_33 = ^_anonymous_type_33;
  _anonymous_type_33 = record
    _unused: Integer;
  end;

  P_anonymous_type_34 = ^_anonymous_type_34;
  _anonymous_type_34 = record
    _unused: Integer;
  end;

  P_anonymous_type_35 = ^_anonymous_type_35;
  _anonymous_type_35 = record
    _unused: Integer;
  end;

  P_anonymous_type_36 = ^_anonymous_type_36;
  _anonymous_type_36 = record
    _unused: Integer;
  end;

  P_anonymous_type_37 = ^_anonymous_type_37;
  _anonymous_type_37 = record
    case Integer of
      0: (started: _anonymous_type_33);
      1: (stopped: _anonymous_type_34);
      2: (rerouted: _anonymous_type_35);
      3: (interruption: _anonymous_type_36);
  end;

  ma_device_notification = record
    pDevice: Pma_device;
    &type: ma_device_notification_type;
    data: _anonymous_type_37;
  end;

  ma_device_notification_proc = procedure(const pNotification: Pma_device_notification); cdecl;
  ma_device_data_proc = procedure(pDevice: Pma_device; pOutput: Pointer; const pInput: Pointer; frameCount: ma_uint32); cdecl;
  ma_stop_proc = procedure(pDevice: Pma_device); cdecl;

  ma_timer = record
    case Integer of
      0: (counter: ma_int64);
      1: (counterD: Double);
  end;

  P_anonymous_type_38 = ^_anonymous_type_38;
  _anonymous_type_38 = record
    case Integer of
      0: (i: Integer);
      1: (s: array [0..255] of UTF8Char);
      2: (p: Pointer);
  end;

  Pma_device_id = ^ma_device_id;
  ma_device_id = record
    case Integer of
      0: (wasapi: array [0..63] of ma_wchar_win32);
      1: (dsound: array [0..15] of ma_uint8);
      2: (winmm: ma_uint32);
      3: (alsa: array [0..255] of UTF8Char);
      4: (pulse: array [0..255] of UTF8Char);
      5: (jack: Integer);
      6: (coreaudio: array [0..255] of UTF8Char);
      7: (sndio: array [0..255] of UTF8Char);
      8: (audio4: array [0..255] of UTF8Char);
      9: (oss: array [0..63] of UTF8Char);
      10: (aaudio: ma_int32);
      11: (opensl: ma_uint32);
      12: (webaudio: array [0..31] of UTF8Char);
      13: (custom: _anonymous_type_38);
      14: (nullbackend: Integer);
  end;

  P_anonymous_type_39 = ^_anonymous_type_39;
  _anonymous_type_39 = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    flags: ma_uint32;
  end;

  ma_device_info = record
    id: ma_device_id;
    name: array [0..255] of UTF8Char;
    isDefault: ma_bool32;
    nativeDataFormatCount: ma_uint32;
    nativeDataFormats: array [0..63] of _anonymous_type_39;
  end;

  P_anonymous_type_40 = ^_anonymous_type_40;
  _anonymous_type_40 = record
    pDeviceID: Pma_device_id;
    format: ma_format;
    channels: ma_uint32;
    pChannelMap: Pma_channel;
    channelMixMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    shareMode: ma_share_mode;
  end;

  P_anonymous_type_41 = ^_anonymous_type_41;
  _anonymous_type_41 = record
    pDeviceID: Pma_device_id;
    format: ma_format;
    channels: ma_uint32;
    pChannelMap: Pma_channel;
    channelMixMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    shareMode: ma_share_mode;
  end;

  P_anonymous_type_42 = ^_anonymous_type_42;
  _anonymous_type_42 = record
    usage: ma_wasapi_usage;
    noAutoConvertSRC: ma_bool8;
    noDefaultQualitySRC: ma_bool8;
    noAutoStreamRouting: ma_bool8;
    noHardwareOffloading: ma_bool8;
    loopbackProcessID: ma_uint32;
    loopbackProcessExclude: ma_bool8;
  end;

  P_anonymous_type_43 = ^_anonymous_type_43;
  _anonymous_type_43 = record
    noMMap: ma_bool32;
    noAutoFormat: ma_bool32;
    noAutoChannels: ma_bool32;
    noAutoResample: ma_bool32;
  end;

  P_anonymous_type_44 = ^_anonymous_type_44;
  _anonymous_type_44 = record
    pStreamNamePlayback: PUTF8Char;
    pStreamNameCapture: PUTF8Char;
  end;

  P_anonymous_type_45 = ^_anonymous_type_45;
  _anonymous_type_45 = record
    allowNominalSampleRateChange: ma_bool32;
  end;

  P_anonymous_type_46 = ^_anonymous_type_46;
  _anonymous_type_46 = record
    streamType: ma_opensl_stream_type;
    recordingPreset: ma_opensl_recording_preset;
    enableCompatibilityWorkarounds: ma_bool32;
  end;

  P_anonymous_type_47 = ^_anonymous_type_47;
  _anonymous_type_47 = record
    usage: ma_aaudio_usage;
    contentType: ma_aaudio_content_type;
    inputPreset: ma_aaudio_input_preset;
    allowedCapturePolicy: ma_aaudio_allowed_capture_policy;
    noAutoStartAfterReroute: ma_bool32;
    enableCompatibilityWorkarounds: ma_bool32;
  end;

  ma_device_config = record
    deviceType: ma_device_type;
    sampleRate: ma_uint32;
    periodSizeInFrames: ma_uint32;
    periodSizeInMilliseconds: ma_uint32;
    periods: ma_uint32;
    performanceProfile: ma_performance_profile;
    noPreSilencedOutputBuffer: ma_bool8;
    noClip: ma_bool8;
    noDisableDenormals: ma_bool8;
    noFixedSizedCallback: ma_bool8;
    dataCallback: ma_device_data_proc;
    notificationCallback: ma_device_notification_proc;
    stopCallback: ma_stop_proc;
    pUserData: Pointer;
    resampling: ma_resampler_config;
    playback: _anonymous_type_40;
    capture: _anonymous_type_41;
    wasapi: _anonymous_type_42;
    alsa: _anonymous_type_43;
    pulse: _anonymous_type_44;
    coreaudio: _anonymous_type_45;
    opensl: _anonymous_type_46;
    aaudio: _anonymous_type_47;
  end;

  ma_enum_devices_callback_proc = function(pContext: Pma_context; deviceType: ma_device_type; const pInfo: Pma_device_info; pUserData: Pointer): ma_bool32; cdecl;

  ma_device_descriptor = record
    pDeviceID: Pma_device_id;
    shareMode: ma_share_mode;
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    channelMap: array [0..253] of ma_channel;
    periodSizeInFrames: ma_uint32;
    periodSizeInMilliseconds: ma_uint32;
    periodCount: ma_uint32;
  end;

  ma_backend_callbacks = record
    onContextInit: function(pContext: Pma_context; const pConfig: Pma_context_config; pCallbacks: Pma_backend_callbacks): ma_result; cdecl;
    onContextUninit: function(pContext: Pma_context): ma_result; cdecl;
    onContextEnumerateDevices: function(pContext: Pma_context; callback: ma_enum_devices_callback_proc; pUserData: Pointer): ma_result; cdecl;
    onContextGetDeviceInfo: function(pContext: Pma_context; deviceType: ma_device_type; const pDeviceID: Pma_device_id; pDeviceInfo: Pma_device_info): ma_result; cdecl;
    onDeviceInit: function(pDevice: Pma_device; const pConfig: Pma_device_config; pDescriptorPlayback: Pma_device_descriptor; pDescriptorCapture: Pma_device_descriptor): ma_result; cdecl;
    onDeviceUninit: function(pDevice: Pma_device): ma_result; cdecl;
    onDeviceStart: function(pDevice: Pma_device): ma_result; cdecl;
    onDeviceStop: function(pDevice: Pma_device): ma_result; cdecl;
    onDeviceRead: function(pDevice: Pma_device; pFrames: Pointer; frameCount: ma_uint32; pFramesRead: Pma_uint32): ma_result; cdecl;
    onDeviceWrite: function(pDevice: Pma_device; const pFrames: Pointer; frameCount: ma_uint32; pFramesWritten: Pma_uint32): ma_result; cdecl;
    onDeviceDataLoop: function(pDevice: Pma_device): ma_result; cdecl;
    onDeviceDataLoopWakeup: function(pDevice: Pma_device): ma_result; cdecl;
    onDeviceGetInfo: function(pDevice: Pma_device; &type: ma_device_type; pDeviceInfo: Pma_device_info): ma_result; cdecl;
  end;

  P_anonymous_type_48 = ^_anonymous_type_48;
  _anonymous_type_48 = record
    useVerboseDeviceEnumeration: ma_bool32;
  end;

  P_anonymous_type_49 = ^_anonymous_type_49;
  _anonymous_type_49 = record
    pApplicationName: PUTF8Char;
    pServerName: PUTF8Char;
    tryAutoSpawn: ma_bool32;
  end;

  P_anonymous_type_50 = ^_anonymous_type_50;
  _anonymous_type_50 = record
    sessionCategory: ma_ios_session_category;
    sessionCategoryOptions: ma_uint32;
    noAudioSessionActivate: ma_bool32;
    noAudioSessionDeactivate: ma_bool32;
  end;

  P_anonymous_type_51 = ^_anonymous_type_51;
  _anonymous_type_51 = record
    pClientName: PUTF8Char;
    tryStartServer: ma_bool32;
  end;

  ma_context_config = record
    pLog: Pma_log;
    threadPriority: ma_thread_priority;
    threadStackSize: NativeUInt;
    pUserData: Pointer;
    allocationCallbacks: ma_allocation_callbacks;
    alsa: _anonymous_type_48;
    pulse: _anonymous_type_49;
    coreaudio: _anonymous_type_50;
    jack: _anonymous_type_51;
    custom: ma_backend_callbacks;
  end;

  P_anonymous_type_52 = ^_anonymous_type_52;
  _anonymous_type_52 = record
    _unused: Integer;
  end;

  P_anonymous_type_53 = ^_anonymous_type_53;
  _anonymous_type_53 = record
    deviceType: ma_device_type;
    pAudioClient: Pointer;
    ppAudioClientService: PPointer;
    pResult: Pma_result;
  end;

  P_anonymous_type_54 = ^_anonymous_type_54;
  _anonymous_type_54 = record
    pDevice: Pma_device;
    deviceType: ma_device_type;
  end;

  P_anonymous_type_55 = ^_anonymous_type_55;
  _anonymous_type_55 = record
    case Integer of
      0: (quit: _anonymous_type_52);
      1: (createAudioClient: _anonymous_type_53);
      2: (releaseAudioClient: _anonymous_type_54);
  end;

  ma_context_command__wasapi = record
    code: Integer;
    pEvent: Pma_event;
    data: _anonymous_type_55;
  end;

  P_anonymous_type_56 = ^_anonymous_type_56;
  _anonymous_type_56 = record
    commandThread: ma_thread;
    commandLock: ma_mutex;
    commandSem: ma_semaphore;
    commandIndex: ma_uint32;
    commandCount: ma_uint32;
    commands: array [0..3] of ma_context_command__wasapi;
    hAvrt: ma_handle;
    AvSetMmThreadCharacteristicsA: ma_proc;
    AvRevertMmThreadcharacteristics: ma_proc;
    hMMDevapi: ma_handle;
    ActivateAudioInterfaceAsync: ma_proc;
  end;

  P_anonymous_type_57 = ^_anonymous_type_57;
  _anonymous_type_57 = record
    hDSoundDLL: ma_handle;
    DirectSoundCreate: ma_proc;
    DirectSoundEnumerateA: ma_proc;
    DirectSoundCaptureCreate: ma_proc;
    DirectSoundCaptureEnumerateA: ma_proc;
  end;

  P_anonymous_type_58 = ^_anonymous_type_58;
  _anonymous_type_58 = record
    hWinMM: ma_handle;
    waveOutGetNumDevs: ma_proc;
    waveOutGetDevCapsA: ma_proc;
    waveOutOpen: ma_proc;
    waveOutClose: ma_proc;
    waveOutPrepareHeader: ma_proc;
    waveOutUnprepareHeader: ma_proc;
    waveOutWrite: ma_proc;
    waveOutReset: ma_proc;
    waveInGetNumDevs: ma_proc;
    waveInGetDevCapsA: ma_proc;
    waveInOpen: ma_proc;
    waveInClose: ma_proc;
    waveInPrepareHeader: ma_proc;
    waveInUnprepareHeader: ma_proc;
    waveInAddBuffer: ma_proc;
    waveInStart: ma_proc;
    waveInReset: ma_proc;
  end;

  P_anonymous_type_59 = ^_anonymous_type_59;
  _anonymous_type_59 = record
    jackSO: ma_handle;
    jack_client_open: ma_proc;
    jack_client_close: ma_proc;
    jack_client_name_size: ma_proc;
    jack_set_process_callback: ma_proc;
    jack_set_buffer_size_callback: ma_proc;
    jack_on_shutdown: ma_proc;
    jack_get_sample_rate: ma_proc;
    jack_get_buffer_size: ma_proc;
    jack_get_ports: ma_proc;
    jack_activate: ma_proc;
    jack_deactivate: ma_proc;
    jack_connect: ma_proc;
    jack_port_register: ma_proc;
    jack_port_name: ma_proc;
    jack_port_get_buffer: ma_proc;
    jack_free: ma_proc;
    pClientName: PUTF8Char;
    tryStartServer: ma_bool32;
  end;

  P_anonymous_type_60 = ^_anonymous_type_60;
  _anonymous_type_60 = record
    _unused: Integer;
  end;

  P_anonymous_type_61 = ^_anonymous_type_61;
  _anonymous_type_61 = record
    case Integer of
      0: (wasapi: _anonymous_type_56);
      1: (dsound: _anonymous_type_57);
      2: (winmm: _anonymous_type_58);
      3: (jack: _anonymous_type_59);
      4: (null_backend: _anonymous_type_60);
  end;

  P_anonymous_type_62 = ^_anonymous_type_62;
  _anonymous_type_62 = record
    hOle32DLL: ma_handle;
    CoInitialize: ma_proc;
    CoInitializeEx: ma_proc;
    CoUninitialize: ma_proc;
    CoCreateInstance: ma_proc;
    CoTaskMemFree: ma_proc;
    PropVariantClear: ma_proc;
    StringFromGUID2: ma_proc;
    hUser32DLL: ma_handle;
    GetForegroundWindow: ma_proc;
    GetDesktopWindow: ma_proc;
    hAdvapi32DLL: ma_handle;
    RegOpenKeyExA: ma_proc;
    RegCloseKey: ma_proc;
    RegQueryValueExA: ma_proc;
    CoInitializeResult: Longint;
  end;

  P_anonymous_type_63 = ^_anonymous_type_63;
  _anonymous_type_63 = record
    case Integer of
      0: (win32: _anonymous_type_62);
      1: (_unused: Integer);
  end;

  ma_context = record
    callbacks: ma_backend_callbacks;
    backend: ma_backend;
    pLog: Pma_log;
    log: ma_log;
    threadPriority: ma_thread_priority;
    threadStackSize: NativeUInt;
    pUserData: Pointer;
    allocationCallbacks: ma_allocation_callbacks;
    deviceEnumLock: ma_mutex;
    deviceInfoLock: ma_mutex;
    deviceInfoCapacity: ma_uint32;
    playbackDeviceInfoCount: ma_uint32;
    captureDeviceInfoCount: ma_uint32;
    pDeviceInfos: Pma_device_info;
    f15: _anonymous_type_61;
    f16: _anonymous_type_63;
  end;

  P_anonymous_type_64 = ^_anonymous_type_64;
  _anonymous_type_64 = record
    lpfOrder: ma_uint32;
  end;

  P_anonymous_type_65 = ^_anonymous_type_65;
  _anonymous_type_65 = record
    algorithm: ma_resample_algorithm;
    pBackendVTable: Pma_resampling_backend_vtable;
    pBackendUserData: Pointer;
    linear: _anonymous_type_64;
  end;

  P_anonymous_type_66 = ^_anonymous_type_66;
  _anonymous_type_66 = record
    pID: Pma_device_id;
    id: ma_device_id;
    name: array [0..255] of UTF8Char;
    shareMode: ma_share_mode;
    format: ma_format;
    channels: ma_uint32;
    channelMap: array [0..253] of ma_channel;
    internalFormat: ma_format;
    internalChannels: ma_uint32;
    internalSampleRate: ma_uint32;
    internalChannelMap: array [0..253] of ma_channel;
    internalPeriodSizeInFrames: ma_uint32;
    internalPeriods: ma_uint32;
    channelMixMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    converter: ma_data_converter;
    pIntermediaryBuffer: Pointer;
    intermediaryBufferCap: ma_uint32;
    intermediaryBufferLen: ma_uint32;
    pInputCache: Pointer;
    inputCacheCap: ma_uint64;
    inputCacheConsumed: ma_uint64;
    inputCacheRemaining: ma_uint64;
  end;

  P_anonymous_type_67 = ^_anonymous_type_67;
  _anonymous_type_67 = record
    pID: Pma_device_id;
    id: ma_device_id;
    name: array [0..255] of UTF8Char;
    shareMode: ma_share_mode;
    format: ma_format;
    channels: ma_uint32;
    channelMap: array [0..253] of ma_channel;
    internalFormat: ma_format;
    internalChannels: ma_uint32;
    internalSampleRate: ma_uint32;
    internalChannelMap: array [0..253] of ma_channel;
    internalPeriodSizeInFrames: ma_uint32;
    internalPeriods: ma_uint32;
    channelMixMode: ma_channel_mix_mode;
    calculateLFEFromSpatialChannels: ma_bool32;
    converter: ma_data_converter;
    pIntermediaryBuffer: Pointer;
    intermediaryBufferCap: ma_uint32;
    intermediaryBufferLen: ma_uint32;
  end;

  P_anonymous_type_68 = ^_anonymous_type_68;
  _anonymous_type_68 = record
    pAudioClientPlayback: ma_ptr;
    pAudioClientCapture: ma_ptr;
    pRenderClient: ma_ptr;
    pCaptureClient: ma_ptr;
    pDeviceEnumerator: ma_ptr;
    notificationClient: ma_IMMNotificationClient;
    hEventPlayback: ma_handle;
    hEventCapture: ma_handle;
    actualBufferSizeInFramesPlayback: ma_uint32;
    actualBufferSizeInFramesCapture: ma_uint32;
    originalPeriodSizeInFrames: ma_uint32;
    originalPeriodSizeInMilliseconds: ma_uint32;
    originalPeriods: ma_uint32;
    originalPerformanceProfile: ma_performance_profile;
    periodSizeInFramesPlayback: ma_uint32;
    periodSizeInFramesCapture: ma_uint32;
    pMappedBufferCapture: Pointer;
    mappedBufferCaptureCap: ma_uint32;
    mappedBufferCaptureLen: ma_uint32;
    pMappedBufferPlayback: Pointer;
    mappedBufferPlaybackCap: ma_uint32;
    mappedBufferPlaybackLen: ma_uint32;
    isStartedCapture: ma_atomic_bool32;
    isStartedPlayback: ma_atomic_bool32;
    loopbackProcessID: ma_uint32;
    loopbackProcessExclude: ma_bool8;
    noAutoConvertSRC: ma_bool8;
    noDefaultQualitySRC: ma_bool8;
    noHardwareOffloading: ma_bool8;
    allowCaptureAutoStreamRouting: ma_bool8;
    allowPlaybackAutoStreamRouting: ma_bool8;
    isDetachedPlayback: ma_bool8;
    isDetachedCapture: ma_bool8;
    usage: ma_wasapi_usage;
    hAvrtHandle: Pointer;
    rerouteLock: ma_mutex;
  end;

  P_anonymous_type_69 = ^_anonymous_type_69;
  _anonymous_type_69 = record
    pPlayback: ma_ptr;
    pPlaybackPrimaryBuffer: ma_ptr;
    pPlaybackBuffer: ma_ptr;
    pCapture: ma_ptr;
    pCaptureBuffer: ma_ptr;
  end;

  P_anonymous_type_70 = ^_anonymous_type_70;
  _anonymous_type_70 = record
    hDevicePlayback: ma_handle;
    hDeviceCapture: ma_handle;
    hEventPlayback: ma_handle;
    hEventCapture: ma_handle;
    fragmentSizeInFrames: ma_uint32;
    iNextHeaderPlayback: ma_uint32;
    iNextHeaderCapture: ma_uint32;
    headerFramesConsumedPlayback: ma_uint32;
    headerFramesConsumedCapture: ma_uint32;
    pWAVEHDRPlayback: Pma_uint8;
    pWAVEHDRCapture: Pma_uint8;
    pIntermediaryBufferPlayback: Pma_uint8;
    pIntermediaryBufferCapture: Pma_uint8;
    _pHeapData: Pma_uint8;
  end;

  P_anonymous_type_71 = ^_anonymous_type_71;
  _anonymous_type_71 = record
    pClient: ma_ptr;
    ppPortsPlayback: Pma_ptr;
    ppPortsCapture: Pma_ptr;
    pIntermediaryBufferPlayback: PSingle;
    pIntermediaryBufferCapture: PSingle;
  end;

  P_anonymous_type_72 = ^_anonymous_type_72;
  _anonymous_type_72 = record
    deviceThread: ma_thread;
    operationEvent: ma_event;
    operationCompletionEvent: ma_event;
    operationSemaphore: ma_semaphore;
    operation: ma_uint32;
    operationResult: ma_result;
    timer: ma_timer;
    priorRunTime: Double;
    currentPeriodFramesRemainingPlayback: ma_uint32;
    currentPeriodFramesRemainingCapture: ma_uint32;
    lastProcessedFramePlayback: ma_uint64;
    lastProcessedFrameCapture: ma_uint64;
    isStarted: ma_atomic_bool32;
  end;

  P_anonymous_type_73 = ^_anonymous_type_73;
  _anonymous_type_73 = record
    case Integer of
      0: (wasapi: _anonymous_type_68);
      1: (dsound: _anonymous_type_69);
      2: (winmm: _anonymous_type_70);
      3: (jack: _anonymous_type_71);
      4: (null_device: _anonymous_type_72);
  end;

  ma_device = record
    pContext: Pma_context;
    &type: ma_device_type;
    sampleRate: ma_uint32;
    state: ma_atomic_device_state;
    onData: ma_device_data_proc;
    onNotification: ma_device_notification_proc;
    onStop: ma_stop_proc;
    pUserData: Pointer;
    startStopLock: ma_mutex;
    wakeupEvent: ma_event;
    startEvent: ma_event;
    stopEvent: ma_event;
    thread: ma_thread;
    workResult: ma_result;
    isOwnerOfContext: ma_bool8;
    noPreSilencedOutputBuffer: ma_bool8;
    noClip: ma_bool8;
    noDisableDenormals: ma_bool8;
    noFixedSizedCallback: ma_bool8;
    masterVolumeFactor: ma_atomic_float;
    duplexRB: ma_duplex_rb;
    resampling: _anonymous_type_65;
    playback: _anonymous_type_66;
    capture: _anonymous_type_67;
    f25: _anonymous_type_73;
  end;

  Pma_vfs = Pointer;
  PPma_vfs = ^Pma_vfs;
  ma_vfs_file = ma_handle;
  Pma_vfs_file = ^ma_vfs_file;

  ma_file_info = record
    sizeInBytes: ma_uint64;
  end;

  ma_vfs_callbacks = record
    onOpen: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; openMode: ma_uint32; pFile: Pma_vfs_file): ma_result; cdecl;
    onOpenW: function(pVFS: Pma_vfs; const pFilePath: PWideChar; openMode: ma_uint32; pFile: Pma_vfs_file): ma_result; cdecl;
    onClose: function(pVFS: Pma_vfs; &file: ma_vfs_file): ma_result; cdecl;
    onRead: function(pVFS: Pma_vfs; &file: ma_vfs_file; pDst: Pointer; sizeInBytes: NativeUInt; pBytesRead: PNativeUInt): ma_result; cdecl;
    onWrite: function(pVFS: Pma_vfs; &file: ma_vfs_file; const pSrc: Pointer; sizeInBytes: NativeUInt; pBytesWritten: PNativeUInt): ma_result; cdecl;
    onSeek: function(pVFS: Pma_vfs; &file: ma_vfs_file; offset: ma_int64; origin: ma_seek_origin): ma_result; cdecl;
    onTell: function(pVFS: Pma_vfs; &file: ma_vfs_file; pCursor: Pma_int64): ma_result; cdecl;
    onInfo: function(pVFS: Pma_vfs; &file: ma_vfs_file; pInfo: Pma_file_info): ma_result; cdecl;
  end;

  ma_default_vfs = record
    cb: ma_vfs_callbacks;
    allocationCallbacks: ma_allocation_callbacks;
  end;

  ma_read_proc = function(pUserData: Pointer; pBufferOut: Pointer; bytesToRead: NativeUInt; pBytesRead: PNativeUInt): ma_result; cdecl;
  ma_seek_proc = function(pUserData: Pointer; offset: ma_int64; origin: ma_seek_origin): ma_result; cdecl;
  ma_tell_proc = function(pUserData: Pointer; pCursor: Pma_int64): ma_result; cdecl;

  ma_decoding_backend_config = record
    preferredFormat: ma_format;
    seekPointCount: ma_uint32;
  end;

  ma_decoding_backend_vtable = record
    onInit: function(pUserData: Pointer; onRead: ma_read_proc; onSeek: ma_seek_proc; onTell: ma_tell_proc; pReadSeekTellUserData: Pointer; const pConfig: Pma_decoding_backend_config; const pAllocationCallbacks: Pma_allocation_callbacks; ppBackend: PPma_data_source): ma_result; cdecl;
    onInitFile: function(pUserData: Pointer; const pFilePath: PUTF8Char; const pConfig: Pma_decoding_backend_config; const pAllocationCallbacks: Pma_allocation_callbacks; ppBackend: PPma_data_source): ma_result; cdecl;
    onInitFileW: function(pUserData: Pointer; const pFilePath: PWideChar; const pConfig: Pma_decoding_backend_config; const pAllocationCallbacks: Pma_allocation_callbacks; ppBackend: PPma_data_source): ma_result; cdecl;
    onInitMemory: function(pUserData: Pointer; const pData: Pointer; dataSize: NativeUInt; const pConfig: Pma_decoding_backend_config; const pAllocationCallbacks: Pma_allocation_callbacks; ppBackend: PPma_data_source): ma_result; cdecl;
    onUninit: procedure(pUserData: Pointer; pBackend: Pma_data_source; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  end;

  ma_decoder_read_proc = function(pDecoder: Pma_decoder; pBufferOut: Pointer; bytesToRead: NativeUInt; pBytesRead: PNativeUInt): ma_result; cdecl;
  ma_decoder_seek_proc = function(pDecoder: Pma_decoder; byteOffset: ma_int64; origin: ma_seek_origin): ma_result; cdecl;
  ma_decoder_tell_proc = function(pDecoder: Pma_decoder; pCursor: Pma_int64): ma_result; cdecl;

  ma_decoder_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    pChannelMap: Pma_channel;
    channelMixMode: ma_channel_mix_mode;
    ditherMode: ma_dither_mode;
    resampling: ma_resampler_config;
    allocationCallbacks: ma_allocation_callbacks;
    encodingFormat: ma_encoding_format;
    seekPointCount: ma_uint32;
    ppCustomBackendVTables: PPma_decoding_backend_vtable;
    customBackendCount: ma_uint32;
    pCustomBackendUserData: Pointer;
  end;

  P_anonymous_type_74 = ^_anonymous_type_74;
  _anonymous_type_74 = record
    pVFS: Pma_vfs;
    &file: ma_vfs_file;
  end;

  P_anonymous_type_75 = ^_anonymous_type_75;
  _anonymous_type_75 = record
    pData: Pma_uint8;
    dataSize: NativeUInt;
    currentReadPos: NativeUInt;
  end;

  P_anonymous_type_76 = ^_anonymous_type_76;
  _anonymous_type_76 = record
    case Integer of
      0: (vfs: _anonymous_type_74);
      1: (memory: _anonymous_type_75);
  end;

  ma_decoder = record
    ds: ma_data_source_base;
    pBackend: Pma_data_source;
    pBackendVTable: Pma_decoding_backend_vtable;
    pBackendUserData: Pointer;
    onRead: ma_decoder_read_proc;
    onSeek: ma_decoder_seek_proc;
    onTell: ma_decoder_tell_proc;
    pUserData: Pointer;
    readPointerInPCMFrames: ma_uint64;
    outputFormat: ma_format;
    outputChannels: ma_uint32;
    outputSampleRate: ma_uint32;
    converter: ma_data_converter;
    pInputCache: Pointer;
    inputCacheCap: ma_uint64;
    inputCacheConsumed: ma_uint64;
    inputCacheRemaining: ma_uint64;
    allocationCallbacks: ma_allocation_callbacks;
    data: _anonymous_type_76;
  end;

  ma_encoder_write_proc = function(pEncoder: Pma_encoder; const pBufferIn: Pointer; bytesToWrite: NativeUInt; pBytesWritten: PNativeUInt): ma_result; cdecl;
  ma_encoder_seek_proc = function(pEncoder: Pma_encoder; offset: ma_int64; origin: ma_seek_origin): ma_result; cdecl;
  ma_encoder_init_proc = function(pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_uninit_proc = procedure(pEncoder: Pma_encoder); cdecl;
  ma_encoder_write_pcm_frames_proc = function(pEncoder: Pma_encoder; const pFramesIn: Pointer; frameCount: ma_uint64; pFramesWritten: Pma_uint64): ma_result; cdecl;

  ma_encoder_config = record
    encodingFormat: ma_encoding_format;
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    allocationCallbacks: ma_allocation_callbacks;
  end;

  P_anonymous_type_77 = ^_anonymous_type_77;
  _anonymous_type_77 = record
    pVFS: Pma_vfs;
    &file: ma_vfs_file;
  end;

  P_anonymous_type_78 = ^_anonymous_type_78;
  _anonymous_type_78 = record
    case Integer of
      0: (vfs: _anonymous_type_77);
  end;

  ma_encoder = record
    config: ma_encoder_config;
    onWrite: ma_encoder_write_proc;
    onSeek: ma_encoder_seek_proc;
    onInit: ma_encoder_init_proc;
    onUninit: ma_encoder_uninit_proc;
    onWritePCMFrames: ma_encoder_write_pcm_frames_proc;
    pUserData: Pointer;
    pInternalEncoder: Pointer;
    data: _anonymous_type_78;
  end;

  ma_waveform_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    &type: ma_waveform_type;
    amplitude: Double;
    frequency: Double;
  end;

  ma_waveform = record
    ds: ma_data_source_base;
    config: ma_waveform_config;
    advance: Double;
    time: Double;
  end;

  ma_pulsewave_config = record
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    dutyCycle: Double;
    amplitude: Double;
    frequency: Double;
  end;

  ma_pulsewave = record
    waveform: ma_waveform;
    config: ma_pulsewave_config;
  end;

  ma_noise_config = record
    format: ma_format;
    channels: ma_uint32;
    &type: ma_noise_type;
    seed: ma_int32;
    amplitude: Double;
    duplicateChannels: ma_bool32;
  end;

  P_anonymous_type_79 = ^_anonymous_type_79;
  _anonymous_type_79 = record
    bin: PPDouble;
    accumulation: PDouble;
    counter: Pma_uint32;
  end;

  P_anonymous_type_80 = ^_anonymous_type_80;
  _anonymous_type_80 = record
    accumulation: PDouble;
  end;

  P_anonymous_type_81 = ^_anonymous_type_81;
  _anonymous_type_81 = record
    case Integer of
      0: (pink: _anonymous_type_79);
      1: (brownian: _anonymous_type_80);
  end;

  ma_noise = record
    ds: ma_data_source_base;
    config: ma_noise_config;
    lcg: ma_lcg;
    state: _anonymous_type_81;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_resource_manager_pipeline_stage_notification = record
    pNotification: Pma_async_notification;
    pFence: Pma_fence;
  end;

  ma_resource_manager_pipeline_notifications = record
    init: ma_resource_manager_pipeline_stage_notification;
    done: ma_resource_manager_pipeline_stage_notification;
  end;

  ma_resource_manager_data_source_config = record
    pFilePath: PUTF8Char;
    pFilePathW: PWideChar;
    pNotifications: Pma_resource_manager_pipeline_notifications;
    initialSeekPointInPCMFrames: ma_uint64;
    rangeBegInPCMFrames: ma_uint64;
    rangeEndInPCMFrames: ma_uint64;
    loopPointBegInPCMFrames: ma_uint64;
    loopPointEndInPCMFrames: ma_uint64;
    isLooping: ma_bool32;
    flags: ma_uint32;
  end;

  P_anonymous_type_82 = ^_anonymous_type_82;
  _anonymous_type_82 = record
    pData: Pointer;
    sizeInBytes: NativeUInt;
  end;

  P_anonymous_type_83 = ^_anonymous_type_83;
  _anonymous_type_83 = record
    pData: Pointer;
    totalFrameCount: ma_uint64;
    decodedFrameCount: ma_uint64;
    format: ma_format;
    channels: ma_uint32;
    sampleRate: ma_uint32;
  end;

  P_anonymous_type_84 = ^_anonymous_type_84;
  _anonymous_type_84 = record
    data: ma_paged_audio_buffer_data;
    decodedFrameCount: ma_uint64;
    sampleRate: ma_uint32;
  end;

  P_anonymous_type_85 = ^_anonymous_type_85;
  _anonymous_type_85 = record
    case Integer of
      0: (encoded: _anonymous_type_82);
      1: (decoded: _anonymous_type_83);
      2: (decodedPaged: _anonymous_type_84);
  end;

  ma_resource_manager_data_supply = record
    &type: ma_resource_manager_data_supply_type;
    backend: _anonymous_type_85;
  end;

  ma_resource_manager_data_buffer_node = record
    hashedName32: ma_uint32;
    refCount: ma_uint32;
    result: ma_result;
    executionCounter: ma_uint32;
    executionPointer: ma_uint32;
    isDataOwnedByResourceManager: ma_bool32;
    data: ma_resource_manager_data_supply;
    pParent: Pma_resource_manager_data_buffer_node;
    pChildLo: Pma_resource_manager_data_buffer_node;
    pChildHi: Pma_resource_manager_data_buffer_node;
  end;

  P_anonymous_type_86 = ^_anonymous_type_86;
  _anonymous_type_86 = record
    case Integer of
      0: (decoder: ma_decoder);
      1: (buffer: ma_audio_buffer);
      2: (pagedBuffer: ma_paged_audio_buffer);
  end;

  ma_resource_manager_data_buffer = record
    ds: ma_data_source_base;
    pResourceManager: Pma_resource_manager;
    pNode: Pma_resource_manager_data_buffer_node;
    flags: ma_uint32;
    executionCounter: ma_uint32;
    executionPointer: ma_uint32;
    seekTargetInPCMFrames: ma_uint64;
    seekToCursorOnNextRead: ma_bool32;
    result: ma_result;
    isLooping: ma_bool32;
    isConnectorInitialized: ma_atomic_bool32;
    connector: _anonymous_type_86;
  end;

  ma_resource_manager_data_stream = record
    ds: ma_data_source_base;
    pResourceManager: Pma_resource_manager;
    flags: ma_uint32;
    decoder: ma_decoder;
    isDecoderInitialized: ma_bool32;
    totalLengthInPCMFrames: ma_uint64;
    relativeCursor: ma_uint32;
    absoluteCursor: ma_uint64;
    currentPageIndex: ma_uint32;
    executionCounter: ma_uint32;
    executionPointer: ma_uint32;
    isLooping: ma_bool32;
    pPageData: Pointer;
    pageFrameCount: array [0..1] of ma_uint32;
    result: ma_result;
    isDecoderAtEnd: ma_bool32;
    isPageValid: array [0..1] of ma_bool32;
    seekCounter: ma_bool32;
  end;

  P_anonymous_type_87 = ^_anonymous_type_87;
  _anonymous_type_87 = record
    case Integer of
      0: (buffer: ma_resource_manager_data_buffer);
      1: (stream: ma_resource_manager_data_stream);
  end;

  ma_resource_manager_data_source = record
    backend: _anonymous_type_87;
    flags: ma_uint32;
    executionCounter: ma_uint32;
    executionPointer: ma_uint32;
  end;

  ma_resource_manager_config = record
    allocationCallbacks: ma_allocation_callbacks;
    pLog: Pma_log;
    decodedFormat: ma_format;
    decodedChannels: ma_uint32;
    decodedSampleRate: ma_uint32;
    jobThreadCount: ma_uint32;
    jobThreadStackSize: NativeUInt;
    jobQueueCapacity: ma_uint32;
    flags: ma_uint32;
    pVFS: Pma_vfs;
    ppCustomDecodingBackendVTables: PPma_decoding_backend_vtable;
    customDecodingBackendCount: ma_uint32;
    pCustomDecodingBackendUserData: Pointer;
  end;

  ma_resource_manager = record
    config: ma_resource_manager_config;
    pRootDataBufferNode: Pma_resource_manager_data_buffer_node;
    dataBufferBSTLock: ma_mutex;
    jobThreads: array [0..63] of ma_thread;
    jobQueue: ma_job_queue;
    defaultVFS: ma_default_vfs;
    log: ma_log;
  end;

  Pma_node = Pointer;
  PPma_node = ^Pma_node;

  ma_node_vtable = record
    onProcess: procedure(pNode: Pma_node; ppFramesIn: PPSingle; pFrameCountIn: Pma_uint32; ppFramesOut: PPSingle; pFrameCountOut: Pma_uint32); cdecl;
    onGetRequiredInputFrameCount: function(pNode: Pma_node; outputFrameCount: ma_uint32; pInputFrameCount: Pma_uint32): ma_result; cdecl;
    inputBusCount: ma_uint8;
    outputBusCount: ma_uint8;
    flags: ma_uint32;
  end;

  ma_node_config = record
    vtable: Pma_node_vtable;
    initialState: ma_node_state;
    inputBusCount: ma_uint32;
    outputBusCount: ma_uint32;
    pInputChannels: Pma_uint32;
    pOutputChannels: Pma_uint32;
  end;

  ma_node_output_bus = record
    pNode: Pma_node;
    outputBusIndex: ma_uint8;
    channels: ma_uint8;
    inputNodeInputBusIndex: ma_uint8;
    flags: ma_uint32;
    refCount: ma_uint32;
    isAttached: ma_bool32;
    lock: ma_spinlock;
    volume: Single;
    pNext: Pma_node_output_bus;
    pPrev: Pma_node_output_bus;
    pInputNode: Pma_node;
  end;

  ma_node_input_bus = record
    head: ma_node_output_bus;
    nextCounter: ma_uint32;
    lock: ma_spinlock;
    channels: ma_uint8;
  end;

  ma_node_base = record
    pNodeGraph: Pma_node_graph;
    vtable: Pma_node_vtable;
    pCachedData: PSingle;
    cachedDataCapInFramesPerBus: ma_uint16;
    cachedFrameCountOut: ma_uint16;
    cachedFrameCountIn: ma_uint16;
    consumedFrameCountIn: ma_uint16;
    state: ma_node_state;
    stateTimes: array [0..1] of ma_uint64;
    localTime: ma_uint64;
    inputBusCount: ma_uint32;
    outputBusCount: ma_uint32;
    pInputBuses: Pma_node_input_bus;
    pOutputBuses: Pma_node_output_bus;
    _inputBuses: array [0..1] of ma_node_input_bus;
    _outputBuses: array [0..1] of ma_node_output_bus;
    _pHeap: Pointer;
    _ownsHeap: ma_bool32;
  end;

  ma_node_graph_config = record
    channels: ma_uint32;
    nodeCacheCapInFrames: ma_uint16;
  end;

  ma_node_graph = record
    base: ma_node_base;
    endpoint: ma_node_base;
    nodeCacheCapInFrames: ma_uint16;
    isReading: ma_bool32;
  end;

  ma_data_source_node_config = record
    nodeConfig: ma_node_config;
    pDataSource: Pma_data_source;
  end;

  ma_data_source_node = record
    base: ma_node_base;
    pDataSource: Pma_data_source;
  end;

  ma_splitter_node_config = record
    nodeConfig: ma_node_config;
    channels: ma_uint32;
    outputBusCount: ma_uint32;
  end;

  ma_splitter_node = record
    base: ma_node_base;
  end;

  ma_biquad_node_config = record
    nodeConfig: ma_node_config;
    biquad: ma_biquad_config;
  end;

  ma_biquad_node = record
    baseNode: ma_node_base;
    biquad: ma_biquad;
  end;

  ma_lpf_node_config = record
    nodeConfig: ma_node_config;
    lpf: ma_lpf_config;
  end;

  ma_lpf_node = record
    baseNode: ma_node_base;
    lpf: ma_lpf;
  end;

  ma_hpf_node_config = record
    nodeConfig: ma_node_config;
    hpf: ma_hpf_config;
  end;

  ma_hpf_node = record
    baseNode: ma_node_base;
    hpf: ma_hpf;
  end;

  ma_bpf_node_config = record
    nodeConfig: ma_node_config;
    bpf: ma_bpf_config;
  end;

  ma_bpf_node = record
    baseNode: ma_node_base;
    bpf: ma_bpf;
  end;

  ma_notch_node_config = record
    nodeConfig: ma_node_config;
    notch: ma_notch_config;
  end;

  ma_notch_node = record
    baseNode: ma_node_base;
    notch: ma_notch2;
  end;

  ma_peak_node_config = record
    nodeConfig: ma_node_config;
    peak: ma_peak_config;
  end;

  ma_peak_node = record
    baseNode: ma_node_base;
    peak: ma_peak2;
  end;

  ma_loshelf_node_config = record
    nodeConfig: ma_node_config;
    loshelf: ma_loshelf_config;
  end;

  ma_loshelf_node = record
    baseNode: ma_node_base;
    loshelf: ma_loshelf2;
  end;

  ma_hishelf_node_config = record
    nodeConfig: ma_node_config;
    hishelf: ma_hishelf_config;
  end;

  ma_hishelf_node = record
    baseNode: ma_node_base;
    hishelf: ma_hishelf2;
  end;

  ma_delay_node_config = record
    nodeConfig: ma_node_config;
    delay: ma_delay_config;
  end;

  ma_delay_node = record
    baseNode: ma_node_base;
    delay: ma_delay;
  end;

  ma_engine_node_config = record
    pEngine: Pma_engine;
    &type: ma_engine_node_type;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    sampleRate: ma_uint32;
    volumeSmoothTimeInPCMFrames: ma_uint32;
    monoExpansionMode: ma_mono_expansion_mode;
    isPitchDisabled: ma_bool8;
    isSpatializationDisabled: ma_bool8;
    pinnedListenerIndex: ma_uint8;
  end;

  P_anonymous_type_88 = ^_anonymous_type_88;
  _anonymous_type_88 = record
    volumeBeg: ma_atomic_float;
    volumeEnd: ma_atomic_float;
    fadeLengthInFrames: ma_atomic_uint64;
    absoluteGlobalTimeInFrames: ma_atomic_uint64;
  end;

  ma_engine_node = record
    baseNode: ma_node_base;
    pEngine: Pma_engine;
    sampleRate: ma_uint32;
    volumeSmoothTimeInPCMFrames: ma_uint32;
    monoExpansionMode: ma_mono_expansion_mode;
    fader: ma_fader;
    resampler: ma_linear_resampler;
    spatializer: ma_spatializer;
    panner: ma_panner;
    volumeGainer: ma_gainer;
    volume: ma_atomic_float;
    pitch: Single;
    oldPitch: Single;
    oldDopplerPitch: Single;
    isPitchDisabled: ma_bool32;
    isSpatializationDisabled: ma_bool32;
    pinnedListenerIndex: ma_uint32;
    fadeSettings: _anonymous_type_88;
    _ownsHeap: ma_bool8;
    _pHeap: Pointer;
  end;

  ma_sound_end_proc = procedure(pUserData: Pointer; pSound: Pma_sound); cdecl;

  ma_sound_config = record
    pFilePath: PUTF8Char;
    pFilePathW: PWideChar;
    pDataSource: Pma_data_source;
    pInitialAttachment: Pma_node;
    initialAttachmentInputBusIndex: ma_uint32;
    channelsIn: ma_uint32;
    channelsOut: ma_uint32;
    monoExpansionMode: ma_mono_expansion_mode;
    flags: ma_uint32;
    volumeSmoothTimeInPCMFrames: ma_uint32;
    initialSeekPointInPCMFrames: ma_uint64;
    rangeBegInPCMFrames: ma_uint64;
    rangeEndInPCMFrames: ma_uint64;
    loopPointBegInPCMFrames: ma_uint64;
    loopPointEndInPCMFrames: ma_uint64;
    isLooping: ma_bool32;
    endCallback: ma_sound_end_proc;
    pEndCallbackUserData: Pointer;
    initNotifications: ma_resource_manager_pipeline_notifications;
    pDoneFence: Pma_fence;
  end;

  ma_sound = record
    engineNode: ma_engine_node;
    pDataSource: Pma_data_source;
    seekTarget: ma_uint64;
    atEnd: ma_bool32;
    endCallback: ma_sound_end_proc;
    pEndCallbackUserData: Pointer;
    ownsDataSource: ma_bool8;
    pResourceManagerDataSource: Pma_resource_manager_data_source;
  end;

  ma_sound_inlined = record
    sound: ma_sound;
    pNext: Pma_sound_inlined;
    pPrev: Pma_sound_inlined;
  end;

  ma_sound_group_config = ma_sound_config;
  Pma_sound_group_config = ^ma_sound_group_config;
  ma_sound_group = ma_sound;
  Pma_sound_group = ^ma_sound_group;

  ma_engine_process_proc = procedure(pUserData: Pointer; pFramesOut: PSingle; frameCount: ma_uint64); cdecl;

  ma_engine_config = record
    pResourceManager: Pma_resource_manager;
    pContext: Pma_context;
    pDevice: Pma_device;
    pPlaybackDeviceID: Pma_device_id;
    dataCallback: ma_device_data_proc;
    notificationCallback: ma_device_notification_proc;
    pLog: Pma_log;
    listenerCount: ma_uint32;
    channels: ma_uint32;
    sampleRate: ma_uint32;
    periodSizeInFrames: ma_uint32;
    periodSizeInMilliseconds: ma_uint32;
    gainSmoothTimeInFrames: ma_uint32;
    gainSmoothTimeInMilliseconds: ma_uint32;
    defaultVolumeSmoothTimeInPCMFrames: ma_uint32;
    allocationCallbacks: ma_allocation_callbacks;
    noAutoStart: ma_bool32;
    noDevice: ma_bool32;
    monoExpansionMode: ma_mono_expansion_mode;
    pResourceManagerVFS: Pma_vfs;
    onProcess: ma_engine_process_proc;
    pProcessUserData: Pointer;
  end;

  ma_engine = record
    nodeGraph: ma_node_graph;
    pResourceManager: Pma_resource_manager;
    pDevice: Pma_device;
    pLog: Pma_log;
    sampleRate: ma_uint32;
    listenerCount: ma_uint32;
    listeners: array [0..3] of ma_spatializer_listener;
    allocationCallbacks: ma_allocation_callbacks;
    ownsResourceManager: ma_bool8;
    ownsDevice: ma_bool8;
    inlinedSoundLock: ma_spinlock;
    pInlinedSoundHead: Pma_sound_inlined;
    inlinedSoundCount: ma_uint32;
    gainSmoothTimeInFrames: ma_uint32;
    defaultVolumeSmoothTimeInPCMFrames: ma_uint32;
    monoExpansionMode: ma_mono_expansion_mode;
    onProcess: ma_engine_process_proc;
    pProcessUserData: Pointer;
  end;

  voidp = Pointer;
  unzFile = voidp;
  zipFile = voidp;
  uInt = Cardinal;
  uLong = Longword;
  Bytef = &Byte;
  PBytef = ^Bytef;

  tm_zip_s = record
    tm_sec: Integer;
    tm_min: Integer;
    tm_hour: Integer;
    tm_mday: Integer;
    tm_mon: Integer;
    tm_year: Integer;
  end;

  tm_zip = tm_zip_s;

  zip_fileinfo = record
    tmz_date: tm_zip;
    dosDate: uLong;
    internal_fa: uLong;
    external_fa: uLong;
  end;

  tm_unz_s = record
    tm_sec: Integer;
    tm_min: Integer;
    tm_hour: Integer;
    tm_mday: Integer;
    tm_mon: Integer;
    tm_year: Integer;
  end;

  tm_unz = tm_unz_s;

  unz_file_info64_s = record
    version: uLong;
    version_needed: uLong;
    flag: uLong;
    compression_method: uLong;
    dosDate: uLong;
    crc: uLong;
    compressed_size: UInt64;
    uncompressed_size: UInt64;
    size_filename: uLong;
    size_file_extra: uLong;
    size_file_comment: uLong;
    disk_num_start: uLong;
    internal_fa: uLong;
    external_fa: uLong;
    tmu_date: tm_unz;
  end;

  unz_file_info64 = unz_file_info64_s;
  Punz_file_info64 = ^unz_file_info64;
  Psqlite3 = Pointer;
  PPsqlite3 = ^Psqlite3;
  sqlite_int64 = Int64;
  sqlite_uint64 = UInt64;
  sqlite3_int64 = sqlite_int64;
  Psqlite3_int64 = ^sqlite3_int64;
  sqlite3_uint64 = sqlite_uint64;

  sqlite3_callback = function(p1: Pointer; p2: Integer; p3: PPUTF8Char; p4: PPUTF8Char): Integer; cdecl;

  sqlite3_file = record
    pMethods: Psqlite3_io_methods;
  end;

  sqlite3_io_methods = record
    iVersion: Integer;
    xClose: function(p1: Psqlite3_file): Integer; cdecl;
    xRead: function(p1: Psqlite3_file; p2: Pointer; iAmt: Integer; iOfst: sqlite3_int64): Integer; cdecl;
    xWrite: function(p1: Psqlite3_file; const p2: Pointer; iAmt: Integer; iOfst: sqlite3_int64): Integer; cdecl;
    xTruncate: function(p1: Psqlite3_file; size: sqlite3_int64): Integer; cdecl;
    xSync: function(p1: Psqlite3_file; flags: Integer): Integer; cdecl;
    xFileSize: function(p1: Psqlite3_file; pSize: Psqlite3_int64): Integer; cdecl;
    xLock: function(p1: Psqlite3_file; p2: Integer): Integer; cdecl;
    xUnlock: function(p1: Psqlite3_file; p2: Integer): Integer; cdecl;
    xCheckReservedLock: function(p1: Psqlite3_file; pResOut: PInteger): Integer; cdecl;
    xFileControl: function(p1: Psqlite3_file; op: Integer; pArg: Pointer): Integer; cdecl;
    xSectorSize: function(p1: Psqlite3_file): Integer; cdecl;
    xDeviceCharacteristics: function(p1: Psqlite3_file): Integer; cdecl;
    xShmMap: function(p1: Psqlite3_file; iPg: Integer; pgsz: Integer; p4: Integer; p5: PPointer): Integer; cdecl;
    xShmLock: function(p1: Psqlite3_file; offset: Integer; n: Integer; flags: Integer): Integer; cdecl;
    xShmBarrier: procedure(p1: Psqlite3_file); cdecl;
    xShmUnmap: function(p1: Psqlite3_file; deleteFlag: Integer): Integer; cdecl;
    xFetch: function(p1: Psqlite3_file; iOfst: sqlite3_int64; iAmt: Integer; pp: PPointer): Integer; cdecl;
    xUnfetch: function(p1: Psqlite3_file; iOfst: sqlite3_int64; p: Pointer): Integer; cdecl;
  end;

  Psqlite3_mutex = Pointer;
  PPsqlite3_mutex = ^Psqlite3_mutex;
  sqlite3_filename = PUTF8Char;

  sqlite3_syscall_ptr = procedure(); cdecl;

  Pvoid = Pointer;
  sqlite3_vfs = record
    iVersion: Integer;
    szOsFile: Integer;
    mxPathname: Integer;
    pNext: Psqlite3_vfs;
    zName: PUTF8Char;
    pAppData: Pointer;
    xOpen: function(p1: Psqlite3_vfs; zName: sqlite3_filename; p3: Psqlite3_file; flags: Integer; pOutFlags: PInteger): Integer; cdecl;
    xDelete: function(p1: Psqlite3_vfs; const zName: PUTF8Char; syncDir: Integer): Integer; cdecl;
    xAccess: function(p1: Psqlite3_vfs; const zName: PUTF8Char; flags: Integer; pResOut: PInteger): Integer; cdecl;
    xFullPathname: function(p1: Psqlite3_vfs; const zName: PUTF8Char; nOut: Integer; zOut: PUTF8Char): Integer; cdecl;
    xDlOpen: function(p1: Psqlite3_vfs; const zFilename: PUTF8Char): Pointer; cdecl;
    xDlError: procedure(p1: Psqlite3_vfs; nByte: Integer; zErrMsg: PUTF8Char); cdecl;
    xDlSym: function(p1: Psqlite3_vfs; p2: Pointer; const zSymbol: PUTF8Char): Pvoid; cdecl;
    xDlClose: procedure(p1: Psqlite3_vfs; p2: Pointer); cdecl;
    xRandomness: function(p1: Psqlite3_vfs; nByte: Integer; zOut: PUTF8Char): Integer; cdecl;
    xSleep: function(p1: Psqlite3_vfs; microseconds: Integer): Integer; cdecl;
    xCurrentTime: function(p1: Psqlite3_vfs; p2: PDouble): Integer; cdecl;
    xGetLastError: function(p1: Psqlite3_vfs; p2: Integer; p3: PUTF8Char): Integer; cdecl;
    xCurrentTimeInt64: function(p1: Psqlite3_vfs; p2: Psqlite3_int64): Integer; cdecl;
    xSetSystemCall: function(p1: Psqlite3_vfs; const zName: PUTF8Char; p3: sqlite3_syscall_ptr): Integer; cdecl;
    xGetSystemCall: function(p1: Psqlite3_vfs; const zName: PUTF8Char): sqlite3_syscall_ptr; cdecl;
    xNextSystemCall: function(p1: Psqlite3_vfs; const zName: PUTF8Char): PUTF8Char; cdecl;
  end;

  sqlite3_mem_methods = record
    xMalloc: function(p1: Integer): Pointer; cdecl;
    xFree: procedure(p1: Pointer); cdecl;
    xRealloc: function(p1: Pointer; p2: Integer): Pointer; cdecl;
    xSize: function(p1: Pointer): Integer; cdecl;
    xRoundup: function(p1: Integer): Integer; cdecl;
    xInit: function(p1: Pointer): Integer; cdecl;
    xShutdown: procedure(p1: Pointer); cdecl;
    pAppData: Pointer;
  end;

  Psqlite3_stmt = Pointer;
  PPsqlite3_stmt = ^Psqlite3_stmt;
  Psqlite3_value = Pointer;
  PPsqlite3_value = ^Psqlite3_value;
  Psqlite3_context = Pointer;
  PPsqlite3_context = ^Psqlite3_context;

  sqlite3_destructor_type = procedure(p1: Pointer); cdecl;

  PPvoid = ^Pvoid;
  TpxFunc = procedure(pCtx: Psqlite3_context; n: Integer; apVal: PPsqlite3_value);
  sqlite3_module = record
    iVersion: Integer;
    xCreate: function(p1: Psqlite3; pAux: Pointer; argc: Integer; const argv: PPUTF8Char; ppVTab: PPsqlite3_vtab; p6: PPUTF8Char): Integer; cdecl;
    xConnect: function(p1: Psqlite3; pAux: Pointer; argc: Integer; const argv: PPUTF8Char; ppVTab: PPsqlite3_vtab; p6: PPUTF8Char): Integer; cdecl;
    xBestIndex: function(pVTab: Psqlite3_vtab; p2: Psqlite3_index_info): Integer; cdecl;
    xDisconnect: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xDestroy: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xOpen: function(pVTab: Psqlite3_vtab; ppCursor: PPsqlite3_vtab_cursor): Integer; cdecl;
    xClose: function(p1: Psqlite3_vtab_cursor): Integer; cdecl;
    xFilter: function(p1: Psqlite3_vtab_cursor; idxNum: Integer; const idxStr: PUTF8Char; argc: Integer; argv: PPsqlite3_value): Integer; cdecl;
    xNext: function(p1: Psqlite3_vtab_cursor): Integer; cdecl;
    xEof: function(p1: Psqlite3_vtab_cursor): Integer; cdecl;
    xColumn: function(p1: Psqlite3_vtab_cursor; p2: Psqlite3_context; p3: Integer): Integer; cdecl;
    xRowid: function(p1: Psqlite3_vtab_cursor; pRowid: Psqlite3_int64): Integer; cdecl;
    xUpdate: function(p1: Psqlite3_vtab; p2: Integer; p3: PPsqlite3_value; p4: Psqlite3_int64): Integer; cdecl;
    xBegin: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xSync: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xCommit: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xRollback: function(pVTab: Psqlite3_vtab): Integer; cdecl;
    xFindFunction: function(pVtab: Psqlite3_vtab; nArg: Integer; zName: PAnsiChar; var pxFunc: TpxFunc; var ppArg: Pointer): Integer; cdecl;
    xRename: function(pVtab: Psqlite3_vtab; const zNew: PUTF8Char): Integer; cdecl;
    xSavepoint: function(pVTab: Psqlite3_vtab; p2: Integer): Integer; cdecl;
    xRelease: function(pVTab: Psqlite3_vtab; p2: Integer): Integer; cdecl;
    xRollbackTo: function(pVTab: Psqlite3_vtab; p2: Integer): Integer; cdecl;
    xShadowName: function(const p1: PUTF8Char): Integer; cdecl;
    xIntegrity: function(pVTab: Psqlite3_vtab; const zSchema: PUTF8Char; const zTabName: PUTF8Char; mFlags: Integer; pzErr: PPUTF8Char): Integer; cdecl;
  end;

  sqlite3_index_constraint = record
    iColumn: Integer;
    op: Byte;
    usable: Byte;
    iTermOffset: Integer;
  end;

  sqlite3_index_orderby = record
    iColumn: Integer;
    desc: Byte;
  end;

  sqlite3_index_constraint_usage = record
    argvIndex: Integer;
    omit: Byte;
  end;

  sqlite3_index_info = record
    nConstraint: Integer;
    aConstraint: Psqlite3_index_constraint;
    nOrderBy: Integer;
    aOrderBy: Psqlite3_index_orderby;
    aConstraintUsage: Psqlite3_index_constraint_usage;
    idxNum: Integer;
    idxStr: PUTF8Char;
    needToFreeIdxStr: Integer;
    orderByConsumed: Integer;
    estimatedCost: Double;
    estimatedRows: sqlite3_int64;
    idxFlags: Integer;
    colUsed: sqlite3_uint64;
  end;

  sqlite3_vtab = record
    pModule: Psqlite3_module;
    nRef: Integer;
    zErrMsg: PUTF8Char;
  end;

  sqlite3_vtab_cursor = record
    pVtab: Psqlite3_vtab;
  end;

  Psqlite3_blob = Pointer;
  PPsqlite3_blob = ^Psqlite3_blob;

  sqlite3_mutex_methods = record
    xMutexInit: function(): Integer; cdecl;
    xMutexEnd: function(): Integer; cdecl;
    xMutexAlloc: function(p1: Integer): Psqlite3_mutex; cdecl;
    xMutexFree: procedure(p1: Psqlite3_mutex); cdecl;
    xMutexEnter: procedure(p1: Psqlite3_mutex); cdecl;
    xMutexTry: function(p1: Psqlite3_mutex): Integer; cdecl;
    xMutexLeave: procedure(p1: Psqlite3_mutex); cdecl;
    xMutexHeld: function(p1: Psqlite3_mutex): Integer; cdecl;
    xMutexNotheld: function(p1: Psqlite3_mutex): Integer; cdecl;
  end;

  Psqlite3_str = Pointer;
  PPsqlite3_str = ^Psqlite3_str;
  Psqlite3_pcache = Pointer;
  PPsqlite3_pcache = ^Psqlite3_pcache;

  sqlite3_pcache_page = record
    pBuf: Pointer;
    pExtra: Pointer;
  end;

  sqlite3_pcache_methods2 = record
    iVersion: Integer;
    pArg: Pointer;
    xInit: function(p1: Pointer): Integer; cdecl;
    xShutdown: procedure(p1: Pointer); cdecl;
    xCreate: function(szPage: Integer; szExtra: Integer; bPurgeable: Integer): Psqlite3_pcache; cdecl;
    xCachesize: procedure(p1: Psqlite3_pcache; nCachesize: Integer); cdecl;
    xPagecount: function(p1: Psqlite3_pcache): Integer; cdecl;
    xFetch: function(p1: Psqlite3_pcache; key: Cardinal; createFlag: Integer): Psqlite3_pcache_page; cdecl;
    xUnpin: procedure(p1: Psqlite3_pcache; p2: Psqlite3_pcache_page; discard: Integer); cdecl;
    xRekey: procedure(p1: Psqlite3_pcache; p2: Psqlite3_pcache_page; oldKey: Cardinal; newKey: Cardinal); cdecl;
    xTruncate: procedure(p1: Psqlite3_pcache; iLimit: Cardinal); cdecl;
    xDestroy: procedure(p1: Psqlite3_pcache); cdecl;
    xShrink: procedure(p1: Psqlite3_pcache); cdecl;
  end;

  sqlite3_pcache_methods = record
    pArg: Pointer;
    xInit: function(p1: Pointer): Integer; cdecl;
    xShutdown: procedure(p1: Pointer); cdecl;
    xCreate: function(szPage: Integer; bPurgeable: Integer): Psqlite3_pcache; cdecl;
    xCachesize: procedure(p1: Psqlite3_pcache; nCachesize: Integer); cdecl;
    xPagecount: function(p1: Psqlite3_pcache): Integer; cdecl;
    xFetch: function(p1: Psqlite3_pcache; key: Cardinal; createFlag: Integer): Pointer; cdecl;
    xUnpin: procedure(p1: Psqlite3_pcache; p2: Pointer; discard: Integer); cdecl;
    xRekey: procedure(p1: Psqlite3_pcache; p2: Pointer; oldKey: Cardinal; newKey: Cardinal); cdecl;
    xTruncate: procedure(p1: Psqlite3_pcache; iLimit: Cardinal); cdecl;
    xDestroy: procedure(p1: Psqlite3_pcache); cdecl;
  end;

  Psqlite3_backup = Pointer;
  PPsqlite3_backup = ^Psqlite3_backup;

  sqlite3_snapshot = record
    hidden: array [0..47] of Byte;
  end;

  sqlite3_rtree_dbl = Double;
  Psqlite3_rtree_dbl = ^sqlite3_rtree_dbl;

  sqlite3_rtree_geometry = record
    pContext: Pointer;
    nParam: Integer;
    aParam: Psqlite3_rtree_dbl;
    pUser: Pointer;
    xDelUser: procedure(p1: Pointer); cdecl;
  end;

  sqlite3_rtree_query_info = record
    pContext: Pointer;
    nParam: Integer;
    aParam: Psqlite3_rtree_dbl;
    pUser: Pointer;
    xDelUser: procedure(p1: Pointer); cdecl;
    aCoord: Psqlite3_rtree_dbl;
    anQueue: PCardinal;
    nCoord: Integer;
    iLevel: Integer;
    mxLevel: Integer;
    iRowid: sqlite3_int64;
    rParentScore: sqlite3_rtree_dbl;
    eParentWithin: Integer;
    eWithin: Integer;
    rScore: sqlite3_rtree_dbl;
    apSqlParam: PPsqlite3_value;
  end;

  PFts5Context = Pointer;
  PPFts5Context = ^PFts5Context;

  fts5_extension_function = procedure(const pApi: PFts5ExtensionApi; pFts: PFts5Context; pCtx: Psqlite3_context; nVal: Integer; apVal: PPsqlite3_value); cdecl;

  Fts5PhraseIter = record
    a: PByte;
    b: PByte;
  end;

  Fts5ExtensionApi = record
    iVersion: Integer;
    xUserData: function(p1: PFts5Context): Pointer; cdecl;
    xColumnCount: function(p1: PFts5Context): Integer; cdecl;
    xRowCount: function(p1: PFts5Context; pnRow: Psqlite3_int64): Integer; cdecl;
    xColumnTotalSize: function(p1: PFts5Context; iCol: Integer; pnToken: Psqlite3_int64): Integer; cdecl;
    xTokenize: function(p1: PFts5Context; const pText: PUTF8Char; nText: Integer; pCtx: Pointer; xToken: Pointer): Integer; cdecl;
    xPhraseCount: function(p1: PFts5Context): Integer; cdecl;
    xPhraseSize: function(p1: PFts5Context; iPhrase: Integer): Integer; cdecl;
    xInstCount: function(p1: PFts5Context; pnInst: PInteger): Integer; cdecl;
    xInst: function(p1: PFts5Context; iIdx: Integer; piPhrase: PInteger; piCol: PInteger; piOff: PInteger): Integer; cdecl;
    xRowid: function(p1: PFts5Context): sqlite3_int64; cdecl;
    xColumnText: function(p1: PFts5Context; iCol: Integer; pz: PPUTF8Char; pn: PInteger): Integer; cdecl;
    xColumnSize: function(p1: PFts5Context; iCol: Integer; pnToken: PInteger): Integer; cdecl;
    xQueryPhrase: function(p1: PFts5Context; iPhrase: Integer; pUserData: Pointer; p4: Pointer): Integer; cdecl;
    xSetAuxdata: function(p1: PFts5Context; pAux: Pointer; xDelete: Pointer): Integer; cdecl;
    xGetAuxdata: function(p1: PFts5Context; bClear: Integer): Pointer; cdecl;
    xPhraseFirst: function(p1: PFts5Context; iPhrase: Integer; p3: PFts5PhraseIter; p4: PInteger; p5: PInteger): Integer; cdecl;
    xPhraseNext: procedure(p1: PFts5Context; p2: PFts5PhraseIter; piCol: PInteger; piOff: PInteger); cdecl;
    xPhraseFirstColumn: function(p1: PFts5Context; iPhrase: Integer; p3: PFts5PhraseIter; p4: PInteger): Integer; cdecl;
    xPhraseNextColumn: procedure(p1: PFts5Context; p2: PFts5PhraseIter; piCol: PInteger); cdecl;
    xQueryToken: function(p1: PFts5Context; iPhrase: Integer; iToken: Integer; ppToken: PPUTF8Char; pnToken: PInteger): Integer; cdecl;
    xInstToken: function(p1: PFts5Context; iIdx: Integer; iToken: Integer; p4: PPUTF8Char; p5: PInteger): Integer; cdecl;
    xColumnLocale: function(p1: PFts5Context; iCol: Integer; pz: PPUTF8Char; pn: PInteger): Integer; cdecl;
    xTokenize_v2: function(p1: PFts5Context; const pText: PUTF8Char; nText: Integer; const pLocale: PUTF8Char; nLocale: Integer; pCtx: Pointer; xToken: Pointer): Integer; cdecl;
  end;

  PFts5Tokenizer = Pointer;
  PPFts5Tokenizer = ^PFts5Tokenizer;

  fts5_tokenizer_v2 = record
    iVersion: Integer;
    xCreate: function(p1: Pointer; azArg: PPUTF8Char; nArg: Integer; ppOut: PPFts5Tokenizer): Integer; cdecl;
    xDelete: procedure(p1: PFts5Tokenizer); cdecl;
    xTokenize: function(p1: PFts5Tokenizer; pCtx: Pointer; flags: Integer; const pText: PUTF8Char; nText: Integer; const pLocale: PUTF8Char; nLocale: Integer; xToken: Pointer): Integer; cdecl;
  end;

  fts5_tokenizer = record
    xCreate: function(p1: Pointer; azArg: PPUTF8Char; nArg: Integer; ppOut: PPFts5Tokenizer): Integer; cdecl;
    xDelete: procedure(p1: PFts5Tokenizer); cdecl;
    xTokenize: function(p1: PFts5Tokenizer; pCtx: Pointer; flags: Integer; const pText: PUTF8Char; nText: Integer; xToken: Pointer): Integer; cdecl;
  end;

  fts5_api = record
    iVersion: Integer;
    xCreateTokenizer: function(pApi: Pfts5_api; const zName: PUTF8Char; pUserData: Pointer; pTokenizer: Pfts5_tokenizer; xDestroy: Pointer): Integer; cdecl;
    xFindTokenizer: function(pApi: Pfts5_api; const zName: PUTF8Char; ppUserData: PPointer; pTokenizer: Pfts5_tokenizer): Integer; cdecl;
    xCreateFunction: function(pApi: Pfts5_api; const zName: PUTF8Char; pUserData: Pointer; xFunction: fts5_extension_function; xDestroy: Pointer): Integer; cdecl;
    xCreateTokenizer_v2: function(pApi: Pfts5_api; const zName: PUTF8Char; pUserData: Pointer; pTokenizer: Pfts5_tokenizer_v2; xDestroy: Pointer): Integer; cdecl;
    xFindTokenizer_v2: function(pApi: Pfts5_api; const zName: PUTF8Char; ppUserData: PPointer; ppTokenizer: PPfts5_tokenizer_v2): Integer; cdecl;
  end;

  sqlite3_api_routines = record
    aggregate_context: function(p1: Psqlite3_context; nBytes: Integer): Pointer; cdecl;
    aggregate_count: function(p1: Psqlite3_context): Integer; cdecl;
    bind_blob: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; n: Integer; p5: Pointer): Integer; cdecl;
    bind_double: function(p1: Psqlite3_stmt; p2: Integer; p3: Double): Integer; cdecl;
    bind_int: function(p1: Psqlite3_stmt; p2: Integer; p3: Integer): Integer; cdecl;
    bind_int64: function(p1: Psqlite3_stmt; p2: Integer; p3: sqlite_int64): Integer; cdecl;
    bind_null: function(p1: Psqlite3_stmt; p2: Integer): Integer; cdecl;
    bind_parameter_count: function(p1: Psqlite3_stmt): Integer; cdecl;
    bind_parameter_index: function(p1: Psqlite3_stmt; const zName: PUTF8Char): Integer; cdecl;
    bind_parameter_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
    bind_text: function(p1: Psqlite3_stmt; p2: Integer; const p3: PUTF8Char; n: Integer; p5: Pointer): Integer; cdecl;
    bind_text16: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; p4: Integer; p5: Pointer): Integer; cdecl;
    bind_value: function(p1: Psqlite3_stmt; p2: Integer; const p3: Psqlite3_value): Integer; cdecl;
    busy_handler: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Integer; cdecl;
    busy_timeout: function(p1: Psqlite3; ms: Integer): Integer; cdecl;
    changes: function(p1: Psqlite3): Integer; cdecl;
    close: function(p1: Psqlite3): Integer; cdecl;
    collation_needed: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Integer; cdecl;
    collation_needed16: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Integer; cdecl;
    column_blob: function(p1: Psqlite3_stmt; iCol: Integer): Pointer; cdecl;
    column_bytes: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
    column_bytes16: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
    column_count: function(pStmt: Psqlite3_stmt): Integer; cdecl;
    column_database_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
    column_database_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
    column_decltype: function(p1: Psqlite3_stmt; i: Integer): PUTF8Char; cdecl;
    column_decltype16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
    column_double: function(p1: Psqlite3_stmt; iCol: Integer): Double; cdecl;
    column_int: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
    column_int64: function(p1: Psqlite3_stmt; iCol: Integer): sqlite_int64; cdecl;
    column_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
    column_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
    column_origin_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
    column_origin_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
    column_table_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
    column_table_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
    column_text: function(p1: Psqlite3_stmt; iCol: Integer): PByte; cdecl;
    column_text16: function(p1: Psqlite3_stmt; iCol: Integer): Pointer; cdecl;
    column_type: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
    column_value: function(p1: Psqlite3_stmt; iCol: Integer): Psqlite3_value; cdecl;
    commit_hook: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Pointer; cdecl;
    complete: function(const sql: PUTF8Char): Integer; cdecl;
    complete16: function(const sql: Pointer): Integer; cdecl;
    create_collation: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Pointer; p5: Pointer): Integer; cdecl;
    create_collation16: function(p1: Psqlite3; const p2: Pointer; p3: Integer; p4: Pointer; p5: Pointer): Integer; cdecl;
    create_function: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Integer; p5: Pointer; xFunc: Pointer; xStep: Pointer; xFinal: Pointer): Integer; cdecl;
    create_function16: function(p1: Psqlite3; const p2: Pointer; p3: Integer; p4: Integer; p5: Pointer; xFunc: Pointer; xStep: Pointer; xFinal: Pointer): Integer; cdecl;
    create_module: function(p1: Psqlite3; const p2: PUTF8Char; const p3: Psqlite3_module; p4: Pointer): Integer; cdecl;
    data_count: function(pStmt: Psqlite3_stmt): Integer; cdecl;
    db_handle: function(p1: Psqlite3_stmt): Psqlite3; cdecl;
    declare_vtab: function(p1: Psqlite3; const p2: PUTF8Char): Integer; cdecl;
    enable_shared_cache: function(p1: Integer): Integer; cdecl;
    errcode: function(db: Psqlite3): Integer; cdecl;
    errmsg: function(p1: Psqlite3): PUTF8Char; cdecl;
    errmsg16: function(p1: Psqlite3): Pointer; cdecl;
    exec: function(p1: Psqlite3; const p2: PUTF8Char; p3: sqlite3_callback; p4: Pointer; p5: PPUTF8Char): Integer; cdecl;
    expired: function(p1: Psqlite3_stmt): Integer; cdecl;
    finalize: function(pStmt: Psqlite3_stmt): Integer; cdecl;
    free: procedure(p1: Pointer); cdecl;
    free_table: procedure(result: PPUTF8Char); cdecl;
    get_autocommit: function(p1: Psqlite3): Integer; cdecl;
    get_auxdata: function(p1: Psqlite3_context; p2: Integer): Pointer; cdecl;
    get_table: function(p1: Psqlite3; const p2: PUTF8Char; p3: PPPUTF8Char; p4: PInteger; p5: PInteger; p6: PPUTF8Char): Integer; cdecl;
    global_recover: function(): Integer; cdecl;
    interruptx: procedure(p1: Psqlite3); cdecl;
    last_insert_rowid: function(p1: Psqlite3): sqlite_int64; cdecl;
    libversion: function(): PUTF8Char; cdecl;
    libversion_number: function(): Integer; cdecl;
    malloc: function(p1: Integer): Pointer; cdecl;
    mprintf: function(const p1: PUTF8Char): PUTF8Char varargs; cdecl;
    open: function(const p1: PUTF8Char; p2: PPsqlite3): Integer; cdecl;
    open16: function(const p1: Pointer; p2: PPsqlite3): Integer; cdecl;
    prepare: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: PPsqlite3_stmt; p5: PPUTF8Char): Integer; cdecl;
    prepare16: function(p1: Psqlite3; const p2: Pointer; p3: Integer; p4: PPsqlite3_stmt; p5: PPointer): Integer; cdecl;
    profile: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Pointer; cdecl;
    progress_handler: procedure(p1: Psqlite3; p2: Integer; p3: Pointer; p4: Pointer); cdecl;
    realloc: function(p1: Pointer; p2: Integer): Pointer; cdecl;
    reset: function(pStmt: Psqlite3_stmt): Integer; cdecl;
    result_blob: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: Pointer); cdecl;
    result_double: procedure(p1: Psqlite3_context; p2: Double); cdecl;
    result_error: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: Integer); cdecl;
    result_error16: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer); cdecl;
    result_int: procedure(p1: Psqlite3_context; p2: Integer); cdecl;
    result_int64: procedure(p1: Psqlite3_context; p2: sqlite_int64); cdecl;
    result_null: procedure(p1: Psqlite3_context); cdecl;
    result_text: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: Integer; p4: Pointer); cdecl;
    result_text16: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: Pointer); cdecl;
    result_text16be: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: Pointer); cdecl;
    result_text16le: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: Pointer); cdecl;
    result_value: procedure(p1: Psqlite3_context; p2: Psqlite3_value); cdecl;
    rollback_hook: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Pointer; cdecl;
    set_authorizer: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Integer; cdecl;
    set_auxdata: procedure(p1: Psqlite3_context; p2: Integer; p3: Pointer; p4: Pointer); cdecl;
    xsnprintf: function(p1: Integer; p2: PUTF8Char; const p3: PUTF8Char): PUTF8Char varargs; cdecl;
    step: function(p1: Psqlite3_stmt): Integer; cdecl;
    table_column_metadata: function(p1: Psqlite3; const p2: PUTF8Char; const p3: PUTF8Char; const p4: PUTF8Char; p5: PPUTF8Char; p6: PPUTF8Char; p7: PInteger; p8: PInteger; p9: PInteger): Integer; cdecl;
    thread_cleanup: procedure(); cdecl;
    total_changes: function(p1: Psqlite3): Integer; cdecl;
    trace: function(p1: Psqlite3; xTrace: Pointer; p3: Pointer): Pointer; cdecl;
    transfer_bindings: function(p1: Psqlite3_stmt; p2: Psqlite3_stmt): Integer; cdecl;
    update_hook: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Pointer; cdecl;
    user_data: function(p1: Psqlite3_context): Pointer; cdecl;
    value_blob: function(p1: Psqlite3_value): Pointer; cdecl;
    value_bytes: function(p1: Psqlite3_value): Integer; cdecl;
    value_bytes16: function(p1: Psqlite3_value): Integer; cdecl;
    value_double: function(p1: Psqlite3_value): Double; cdecl;
    value_int: function(p1: Psqlite3_value): Integer; cdecl;
    value_int64: function(p1: Psqlite3_value): sqlite_int64; cdecl;
    value_numeric_type: function(p1: Psqlite3_value): Integer; cdecl;
    value_text: function(p1: Psqlite3_value): PByte; cdecl;
    value_text16: function(p1: Psqlite3_value): Pointer; cdecl;
    value_text16be: function(p1: Psqlite3_value): Pointer; cdecl;
    value_text16le: function(p1: Psqlite3_value): Pointer; cdecl;
    value_type: function(p1: Psqlite3_value): Integer; cdecl;
    vmprintf: function(const p1: PUTF8Char; p2: Pointer): PUTF8Char; cdecl;
    overload_function: function(p1: Psqlite3; const zFuncName: PUTF8Char; nArg: Integer): Integer; cdecl;
    prepare_v2: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: PPsqlite3_stmt; p5: PPUTF8Char): Integer; cdecl;
    prepare16_v2: function(p1: Psqlite3; const p2: Pointer; p3: Integer; p4: PPsqlite3_stmt; p5: PPointer): Integer; cdecl;
    clear_bindings: function(p1: Psqlite3_stmt): Integer; cdecl;
    create_module_v2: function(p1: Psqlite3; const p2: PUTF8Char; const p3: Psqlite3_module; p4: Pointer; xDestroy: Pointer): Integer; cdecl;
    bind_zeroblob: function(p1: Psqlite3_stmt; p2: Integer; p3: Integer): Integer; cdecl;
    blob_bytes: function(p1: Psqlite3_blob): Integer; cdecl;
    blob_close: function(p1: Psqlite3_blob): Integer; cdecl;
    blob_open: function(p1: Psqlite3; const p2: PUTF8Char; const p3: PUTF8Char; const p4: PUTF8Char; p5: sqlite3_int64; p6: Integer; p7: PPsqlite3_blob): Integer; cdecl;
    blob_read: function(p1: Psqlite3_blob; p2: Pointer; p3: Integer; p4: Integer): Integer; cdecl;
    blob_write: function(p1: Psqlite3_blob; const p2: Pointer; p3: Integer; p4: Integer): Integer; cdecl;
    create_collation_v2: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Pointer; p5: Pointer; p6: Pointer): Integer; cdecl;
    file_control: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Pointer): Integer; cdecl;
    memory_highwater: function(p1: Integer): sqlite3_int64; cdecl;
    memory_used: function(): sqlite3_int64; cdecl;
    mutex_alloc: function(p1: Integer): Psqlite3_mutex; cdecl;
    mutex_enter: procedure(p1: Psqlite3_mutex); cdecl;
    mutex_free: procedure(p1: Psqlite3_mutex); cdecl;
    mutex_leave: procedure(p1: Psqlite3_mutex); cdecl;
    mutex_try: function(p1: Psqlite3_mutex): Integer; cdecl;
    open_v2: function(const p1: PUTF8Char; p2: PPsqlite3; p3: Integer; const p4: PUTF8Char): Integer; cdecl;
    release_memory: function(p1: Integer): Integer; cdecl;
    result_error_nomem: procedure(p1: Psqlite3_context); cdecl;
    result_error_toobig: procedure(p1: Psqlite3_context); cdecl;
    sleep: function(p1: Integer): Integer; cdecl;
    soft_heap_limit: procedure(p1: Integer); cdecl;
    vfs_find: function(const p1: PUTF8Char): Psqlite3_vfs; cdecl;
    vfs_register: function(p1: Psqlite3_vfs; p2: Integer): Integer; cdecl;
    vfs_unregister: function(p1: Psqlite3_vfs): Integer; cdecl;
    xthreadsafe: function(): Integer; cdecl;
    result_zeroblob: procedure(p1: Psqlite3_context; p2: Integer); cdecl;
    result_error_code: procedure(p1: Psqlite3_context; p2: Integer); cdecl;
    test_control: function(p1: Integer): Integer varargs; cdecl;
    randomness: procedure(p1: Integer; p2: Pointer); cdecl;
    context_db_handle: function(p1: Psqlite3_context): Psqlite3; cdecl;
    extended_result_codes: function(p1: Psqlite3; p2: Integer): Integer; cdecl;
    limit: function(p1: Psqlite3; p2: Integer; p3: Integer): Integer; cdecl;
    next_stmt: function(p1: Psqlite3; p2: Psqlite3_stmt): Psqlite3_stmt; cdecl;
    sql: function(p1: Psqlite3_stmt): PUTF8Char; cdecl;
    status: function(p1: Integer; p2: PInteger; p3: PInteger; p4: Integer): Integer; cdecl;
    backup_finish: function(p1: Psqlite3_backup): Integer; cdecl;
    backup_init: function(p1: Psqlite3; const p2: PUTF8Char; p3: Psqlite3; const p4: PUTF8Char): Psqlite3_backup; cdecl;
    backup_pagecount: function(p1: Psqlite3_backup): Integer; cdecl;
    backup_remaining: function(p1: Psqlite3_backup): Integer; cdecl;
    backup_step: function(p1: Psqlite3_backup; p2: Integer): Integer; cdecl;
    compileoption_get: function(p1: Integer): PUTF8Char; cdecl;
    compileoption_used: function(const p1: PUTF8Char): Integer; cdecl;
    create_function_v2: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Integer; p5: Pointer; xFunc: Pointer; xStep: Pointer; xFinal: Pointer; xDestroy: Pointer): Integer; cdecl;
    db_config: function(p1: Psqlite3; p2: Integer): Integer varargs; cdecl;
    db_mutex: function(p1: Psqlite3): Psqlite3_mutex; cdecl;
    db_status: function(p1: Psqlite3; p2: Integer; p3: PInteger; p4: PInteger; p5: Integer): Integer; cdecl;
    extended_errcode: function(p1: Psqlite3): Integer; cdecl;
    log: procedure(p1: Integer; const p2: PUTF8Char) varargs; cdecl;
    soft_heap_limit64: function(p1: sqlite3_int64): sqlite3_int64; cdecl;
    sourceid: function(): PUTF8Char; cdecl;
    stmt_status: function(p1: Psqlite3_stmt; p2: Integer; p3: Integer): Integer; cdecl;
    strnicmp: function(const p1: PUTF8Char; const p2: PUTF8Char; p3: Integer): Integer; cdecl;
    unlock_notify: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Integer; cdecl;
    wal_autocheckpoint: function(p1: Psqlite3; p2: Integer): Integer; cdecl;
    wal_checkpoint: function(p1: Psqlite3; const p2: PUTF8Char): Integer; cdecl;
    wal_hook: function(p1: Psqlite3; p2: Pointer; p3: Pointer): Pointer; cdecl;
    blob_reopen: function(p1: Psqlite3_blob; p2: sqlite3_int64): Integer; cdecl;
    vtab_config: function(p1: Psqlite3; op: Integer): Integer varargs; cdecl;
    vtab_on_conflict: function(p1: Psqlite3): Integer; cdecl;
    close_v2: function(p1: Psqlite3): Integer; cdecl;
    db_filename: function(p1: Psqlite3; const p2: PUTF8Char): PUTF8Char; cdecl;
    db_readonly: function(p1: Psqlite3; const p2: PUTF8Char): Integer; cdecl;
    db_release_memory: function(p1: Psqlite3): Integer; cdecl;
    errstr: function(p1: Integer): PUTF8Char; cdecl;
    stmt_busy: function(p1: Psqlite3_stmt): Integer; cdecl;
    stmt_readonly: function(p1: Psqlite3_stmt): Integer; cdecl;
    stricmp: function(const p1: PUTF8Char; const p2: PUTF8Char): Integer; cdecl;
    uri_boolean: function(const p1: PUTF8Char; const p2: PUTF8Char; p3: Integer): Integer; cdecl;
    uri_int64: function(const p1: PUTF8Char; const p2: PUTF8Char; p3: sqlite3_int64): sqlite3_int64; cdecl;
    uri_parameter: function(const p1: PUTF8Char; const p2: PUTF8Char): PUTF8Char; cdecl;
    xvsnprintf: function(p1: Integer; p2: PUTF8Char; const p3: PUTF8Char; p4: Pointer): PUTF8Char; cdecl;
    wal_checkpoint_v2: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: PInteger; p5: PInteger): Integer; cdecl;
    auto_extension: function(p1: Pointer): Integer; cdecl;
    bind_blob64: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; p4: sqlite3_uint64; p5: Pointer): Integer; cdecl;
    bind_text64: function(p1: Psqlite3_stmt; p2: Integer; const p3: PUTF8Char; p4: sqlite3_uint64; p5: Pointer; p6: Byte): Integer; cdecl;
    cancel_auto_extension: function(p1: Pointer): Integer; cdecl;
    load_extension: function(p1: Psqlite3; const p2: PUTF8Char; const p3: PUTF8Char; p4: PPUTF8Char): Integer; cdecl;
    malloc64: function(p1: sqlite3_uint64): Pointer; cdecl;
    msize: function(p1: Pointer): sqlite3_uint64; cdecl;
    realloc64: function(p1: Pointer; p2: sqlite3_uint64): Pointer; cdecl;
    reset_auto_extension: procedure(); cdecl;
    result_blob64: procedure(p1: Psqlite3_context; const p2: Pointer; p3: sqlite3_uint64; p4: Pointer); cdecl;
    result_text64: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: sqlite3_uint64; p4: Pointer; p5: Byte); cdecl;
    strglob: function(const p1: PUTF8Char; const p2: PUTF8Char): Integer; cdecl;
    value_dup: function(const p1: Psqlite3_value): Psqlite3_value; cdecl;
    value_free: procedure(p1: Psqlite3_value); cdecl;
    result_zeroblob64: function(p1: Psqlite3_context; p2: sqlite3_uint64): Integer; cdecl;
    bind_zeroblob64: function(p1: Psqlite3_stmt; p2: Integer; p3: sqlite3_uint64): Integer; cdecl;
    value_subtype: function(p1: Psqlite3_value): Cardinal; cdecl;
    result_subtype: procedure(p1: Psqlite3_context; p2: Cardinal); cdecl;
    status64: function(p1: Integer; p2: Psqlite3_int64; p3: Psqlite3_int64; p4: Integer): Integer; cdecl;
    strlike: function(const p1: PUTF8Char; const p2: PUTF8Char; p3: Cardinal): Integer; cdecl;
    db_cacheflush: function(p1: Psqlite3): Integer; cdecl;
    system_errno: function(p1: Psqlite3): Integer; cdecl;
    trace_v2: function(p1: Psqlite3; p2: Cardinal; p3: Pointer; p4: Pointer): Integer; cdecl;
    expanded_sql: function(p1: Psqlite3_stmt): PUTF8Char; cdecl;
    set_last_insert_rowid: procedure(p1: Psqlite3; p2: sqlite3_int64); cdecl;
    prepare_v3: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Cardinal; p5: PPsqlite3_stmt; p6: PPUTF8Char): Integer; cdecl;
    prepare16_v3: function(p1: Psqlite3; const p2: Pointer; p3: Integer; p4: Cardinal; p5: PPsqlite3_stmt; p6: PPointer): Integer; cdecl;
    bind_pointer: function(p1: Psqlite3_stmt; p2: Integer; p3: Pointer; const p4: PUTF8Char; p5: Pointer): Integer; cdecl;
    result_pointer: procedure(p1: Psqlite3_context; p2: Pointer; const p3: PUTF8Char; p4: Pointer); cdecl;
    value_pointer: function(p1: Psqlite3_value; const p2: PUTF8Char): Pointer; cdecl;
    vtab_nochange: function(p1: Psqlite3_context): Integer; cdecl;
    value_nochange: function(p1: Psqlite3_value): Integer; cdecl;
    vtab_collation: function(p1: Psqlite3_index_info; p2: Integer): PUTF8Char; cdecl;
    keyword_count: function(): Integer; cdecl;
    keyword_name: function(p1: Integer; p2: PPUTF8Char; p3: PInteger): Integer; cdecl;
    keyword_check: function(const p1: PUTF8Char; p2: Integer): Integer; cdecl;
    str_new: function(p1: Psqlite3): Psqlite3_str; cdecl;
    str_finish: function(p1: Psqlite3_str): PUTF8Char; cdecl;
    str_appendf: procedure(p1: Psqlite3_str; const zFormat: PUTF8Char) varargs; cdecl;
    str_vappendf: procedure(p1: Psqlite3_str; const zFormat: PUTF8Char; p3: Pointer); cdecl;
    str_append: procedure(p1: Psqlite3_str; const zIn: PUTF8Char; N: Integer); cdecl;
    str_appendall: procedure(p1: Psqlite3_str; const zIn: PUTF8Char); cdecl;
    str_appendchar: procedure(p1: Psqlite3_str; N: Integer; C: UTF8Char); cdecl;
    str_reset: procedure(p1: Psqlite3_str); cdecl;
    str_errcode: function(p1: Psqlite3_str): Integer; cdecl;
    str_length: function(p1: Psqlite3_str): Integer; cdecl;
    str_value: function(p1: Psqlite3_str): PUTF8Char; cdecl;
    create_window_function: function(p1: Psqlite3; const p2: PUTF8Char; p3: Integer; p4: Integer; p5: Pointer; xStep: Pointer; xFinal: Pointer; xValue: Pointer; xInv: Pointer; xDestroy: Pointer): Integer; cdecl;
    normalized_sql: function(p1: Psqlite3_stmt): PUTF8Char; cdecl;
    stmt_isexplain: function(p1: Psqlite3_stmt): Integer; cdecl;
    value_frombind: function(p1: Psqlite3_value): Integer; cdecl;
    drop_modules: function(p1: Psqlite3; p2: PPUTF8Char): Integer; cdecl;
    hard_heap_limit64: function(p1: sqlite3_int64): sqlite3_int64; cdecl;
    uri_key: function(const p1: PUTF8Char; p2: Integer): PUTF8Char; cdecl;
    filename_database: function(const p1: PUTF8Char): PUTF8Char; cdecl;
    filename_journal: function(const p1: PUTF8Char): PUTF8Char; cdecl;
    filename_wal: function(const p1: PUTF8Char): PUTF8Char; cdecl;
    create_filename: function(const p1: PUTF8Char; const p2: PUTF8Char; const p3: PUTF8Char; p4: Integer; p5: PPUTF8Char): PUTF8Char; cdecl;
    free_filename: procedure(const p1: PUTF8Char); cdecl;
    database_file_object: function(const p1: PUTF8Char): Psqlite3_file; cdecl;
    txn_state: function(p1: Psqlite3; const p2: PUTF8Char): Integer; cdecl;
    changes64: function(p1: Psqlite3): sqlite3_int64; cdecl;
    total_changes64: function(p1: Psqlite3): sqlite3_int64; cdecl;
    autovacuum_pages: function(p1: Psqlite3; p2: Pointer; p3: Pointer; p4: Pointer): Integer; cdecl;
    error_offset: function(p1: Psqlite3): Integer; cdecl;
    vtab_rhs_value: function(p1: Psqlite3_index_info; p2: Integer; p3: PPsqlite3_value): Integer; cdecl;
    vtab_distinct: function(p1: Psqlite3_index_info): Integer; cdecl;
    vtab_in: function(p1: Psqlite3_index_info; p2: Integer; p3: Integer): Integer; cdecl;
    vtab_in_first: function(p1: Psqlite3_value; p2: PPsqlite3_value): Integer; cdecl;
    vtab_in_next: function(p1: Psqlite3_value; p2: PPsqlite3_value): Integer; cdecl;
    deserialize: function(p1: Psqlite3; const p2: PUTF8Char; p3: PByte; p4: sqlite3_int64; p5: sqlite3_int64; p6: Cardinal): Integer; cdecl;
    serialize: function(p1: Psqlite3; const p2: PUTF8Char; p3: Psqlite3_int64; p4: Cardinal): PByte; cdecl;
    db_name: function(p1: Psqlite3; p2: Integer): PUTF8Char; cdecl;
    value_encoding: function(p1: Psqlite3_value): Integer; cdecl;
    is_interrupted: function(p1: Psqlite3): Integer; cdecl;
    stmt_explain: function(p1: Psqlite3_stmt; p2: Integer): Integer; cdecl;
    get_clientdata: function(p1: Psqlite3; const p2: PUTF8Char): Pointer; cdecl;
    set_clientdata: function(p1: Psqlite3; const p2: PUTF8Char; p3: Pointer; p4: Pointer): Integer; cdecl;
  end;

  sqlite3_loadext_entry = function(db: Psqlite3; pzErrMsg: PPUTF8Char; const pThunk: Psqlite3_api_routines): Integer; cdecl;
  ImU64 = UInt64;
  PImU64 = ^ImU64;
  PImGuiDockRequest = Pointer;
  PPImGuiDockRequest = ^PImGuiDockRequest;
  PImGuiDockNodeSettings = Pointer;
  PPImGuiDockNodeSettings = ^PImGuiDockNodeSettings;
  PImGuiInputTextDeactivateData = Pointer;
  PPImGuiInputTextDeactivateData = ^PImGuiInputTextDeactivateData;
  PImGuiTableColumnsSettings = Pointer;
  PPImGuiTableColumnsSettings = ^PImGuiTableColumnsSettings;
  PSTB_TexteditState = Pointer;
  PPSTB_TexteditState = ^PSTB_TexteditState;

  ImVector_const_charPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPUTF8Char;
  end;

  ImGuiID = Cardinal;
  PImGuiID = ^ImGuiID;
  ImS8 = UTF8Char;
  ImU8 = Byte;
  PImU8 = ^ImU8;
  ImS16 = Smallint;
  ImU16 = Word;
  PImU16 = ^ImU16;
  ImS32 = Integer;
  ImU32 = Cardinal;
  PImU32 = ^ImU32;
  ImS64 = Int64;
  PImS64 = ^ImS64;
  ImGuiCol = Integer;
  ImGuiCond = Integer;
  ImGuiDataType = Integer;
  ImGuiMouseButton = Integer;
  ImGuiMouseCursor = Integer;
  ImGuiStyleVar = Integer;
  ImGuiTableBgTarget = Integer;
  ImDrawFlags = Integer;
  ImDrawListFlags = Integer;
  ImFontAtlasFlags = Integer;
  ImGuiBackendFlags = Integer;
  ImGuiButtonFlags = Integer;
  PImGuiButtonFlags = ^ImGuiButtonFlags;
  ImGuiChildFlags = Integer;
  ImGuiColorEditFlags = Integer;
  ImGuiConfigFlags = Integer;
  ImGuiComboFlags = Integer;
  ImGuiDockNodeFlags = Integer;
  ImGuiDragDropFlags = Integer;
  ImGuiFocusedFlags = Integer;
  ImGuiHoveredFlags = Integer;
  ImGuiInputFlags = Integer;
  ImGuiInputTextFlags = Integer;
  ImGuiItemFlags = Integer;
  PImGuiItemFlags = ^ImGuiItemFlags;
  ImGuiKeyChord = Integer;
  ImGuiPopupFlags = Integer;
  ImGuiMultiSelectFlags = Integer;
  ImGuiSelectableFlags = Integer;
  ImGuiSliderFlags = Integer;
  ImGuiTabBarFlags = Integer;
  ImGuiTabItemFlags = Integer;
  ImGuiTableFlags = Integer;
  ImGuiTableColumnFlags = Integer;
  ImGuiTableRowFlags = Integer;
  ImGuiTreeNodeFlags = Integer;
  ImGuiViewportFlags = Integer;
  ImGuiWindowFlags = Integer;
  ImTextureID = ImU64;
  PImTextureID = ^ImTextureID;
  ImDrawIdx = Word;
  PImDrawIdx = ^ImDrawIdx;
  ImWchar32 = Cardinal;
  ImWchar16 = Word;
  ImWchar = ImWchar16;
  PImWchar = ^ImWchar;
  ImGuiSelectionUserData = ImS64;

  ImGuiInputTextCallback = function(data: PImGuiInputTextCallbackData): Integer; cdecl;
  ImGuiSizeCallback = procedure(data: PImGuiSizeCallbackData); cdecl;
  ImGuiMemAllocFunc = function(sz: NativeUInt; user_data: Pointer): Pointer; cdecl;
  PImGuiMemAllocFunc = ^ImGuiMemAllocFunc;

  ImGuiMemFreeFunc = procedure(ptr: Pointer; user_data: Pointer); cdecl;
  PImGuiMemFreeFunc = ^ImGuiMemFreeFunc;

  ImVec2 = record
    x: Single;
    y: Single;
  end;

  ImVec4 = record
    x: Single;
    y: Single;
    z: Single;
    w: Single;
  end;

  ImGuiTableSortSpecs = record
    Specs: PImGuiTableColumnSortSpecs;
    SpecsCount: Integer;
    SpecsDirty: Boolean;
  end;

  ImGuiTableColumnSortSpecs = record
    ColumnUserID: ImGuiID;
    ColumnIndex: ImS16;
    SortOrder: ImS16;
    SortDirection: ImGuiSortDirection;
  end;

  ImGuiStyle = record
    Alpha: Single;
    DisabledAlpha: Single;
    WindowPadding: ImVec2;
    WindowRounding: Single;
    WindowBorderSize: Single;
    WindowMinSize: ImVec2;
    WindowTitleAlign: ImVec2;
    WindowMenuButtonPosition: ImGuiDir;
    ChildRounding: Single;
    ChildBorderSize: Single;
    PopupRounding: Single;
    PopupBorderSize: Single;
    FramePadding: ImVec2;
    FrameRounding: Single;
    FrameBorderSize: Single;
    ItemSpacing: ImVec2;
    ItemInnerSpacing: ImVec2;
    CellPadding: ImVec2;
    TouchExtraPadding: ImVec2;
    IndentSpacing: Single;
    ColumnsMinSpacing: Single;
    ScrollbarSize: Single;
    ScrollbarRounding: Single;
    GrabMinSize: Single;
    GrabRounding: Single;
    LogSliderDeadzone: Single;
    TabRounding: Single;
    TabBorderSize: Single;
    TabMinWidthForCloseButton: Single;
    TabBarBorderSize: Single;
    TabBarOverlineSize: Single;
    TableAngledHeadersAngle: Single;
    TableAngledHeadersTextAlign: ImVec2;
    ColorButtonPosition: ImGuiDir;
    ButtonTextAlign: ImVec2;
    SelectableTextAlign: ImVec2;
    SeparatorTextBorderSize: Single;
    SeparatorTextAlign: ImVec2;
    SeparatorTextPadding: ImVec2;
    DisplayWindowPadding: ImVec2;
    DisplaySafeAreaPadding: ImVec2;
    DockingSeparatorSize: Single;
    MouseCursorScale: Single;
    AntiAliasedLines: Boolean;
    AntiAliasedLinesUseTex: Boolean;
    AntiAliasedFill: Boolean;
    CurveTessellationTol: Single;
    CircleTessellationMaxError: Single;
    Colors: array [0..57] of ImVec4;
    HoverStationaryDelay: Single;
    HoverDelayShort: Single;
    HoverDelayNormal: Single;
    HoverFlagsForTooltipMouse: ImGuiHoveredFlags;
    HoverFlagsForTooltipNav: ImGuiHoveredFlags;
  end;

  ImGuiKeyData = record
    Down: Boolean;
    DownDuration: Single;
    DownDurationPrev: Single;
    AnalogValue: Single;
  end;

  ImVector_ImWchar = record
    Size: Integer;
    Capacity: Integer;
    Data: PImWchar;
  end;

  ImGuiIO = record
    ConfigFlags: ImGuiConfigFlags;
    BackendFlags: ImGuiBackendFlags;
    DisplaySize: ImVec2;
    DeltaTime: Single;
    IniSavingRate: Single;
    IniFilename: PUTF8Char;
    LogFilename: PUTF8Char;
    UserData: Pointer;
    Fonts: PImFontAtlas;
    FontGlobalScale: Single;
    FontAllowUserScaling: Boolean;
    FontDefault: PImFont;
    DisplayFramebufferScale: ImVec2;
    ConfigNavSwapGamepadButtons: Boolean;
    ConfigNavMoveSetMousePos: Boolean;
    ConfigNavCaptureKeyboard: Boolean;
    ConfigNavEscapeClearFocusItem: Boolean;
    ConfigNavEscapeClearFocusWindow: Boolean;
    ConfigNavCursorVisibleAuto: Boolean;
    ConfigNavCursorVisibleAlways: Boolean;
    ConfigDockingNoSplit: Boolean;
    ConfigDockingWithShift: Boolean;
    ConfigDockingAlwaysTabBar: Boolean;
    ConfigDockingTransparentPayload: Boolean;
    ConfigViewportsNoAutoMerge: Boolean;
    ConfigViewportsNoTaskBarIcon: Boolean;
    ConfigViewportsNoDecoration: Boolean;
    ConfigViewportsNoDefaultParent: Boolean;
    MouseDrawCursor: Boolean;
    ConfigMacOSXBehaviors: Boolean;
    ConfigInputTrickleEventQueue: Boolean;
    ConfigInputTextCursorBlink: Boolean;
    ConfigInputTextEnterKeepActive: Boolean;
    ConfigDragClickToInputText: Boolean;
    ConfigWindowsResizeFromEdges: Boolean;
    ConfigWindowsMoveFromTitleBarOnly: Boolean;
    ConfigWindowsCopyContentsWithCtrlC: Boolean;
    ConfigScrollbarScrollByPage: Boolean;
    ConfigMemoryCompactTimer: Single;
    MouseDoubleClickTime: Single;
    MouseDoubleClickMaxDist: Single;
    MouseDragThreshold: Single;
    KeyRepeatDelay: Single;
    KeyRepeatRate: Single;
    ConfigErrorRecovery: Boolean;
    ConfigErrorRecoveryEnableAssert: Boolean;
    ConfigErrorRecoveryEnableDebugLog: Boolean;
    ConfigErrorRecoveryEnableTooltip: Boolean;
    ConfigDebugIsDebuggerPresent: Boolean;
    ConfigDebugHighlightIdConflicts: Boolean;
    ConfigDebugBeginReturnValueOnce: Boolean;
    ConfigDebugBeginReturnValueLoop: Boolean;
    ConfigDebugIgnoreFocusLoss: Boolean;
    ConfigDebugIniSettings: Boolean;
    BackendPlatformName: PUTF8Char;
    BackendRendererName: PUTF8Char;
    BackendPlatformUserData: Pointer;
    BackendRendererUserData: Pointer;
    BackendLanguageUserData: Pointer;
    WantCaptureMouse: Boolean;
    WantCaptureKeyboard: Boolean;
    WantTextInput: Boolean;
    WantSetMousePos: Boolean;
    WantSaveIniSettings: Boolean;
    NavActive: Boolean;
    NavVisible: Boolean;
    Framerate: Single;
    MetricsRenderVertices: Integer;
    MetricsRenderIndices: Integer;
    MetricsRenderWindows: Integer;
    MetricsActiveWindows: Integer;
    MouseDelta: ImVec2;
    Ctx: PImGuiContext;
    MousePos: ImVec2;
    MouseDown: array [0..4] of Boolean;
    MouseWheel: Single;
    MouseWheelH: Single;
    MouseSource: ImGuiMouseSource;
    MouseHoveredViewport: ImGuiID;
    KeyCtrl: Boolean;
    KeyShift: Boolean;
    KeyAlt: Boolean;
    KeySuper: Boolean;
    KeyMods: ImGuiKeyChord;
    KeysData: array [0..153] of ImGuiKeyData;
    WantCaptureMouseUnlessPopupClose: Boolean;
    MousePosPrev: ImVec2;
    MouseClickedPos: array [0..4] of ImVec2;
    MouseClickedTime: array [0..4] of Double;
    MouseClicked: array [0..4] of Boolean;
    MouseDoubleClicked: array [0..4] of Boolean;
    MouseClickedCount: array [0..4] of ImU16;
    MouseClickedLastCount: array [0..4] of ImU16;
    MouseReleased: array [0..4] of Boolean;
    MouseReleasedTime: array [0..4] of Double;
    MouseDownOwned: array [0..4] of Boolean;
    MouseDownOwnedUnlessPopupClose: array [0..4] of Boolean;
    MouseWheelRequestAxisSwap: Boolean;
    MouseCtrlLeftAsRightClick: Boolean;
    MouseDownDuration: array [0..4] of Single;
    MouseDownDurationPrev: array [0..4] of Single;
    MouseDragMaxDistanceAbs: array [0..4] of ImVec2;
    MouseDragMaxDistanceSqr: array [0..4] of Single;
    PenPressure: Single;
    AppFocusLost: Boolean;
    AppAcceptingEvents: Boolean;
    InputQueueSurrogate: ImWchar16;
    InputQueueCharacters: ImVector_ImWchar;
  end;

  ImGuiInputTextCallbackData = record
    Ctx: PImGuiContext;
    EventFlag: ImGuiInputTextFlags;
    Flags: ImGuiInputTextFlags;
    UserData: Pointer;
    EventChar: ImWchar;
    EventKey: ImGuiKey;
    Buf: PUTF8Char;
    BufTextLen: Integer;
    BufSize: Integer;
    BufDirty: Boolean;
    CursorPos: Integer;
    SelectionStart: Integer;
    SelectionEnd: Integer;
  end;

  ImGuiSizeCallbackData = record
    UserData: Pointer;
    Pos: ImVec2;
    CurrentSize: ImVec2;
    DesiredSize: ImVec2;
  end;

  ImGuiWindowClass = record
    ClassId: ImGuiID;
    ParentViewportId: ImGuiID;
    FocusRouteParentWindowId: ImGuiID;
    ViewportFlagsOverrideSet: ImGuiViewportFlags;
    ViewportFlagsOverrideClear: ImGuiViewportFlags;
    TabItemFlagsOverrideSet: ImGuiTabItemFlags;
    DockNodeFlagsOverrideSet: ImGuiDockNodeFlags;
    DockingAlwaysTabBar: Boolean;
    DockingAllowUnclassed: Boolean;
  end;

  ImGuiPayload = record
    Data: Pointer;
    DataSize: Integer;
    SourceId: ImGuiID;
    SourceParentId: ImGuiID;
    DataFrameCount: Integer;
    DataType: array [0..32] of UTF8Char;
    Preview: Boolean;
    Delivery: Boolean;
  end;

  ImGuiOnceUponAFrame = record
    RefFrame: Integer;
  end;

  ImGuiTextRange = record
    b: PUTF8Char;
    e: PUTF8Char;
  end;

  ImVector_ImGuiTextRange = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTextRange;
  end;

  ImGuiTextFilter = record
    InputBuf: array [0..255] of UTF8Char;
    Filters: ImVector_ImGuiTextRange;
    CountGrep: Integer;
  end;

  ImVector_char = record
    Size: Integer;
    Capacity: Integer;
    Data: PUTF8Char;
  end;

  ImGuiTextBuffer = record
    Buf: ImVector_char;
  end;

  P_anonymous_type_89 = ^_anonymous_type_89;
  _anonymous_type_89 = record
    case Integer of
      0: (val_i: Integer);
      1: (val_f: Single);
      2: (val_p: Pointer);
  end;

  ImGuiStoragePair = record
    key: ImGuiID;
    f2: _anonymous_type_89;
  end;

  ImVector_ImGuiStoragePair = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiStoragePair;
  end;

  ImGuiStorage = record
    Data: ImVector_ImGuiStoragePair;
  end;

  ImGuiListClipper = record
    Ctx: PImGuiContext;
    DisplayStart: Integer;
    DisplayEnd: Integer;
    ItemsCount: Integer;
    ItemsHeight: Single;
    StartPosY: Single;
    StartSeekOffsetY: Double;
    TempData: Pointer;
  end;

  ImColor = record
    Value: ImVec4;
  end;

  ImVector_ImGuiSelectionRequest = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiSelectionRequest;
  end;

  ImGuiMultiSelectIO = record
    Requests: ImVector_ImGuiSelectionRequest;
    RangeSrcItem: ImGuiSelectionUserData;
    NavIdItem: ImGuiSelectionUserData;
    NavIdSelected: Boolean;
    RangeSrcReset: Boolean;
    ItemsCount: Integer;
  end;

  ImGuiSelectionRequest = record
    &Type: ImGuiSelectionRequestType;
    Selected: Boolean;
    RangeDirection: ImS8;
    RangeFirstItem: ImGuiSelectionUserData;
    RangeLastItem: ImGuiSelectionUserData;
  end;

  ImGuiSelectionBasicStorage = record
    Size: Integer;
    PreserveOrder: Boolean;
    UserData: Pointer;
    AdapterIndexToStorageId: function(self: PImGuiSelectionBasicStorage; idx: Integer): ImGuiID; cdecl;
    _SelectionOrder: Integer;
    _Storage: ImGuiStorage;
  end;

  ImGuiSelectionExternalStorage = record
    UserData: Pointer;
    AdapterSetItemSelected: procedure(self: PImGuiSelectionExternalStorage; idx: Integer; selected: Boolean); cdecl;
  end;

  ImDrawCallback = procedure(const parent_list: PImDrawList; const cmd: PImDrawCmd); cdecl;

  ImDrawCmd = record
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: Cardinal;
    IdxOffset: Cardinal;
    ElemCount: Cardinal;
    UserCallback: ImDrawCallback;
    UserCallbackData: Pointer;
    UserCallbackDataSize: Integer;
    UserCallbackDataOffset: Integer;
  end;

  ImDrawVert = record
    pos: ImVec2;
    uv: ImVec2;
    col: ImU32;
  end;

  ImDrawCmdHeader = record
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: Cardinal;
  end;

  ImVector_ImDrawCmd = record
    Size: Integer;
    Capacity: Integer;
    Data: PImDrawCmd;
  end;

  ImVector_ImDrawIdx = record
    Size: Integer;
    Capacity: Integer;
    Data: PImDrawIdx;
  end;

  ImDrawChannel = record
    _CmdBuffer: ImVector_ImDrawCmd;
    _IdxBuffer: ImVector_ImDrawIdx;
  end;

  ImVector_ImDrawChannel = record
    Size: Integer;
    Capacity: Integer;
    Data: PImDrawChannel;
  end;

  ImDrawListSplitter = record
    _Current: Integer;
    _Count: Integer;
    _Channels: ImVector_ImDrawChannel;
  end;

  ImVector_ImDrawVert = record
    Size: Integer;
    Capacity: Integer;
    Data: PImDrawVert;
  end;

  ImVector_ImVec2 = record
    Size: Integer;
    Capacity: Integer;
    Data: PImVec2;
  end;

  ImVector_ImVec4 = record
    Size: Integer;
    Capacity: Integer;
    Data: PImVec4;
  end;

  ImVector_ImTextureID = record
    Size: Integer;
    Capacity: Integer;
    Data: PImTextureID;
  end;

  ImVector_ImU8 = record
    Size: Integer;
    Capacity: Integer;
    Data: PImU8;
  end;

  ImDrawList = record
    CmdBuffer: ImVector_ImDrawCmd;
    IdxBuffer: ImVector_ImDrawIdx;
    VtxBuffer: ImVector_ImDrawVert;
    Flags: ImDrawListFlags;
    _VtxCurrentIdx: Cardinal;
    _Data: PImDrawListSharedData;
    _VtxWritePtr: PImDrawVert;
    _IdxWritePtr: PImDrawIdx;
    _Path: ImVector_ImVec2;
    _CmdHeader: ImDrawCmdHeader;
    _Splitter: ImDrawListSplitter;
    _ClipRectStack: ImVector_ImVec4;
    _TextureIdStack: ImVector_ImTextureID;
    _CallbacksDataBuf: ImVector_ImU8;
    _FringeScale: Single;
    _OwnerName: PUTF8Char;
  end;

  ImVector_ImDrawListPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPImDrawList;
  end;

  ImDrawData = record
    Valid: Boolean;
    CmdListsCount: Integer;
    TotalIdxCount: Integer;
    TotalVtxCount: Integer;
    CmdLists: ImVector_ImDrawListPtr;
    DisplayPos: ImVec2;
    DisplaySize: ImVec2;
    FramebufferScale: ImVec2;
    OwnerViewport: PImGuiViewport;
  end;

  ImFontConfig = record
    FontData: Pointer;
    FontDataSize: Integer;
    FontDataOwnedByAtlas: Boolean;
    MergeMode: Boolean;
    PixelSnapH: Boolean;
    FontNo: Integer;
    OversampleH: Integer;
    OversampleV: Integer;
    SizePixels: Single;
    GlyphExtraSpacing: ImVec2;
    GlyphOffset: ImVec2;
    GlyphRanges: PImWchar;
    GlyphMinAdvanceX: Single;
    GlyphMaxAdvanceX: Single;
    FontBuilderFlags: Cardinal;
    RasterizerMultiply: Single;
    RasterizerDensity: Single;
    EllipsisChar: ImWchar;
    Name: array [0..39] of UTF8Char;
    DstFont: PImFont;
  end;

  ImFontGlyph = record
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property Colored: Cardinal index $0001 read GetData0Value write SetData0Value; // 1 bits at offset 0 in Data0
    property Visible: Cardinal index $0101 read GetData0Value write SetData0Value; // 1 bits at offset 1 in Data0
    property Codepoint: Cardinal index $021E read GetData0Value write SetData0Value; // 30 bits at offset 2 in Data0
  var
    AdvanceX: Single;
    X0: Single;
    Y0: Single;
    X1: Single;
    Y1: Single;
    U0: Single;
    V0: Single;
    U1: Single;
    V1: Single;
  end;

  ImVector_ImU32 = record
    Size: Integer;
    Capacity: Integer;
    Data: PImU32;
  end;

  ImFontGlyphRangesBuilder = record
    UsedChars: ImVector_ImU32;
  end;

  ImFontAtlasCustomRect = record
    X: Word;
    Y: Word;
    Width: Word;
    Height: Word;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property GlyphID: Cardinal index $001F read GetData0Value write SetData0Value; // 31 bits at offset 0 in Data0
    property GlyphColored: Cardinal index $1F01 read GetData0Value write SetData0Value; // 1 bits at offset 31 in Data0
  var
    GlyphAdvanceX: Single;
    GlyphOffset: ImVec2;
    Font: PImFont;
  end;

  ImVector_ImFontPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPImFont;
  end;

  ImVector_ImFontAtlasCustomRect = record
    Size: Integer;
    Capacity: Integer;
    Data: PImFontAtlasCustomRect;
  end;

  ImVector_ImFontConfig = record
    Size: Integer;
    Capacity: Integer;
    Data: PImFontConfig;
  end;

  ImFontAtlas = record
    Flags: ImFontAtlasFlags;
    TexID: ImTextureID;
    TexDesiredWidth: Integer;
    TexGlyphPadding: Integer;
    UserData: Pointer;
    Locked: Boolean;
    TexReady: Boolean;
    TexPixelsUseColors: Boolean;
    TexPixelsAlpha8: PByte;
    TexPixelsRGBA32: PCardinal;
    TexWidth: Integer;
    TexHeight: Integer;
    TexUvScale: ImVec2;
    TexUvWhitePixel: ImVec2;
    Fonts: ImVector_ImFontPtr;
    CustomRects: ImVector_ImFontAtlasCustomRect;
    ConfigData: ImVector_ImFontConfig;
    TexUvLines: array [0..32] of ImVec4;
    FontBuilderIO: PImFontBuilderIO;
    FontBuilderFlags: Cardinal;
    PackIdMouseCursors: Integer;
    PackIdLines: Integer;
  end;

  ImVector_float = record
    Size: Integer;
    Capacity: Integer;
    Data: PSingle;
  end;

  ImVector_ImU16 = record
    Size: Integer;
    Capacity: Integer;
    Data: PImU16;
  end;

  ImVector_ImFontGlyph = record
    Size: Integer;
    Capacity: Integer;
    Data: PImFontGlyph;
  end;

  ImFont = record
    IndexAdvanceX: ImVector_float;
    FallbackAdvanceX: Single;
    FontSize: Single;
    IndexLookup: ImVector_ImU16;
    Glyphs: ImVector_ImFontGlyph;
    FallbackGlyph: PImFontGlyph;
    ContainerAtlas: PImFontAtlas;
    ConfigData: PImFontConfig;
    ConfigDataCount: Smallint;
    EllipsisCharCount: Smallint;
    EllipsisChar: ImWchar;
    FallbackChar: ImWchar;
    EllipsisWidth: Single;
    EllipsisCharStep: Single;
    Scale: Single;
    Ascent: Single;
    Descent: Single;
    MetricsTotalSurface: Integer;
    DirtyLookupTables: Boolean;
    Used8kPagesMap: array [0..0] of ImU8;
  end;

  ImGuiViewport = record
    ID: ImGuiID;
    Flags: ImGuiViewportFlags;
    Pos: ImVec2;
    Size: ImVec2;
    WorkPos: ImVec2;
    WorkSize: ImVec2;
    DpiScale: Single;
    ParentViewportId: ImGuiID;
    DrawData: PImDrawData;
    RendererUserData: Pointer;
    PlatformUserData: Pointer;
    PlatformHandle: Pointer;
    PlatformHandleRaw: Pointer;
    PlatformWindowCreated: Boolean;
    PlatformRequestMove: Boolean;
    PlatformRequestResize: Boolean;
    PlatformRequestClose: Boolean;
  end;

  ImVector_ImGuiPlatformMonitor = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiPlatformMonitor;
  end;

  ImVector_ImGuiViewportPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPImGuiViewport;
  end;

  ImGuiPlatformIO = record
    Platform_GetClipboardTextFn: function(ctx: PImGuiContext): PUTF8Char; cdecl;
    Platform_SetClipboardTextFn: procedure(ctx: PImGuiContext; const text: PUTF8Char); cdecl;
    Platform_ClipboardUserData: Pointer;
    Platform_OpenInShellFn: function(ctx: PImGuiContext; const path: PUTF8Char): Boolean; cdecl;
    Platform_OpenInShellUserData: Pointer;
    Platform_SetImeDataFn: procedure(ctx: PImGuiContext; viewport: PImGuiViewport; data: PImGuiPlatformImeData); cdecl;
    Platform_ImeUserData: Pointer;
    Platform_LocaleDecimalPoint: ImWchar;
    Renderer_RenderState: Pointer;
    Platform_CreateWindow: procedure(vp: PImGuiViewport); cdecl;
    Platform_DestroyWindow: procedure(vp: PImGuiViewport); cdecl;
    Platform_ShowWindow: procedure(vp: PImGuiViewport); cdecl;
    Platform_SetWindowPos: procedure(vp: PImGuiViewport; pos: ImVec2); cdecl;
    Platform_GetWindowPos: function(vp: PImGuiViewport): ImVec2; cdecl;
    Platform_SetWindowSize: procedure(vp: PImGuiViewport; size: ImVec2); cdecl;
    Platform_GetWindowSize: function(vp: PImGuiViewport): ImVec2; cdecl;
    Platform_SetWindowFocus: procedure(vp: PImGuiViewport); cdecl;
    Platform_GetWindowFocus: function(vp: PImGuiViewport): Boolean; cdecl;
    Platform_GetWindowMinimized: function(vp: PImGuiViewport): Boolean; cdecl;
    Platform_SetWindowTitle: procedure(vp: PImGuiViewport; const str: PUTF8Char); cdecl;
    Platform_SetWindowAlpha: procedure(vp: PImGuiViewport; alpha: Single); cdecl;
    Platform_UpdateWindow: procedure(vp: PImGuiViewport); cdecl;
    Platform_RenderWindow: procedure(vp: PImGuiViewport; render_arg: Pointer); cdecl;
    Platform_SwapBuffers: procedure(vp: PImGuiViewport; render_arg: Pointer); cdecl;
    Platform_GetWindowDpiScale: function(vp: PImGuiViewport): Single; cdecl;
    Platform_OnChangedViewport: procedure(vp: PImGuiViewport); cdecl;
    Platform_GetWindowWorkAreaInsets: function(vp: PImGuiViewport): ImVec4; cdecl;
    Platform_CreateVkSurface: function(vp: PImGuiViewport; vk_inst: ImU64; const vk_allocators: Pointer; out_vk_surface: PImU64): Integer; cdecl;
    Renderer_CreateWindow: procedure(vp: PImGuiViewport); cdecl;
    Renderer_DestroyWindow: procedure(vp: PImGuiViewport); cdecl;
    Renderer_SetWindowSize: procedure(vp: PImGuiViewport; size: ImVec2); cdecl;
    Renderer_RenderWindow: procedure(vp: PImGuiViewport; render_arg: Pointer); cdecl;
    Renderer_SwapBuffers: procedure(vp: PImGuiViewport; render_arg: Pointer); cdecl;
    Monitors: ImVector_ImGuiPlatformMonitor;
    Viewports: ImVector_ImGuiViewportPtr;
  end;

  ImGuiPlatformMonitor = record
    MainPos: ImVec2;
    MainSize: ImVec2;
    WorkPos: ImVec2;
    WorkSize: ImVec2;
    DpiScale: Single;
    PlatformHandle: Pointer;
  end;

  ImGuiPlatformImeData = record
    WantVisible: Boolean;
    InputPos: ImVec2;
    InputLineHeight: Single;
  end;

  ImGuiDataAuthority = Integer;
  ImGuiLayoutType = Integer;
  ImGuiActivateFlags = Integer;
  ImGuiDebugLogFlags = Integer;
  ImGuiFocusRequestFlags = Integer;
  ImGuiItemStatusFlags = Integer;
  ImGuiOldColumnFlags = Integer;
  ImGuiLogFlags = Integer;
  ImGuiNavRenderCursorFlags = Integer;
  ImGuiNavMoveFlags = Integer;
  ImGuiNextItemDataFlags = Integer;
  ImGuiNextWindowDataFlags = Integer;
  ImGuiScrollFlags = Integer;
  ImGuiSeparatorFlags = Integer;
  ImGuiTextFlags = Integer;
  ImGuiTooltipFlags = Integer;
  ImGuiTypingSelectFlags = Integer;
  ImGuiWindowRefreshFlags = Integer;
  ImFileHandle = PPointer;

  ImVec1 = record
    x: Single;
  end;

  ImVec2ih = record
    x: Smallint;
    y: Smallint;
  end;

  ImRect = record
    Min: ImVec2;
    Max: ImVec2;
  end;

  ImBitArrayPtr = PImU32;

  ImBitVector = record
    Storage: ImVector_ImU32;
  end;

  ImPoolIdx = Integer;

  ImVector_int = record
    Size: Integer;
    Capacity: Integer;
    Data: PInteger;
  end;

  ImGuiTextIndex = record
    LineOffsets: ImVector_int;
    EndOffset: Integer;
  end;

  ImDrawListSharedData = record
    TexUvWhitePixel: ImVec2;
    TexUvLines: PImVec4;
    Font: PImFont;
    FontSize: Single;
    FontScale: Single;
    CurveTessellationTol: Single;
    CircleSegmentMaxError: Single;
    ClipRectFullscreen: ImVec4;
    InitialFlags: ImDrawListFlags;
    TempBuffer: ImVector_ImVec2;
    ArcFastVtx: array [0..47] of ImVec2;
    ArcFastRadiusCutoff: Single;
    CircleSegmentCounts: array [0..63] of ImU8;
  end;

  ImDrawDataBuilder = record
    Layers: array [0..1] of PImVector_ImDrawListPtr;
    LayerData1: ImVector_ImDrawListPtr;
  end;

  ImGuiDataVarInfo = record
    &Type: ImGuiDataType;
    Count: ImU32;
    Offset: ImU32;
  end;

  ImGuiDataTypeStorage = record
    Data: array [0..7] of ImU8;
  end;

  ImGuiDataTypeInfo = record
    Size: NativeUInt;
    Name: PUTF8Char;
    PrintFmt: PUTF8Char;
    ScanFmt: PUTF8Char;
  end;

  ImGuiColorMod = record
    Col: ImGuiCol;
    BackupValue: ImVec4;
  end;

  P_anonymous_type_90 = ^_anonymous_type_90;
  _anonymous_type_90 = record
    case Integer of
      0: (BackupInt: array [0..1] of Integer);
      1: (BackupFloat: array [0..1] of Single);
  end;

  ImGuiStyleMod = record
    VarIdx: ImGuiStyleVar;
    f2: _anonymous_type_90;
  end;

  ImGuiComboPreviewData = record
    PreviewRect: ImRect;
    BackupCursorPos: ImVec2;
    BackupCursorMaxPos: ImVec2;
    BackupCursorPosPrevLine: ImVec2;
    BackupPrevLineTextBaseOffset: Single;
    BackupLayout: ImGuiLayoutType;
  end;

  ImGuiGroupData = record
    WindowID: ImGuiID;
    BackupCursorPos: ImVec2;
    BackupCursorMaxPos: ImVec2;
    BackupCursorPosPrevLine: ImVec2;
    BackupIndent: ImVec1;
    BackupGroupOffset: ImVec1;
    BackupCurrLineSize: ImVec2;
    BackupCurrLineTextBaseOffset: Single;
    BackupActiveIdIsAlive: ImGuiID;
    BackupDeactivatedIdIsAlive: Boolean;
    BackupHoveredIdIsAlive: Boolean;
    BackupIsSameLine: Boolean;
    EmitItem: Boolean;
  end;

  ImGuiMenuColumns = record
    TotalWidth: ImU32;
    NextTotalWidth: ImU32;
    Spacing: ImU16;
    OffsetIcon: ImU16;
    OffsetLabel: ImU16;
    OffsetShortcut: ImU16;
    OffsetMark: ImU16;
    Widths: array [0..3] of ImU16;
  end;

  ImGuiInputTextDeactivatedState = record
    ID: ImGuiID;
    TextA: ImVector_char;
  end;

  PImStbTexteditState = Pointer;
  PPImStbTexteditState = ^PImStbTexteditState;

  ImGuiInputTextState = record
    Ctx: PImGuiContext;
    Stb: PImStbTexteditState;
    Flags: ImGuiInputTextFlags;
    ID: ImGuiID;
    TextLen: Integer;
    TextSrc: PUTF8Char;
    TextA: ImVector_char;
    TextToRevertTo: ImVector_char;
    CallbackTextBackup: ImVector_char;
    BufCapacity: Integer;
    Scroll: ImVec2;
    CursorAnim: Single;
    CursorFollow: Boolean;
    SelectedAllMouseLock: Boolean;
    Edited: Boolean;
    WantReloadUserBuf: Boolean;
    ReloadSelectionStart: Integer;
    ReloadSelectionEnd: Integer;
  end;

  ImGuiNextWindowData = record
    Flags: ImGuiNextWindowDataFlags;
    PosCond: ImGuiCond;
    SizeCond: ImGuiCond;
    CollapsedCond: ImGuiCond;
    DockCond: ImGuiCond;
    PosVal: ImVec2;
    PosPivotVal: ImVec2;
    SizeVal: ImVec2;
    ContentSizeVal: ImVec2;
    ScrollVal: ImVec2;
    ChildFlags: ImGuiChildFlags;
    PosUndock: Boolean;
    CollapsedVal: Boolean;
    SizeConstraintRect: ImRect;
    SizeCallback: ImGuiSizeCallback;
    SizeCallbackUserData: Pointer;
    BgAlphaVal: Single;
    ViewportId: ImGuiID;
    DockId: ImGuiID;
    WindowClass: ImGuiWindowClass;
    MenuBarOffsetMinVal: ImVec2;
    RefreshFlagsVal: ImGuiWindowRefreshFlags;
  end;

  ImGuiNextItemData = record
    HasFlags: ImGuiNextItemDataFlags;
    ItemFlags: ImGuiItemFlags;
    FocusScopeId: ImGuiID;
    SelectionUserData: ImGuiSelectionUserData;
    Width: Single;
    Shortcut: ImGuiKeyChord;
    ShortcutFlags: ImGuiInputFlags;
    OpenVal: Boolean;
    OpenCond: ImU8;
    RefVal: ImGuiDataTypeStorage;
    StorageId: ImGuiID;
  end;

  ImGuiLastItemData = record
    ID: ImGuiID;
    ItemFlags: ImGuiItemFlags;
    StatusFlags: ImGuiItemStatusFlags;
    Rect: ImRect;
    NavRect: ImRect;
    DisplayRect: ImRect;
    ClipRect: ImRect;
    Shortcut: ImGuiKeyChord;
  end;

  ImGuiTreeNodeStackData = record
    ID: ImGuiID;
    TreeFlags: ImGuiTreeNodeFlags;
    ItemFlags: ImGuiItemFlags;
    NavRect: ImRect;
  end;

  ImGuiErrorRecoveryState = record
    SizeOfWindowStack: Smallint;
    SizeOfIDStack: Smallint;
    SizeOfTreeStack: Smallint;
    SizeOfColorStack: Smallint;
    SizeOfStyleVarStack: Smallint;
    SizeOfFontStack: Smallint;
    SizeOfFocusScopeStack: Smallint;
    SizeOfGroupStack: Smallint;
    SizeOfItemFlagsStack: Smallint;
    SizeOfBeginPopupStack: Smallint;
    SizeOfDisabledStack: Smallint;
  end;

  ImGuiWindowStackData = record
    Window: PImGuiWindow;
    ParentLastItemDataBackup: ImGuiLastItemData;
    StackSizesInBegin: ImGuiErrorRecoveryState;
    DisabledOverrideReenable: Boolean;
  end;

  ImGuiShrinkWidthItem = record
    Index: Integer;
    Width: Single;
    InitialWidth: Single;
  end;

  ImGuiPtrOrIndex = record
    Ptr: Pointer;
    Index: Integer;
  end;

  ImGuiDeactivatedItemData = record
    ID: ImGuiID;
    ElapseFrame: Integer;
    HasBeenEditedBefore: Boolean;
    IsAlive: Boolean;
  end;

  ImGuiPopupData = record
    PopupId: ImGuiID;
    Window: PImGuiWindow;
    RestoreNavWindow: PImGuiWindow;
    ParentNavLayer: Integer;
    OpenFrameCount: Integer;
    OpenParentId: ImGuiID;
    OpenPopupPos: ImVec2;
    OpenMousePos: ImVec2;
  end;

  ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN = record
    Storage: array [0..4] of ImU32;
  end;

  ImBitArrayForNamedKeys = ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN;

  ImGuiInputEventMousePos = record
    PosX: Single;
    PosY: Single;
    MouseSource: ImGuiMouseSource;
  end;

  ImGuiInputEventMouseWheel = record
    WheelX: Single;
    WheelY: Single;
    MouseSource: ImGuiMouseSource;
  end;

  ImGuiInputEventMouseButton = record
    Button: Integer;
    Down: Boolean;
    MouseSource: ImGuiMouseSource;
  end;

  ImGuiInputEventMouseViewport = record
    HoveredViewportID: ImGuiID;
  end;

  ImGuiInputEventKey = record
    Key: ImGuiKey;
    Down: Boolean;
    AnalogValue: Single;
  end;

  ImGuiInputEventText = record
    Char: Cardinal;
  end;

  ImGuiInputEventAppFocused = record
    Focused: Boolean;
  end;

  P_anonymous_type_91 = ^_anonymous_type_91;
  _anonymous_type_91 = record
    case Integer of
      0: (MousePos: ImGuiInputEventMousePos);
      1: (MouseWheel: ImGuiInputEventMouseWheel);
      2: (MouseButton: ImGuiInputEventMouseButton);
      3: (MouseViewport: ImGuiInputEventMouseViewport);
      4: (Key: ImGuiInputEventKey);
      5: (Text: ImGuiInputEventText);
      6: (AppFocused: ImGuiInputEventAppFocused);
  end;

  ImGuiInputEvent = record
    &Type: ImGuiInputEventType;
    Source: ImGuiInputSource;
    EventId: ImU32;
    f4: _anonymous_type_91;
    AddedByTestEngine: Boolean;
  end;

  ImGuiKeyRoutingIndex = ImS16;

  ImGuiKeyRoutingData = record
    NextEntryIndex: ImGuiKeyRoutingIndex;
    Mods: ImU16;
    RoutingCurrScore: ImU8;
    RoutingNextScore: ImU8;
    RoutingCurr: ImGuiID;
    RoutingNext: ImGuiID;
  end;

  ImVector_ImGuiKeyRoutingData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiKeyRoutingData;
  end;

  ImGuiKeyRoutingTable = record
    Index: array [0..153] of ImGuiKeyRoutingIndex;
    Entries: ImVector_ImGuiKeyRoutingData;
    EntriesNext: ImVector_ImGuiKeyRoutingData;
  end;

  ImGuiKeyOwnerData = record
    OwnerCurr: ImGuiID;
    OwnerNext: ImGuiID;
    LockThisFrame: Boolean;
    LockUntilRelease: Boolean;
  end;

  ImGuiListClipperRange = record
    Min: Integer;
    Max: Integer;
    PosToIndexConvert: Boolean;
    PosToIndexOffsetMin: ImS8;
    PosToIndexOffsetMax: ImS8;
  end;

  ImVector_ImGuiListClipperRange = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiListClipperRange;
  end;

  ImGuiListClipperData = record
    ListClipper: PImGuiListClipper;
    LossynessOffset: Single;
    StepNo: Integer;
    ItemsFrozen: Integer;
    Ranges: ImVector_ImGuiListClipperRange;
  end;

  ImGuiNavItemData = record
    Window: PImGuiWindow;
    ID: ImGuiID;
    FocusScopeId: ImGuiID;
    RectRel: ImRect;
    ItemFlags: ImGuiItemFlags;
    DistBox: Single;
    DistCenter: Single;
    DistAxial: Single;
    SelectionUserData: ImGuiSelectionUserData;
  end;

  ImGuiFocusScopeData = record
    ID: ImGuiID;
    WindowID: ImGuiID;
  end;

  ImGuiTypingSelectRequest = record
    Flags: ImGuiTypingSelectFlags;
    SearchBufferLen: Integer;
    SearchBuffer: PUTF8Char;
    SelectRequest: Boolean;
    SingleCharMode: Boolean;
    SingleCharSize: ImS8;
  end;

  ImGuiTypingSelectState = record
    Request: ImGuiTypingSelectRequest;
    SearchBuffer: array [0..63] of UTF8Char;
    FocusScope: ImGuiID;
    LastRequestFrame: Integer;
    LastRequestTime: Single;
    SingleCharModeLock: Boolean;
  end;

  ImGuiOldColumnData = record
    OffsetNorm: Single;
    OffsetNormBeforeResize: Single;
    Flags: ImGuiOldColumnFlags;
    ClipRect: ImRect;
  end;

  ImVector_ImGuiOldColumnData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiOldColumnData;
  end;

  ImGuiOldColumns = record
    ID: ImGuiID;
    Flags: ImGuiOldColumnFlags;
    IsFirstFrame: Boolean;
    IsBeingResized: Boolean;
    Current: Integer;
    Count: Integer;
    OffMinX: Single;
    OffMaxX: Single;
    LineMinY: Single;
    LineMaxY: Single;
    HostCursorPosY: Single;
    HostCursorMaxPosX: Single;
    HostInitialClipRect: ImRect;
    HostBackupClipRect: ImRect;
    HostBackupParentWorkRect: ImRect;
    Columns: ImVector_ImGuiOldColumnData;
    Splitter: ImDrawListSplitter;
  end;

  ImGuiBoxSelectState = record
    ID: ImGuiID;
    IsActive: Boolean;
    IsStarting: Boolean;
    IsStartedFromVoid: Boolean;
    IsStartedSetNavIdOnce: Boolean;
    RequestClear: Boolean;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property KeyMods: Cardinal index $0010 read GetData0Value write SetData0Value; // 16 bits at offset 0 in Data0
  var
    StartPosRel: ImVec2;
    EndPosRel: ImVec2;
    ScrollAccum: ImVec2;
    Window: PImGuiWindow;
    UnclipMode: Boolean;
    UnclipRect: ImRect;
    BoxSelectRectPrev: ImRect;
    BoxSelectRectCurr: ImRect;
  end;

  ImGuiMultiSelectTempData = record
    IO: ImGuiMultiSelectIO;
    Storage: PImGuiMultiSelectState;
    FocusScopeId: ImGuiID;
    Flags: ImGuiMultiSelectFlags;
    ScopeRectMin: ImVec2;
    BackupCursorMaxPos: ImVec2;
    LastSubmittedItem: ImGuiSelectionUserData;
    BoxSelectId: ImGuiID;
    KeyMods: ImGuiKeyChord;
    LoopRequestSetAll: ImS8;
    IsEndIO: Boolean;
    IsFocused: Boolean;
    IsKeyboardSetRange: Boolean;
    NavIdPassedBy: Boolean;
    RangeSrcPassedBy: Boolean;
    RangeDstPassedBy: Boolean;
  end;

  ImGuiMultiSelectState = record
    Window: PImGuiWindow;
    ID: ImGuiID;
    LastFrameActive: Integer;
    LastSelectionSize: Integer;
    RangeSelected: ImS8;
    NavIdSelected: ImS8;
    RangeSrcItem: ImGuiSelectionUserData;
    NavIdItem: ImGuiSelectionUserData;
  end;

  ImVector_ImGuiWindowPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPImGuiWindow;
  end;

  ImGuiDockNode = record
    ID: ImGuiID;
    SharedFlags: ImGuiDockNodeFlags;
    LocalFlags: ImGuiDockNodeFlags;
    LocalFlagsInWindows: ImGuiDockNodeFlags;
    MergedFlags: ImGuiDockNodeFlags;
    State: ImGuiDockNodeState;
    ParentNode: PImGuiDockNode;
    ChildNodes: array [0..1] of PImGuiDockNode;
    Windows: ImVector_ImGuiWindowPtr;
    TabBar: PImGuiTabBar;
    Pos: ImVec2;
    Size: ImVec2;
    SizeRef: ImVec2;
    SplitAxis: ImGuiAxis;
    WindowClass: ImGuiWindowClass;
    LastBgColor: ImU32;
    HostWindow: PImGuiWindow;
    VisibleWindow: PImGuiWindow;
    CentralNode: PImGuiDockNode;
    OnlyNodeWithWindows: PImGuiDockNode;
    CountNodeWithWindows: Integer;
    LastFrameAlive: Integer;
    LastFrameActive: Integer;
    LastFrameFocused: Integer;
    LastFocusedNodeId: ImGuiID;
    SelectedTabId: ImGuiID;
    WantCloseTabId: ImGuiID;
    RefViewportId: ImGuiID;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property AuthorityForPos: Cardinal index $0003 read GetData0Value write SetData0Value; // 3 bits at offset 0 in Data0
    property AuthorityForSize: Cardinal index $0303 read GetData0Value write SetData0Value; // 3 bits at offset 3 in Data0
    property AuthorityForViewport: Cardinal index $0603 read GetData0Value write SetData0Value; // 3 bits at offset 6 in Data0
    property IsVisible: Cardinal index $901 read GetData0Value write SetData0Value; // 1 bits at offset 9 in Data0
    property IsFocused: Cardinal index $A01 read GetData0Value write SetData0Value; // 1 bits at offset 10 in Data0
    property IsBgDrawnThisFrame: Cardinal index $B01 read GetData0Value write SetData0Value; // 1 bits at offset 11 in Data0
    property HasCloseButton: Cardinal index $C01 read GetData0Value write SetData0Value; // 1 bits at offset 12 in Data0
    property HasWindowMenuButton: Cardinal index $D01 read GetData0Value write SetData0Value; // 1 bits at offset 13 in Data0
    property HasCentralNodeChild: Cardinal index $E01 read GetData0Value write SetData0Value; // 1 bits at offset 14 in Data0
    property WantCloseAll: Cardinal index $F01 read GetData0Value write SetData0Value; // 1 bits at offset 15 in Data0
    property WantLockSizeOnce: Cardinal index $1001 read GetData0Value write SetData0Value; // 1 bits at offset 16 in Data0
    property WantMouseMove: Cardinal index $1101 read GetData0Value write SetData0Value; // 1 bits at offset 17 in Data0
    property WantHiddenTabBarUpdate: Cardinal index $1201 read GetData0Value write SetData0Value; // 1 bits at offset 18 in Data0
    property WantHiddenTabBarToggle: Cardinal index $1301 read GetData0Value write SetData0Value; // 1 bits at offset 19 in Data0
  end;

  ImGuiWindowDockStyle = record
    Colors: array [0..7] of ImU32;
  end;

  ImVector_ImGuiDockRequest = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiDockRequest;
  end;

  ImVector_ImGuiDockNodeSettings = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiDockNodeSettings;
  end;

  ImGuiDockContext = record
    Nodes: ImGuiStorage;
    Requests: ImVector_ImGuiDockRequest;
    NodesSettings: ImVector_ImGuiDockNodeSettings;
    WantFullRebuild: Boolean;
  end;

  ImGuiViewportP = record
    _ImGuiViewport: ImGuiViewport;
    Window: PImGuiWindow;
    Idx: Integer;
    LastFrameActive: Integer;
    LastFocusedStampCount: Integer;
    LastNameHash: ImGuiID;
    LastPos: ImVec2;
    LastSize: ImVec2;
    Alpha: Single;
    LastAlpha: Single;
    LastFocusedHadNavWindow: Boolean;
    PlatformMonitor: Smallint;
    BgFgDrawListsLastFrame: array [0..1] of Integer;
    BgFgDrawLists: array [0..1] of PImDrawList;
    DrawDataP: ImDrawData;
    DrawDataBuilder: ImDrawDataBuilder;
    LastPlatformPos: ImVec2;
    LastPlatformSize: ImVec2;
    LastRendererSize: ImVec2;
    WorkInsetMin: ImVec2;
    WorkInsetMax: ImVec2;
    BuildWorkInsetMin: ImVec2;
    BuildWorkInsetMax: ImVec2;
  end;

  ImGuiWindowSettings = record
    ID: ImGuiID;
    Pos: ImVec2ih;
    Size: ImVec2ih;
    ViewportPos: ImVec2ih;
    ViewportId: ImGuiID;
    DockId: ImGuiID;
    ClassId: ImGuiID;
    DockOrder: Smallint;
    Collapsed: Boolean;
    IsChild: Boolean;
    WantApply: Boolean;
    WantDelete: Boolean;
  end;

  ImGuiSettingsHandler = record
    TypeName: PUTF8Char;
    TypeHash: ImGuiID;
    ClearAllFn: procedure(ctx: PImGuiContext; handler: PImGuiSettingsHandler); cdecl;
    ReadInitFn: procedure(ctx: PImGuiContext; handler: PImGuiSettingsHandler); cdecl;
    ReadOpenFn: function(ctx: PImGuiContext; handler: PImGuiSettingsHandler; const name: PUTF8Char): Pointer; cdecl;
    ReadLineFn: procedure(ctx: PImGuiContext; handler: PImGuiSettingsHandler; entry: Pointer; const line: PUTF8Char); cdecl;
    ApplyAllFn: procedure(ctx: PImGuiContext; handler: PImGuiSettingsHandler); cdecl;
    WriteAllFn: procedure(ctx: PImGuiContext; handler: PImGuiSettingsHandler; out_buf: PImGuiTextBuffer); cdecl;
    UserData: Pointer;
  end;

  ImGuiLocEntry = record
    Key: ImGuiLocKey;
    Text: PUTF8Char;
  end;

  ImGuiErrorCallback = procedure(ctx: PImGuiContext; user_data: Pointer; const msg: PUTF8Char); cdecl;

  ImGuiDebugAllocEntry = record
    FrameCount: Integer;
    AllocCount: ImS16;
    FreeCount: ImS16;
  end;

  ImGuiDebugAllocInfo = record
    TotalAllocCount: Integer;
    TotalFreeCount: Integer;
    LastEntriesIdx: ImS16;
    LastEntriesBuf: array [0..5] of ImGuiDebugAllocEntry;
  end;

  ImGuiMetricsConfig = record
    ShowDebugLog: Boolean;
    ShowIDStackTool: Boolean;
    ShowWindowsRects: Boolean;
    ShowWindowsBeginOrder: Boolean;
    ShowTablesRects: Boolean;
    ShowDrawCmdMesh: Boolean;
    ShowDrawCmdBoundingBoxes: Boolean;
    ShowTextEncodingViewer: Boolean;
    ShowAtlasTintedWithTextColor: Boolean;
    ShowDockingNodes: Boolean;
    ShowWindowsRectsType: Integer;
    ShowTablesRectsType: Integer;
    HighlightMonitorIdx: Integer;
    HighlightViewportID: ImGuiID;
  end;

  ImGuiStackLevelInfo = record
    ID: ImGuiID;
    QueryFrameCount: ImS8;
    QuerySuccess: Boolean;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property DataType: Cardinal index $0008 read GetData0Value write SetData0Value; // 8 bits at offset 0 in Data0
  var
    Desc: array [0..56] of UTF8Char;
  end;

  ImVector_ImGuiStackLevelInfo = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiStackLevelInfo;
  end;

  ImGuiIDStackTool = record
    LastActiveFrame: Integer;
    StackLevel: Integer;
    QueryId: ImGuiID;
    Results: ImVector_ImGuiStackLevelInfo;
    CopyToClipboardOnCtrlC: Boolean;
    CopyToClipboardLastTime: Single;
  end;

  ImGuiContextHookCallback = procedure(ctx: PImGuiContext; hook: PImGuiContextHook); cdecl;

  ImGuiContextHook = record
    HookId: ImGuiID;
    &Type: ImGuiContextHookType;
    Owner: ImGuiID;
    Callback: ImGuiContextHookCallback;
    UserData: Pointer;
  end;

  ImVector_ImGuiInputEvent = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiInputEvent;
  end;

  ImVector_ImGuiWindowStackData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiWindowStackData;
  end;

  ImVector_ImGuiColorMod = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiColorMod;
  end;

  ImVector_ImGuiStyleMod = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiStyleMod;
  end;

  ImVector_ImGuiFocusScopeData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiFocusScopeData;
  end;

  ImVector_ImGuiItemFlags = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiItemFlags;
  end;

  ImVector_ImGuiGroupData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiGroupData;
  end;

  ImVector_ImGuiPopupData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiPopupData;
  end;

  ImVector_ImGuiTreeNodeStackData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTreeNodeStackData;
  end;

  ImVector_ImGuiViewportPPtr = record
    Size: Integer;
    Capacity: Integer;
    Data: PPImGuiViewportP;
  end;

  ImVector_unsigned_char = record
    Size: Integer;
    Capacity: Integer;
    Data: PByte;
  end;

  ImVector_ImGuiListClipperData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiListClipperData;
  end;

  ImVector_ImGuiTableTempData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTableTempData;
  end;

  ImVector_ImGuiTable = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTable;
  end;

  ImPool_ImGuiTable = record
    Buf: ImVector_ImGuiTable;
    Map: ImGuiStorage;
    FreeIdx: ImPoolIdx;
    AliveCount: ImPoolIdx;
  end;

  ImVector_ImGuiTabBar = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTabBar;
  end;

  ImPool_ImGuiTabBar = record
    Buf: ImVector_ImGuiTabBar;
    Map: ImGuiStorage;
    FreeIdx: ImPoolIdx;
    AliveCount: ImPoolIdx;
  end;

  ImVector_ImGuiPtrOrIndex = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiPtrOrIndex;
  end;

  ImVector_ImGuiShrinkWidthItem = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiShrinkWidthItem;
  end;

  ImVector_ImGuiMultiSelectTempData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiMultiSelectTempData;
  end;

  ImVector_ImGuiMultiSelectState = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiMultiSelectState;
  end;

  ImPool_ImGuiMultiSelectState = record
    Buf: ImVector_ImGuiMultiSelectState;
    Map: ImGuiStorage;
    FreeIdx: ImPoolIdx;
    AliveCount: ImPoolIdx;
  end;

  ImVector_ImGuiID = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiID;
  end;

  ImVector_ImGuiSettingsHandler = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiSettingsHandler;
  end;

  ImChunkStream_ImGuiWindowSettings = record
    Buf: ImVector_char;
  end;

  ImChunkStream_ImGuiTableSettings = record
    Buf: ImVector_char;
  end;

  ImVector_ImGuiContextHook = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiContextHook;
  end;

  ImGuiContext = record
    Initialized: Boolean;
    FontAtlasOwnedByContext: Boolean;
    IO: ImGuiIO;
    PlatformIO: ImGuiPlatformIO;
    Style: ImGuiStyle;
    ConfigFlagsCurrFrame: ImGuiConfigFlags;
    ConfigFlagsLastFrame: ImGuiConfigFlags;
    Font: PImFont;
    FontSize: Single;
    FontBaseSize: Single;
    FontScale: Single;
    CurrentDpiScale: Single;
    DrawListSharedData: ImDrawListSharedData;
    Time: Double;
    FrameCount: Integer;
    FrameCountEnded: Integer;
    FrameCountPlatformEnded: Integer;
    FrameCountRendered: Integer;
    WithinEndChildID: ImGuiID;
    WithinFrameScope: Boolean;
    WithinFrameScopeWithImplicitWindow: Boolean;
    GcCompactAll: Boolean;
    TestEngineHookItems: Boolean;
    TestEngine: Pointer;
    ContextName: array [0..15] of UTF8Char;
    InputEventsQueue: ImVector_ImGuiInputEvent;
    InputEventsTrail: ImVector_ImGuiInputEvent;
    InputEventsNextMouseSource: ImGuiMouseSource;
    InputEventsNextEventId: ImU32;
    Windows: ImVector_ImGuiWindowPtr;
    WindowsFocusOrder: ImVector_ImGuiWindowPtr;
    WindowsTempSortBuffer: ImVector_ImGuiWindowPtr;
    CurrentWindowStack: ImVector_ImGuiWindowStackData;
    WindowsById: ImGuiStorage;
    WindowsActiveCount: Integer;
    WindowsHoverPadding: ImVec2;
    DebugBreakInWindow: ImGuiID;
    CurrentWindow: PImGuiWindow;
    HoveredWindow: PImGuiWindow;
    HoveredWindowUnderMovingWindow: PImGuiWindow;
    HoveredWindowBeforeClear: PImGuiWindow;
    MovingWindow: PImGuiWindow;
    WheelingWindow: PImGuiWindow;
    WheelingWindowRefMousePos: ImVec2;
    WheelingWindowStartFrame: Integer;
    WheelingWindowScrolledFrame: Integer;
    WheelingWindowReleaseTimer: Single;
    WheelingWindowWheelRemainder: ImVec2;
    WheelingAxisAvg: ImVec2;
    DebugDrawIdConflicts: ImGuiID;
    DebugHookIdInfo: ImGuiID;
    HoveredId: ImGuiID;
    HoveredIdPreviousFrame: ImGuiID;
    HoveredIdPreviousFrameItemCount: Integer;
    HoveredIdTimer: Single;
    HoveredIdNotActiveTimer: Single;
    HoveredIdAllowOverlap: Boolean;
    HoveredIdIsDisabled: Boolean;
    ItemUnclipByLog: Boolean;
    ActiveId: ImGuiID;
    ActiveIdIsAlive: ImGuiID;
    ActiveIdTimer: Single;
    ActiveIdIsJustActivated: Boolean;
    ActiveIdAllowOverlap: Boolean;
    ActiveIdNoClearOnFocusLoss: Boolean;
    ActiveIdHasBeenPressedBefore: Boolean;
    ActiveIdHasBeenEditedBefore: Boolean;
    ActiveIdHasBeenEditedThisFrame: Boolean;
    ActiveIdFromShortcut: Boolean;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property ActiveIdMouseButton: Cardinal index $0008 read GetData0Value write SetData0Value; // 8 bits at offset 0 in Data0
  var
    ActiveIdClickOffset: ImVec2;
    ActiveIdWindow: PImGuiWindow;
    ActiveIdSource: ImGuiInputSource;
    ActiveIdPreviousFrame: ImGuiID;
    DeactivatedItemData: ImGuiDeactivatedItemData;
    ActiveIdValueOnActivation: ImGuiDataTypeStorage;
    LastActiveId: ImGuiID;
    LastActiveIdTimer: Single;
    LastKeyModsChangeTime: Double;
    LastKeyModsChangeFromNoneTime: Double;
    LastKeyboardKeyPressTime: Double;
    KeysMayBeCharInput: ImBitArrayForNamedKeys;
    KeysOwnerData: array [0..153] of ImGuiKeyOwnerData;
    KeysRoutingTable: ImGuiKeyRoutingTable;
    ActiveIdUsingNavDirMask: ImU32;
    ActiveIdUsingAllKeyboardKeys: Boolean;
    DebugBreakInShortcutRouting: ImGuiKeyChord;
    CurrentFocusScopeId: ImGuiID;
    CurrentItemFlags: ImGuiItemFlags;
    DebugLocateId: ImGuiID;
    NextItemData: ImGuiNextItemData;
    LastItemData: ImGuiLastItemData;
    NextWindowData: ImGuiNextWindowData;
    DebugShowGroupRects: Boolean;
    DebugFlashStyleColorIdx: ImGuiCol;
    ColorStack: ImVector_ImGuiColorMod;
    StyleVarStack: ImVector_ImGuiStyleMod;
    FontStack: ImVector_ImFontPtr;
    FocusScopeStack: ImVector_ImGuiFocusScopeData;
    ItemFlagsStack: ImVector_ImGuiItemFlags;
    GroupStack: ImVector_ImGuiGroupData;
    OpenPopupStack: ImVector_ImGuiPopupData;
    BeginPopupStack: ImVector_ImGuiPopupData;
    TreeNodeStack: ImVector_ImGuiTreeNodeStackData;
    Viewports: ImVector_ImGuiViewportPPtr;
    CurrentViewport: PImGuiViewportP;
    MouseViewport: PImGuiViewportP;
    MouseLastHoveredViewport: PImGuiViewportP;
    PlatformLastFocusedViewportId: ImGuiID;
    FallbackMonitor: ImGuiPlatformMonitor;
    PlatformMonitorsFullWorkRect: ImRect;
    ViewportCreatedCount: Integer;
    PlatformWindowsCreatedCount: Integer;
    ViewportFocusedStampCount: Integer;
    NavCursorVisible: Boolean;
    NavHighlightItemUnderNav: Boolean;
    NavMousePosDirty: Boolean;
    NavIdIsAlive: Boolean;
    NavId: ImGuiID;
    NavWindow: PImGuiWindow;
    NavFocusScopeId: ImGuiID;
    NavLayer: ImGuiNavLayer;
    NavActivateId: ImGuiID;
    NavActivateDownId: ImGuiID;
    NavActivatePressedId: ImGuiID;
    NavActivateFlags: ImGuiActivateFlags;
    NavFocusRoute: ImVector_ImGuiFocusScopeData;
    NavHighlightActivatedId: ImGuiID;
    NavHighlightActivatedTimer: Single;
    NavNextActivateId: ImGuiID;
    NavNextActivateFlags: ImGuiActivateFlags;
    NavInputSource: ImGuiInputSource;
    NavLastValidSelectionUserData: ImGuiSelectionUserData;
    NavCursorHideFrames: ImS8;
    NavAnyRequest: Boolean;
    NavInitRequest: Boolean;
    NavInitRequestFromMove: Boolean;
    NavInitResult: ImGuiNavItemData;
    NavMoveSubmitted: Boolean;
    NavMoveScoringItems: Boolean;
    NavMoveForwardToNextFrame: Boolean;
    NavMoveFlags: ImGuiNavMoveFlags;
    NavMoveScrollFlags: ImGuiScrollFlags;
    NavMoveKeyMods: ImGuiKeyChord;
    NavMoveDir: ImGuiDir;
    NavMoveDirForDebug: ImGuiDir;
    NavMoveClipDir: ImGuiDir;
    NavScoringRect: ImRect;
    NavScoringNoClipRect: ImRect;
    NavScoringDebugCount: Integer;
    NavTabbingDir: Integer;
    NavTabbingCounter: Integer;
    NavMoveResultLocal: ImGuiNavItemData;
    NavMoveResultLocalVisible: ImGuiNavItemData;
    NavMoveResultOther: ImGuiNavItemData;
    NavTabbingResultFirst: ImGuiNavItemData;
    NavJustMovedFromFocusScopeId: ImGuiID;
    NavJustMovedToId: ImGuiID;
    NavJustMovedToFocusScopeId: ImGuiID;
    NavJustMovedToKeyMods: ImGuiKeyChord;
    NavJustMovedToIsTabbing: Boolean;
    NavJustMovedToHasSelectionData: Boolean;
    ConfigNavWindowingKeyNext: ImGuiKeyChord;
    ConfigNavWindowingKeyPrev: ImGuiKeyChord;
    NavWindowingTarget: PImGuiWindow;
    NavWindowingTargetAnim: PImGuiWindow;
    NavWindowingListWindow: PImGuiWindow;
    NavWindowingTimer: Single;
    NavWindowingHighlightAlpha: Single;
    NavWindowingToggleLayer: Boolean;
    NavWindowingToggleKey: ImGuiKey;
    NavWindowingAccumDeltaPos: ImVec2;
    NavWindowingAccumDeltaSize: ImVec2;
    DimBgRatio: Single;
    DragDropActive: Boolean;
    DragDropWithinSource: Boolean;
    DragDropWithinTarget: Boolean;
    DragDropSourceFlags: ImGuiDragDropFlags;
    DragDropSourceFrameCount: Integer;
    DragDropMouseButton: Integer;
    DragDropPayload: ImGuiPayload;
    DragDropTargetRect: ImRect;
    DragDropTargetClipRect: ImRect;
    DragDropTargetId: ImGuiID;
    DragDropAcceptFlags: ImGuiDragDropFlags;
    DragDropAcceptIdCurrRectSurface: Single;
    DragDropAcceptIdCurr: ImGuiID;
    DragDropAcceptIdPrev: ImGuiID;
    DragDropAcceptFrameCount: Integer;
    DragDropHoldJustPressedId: ImGuiID;
    DragDropPayloadBufHeap: ImVector_unsigned_char;
    DragDropPayloadBufLocal: array [0..15] of Byte;
    ClipperTempDataStacked: Integer;
    ClipperTempData: ImVector_ImGuiListClipperData;
    CurrentTable: PImGuiTable;
    DebugBreakInTable: ImGuiID;
    TablesTempDataStacked: Integer;
    TablesTempData: ImVector_ImGuiTableTempData;
    Tables: ImPool_ImGuiTable;
    TablesLastTimeActive: ImVector_float;
    DrawChannelsTempMergeBuffer: ImVector_ImDrawChannel;
    CurrentTabBar: PImGuiTabBar;
    TabBars: ImPool_ImGuiTabBar;
    CurrentTabBarStack: ImVector_ImGuiPtrOrIndex;
    ShrinkWidthBuffer: ImVector_ImGuiShrinkWidthItem;
    BoxSelectState: ImGuiBoxSelectState;
    CurrentMultiSelect: PImGuiMultiSelectTempData;
    MultiSelectTempDataStacked: Integer;
    MultiSelectTempData: ImVector_ImGuiMultiSelectTempData;
    MultiSelectStorage: ImPool_ImGuiMultiSelectState;
    HoverItemDelayId: ImGuiID;
    HoverItemDelayIdPreviousFrame: ImGuiID;
    HoverItemDelayTimer: Single;
    HoverItemDelayClearTimer: Single;
    HoverItemUnlockedStationaryId: ImGuiID;
    HoverWindowUnlockedStationaryId: ImGuiID;
    MouseCursor: ImGuiMouseCursor;
    MouseStationaryTimer: Single;
    MouseLastValidPos: ImVec2;
    InputTextState: ImGuiInputTextState;
    InputTextDeactivatedState: ImGuiInputTextDeactivatedState;
    InputTextPasswordFont: ImFont;
    TempInputId: ImGuiID;
    DataTypeZeroValue: ImGuiDataTypeStorage;
    BeginMenuDepth: Integer;
    BeginComboDepth: Integer;
    ColorEditOptions: ImGuiColorEditFlags;
    ColorEditCurrentID: ImGuiID;
    ColorEditSavedID: ImGuiID;
    ColorEditSavedHue: Single;
    ColorEditSavedSat: Single;
    ColorEditSavedColor: ImU32;
    ColorPickerRef: ImVec4;
    ComboPreviewData: ImGuiComboPreviewData;
    WindowResizeBorderExpectedRect: ImRect;
    WindowResizeRelativeMode: Boolean;
    ScrollbarSeekMode: Smallint;
    ScrollbarClickDeltaToGrabCenter: Single;
    SliderGrabClickOffset: Single;
    SliderCurrentAccum: Single;
    SliderCurrentAccumDirty: Boolean;
    DragCurrentAccumDirty: Boolean;
    DragCurrentAccum: Single;
    DragSpeedDefaultRatio: Single;
    DisabledAlphaBackup: Single;
    DisabledStackSize: Smallint;
    TooltipOverrideCount: Smallint;
    TooltipPreviousWindow: PImGuiWindow;
    ClipboardHandlerData: ImVector_char;
    MenusIdSubmittedThisFrame: ImVector_ImGuiID;
    TypingSelectState: ImGuiTypingSelectState;
    PlatformImeData: ImGuiPlatformImeData;
    PlatformImeDataPrev: ImGuiPlatformImeData;
    PlatformImeViewport: ImGuiID;
    DockContext: ImGuiDockContext;
    DockNodeWindowMenuHandler: procedure(ctx: PImGuiContext; node: PImGuiDockNode; tab_bar: PImGuiTabBar); cdecl;
    SettingsLoaded: Boolean;
    SettingsDirtyTimer: Single;
    SettingsIniData: ImGuiTextBuffer;
    SettingsHandlers: ImVector_ImGuiSettingsHandler;
    SettingsWindows: ImChunkStream_ImGuiWindowSettings;
    SettingsTables: ImChunkStream_ImGuiTableSettings;
    Hooks: ImVector_ImGuiContextHook;
    HookIdNext: ImGuiID;
    LocalizationTable: array [0..12] of PUTF8Char;
    LogEnabled: Boolean;
    LogFlags: ImGuiLogFlags;
    LogWindow: PImGuiWindow;
    LogFile: ImFileHandle;
    LogBuffer: ImGuiTextBuffer;
    LogNextPrefix: PUTF8Char;
    LogNextSuffix: PUTF8Char;
    LogLinePosY: Single;
    LogLineFirstItem: Boolean;
    LogDepthRef: Integer;
    LogDepthToExpand: Integer;
    LogDepthToExpandDefault: Integer;
    ErrorCallback: ImGuiErrorCallback;
    ErrorCallbackUserData: Pointer;
    ErrorTooltipLockedPos: ImVec2;
    ErrorFirst: Boolean;
    ErrorCountCurrentFrame: Integer;
    StackSizesInNewFrame: ImGuiErrorRecoveryState;
    StackSizesInBeginForCurrentWindow: PImGuiErrorRecoveryState;
    DebugDrawIdConflictsCount: Integer;
    DebugLogFlags: ImGuiDebugLogFlags;
    DebugLogBuf: ImGuiTextBuffer;
    DebugLogIndex: ImGuiTextIndex;
    DebugLogSkippedErrors: Integer;
    DebugLogAutoDisableFlags: ImGuiDebugLogFlags;
    DebugLogAutoDisableFrames: ImU8;
    DebugLocateFrames: ImU8;
    DebugBreakInLocateId: Boolean;
    DebugBreakKeyChord: ImGuiKeyChord;
    DebugBeginReturnValueCullDepth: ImS8;
    DebugItemPickerActive: Boolean;
    DebugItemPickerMouseButton: ImU8;
    DebugItemPickerBreakId: ImGuiID;
    DebugFlashStyleColorTime: Single;
    DebugFlashStyleColorBackup: ImVec4;
    DebugMetricsConfig: ImGuiMetricsConfig;
    DebugIDStackTool: ImGuiIDStackTool;
    DebugAllocInfo: ImGuiDebugAllocInfo;
    DebugHoveredDockNode: PImGuiDockNode;
    FramerateSecPerFrame: array [0..59] of Single;
    FramerateSecPerFrameIdx: Integer;
    FramerateSecPerFrameCount: Integer;
    FramerateSecPerFrameAccum: Single;
    WantCaptureMouseNextFrame: Integer;
    WantCaptureKeyboardNextFrame: Integer;
    WantTextInputNextFrame: Integer;
    TempBuffer: ImVector_char;
    TempKeychordName: array [0..63] of UTF8Char;
  end;

  ImGuiWindowTempData = record
    CursorPos: ImVec2;
    CursorPosPrevLine: ImVec2;
    CursorStartPos: ImVec2;
    CursorMaxPos: ImVec2;
    IdealMaxPos: ImVec2;
    CurrLineSize: ImVec2;
    PrevLineSize: ImVec2;
    CurrLineTextBaseOffset: Single;
    PrevLineTextBaseOffset: Single;
    IsSameLine: Boolean;
    IsSetPos: Boolean;
    Indent: ImVec1;
    ColumnsOffset: ImVec1;
    GroupOffset: ImVec1;
    CursorStartPosLossyness: ImVec2;
    NavLayerCurrent: ImGuiNavLayer;
    NavLayersActiveMask: Smallint;
    NavLayersActiveMaskNext: Smallint;
    NavIsScrollPushableX: Boolean;
    NavHideHighlightOneFrame: Boolean;
    NavWindowHasScrollY: Boolean;
    MenuBarAppending: Boolean;
    MenuBarOffset: ImVec2;
    MenuColumns: ImGuiMenuColumns;
    TreeDepth: Integer;
    TreeHasStackDataDepthMask: ImU32;
    ChildWindows: ImVector_ImGuiWindowPtr;
    StateStorage: PImGuiStorage;
    CurrentColumns: PImGuiOldColumns;
    CurrentTableIdx: Integer;
    LayoutType: ImGuiLayoutType;
    ParentLayoutType: ImGuiLayoutType;
    ModalDimBgColor: ImU32;
    WindowItemStatusFlags: ImGuiItemStatusFlags;
    ChildItemStatusFlags: ImGuiItemStatusFlags;
    DockTabItemStatusFlags: ImGuiItemStatusFlags;
    DockTabItemRect: ImRect;
    ItemWidth: Single;
    TextWrapPos: Single;
    ItemWidthStack: ImVector_float;
    TextWrapPosStack: ImVector_float;
  end;

  ImVector_ImGuiOldColumns = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiOldColumns;
  end;

  ImGuiWindow = record
    Ctx: PImGuiContext;
    Name: PUTF8Char;
    ID: ImGuiID;
    Flags: ImGuiWindowFlags;
    FlagsPreviousFrame: ImGuiWindowFlags;
    ChildFlags: ImGuiChildFlags;
    WindowClass: ImGuiWindowClass;
    Viewport: PImGuiViewportP;
    ViewportId: ImGuiID;
    ViewportPos: ImVec2;
    ViewportAllowPlatformMonitorExtend: Integer;
    Pos: ImVec2;
    Size: ImVec2;
    SizeFull: ImVec2;
    ContentSize: ImVec2;
    ContentSizeIdeal: ImVec2;
    ContentSizeExplicit: ImVec2;
    WindowPadding: ImVec2;
    WindowRounding: Single;
    WindowBorderSize: Single;
    TitleBarHeight: Single;
    MenuBarHeight: Single;
    DecoOuterSizeX1: Single;
    DecoOuterSizeY1: Single;
    DecoOuterSizeX2: Single;
    DecoOuterSizeY2: Single;
    DecoInnerSizeX1: Single;
    DecoInnerSizeY1: Single;
    NameBufLen: Integer;
    MoveId: ImGuiID;
    TabId: ImGuiID;
    ChildId: ImGuiID;
    PopupId: ImGuiID;
    Scroll: ImVec2;
    ScrollMax: ImVec2;
    ScrollTarget: ImVec2;
    ScrollTargetCenterRatio: ImVec2;
    ScrollTargetEdgeSnapDist: ImVec2;
    ScrollbarSizes: ImVec2;
    ScrollbarX: Boolean;
    ScrollbarY: Boolean;
    ViewportOwned: Boolean;
    Active: Boolean;
    WasActive: Boolean;
    WriteAccessed: Boolean;
    Collapsed: Boolean;
    WantCollapseToggle: Boolean;
    SkipItems: Boolean;
    SkipRefresh: Boolean;
    Appearing: Boolean;
    Hidden: Boolean;
    IsFallbackWindow: Boolean;
    IsExplicitChild: Boolean;
    HasCloseButton: Boolean;
    ResizeBorderHovered: UTF8Char;
    ResizeBorderHeld: UTF8Char;
    BeginCount: Smallint;
    BeginCountPreviousFrame: Smallint;
    BeginOrderWithinParent: Smallint;
    BeginOrderWithinContext: Smallint;
    FocusOrder: Smallint;
    AutoFitFramesX: ImS8;
    AutoFitFramesY: ImS8;
    AutoFitOnlyGrows: Boolean;
    AutoPosLastDirection: ImGuiDir;
    HiddenFramesCanSkipItems: ImS8;
    HiddenFramesCannotSkipItems: ImS8;
    HiddenFramesForRenderOnly: ImS8;
    DisableInputsFrames: ImS8;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property SetWindowPosAllowFlags: Cardinal index $0008 read GetData0Value write SetData0Value; // 8 bits at offset 0 in Data0
    property SetWindowSizeAllowFlags: Cardinal index $0808 read GetData0Value write SetData0Value; // 8 bits at offset 8 in Data0
    property SetWindowCollapsedAllowFlags: Cardinal index $1008 read GetData0Value write SetData0Value; // 8 bits at offset 16 in Data0
    property SetWindowDockAllowFlags: Cardinal index $1808 read GetData0Value write SetData0Value; // 8 bits at offset 24 in Data0
  var
    SetWindowPosVal: ImVec2;
    SetWindowPosPivot: ImVec2;
    IDStack: ImVector_ImGuiID;
    DC: ImGuiWindowTempData;
    OuterRectClipped: ImRect;
    InnerRect: ImRect;
    InnerClipRect: ImRect;
    WorkRect: ImRect;
    ParentWorkRect: ImRect;
    ClipRect: ImRect;
    ContentRegionRect: ImRect;
    HitTestHoleSize: ImVec2ih;
    HitTestHoleOffset: ImVec2ih;
    LastFrameActive: Integer;
    LastFrameJustFocused: Integer;
    LastTimeActive: Single;
    ItemWidthDefault: Single;
    StateStorage: ImGuiStorage;
    ColumnsStorage: ImVector_ImGuiOldColumns;
    FontWindowScale: Single;
    FontWindowScaleParents: Single;
    FontDpiScale: Single;
    FontRefSize: Single;
    SettingsOffset: Integer;
    DrawList: PImDrawList;
    DrawListInst: ImDrawList;
    ParentWindow: PImGuiWindow;
    ParentWindowInBeginStack: PImGuiWindow;
    RootWindow: PImGuiWindow;
    RootWindowPopupTree: PImGuiWindow;
    RootWindowDockTree: PImGuiWindow;
    RootWindowForTitleBarHighlight: PImGuiWindow;
    RootWindowForNav: PImGuiWindow;
    ParentWindowForFocusRoute: PImGuiWindow;
    NavLastChildNavWindow: PImGuiWindow;
    NavLastIds: array [0..1] of ImGuiID;
    NavRectRel: array [0..1] of ImRect;
    NavPreferredScoringPosRel: array [0..1] of ImVec2;
    NavRootFocusScopeId: ImGuiID;
    MemoryDrawListIdxCapacity: Integer;
    MemoryDrawListVtxCapacity: Integer;
    MemoryCompacted: Boolean;
  private
    Data1: Cardinal;
    function GetData1Value(const AIndex: Integer): Cardinal;
    procedure SetData1Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property DockIsActive: Cardinal index $1 read GetData1Value write SetData1Value; // 1 bits at offset 0 in Data1
    property DockNodeIsVisible: Cardinal index $101 read GetData1Value write SetData1Value; // 1 bits at offset 1 in Data1
    property DockTabIsVisible: Cardinal index $201 read GetData1Value write SetData1Value; // 1 bits at offset 2 in Data1
    property DockTabWantClose: Cardinal index $301 read GetData1Value write SetData1Value; // 1 bits at offset 3 in Data1
  var
    DockOrder: Smallint;
    DockStyle: ImGuiWindowDockStyle;
    DockNode: PImGuiDockNode;
    DockNodeAsHost: PImGuiDockNode;
    DockId: ImGuiID;
  end;

  ImGuiTabItem = record
    ID: ImGuiID;
    Flags: ImGuiTabItemFlags;
    Window: PImGuiWindow;
    LastFrameVisible: Integer;
    LastFrameSelected: Integer;
    Offset: Single;
    Width: Single;
    ContentWidth: Single;
    RequestedWidth: Single;
    NameOffset: ImS32;
    BeginOrder: ImS16;
    IndexDuringLayout: ImS16;
    WantClose: Boolean;
  end;

  ImVector_ImGuiTabItem = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTabItem;
  end;

  ImGuiTabBar = record
    Window: PImGuiWindow;
    Tabs: ImVector_ImGuiTabItem;
    Flags: ImGuiTabBarFlags;
    ID: ImGuiID;
    SelectedTabId: ImGuiID;
    NextSelectedTabId: ImGuiID;
    VisibleTabId: ImGuiID;
    CurrFrameVisible: Integer;
    PrevFrameVisible: Integer;
    BarRect: ImRect;
    CurrTabsContentsHeight: Single;
    PrevTabsContentsHeight: Single;
    WidthAllTabs: Single;
    WidthAllTabsIdeal: Single;
    ScrollingAnim: Single;
    ScrollingTarget: Single;
    ScrollingTargetDistToVisibility: Single;
    ScrollingSpeed: Single;
    ScrollingRectMinX: Single;
    ScrollingRectMaxX: Single;
    SeparatorMinX: Single;
    SeparatorMaxX: Single;
    ReorderRequestTabId: ImGuiID;
    ReorderRequestOffset: ImS16;
    BeginCount: ImS8;
    WantLayout: Boolean;
    VisibleTabWasSubmitted: Boolean;
    TabsAddedNew: Boolean;
    TabsActiveCount: ImS16;
    LastTabItemIdx: ImS16;
    ItemSpacingY: Single;
    FramePadding: ImVec2;
    BackupCursorPos: ImVec2;
    TabsNames: ImGuiTextBuffer;
  end;

  ImGuiTableColumnIdx = ImS16;
  PImGuiTableColumnIdx = ^ImGuiTableColumnIdx;
  ImGuiTableDrawChannelIdx = ImU16;

  ImGuiTableColumn = record
    Flags: ImGuiTableColumnFlags;
    WidthGiven: Single;
    MinX: Single;
    MaxX: Single;
    WidthRequest: Single;
    WidthAuto: Single;
    WidthMax: Single;
    StretchWeight: Single;
    InitStretchWeightOrWidth: Single;
    ClipRect: ImRect;
    UserID: ImGuiID;
    WorkMinX: Single;
    WorkMaxX: Single;
    ItemWidth: Single;
    ContentMaxXFrozen: Single;
    ContentMaxXUnfrozen: Single;
    ContentMaxXHeadersUsed: Single;
    ContentMaxXHeadersIdeal: Single;
    NameOffset: ImS16;
    DisplayOrder: ImGuiTableColumnIdx;
    IndexWithinEnabledSet: ImGuiTableColumnIdx;
    PrevEnabledColumn: ImGuiTableColumnIdx;
    NextEnabledColumn: ImGuiTableColumnIdx;
    SortOrder: ImGuiTableColumnIdx;
    DrawChannelCurrent: ImGuiTableDrawChannelIdx;
    DrawChannelFrozen: ImGuiTableDrawChannelIdx;
    DrawChannelUnfrozen: ImGuiTableDrawChannelIdx;
    IsEnabled: Boolean;
    IsUserEnabled: Boolean;
    IsUserEnabledNextFrame: Boolean;
    IsVisibleX: Boolean;
    IsVisibleY: Boolean;
    IsRequestOutput: Boolean;
    IsSkipItems: Boolean;
    IsPreserveWidthAuto: Boolean;
    NavLayerCurrent: ImS8;
    AutoFitQueue: ImU8;
    CannotSkipItemsQueue: ImU8;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property SortDirection: Cardinal index $2 read GetData0Value write SetData0Value; // 2 bits at offset 0 in Data0
    property SortDirectionsAvailCount: Cardinal index $202 read GetData0Value write SetData0Value; // 2 bits at offset 2 in Data0
    property SortDirectionsAvailMask: Cardinal index $404 read GetData0Value write SetData0Value; // 4 bits at offset 4 in Data0
  var
    SortDirectionsAvailList: ImU8;
  end;

  ImGuiTableCellData = record
    BgColor: ImU32;
    Column: ImGuiTableColumnIdx;
  end;

  ImGuiTableHeaderData = record
    Index: ImGuiTableColumnIdx;
    TextColor: ImU32;
    BgColor0: ImU32;
    BgColor1: ImU32;
  end;

  ImGuiTableInstanceData = record
    TableInstanceID: ImGuiID;
    LastOuterHeight: Single;
    LastTopHeadersRowHeight: Single;
    LastFrozenHeight: Single;
    HoveredRowLast: Integer;
    HoveredRowNext: Integer;
  end;

  ImSpan_ImGuiTableColumn = record
    Data: PImGuiTableColumn;
    DataEnd: PImGuiTableColumn;
  end;

  ImSpan_ImGuiTableColumnIdx = record
    Data: PImGuiTableColumnIdx;
    DataEnd: PImGuiTableColumnIdx;
  end;

  ImSpan_ImGuiTableCellData = record
    Data: PImGuiTableCellData;
    DataEnd: PImGuiTableCellData;
  end;

  ImVector_ImGuiTableInstanceData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTableInstanceData;
  end;

  ImVector_ImGuiTableColumnSortSpecs = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTableColumnSortSpecs;
  end;

  ImGuiTable = record
    ID: ImGuiID;
    Flags: ImGuiTableFlags;
    RawData: Pointer;
    TempData: PImGuiTableTempData;
    Columns: ImSpan_ImGuiTableColumn;
    DisplayOrderToIndex: ImSpan_ImGuiTableColumnIdx;
    RowCellData: ImSpan_ImGuiTableCellData;
    EnabledMaskByDisplayOrder: ImBitArrayPtr;
    EnabledMaskByIndex: ImBitArrayPtr;
    VisibleMaskByIndex: ImBitArrayPtr;
    SettingsLoadedFlags: ImGuiTableFlags;
    SettingsOffset: Integer;
    LastFrameActive: Integer;
    ColumnsCount: Integer;
    CurrentRow: Integer;
    CurrentColumn: Integer;
    InstanceCurrent: ImS16;
    InstanceInteracted: ImS16;
    RowPosY1: Single;
    RowPosY2: Single;
    RowMinHeight: Single;
    RowCellPaddingY: Single;
    RowTextBaseline: Single;
    RowIndentOffsetX: Single;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property RowFlags: Cardinal index $0010 read GetData0Value write SetData0Value; // 16 bits at offset 0 in Data0
    property LastRowFlags: Cardinal index $1010 read GetData0Value write SetData0Value; // 16 bits at offset 16 in Data0
  var
    RowBgColorCounter: Integer;
    RowBgColor: array [0..1] of ImU32;
    BorderColorStrong: ImU32;
    BorderColorLight: ImU32;
    BorderX1: Single;
    BorderX2: Single;
    HostIndentX: Single;
    MinColumnWidth: Single;
    OuterPaddingX: Single;
    CellPaddingX: Single;
    CellSpacingX1: Single;
    CellSpacingX2: Single;
    InnerWidth: Single;
    ColumnsGivenWidth: Single;
    ColumnsAutoFitWidth: Single;
    ColumnsStretchSumWeights: Single;
    ResizedColumnNextWidth: Single;
    ResizeLockMinContentsX2: Single;
    RefScale: Single;
    AngledHeadersHeight: Single;
    AngledHeadersSlope: Single;
    OuterRect: ImRect;
    InnerRect: ImRect;
    WorkRect: ImRect;
    InnerClipRect: ImRect;
    BgClipRect: ImRect;
    Bg0ClipRectForDrawCmd: ImRect;
    Bg2ClipRectForDrawCmd: ImRect;
    HostClipRect: ImRect;
    HostBackupInnerClipRect: ImRect;
    OuterWindow: PImGuiWindow;
    InnerWindow: PImGuiWindow;
    ColumnsNames: ImGuiTextBuffer;
    DrawSplitter: PImDrawListSplitter;
    InstanceDataFirst: ImGuiTableInstanceData;
    InstanceDataExtra: ImVector_ImGuiTableInstanceData;
    SortSpecsSingle: ImGuiTableColumnSortSpecs;
    SortSpecsMulti: ImVector_ImGuiTableColumnSortSpecs;
    SortSpecs: ImGuiTableSortSpecs;
    SortSpecsCount: ImGuiTableColumnIdx;
    ColumnsEnabledCount: ImGuiTableColumnIdx;
    ColumnsEnabledFixedCount: ImGuiTableColumnIdx;
    DeclColumnsCount: ImGuiTableColumnIdx;
    AngledHeadersCount: ImGuiTableColumnIdx;
    HoveredColumnBody: ImGuiTableColumnIdx;
    HoveredColumnBorder: ImGuiTableColumnIdx;
    HighlightColumnHeader: ImGuiTableColumnIdx;
    AutoFitSingleColumn: ImGuiTableColumnIdx;
    ResizedColumn: ImGuiTableColumnIdx;
    LastResizedColumn: ImGuiTableColumnIdx;
    HeldHeaderColumn: ImGuiTableColumnIdx;
    ReorderColumn: ImGuiTableColumnIdx;
    ReorderColumnDir: ImGuiTableColumnIdx;
    LeftMostEnabledColumn: ImGuiTableColumnIdx;
    RightMostEnabledColumn: ImGuiTableColumnIdx;
    LeftMostStretchedColumn: ImGuiTableColumnIdx;
    RightMostStretchedColumn: ImGuiTableColumnIdx;
    ContextPopupColumn: ImGuiTableColumnIdx;
    FreezeRowsRequest: ImGuiTableColumnIdx;
    FreezeRowsCount: ImGuiTableColumnIdx;
    FreezeColumnsRequest: ImGuiTableColumnIdx;
    FreezeColumnsCount: ImGuiTableColumnIdx;
    RowCellDataCurrent: ImGuiTableColumnIdx;
    DummyDrawChannel: ImGuiTableDrawChannelIdx;
    Bg2DrawChannelCurrent: ImGuiTableDrawChannelIdx;
    Bg2DrawChannelUnfrozen: ImGuiTableDrawChannelIdx;
    NavLayer: ImS8;
    IsLayoutLocked: Boolean;
    IsInsideRow: Boolean;
    IsInitializing: Boolean;
    IsSortSpecsDirty: Boolean;
    IsUsingHeaders: Boolean;
    IsContextPopupOpen: Boolean;
    DisableDefaultContextMenu: Boolean;
    IsSettingsRequestLoad: Boolean;
    IsSettingsDirty: Boolean;
    IsDefaultDisplayOrder: Boolean;
    IsResetAllRequest: Boolean;
    IsResetDisplayOrderRequest: Boolean;
    IsUnfrozenRows: Boolean;
    IsDefaultSizingPolicy: Boolean;
    IsActiveIdAliveBeforeTable: Boolean;
    IsActiveIdInTable: Boolean;
    HasScrollbarYCurr: Boolean;
    HasScrollbarYPrev: Boolean;
    MemoryCompacted: Boolean;
    HostSkipItems: Boolean;
  end;

  ImVector_ImGuiTableHeaderData = record
    Size: Integer;
    Capacity: Integer;
    Data: PImGuiTableHeaderData;
  end;

  ImGuiTableTempData = record
    TableIndex: Integer;
    LastTimeActive: Single;
    AngledHeadersExtraWidth: Single;
    AngledHeadersRequests: ImVector_ImGuiTableHeaderData;
    UserOuterSize: ImVec2;
    DrawSplitter: ImDrawListSplitter;
    HostBackupWorkRect: ImRect;
    HostBackupParentWorkRect: ImRect;
    HostBackupPrevLineSize: ImVec2;
    HostBackupCurrLineSize: ImVec2;
    HostBackupCursorMaxPos: ImVec2;
    HostBackupColumnsOffset: ImVec1;
    HostBackupItemWidth: Single;
    HostBackupItemWidthStackSize: Integer;
  end;

  ImGuiTableColumnSettings = record
    WidthOrWeight: Single;
    UserID: ImGuiID;
    Index: ImGuiTableColumnIdx;
    DisplayOrder: ImGuiTableColumnIdx;
    SortOrder: ImGuiTableColumnIdx;
  private
    Data0: Cardinal;
    function GetData0Value(const AIndex: Integer): Cardinal;
    procedure SetData0Value(const AIndex: Integer; const AValue: Cardinal);
  public
    property SortDirection: Cardinal index $2 read GetData0Value write SetData0Value; // 2 bits at offset 0 in Data0
    property IsEnabled: Cardinal index $201 read GetData0Value write SetData0Value; // 1 bits at offset 2 in Data0
    property IsStretch: Cardinal index $301 read GetData0Value write SetData0Value; // 1 bits at offset 3 in Data0
  end;

  ImGuiTableSettings = record
    ID: ImGuiID;
    SaveFlags: ImGuiTableFlags;
    RefScale: Single;
    ColumnsCount: ImGuiTableColumnIdx;
    ColumnsCountMax: ImGuiTableColumnIdx;
    WantApply: Boolean;
  end;

  ImFontBuilderIO = record
    FontBuilder_Build: function(atlas: PImFontAtlas): Boolean; cdecl;
  end;

const
  PLM_DEMUX_PACKET_PRIVATE: Integer = $BD;
  PLM_DEMUX_PACKET_AUDIO_1: Integer = $C0;
  PLM_DEMUX_PACKET_AUDIO_2: Integer = $C1;
  PLM_DEMUX_PACKET_AUDIO_3: Integer = $C2;
  PLM_DEMUX_PACKET_AUDIO_4: Integer = $C3;
  PLM_DEMUX_PACKET_VIDEO_1: Integer = $E0;

type
  sqlite3_exec_callback = function(p1: Pointer; p2: Integer; p3: PPUTF8Char; p4: PPUTF8Char): Integer; cdecl;

type
  sqlite3_busy_handler_ = function(p1: Pointer; p2: Integer): Integer; cdecl;

type
  sqlite3_set_authorizer_xAuth = function(p1: Pointer; p2: Integer; const p3: PUTF8Char; const p4: PUTF8Char; const p5: PUTF8Char; const p6: PUTF8Char): Integer; cdecl;

type
  sqlite3_trace_xTrace = procedure(p1: Pointer; const p2: PUTF8Char); cdecl;

type
  sqlite3_profile_xProfile = procedure(p1: Pointer; const p2: PUTF8Char; p3: sqlite3_uint64); cdecl;

type
  sqlite3_trace_v2_xCallback = function(p1: Cardinal; p2: Pointer; p3: Pointer; p4: Pointer): Integer; cdecl;

type
  sqlite3_progress_handler_ = function(p1: Pointer): Integer; cdecl;

type
  sqlite3_bind_blob_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_bind_blob64_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_bind_text_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_bind_text16_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_bind_text64_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_bind_pointer_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_create_function_xFunc = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function_xStep = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function_xFinal = procedure(p1: Psqlite3_context); cdecl;

type
  sqlite3_create_function16_xFunc = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function16_xStep = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function16_xFinal = procedure(p1: Psqlite3_context); cdecl;

type
  sqlite3_create_function_v2_xFunc = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function_v2_xStep = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_function_v2_xFinal = procedure(p1: Psqlite3_context); cdecl;

type
  sqlite3_create_function_v2_xDestroy = procedure(p1: Pointer); cdecl;

type
  sqlite3_create_window_function_xStep = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_window_function_xFinal = procedure(p1: Psqlite3_context); cdecl;

type
  sqlite3_create_window_function_xValue = procedure(p1: Psqlite3_context); cdecl;

type
  sqlite3_create_window_function_xInverse = procedure(p1: Psqlite3_context; p2: Integer; p3: PPsqlite3_value); cdecl;

type
  sqlite3_create_window_function_xDestroy = procedure(p1: Pointer); cdecl;

type
  sqlite3_memory_alarm_ = procedure(p1: Pointer; p2: sqlite3_int64; p3: Integer); cdecl;

type
  sqlite3_set_auxdata_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_set_clientdata_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_blob_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_blob64_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_text_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_text64_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_text16_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_text16le_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_text16be_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_result_pointer_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_create_collation_xCompare = function(p1: Pointer; p2: Integer; const p3: Pointer; p4: Integer; const p5: Pointer): Integer; cdecl;

type
  sqlite3_create_collation_v2_xCompare = function(p1: Pointer; p2: Integer; const p3: Pointer; p4: Integer; const p5: Pointer): Integer; cdecl;

type
  sqlite3_create_collation_v2_xDestroy = procedure(p1: Pointer); cdecl;

type
  sqlite3_create_collation16_xCompare = function(p1: Pointer; p2: Integer; const p3: Pointer; p4: Integer; const p5: Pointer): Integer; cdecl;

type
  sqlite3_collation_needed_ = procedure(p1: Pointer; p2: Psqlite3; eTextRep: Integer; const p4: PUTF8Char); cdecl;

type
  sqlite3_collation_needed16_ = procedure(p1: Pointer; p2: Psqlite3; eTextRep: Integer; const p4: Pointer); cdecl;

type
  sqlite3_commit_hook_ = function(p1: Pointer): Integer; cdecl;

type
  sqlite3_rollback_hook_ = procedure(p1: Pointer); cdecl;

type
  sqlite3_autovacuum_pages_1 = function(p1: Pointer; const p2: PUTF8Char; p3: Cardinal; p4: Cardinal; p5: Cardinal): Cardinal; cdecl;

type
  sqlite3_autovacuum_pages_2 = procedure(p1: Pointer); cdecl;

type
  sqlite3_update_hook_ = procedure(p1: Pointer; p2: Integer; const p3: PUTF8Char; const p4: PUTF8Char; p5: sqlite3_int64); cdecl;

type
  sqlite3_auto_extension_xEntryPoint = procedure(); cdecl;

type
  sqlite3_cancel_auto_extension_xEntryPoint = procedure(); cdecl;

type
  sqlite3_create_module_v2_xDestroy = procedure(p1: Pointer); cdecl;

type
  sqlite3_wal_hook_ = function(p1: Pointer; p2: Psqlite3; const p3: PUTF8Char; p4: Integer): Integer; cdecl;

type
  igCombo_FnStrPtr_getter = function(user_data: Pointer; idx: Integer): PUTF8Char; cdecl;

type
  igListBox_FnStrPtr_getter = function(user_data: Pointer; idx: Integer): PUTF8Char; cdecl;

type
  igPlotLines_FnFloatPtr_values_getter = function(data: Pointer; idx: Integer): Single; cdecl;

type
  igPlotHistogram_FnFloatPtr_values_getter = function(data: Pointer; idx: Integer): Single; cdecl;

type
  igImQsort_compare_func = function(const p1: Pointer; const p2: Pointer): Integer; cdecl;

type
  igTypingSelectFindMatch_get_item_name_func = function(p1: Pointer; p2: Integer): PUTF8Char; cdecl;

type
  igTypingSelectFindNextSingleCharMatch_get_item_name_func = function(p1: Pointer; p2: Integer): PUTF8Char; cdecl;

type
  igTypingSelectFindBestLeadingMatch_get_item_name_func = function(p1: Pointer; p2: Integer): PUTF8Char; cdecl;

type
  igPlotEx_values_getter = function(data: Pointer; idx: Integer): Single; cdecl;

type
  ImGuiPlatformIO_Set_Platform_GetWindowPos_user_callback = procedure(vp: PImGuiViewport; out_pos: PImVec2); cdecl;

type
  ImGuiPlatformIO_Set_Platform_GetWindowSize_user_callback = procedure(vp: PImGuiViewport; out_size: PImVec2); cdecl;

var
  lua_newstate: function(f: lua_Alloc; ud: Pointer): Plua_State; cdecl;
  lua_close: procedure(L: Plua_State); cdecl;
  lua_newthread: function(L: Plua_State): Plua_State; cdecl;
  lua_atpanic: function(L: Plua_State; panicf: lua_CFunction): lua_CFunction; cdecl;
  lua_gettop: function(L: Plua_State): Integer; cdecl;
  lua_settop: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_pushvalue: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_remove: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_insert: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_replace: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_checkstack: function(L: Plua_State; sz: Integer): Integer; cdecl;
  lua_xmove: procedure(from: Plua_State; &to: Plua_State; n: Integer); cdecl;
  lua_isnumber: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_isstring: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_iscfunction: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_isuserdata: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_type: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_typename: function(L: Plua_State; tp: Integer): PUTF8Char; cdecl;
  lua_equal: function(L: Plua_State; idx1: Integer; idx2: Integer): Integer; cdecl;
  lua_rawequal: function(L: Plua_State; idx1: Integer; idx2: Integer): Integer; cdecl;
  lua_lessthan: function(L: Plua_State; idx1: Integer; idx2: Integer): Integer; cdecl;
  lua_tonumber: function(L: Plua_State; idx: Integer): lua_Number; cdecl;
  lua_tointeger: function(L: Plua_State; idx: Integer): lua_Integer; cdecl;
  lua_toboolean: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_tolstring: function(L: Plua_State; idx: Integer; len: PNativeUInt): PUTF8Char; cdecl;
  lua_objlen: function(L: Plua_State; idx: Integer): NativeUInt; cdecl;
  lua_tocfunction: function(L: Plua_State; idx: Integer): lua_CFunction; cdecl;
  lua_touserdata: function(L: Plua_State; idx: Integer): Pointer; cdecl;
  lua_tothread: function(L: Plua_State; idx: Integer): Plua_State; cdecl;
  lua_topointer: function(L: Plua_State; idx: Integer): Pointer; cdecl;
  lua_pushnil: procedure(L: Plua_State); cdecl;
  lua_pushnumber: procedure(L: Plua_State; n: lua_Number); cdecl;
  lua_pushinteger: procedure(L: Plua_State; n: lua_Integer); cdecl;
  lua_pushlstring: procedure(L: Plua_State; const s: PUTF8Char; l_: NativeUInt); cdecl;
  lua_pushstring: procedure(L: Plua_State; const s: PUTF8Char); cdecl;
  lua_pushvfstring: function(L: Plua_State; const fmt: PUTF8Char; argp: Pointer): PUTF8Char; cdecl;
  lua_pushfstring: function(L: Plua_State; const fmt: PUTF8Char): PUTF8Char varargs; cdecl;
  lua_pushcclosure: procedure(L: Plua_State; fn: lua_CFunction; n: Integer); cdecl;
  lua_pushboolean: procedure(L: Plua_State; b: Integer); cdecl;
  lua_pushlightuserdata: procedure(L: Plua_State; p: Pointer); cdecl;
  lua_pushthread: function(L: Plua_State): Integer; cdecl;
  lua_gettable: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_getfield: procedure(L: Plua_State; idx: Integer; const k: PUTF8Char); cdecl;
  lua_rawget: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_rawgeti: procedure(L: Plua_State; idx: Integer; n: Integer); cdecl;
  lua_createtable: procedure(L: Plua_State; narr: Integer; nrec: Integer); cdecl;
  lua_newuserdata: function(L: Plua_State; sz: NativeUInt): Pointer; cdecl;
  lua_getmetatable: function(L: Plua_State; objindex: Integer): Integer; cdecl;
  lua_getfenv: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_settable: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_setfield: procedure(L: Plua_State; idx: Integer; const k: PUTF8Char); cdecl;
  lua_rawset: procedure(L: Plua_State; idx: Integer); cdecl;
  lua_rawseti: procedure(L: Plua_State; idx: Integer; n: Integer); cdecl;
  lua_setmetatable: function(L: Plua_State; objindex: Integer): Integer; cdecl;
  lua_setfenv: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_call: procedure(L: Plua_State; nargs: Integer; nresults: Integer); cdecl;
  lua_pcall: function(L: Plua_State; nargs: Integer; nresults: Integer; errfunc: Integer): Integer; cdecl;
  lua_cpcall: function(L: Plua_State; func: lua_CFunction; ud: Pointer): Integer; cdecl;
  lua_load: function(L: Plua_State; reader: lua_Reader; dt: Pointer; const chunkname: PUTF8Char): Integer; cdecl;
  lua_dump: function(L: Plua_State; writer: lua_Writer; data: Pointer): Integer; cdecl;
  lua_yield: function(L: Plua_State; nresults: Integer): Integer; cdecl;
  lua_resume: function(L: Plua_State; narg: Integer): Integer; cdecl;
  lua_status: function(L: Plua_State): Integer; cdecl;
  lua_gc: function(L: Plua_State; what: Integer; data: Integer): Integer; cdecl;
  lua_error: function(L: Plua_State): Integer; cdecl;
  lua_next: function(L: Plua_State; idx: Integer): Integer; cdecl;
  lua_concat: procedure(L: Plua_State; n: Integer); cdecl;
  lua_getallocf: function(L: Plua_State; ud: PPointer): lua_Alloc; cdecl;
  lua_setallocf: procedure(L: Plua_State; f: lua_Alloc; ud: Pointer); cdecl;
  lua_getstack: function(L: Plua_State; level: Integer; ar: Plua_Debug): Integer; cdecl;
  lua_getinfo: function(L: Plua_State; const what: PUTF8Char; ar: Plua_Debug): Integer; cdecl;
  lua_getlocal: function(L: Plua_State; const ar: Plua_Debug; n: Integer): PUTF8Char; cdecl;
  lua_setlocal: function(L: Plua_State; const ar: Plua_Debug; n: Integer): PUTF8Char; cdecl;
  lua_getupvalue: function(L: Plua_State; funcindex: Integer; n: Integer): PUTF8Char; cdecl;
  lua_setupvalue: function(L: Plua_State; funcindex: Integer; n: Integer): PUTF8Char; cdecl;
  lua_sethook: function(L: Plua_State; func: lua_Hook; mask: Integer; count: Integer): Integer; cdecl;
  lua_gethook: function(L: Plua_State): lua_Hook; cdecl;
  lua_gethookmask: function(L: Plua_State): Integer; cdecl;
  lua_gethookcount: function(L: Plua_State): Integer; cdecl;
  lua_upvalueid: function(L: Plua_State; idx: Integer; n: Integer): Pointer; cdecl;
  lua_upvaluejoin: procedure(L: Plua_State; idx1: Integer; n1: Integer; idx2: Integer; n2: Integer); cdecl;
  lua_loadx: function(L: Plua_State; reader: lua_Reader; dt: Pointer; const chunkname: PUTF8Char; const mode: PUTF8Char): Integer; cdecl;
  lua_version: function(L: Plua_State): Plua_Number; cdecl;
  lua_copy: procedure(L: Plua_State; fromidx: Integer; toidx: Integer); cdecl;
  lua_tonumberx: function(L: Plua_State; idx: Integer; isnum: PInteger): lua_Number; cdecl;
  lua_tointegerx: function(L: Plua_State; idx: Integer; isnum: PInteger): lua_Integer; cdecl;
  lua_isyieldable: function(L: Plua_State): Integer; cdecl;
  luaopen_base: function(L: Plua_State): Integer; cdecl;
  luaopen_math: function(L: Plua_State): Integer; cdecl;
  luaopen_string: function(L: Plua_State): Integer; cdecl;
  luaopen_table: function(L: Plua_State): Integer; cdecl;
  luaopen_io: function(L: Plua_State): Integer; cdecl;
  luaopen_os: function(L: Plua_State): Integer; cdecl;
  luaopen_package: function(L: Plua_State): Integer; cdecl;
  luaopen_debug: function(L: Plua_State): Integer; cdecl;
  luaopen_bit: function(L: Plua_State): Integer; cdecl;
  luaopen_jit: function(L: Plua_State): Integer; cdecl;
  luaopen_ffi: function(L: Plua_State): Integer; cdecl;
  luaopen_string_buffer: function(L: Plua_State): Integer; cdecl;
  luaL_openlibs: procedure(L: Plua_State); cdecl;
  luaL_openlib: procedure(L: Plua_State; const libname: PUTF8Char; const l_: PluaL_Reg; nup: Integer); cdecl;
  luaL_register: procedure(L: Plua_State; const libname: PUTF8Char; const l_: PluaL_Reg); cdecl;
  luaL_getmetafield: function(L: Plua_State; obj: Integer; const e: PUTF8Char): Integer; cdecl;
  luaL_callmeta: function(L: Plua_State; obj: Integer; const e: PUTF8Char): Integer; cdecl;
  luaL_typerror: function(L: Plua_State; narg: Integer; const tname: PUTF8Char): Integer; cdecl;
  luaL_argerror: function(L: Plua_State; numarg: Integer; const extramsg: PUTF8Char): Integer; cdecl;
  luaL_checklstring: function(L: Plua_State; numArg: Integer; l_: PNativeUInt): PUTF8Char; cdecl;
  luaL_optlstring: function(L: Plua_State; numArg: Integer; const def: PUTF8Char; l_: PNativeUInt): PUTF8Char; cdecl;
  luaL_checknumber: function(L: Plua_State; numArg: Integer): lua_Number; cdecl;
  luaL_optnumber: function(L: Plua_State; nArg: Integer; def: lua_Number): lua_Number; cdecl;
  luaL_checkinteger: function(L: Plua_State; numArg: Integer): lua_Integer; cdecl;
  luaL_optinteger: function(L: Plua_State; nArg: Integer; def: lua_Integer): lua_Integer; cdecl;
  luaL_checkstack: procedure(L: Plua_State; sz: Integer; const msg: PUTF8Char); cdecl;
  luaL_checktype: procedure(L: Plua_State; narg: Integer; t: Integer); cdecl;
  luaL_checkany: procedure(L: Plua_State; narg: Integer); cdecl;
  luaL_newmetatable: function(L: Plua_State; const tname: PUTF8Char): Integer; cdecl;
  luaL_checkudata: function(L: Plua_State; ud: Integer; const tname: PUTF8Char): Pointer; cdecl;
  luaL_where: procedure(L: Plua_State; lvl: Integer); cdecl;
  luaL_error: function(L: Plua_State; const fmt: PUTF8Char): Integer varargs; cdecl;
  luaL_checkoption: function(L: Plua_State; narg: Integer; const def: PUTF8Char; lst: PPUTF8Char): Integer; cdecl;
  luaL_ref: function(L: Plua_State; t: Integer): Integer; cdecl;
  luaL_unref: procedure(L: Plua_State; t: Integer; ref: Integer); cdecl;
  luaL_loadfile: function(L: Plua_State; const filename: PUTF8Char): Integer; cdecl;
  luaL_loadbuffer: function(L: Plua_State; const buff: PUTF8Char; sz: NativeUInt; const name: PUTF8Char): Integer; cdecl;
  luaL_loadstring: function(L: Plua_State; const s: PUTF8Char): Integer; cdecl;
  luaL_newstate: function(): Plua_State; cdecl;
  luaL_gsub: function(L: Plua_State; const s: PUTF8Char; const p: PUTF8Char; const r: PUTF8Char): PUTF8Char; cdecl;
  luaL_findtable: function(L: Plua_State; idx: Integer; const fname: PUTF8Char; szhint: Integer): PUTF8Char; cdecl;
  luaL_fileresult: function(L: Plua_State; stat: Integer; const fname: PUTF8Char): Integer; cdecl;
  luaL_execresult: function(L: Plua_State; stat: Integer): Integer; cdecl;
  luaL_loadfilex: function(L: Plua_State; const filename: PUTF8Char; const mode: PUTF8Char): Integer; cdecl;
  luaL_loadbufferx: function(L: Plua_State; const buff: PUTF8Char; sz: NativeUInt; const name: PUTF8Char; const mode: PUTF8Char): Integer; cdecl;
  luaL_traceback: procedure(L: Plua_State; L1: Plua_State; const msg: PUTF8Char; level: Integer); cdecl;
  luaL_setfuncs: procedure(L: Plua_State; const l_: PluaL_Reg; nup: Integer); cdecl;
  luaL_pushmodule: procedure(L: Plua_State; const modname: PUTF8Char; sizehint: Integer); cdecl;
  luaL_testudata: function(L: Plua_State; ud: Integer; const tname: PUTF8Char): Pointer; cdecl;
  luaL_setmetatable: procedure(L: Plua_State; const tname: PUTF8Char); cdecl;
  luaL_buffinit: procedure(L: Plua_State; B: PluaL_Buffer); cdecl;
  luaL_prepbuffer: function(B: PluaL_Buffer): PUTF8Char; cdecl;
  luaL_addlstring: procedure(B: PluaL_Buffer; const s: PUTF8Char; l: NativeUInt); cdecl;
  luaL_addstring: procedure(B: PluaL_Buffer; const s: PUTF8Char); cdecl;
  luaL_addvalue: procedure(B: PluaL_Buffer); cdecl;
  luaL_pushresult: procedure(B: PluaL_Buffer); cdecl;
  luaJIT_setmode: function(L: Plua_State; idx: Integer; mode: Integer): Integer; cdecl;
  luaJIT_profile_start: procedure(L: Plua_State; const mode: PUTF8Char; cb: luaJIT_profile_callback; data: Pointer); cdecl;
  luaJIT_profile_stop: procedure(L: Plua_State); cdecl;
  luaJIT_profile_dumpstack: function(L: Plua_State; const fmt: PUTF8Char; depth: Integer; len: PNativeUInt): PUTF8Char; cdecl;
  luaJIT_version_2_1_1736781742: procedure(); cdecl;
  spFloatArray_create: function(initialCapacity: Integer): PspFloatArray; cdecl;
  spFloatArray_dispose: procedure(self: PspFloatArray); cdecl;
  spFloatArray_clear: procedure(self: PspFloatArray); cdecl;
  spFloatArray_setSize: function(self: PspFloatArray; newSize: Integer): PspFloatArray; cdecl;
  spFloatArray_ensureCapacity: procedure(self: PspFloatArray; newCapacity: Integer); cdecl;
  spFloatArray_add: procedure(self: PspFloatArray; value: Single); cdecl;
  spFloatArray_addAll: procedure(self: PspFloatArray; other: PspFloatArray); cdecl;
  spFloatArray_addAllValues: procedure(self: PspFloatArray; values: PSingle; offset: Integer; count: Integer); cdecl;
  spFloatArray_removeAt: procedure(self: PspFloatArray; index: Integer); cdecl;
  spFloatArray_contains: function(self: PspFloatArray; value: Single): Integer; cdecl;
  spFloatArray_pop: function(self: PspFloatArray): Single; cdecl;
  spFloatArray_peek: function(self: PspFloatArray): Single; cdecl;
  spIntArray_create: function(initialCapacity: Integer): PspIntArray; cdecl;
  spIntArray_dispose: procedure(self: PspIntArray); cdecl;
  spIntArray_clear: procedure(self: PspIntArray); cdecl;
  spIntArray_setSize: function(self: PspIntArray; newSize: Integer): PspIntArray; cdecl;
  spIntArray_ensureCapacity: procedure(self: PspIntArray; newCapacity: Integer); cdecl;
  spIntArray_add: procedure(self: PspIntArray; value: Integer); cdecl;
  spIntArray_addAll: procedure(self: PspIntArray; other: PspIntArray); cdecl;
  spIntArray_addAllValues: procedure(self: PspIntArray; values: PInteger; offset: Integer; count: Integer); cdecl;
  spIntArray_removeAt: procedure(self: PspIntArray; index: Integer); cdecl;
  spIntArray_contains: function(self: PspIntArray; value: Integer): Integer; cdecl;
  spIntArray_pop: function(self: PspIntArray): Integer; cdecl;
  spIntArray_peek: function(self: PspIntArray): Integer; cdecl;
  spShortArray_create: function(initialCapacity: Integer): PspShortArray; cdecl;
  spShortArray_dispose: procedure(self: PspShortArray); cdecl;
  spShortArray_clear: procedure(self: PspShortArray); cdecl;
  spShortArray_setSize: function(self: PspShortArray; newSize: Integer): PspShortArray; cdecl;
  spShortArray_ensureCapacity: procedure(self: PspShortArray; newCapacity: Integer); cdecl;
  spShortArray_add: procedure(self: PspShortArray; value: Smallint); cdecl;
  spShortArray_addAll: procedure(self: PspShortArray; other: PspShortArray); cdecl;
  spShortArray_addAllValues: procedure(self: PspShortArray; values: PSmallint; offset: Integer; count: Integer); cdecl;
  spShortArray_removeAt: procedure(self: PspShortArray; index: Integer); cdecl;
  spShortArray_contains: function(self: PspShortArray; value: Smallint): Integer; cdecl;
  spShortArray_pop: function(self: PspShortArray): Smallint; cdecl;
  spShortArray_peek: function(self: PspShortArray): Smallint; cdecl;
  spUnsignedShortArray_create: function(initialCapacity: Integer): PspUnsignedShortArray; cdecl;
  spUnsignedShortArray_dispose: procedure(self: PspUnsignedShortArray); cdecl;
  spUnsignedShortArray_clear: procedure(self: PspUnsignedShortArray); cdecl;
  spUnsignedShortArray_setSize: function(self: PspUnsignedShortArray; newSize: Integer): PspUnsignedShortArray; cdecl;
  spUnsignedShortArray_ensureCapacity: procedure(self: PspUnsignedShortArray; newCapacity: Integer); cdecl;
  spUnsignedShortArray_add: procedure(self: PspUnsignedShortArray; value: Word); cdecl;
  spUnsignedShortArray_addAll: procedure(self: PspUnsignedShortArray; other: PspUnsignedShortArray); cdecl;
  spUnsignedShortArray_addAllValues: procedure(self: PspUnsignedShortArray; values: PWord; offset: Integer; count: Integer); cdecl;
  spUnsignedShortArray_removeAt: procedure(self: PspUnsignedShortArray; index: Integer); cdecl;
  spUnsignedShortArray_contains: function(self: PspUnsignedShortArray; value: Word): Integer; cdecl;
  spUnsignedShortArray_pop: function(self: PspUnsignedShortArray): Word; cdecl;
  spUnsignedShortArray_peek: function(self: PspUnsignedShortArray): Word; cdecl;
  spArrayFloatArray_create: function(initialCapacity: Integer): PspArrayFloatArray; cdecl;
  spArrayFloatArray_dispose: procedure(self: PspArrayFloatArray); cdecl;
  spArrayFloatArray_clear: procedure(self: PspArrayFloatArray); cdecl;
  spArrayFloatArray_setSize: function(self: PspArrayFloatArray; newSize: Integer): PspArrayFloatArray; cdecl;
  spArrayFloatArray_ensureCapacity: procedure(self: PspArrayFloatArray; newCapacity: Integer); cdecl;
  spArrayFloatArray_add: procedure(self: PspArrayFloatArray; value: PspFloatArray); cdecl;
  spArrayFloatArray_addAll: procedure(self: PspArrayFloatArray; other: PspArrayFloatArray); cdecl;
  spArrayFloatArray_addAllValues: procedure(self: PspArrayFloatArray; values: PPspFloatArray; offset: Integer; count: Integer); cdecl;
  spArrayFloatArray_removeAt: procedure(self: PspArrayFloatArray; index: Integer); cdecl;
  spArrayFloatArray_contains: function(self: PspArrayFloatArray; value: PspFloatArray): Integer; cdecl;
  spArrayFloatArray_pop: function(self: PspArrayFloatArray): PspFloatArray; cdecl;
  spArrayFloatArray_peek: function(self: PspArrayFloatArray): PspFloatArray; cdecl;
  spArrayShortArray_create: function(initialCapacity: Integer): PspArrayShortArray; cdecl;
  spArrayShortArray_dispose: procedure(self: PspArrayShortArray); cdecl;
  spArrayShortArray_clear: procedure(self: PspArrayShortArray); cdecl;
  spArrayShortArray_setSize: function(self: PspArrayShortArray; newSize: Integer): PspArrayShortArray; cdecl;
  spArrayShortArray_ensureCapacity: procedure(self: PspArrayShortArray; newCapacity: Integer); cdecl;
  spArrayShortArray_add: procedure(self: PspArrayShortArray; value: PspShortArray); cdecl;
  spArrayShortArray_addAll: procedure(self: PspArrayShortArray; other: PspArrayShortArray); cdecl;
  spArrayShortArray_addAllValues: procedure(self: PspArrayShortArray; values: PPspShortArray; offset: Integer; count: Integer); cdecl;
  spArrayShortArray_removeAt: procedure(self: PspArrayShortArray; index: Integer); cdecl;
  spArrayShortArray_contains: function(self: PspArrayShortArray; value: PspShortArray): Integer; cdecl;
  spArrayShortArray_pop: function(self: PspArrayShortArray): PspShortArray; cdecl;
  spArrayShortArray_peek: function(self: PspArrayShortArray): PspShortArray; cdecl;
  spEventData_create: function(const name: PUTF8Char): PspEventData; cdecl;
  spEventData_dispose: procedure(self: PspEventData); cdecl;
  spEvent_create: function(time: Single; data: PspEventData): PspEvent; cdecl;
  spEvent_dispose: procedure(self: PspEvent); cdecl;
  spAttachment_dispose: procedure(self: PspAttachment); cdecl;
  spAttachment_copy: function(self: PspAttachment): PspAttachment; cdecl;
  spColor_create: function(): PspColor; cdecl;
  spColor_dispose: procedure(self: PspColor); cdecl;
  spColor_setFromFloats: procedure(color: PspColor; r: Single; g: Single; b: Single; a: Single); cdecl;
  spColor_setFromFloats3: procedure(self: PspColor; r: Single; g: Single; b: Single); cdecl;
  spColor_setFromColor: procedure(color: PspColor; otherColor: PspColor); cdecl;
  spColor_setFromColor3: procedure(self: PspColor; otherColor: PspColor); cdecl;
  spColor_addFloats: procedure(color: PspColor; r: Single; g: Single; b: Single; a: Single); cdecl;
  spColor_addFloats3: procedure(color: PspColor; r: Single; g: Single; b: Single); cdecl;
  spColor_addColor: procedure(color: PspColor; otherColor: PspColor); cdecl;
  spColor_clamp: procedure(color: PspColor); cdecl;
  spBoneData_create: function(index: Integer; const name: PUTF8Char; parent: PspBoneData): PspBoneData; cdecl;
  spBoneData_dispose: procedure(self: PspBoneData); cdecl;
  spBone_setYDown: procedure(yDown: Integer); cdecl;
  spBone_isYDown: function(): Integer; cdecl;
  spBone_create: function(data: PspBoneData; skeleton: PspSkeleton; parent: PspBone): PspBone; cdecl;
  spBone_dispose: procedure(self: PspBone); cdecl;
  spBone_setToSetupPose: procedure(self: PspBone); cdecl;
  spBone_update: procedure(self: PspBone); cdecl;
  spBone_updateWorldTransform: procedure(self: PspBone); cdecl;
  spBone_updateWorldTransformWith: procedure(self: PspBone; x: Single; y: Single; rotation: Single; scaleX: Single; scaleY: Single; shearX: Single; shearY: Single); cdecl;
  spBone_getWorldRotationX: function(self: PspBone): Single; cdecl;
  spBone_getWorldRotationY: function(self: PspBone): Single; cdecl;
  spBone_getWorldScaleX: function(self: PspBone): Single; cdecl;
  spBone_getWorldScaleY: function(self: PspBone): Single; cdecl;
  spBone_updateAppliedTransform: procedure(self: PspBone); cdecl;
  spBone_worldToLocal: procedure(self: PspBone; worldX: Single; worldY: Single; localX: PSingle; localY: PSingle); cdecl;
  spBone_worldToParent: procedure(self: PspBone; worldX: Single; worldY: Single; parentX: PSingle; parentY: PSingle); cdecl;
  spBone_localToWorld: procedure(self: PspBone; localX: Single; localY: Single; worldX: PSingle; worldY: PSingle); cdecl;
  spBone_worldToLocalRotation: function(self: PspBone; worldRotation: Single): Single; cdecl;
  spBone_localToWorldRotation: function(self: PspBone; localRotation: Single): Single; cdecl;
  spBone_rotateWorld: procedure(self: PspBone; degrees: Single); cdecl;
  spSlotData_create: function(const index: Integer; const name: PUTF8Char; boneData: PspBoneData): PspSlotData; cdecl;
  spSlotData_dispose: procedure(self: PspSlotData); cdecl;
  spSlotData_setAttachmentName: procedure(self: PspSlotData; const attachmentName: PUTF8Char); cdecl;
  spSlot_create: function(data: PspSlotData; bone: PspBone): PspSlot; cdecl;
  spSlot_dispose: procedure(self: PspSlot); cdecl;
  spSlot_setAttachment: procedure(self: PspSlot; attachment: PspAttachment); cdecl;
  spSlot_setToSetupPose: procedure(self: PspSlot); cdecl;
  spVertexAttachment_computeWorldVertices: procedure(self: PspVertexAttachment; slot: PspSlot; start: Integer; count: Integer; worldVertices: PSingle; offset: Integer; stride: Integer); cdecl;
  spVertexAttachment_copyTo: procedure(self: PspVertexAttachment; other: PspVertexAttachment); cdecl;
  spAtlasPage_create: function(atlas: PspAtlas; const name: PUTF8Char): PspAtlasPage; cdecl;
  spAtlasPage_dispose: procedure(self: PspAtlasPage); cdecl;
  spKeyValueArray_create: function(initialCapacity: Integer): PspKeyValueArray; cdecl;
  spKeyValueArray_dispose: procedure(self: PspKeyValueArray); cdecl;
  spKeyValueArray_clear: procedure(self: PspKeyValueArray); cdecl;
  spKeyValueArray_setSize: function(self: PspKeyValueArray; newSize: Integer): PspKeyValueArray; cdecl;
  spKeyValueArray_ensureCapacity: procedure(self: PspKeyValueArray; newCapacity: Integer); cdecl;
  spKeyValueArray_add: procedure(self: PspKeyValueArray; value: spKeyValue); cdecl;
  spKeyValueArray_addAll: procedure(self: PspKeyValueArray; other: PspKeyValueArray); cdecl;
  spKeyValueArray_addAllValues: procedure(self: PspKeyValueArray; values: PspKeyValue; offset: Integer; count: Integer); cdecl;
  spKeyValueArray_contains: function(self: PspKeyValueArray; value: spKeyValue): Integer; cdecl;
  spKeyValueArray_pop: function(self: PspKeyValueArray): spKeyValue; cdecl;
  spKeyValueArray_peek: function(self: PspKeyValueArray): spKeyValue; cdecl;
  spAtlasRegion_create: function(): PspAtlasRegion; cdecl;
  spAtlasRegion_dispose: procedure(self: PspAtlasRegion); cdecl;
  spAtlas_create: function(const data: PUTF8Char; length: Integer; const dir: PUTF8Char; rendererObject: Pointer): PspAtlas; cdecl;
  spAtlas_createFromFile: function(const path: PUTF8Char; rendererObject: Pointer): PspAtlas; cdecl;
  spAtlas_dispose: procedure(atlas: PspAtlas); cdecl;
  spAtlas_findRegion: function(const self: PspAtlas; const name: PUTF8Char): PspAtlasRegion; cdecl;
  spTextureRegionArray_create: function(initialCapacity: Integer): PspTextureRegionArray; cdecl;
  spTextureRegionArray_dispose: procedure(self: PspTextureRegionArray); cdecl;
  spTextureRegionArray_clear: procedure(self: PspTextureRegionArray); cdecl;
  spTextureRegionArray_setSize: function(self: PspTextureRegionArray; newSize: Integer): PspTextureRegionArray; cdecl;
  spTextureRegionArray_ensureCapacity: procedure(self: PspTextureRegionArray; newCapacity: Integer); cdecl;
  spTextureRegionArray_add: procedure(self: PspTextureRegionArray; value: PspTextureRegion); cdecl;
  spTextureRegionArray_addAll: procedure(self: PspTextureRegionArray; other: PspTextureRegionArray); cdecl;
  spTextureRegionArray_addAllValues: procedure(self: PspTextureRegionArray; values: PPspTextureRegion; offset: Integer; count: Integer); cdecl;
  spTextureRegionArray_removeAt: procedure(self: PspTextureRegionArray; index: Integer); cdecl;
  spTextureRegionArray_contains: function(self: PspTextureRegionArray; value: PspTextureRegion): Integer; cdecl;
  spTextureRegionArray_pop: function(self: PspTextureRegionArray): PspTextureRegion; cdecl;
  spTextureRegionArray_peek: function(self: PspTextureRegionArray): PspTextureRegion; cdecl;
  spSequence_create: function(numRegions: Integer): PspSequence; cdecl;
  spSequence_dispose: procedure(self: PspSequence); cdecl;
  spSequence_copy: function(self: PspSequence): PspSequence; cdecl;
  spSequence_apply: procedure(self: PspSequence; slot: PspSlot; attachment: PspAttachment); cdecl;
  spSequence_getPath: procedure(self: PspSequence; const basePath: PUTF8Char; index: Integer; path: PUTF8Char); cdecl;
  spPropertyIdArray_create: function(initialCapacity: Integer): PspPropertyIdArray; cdecl;
  spPropertyIdArray_dispose: procedure(self: PspPropertyIdArray); cdecl;
  spPropertyIdArray_clear: procedure(self: PspPropertyIdArray); cdecl;
  spPropertyIdArray_setSize: function(self: PspPropertyIdArray; newSize: Integer): PspPropertyIdArray; cdecl;
  spPropertyIdArray_ensureCapacity: procedure(self: PspPropertyIdArray; newCapacity: Integer); cdecl;
  spPropertyIdArray_add: procedure(self: PspPropertyIdArray; value: spPropertyId); cdecl;
  spPropertyIdArray_addAll: procedure(self: PspPropertyIdArray; other: PspPropertyIdArray); cdecl;
  spPropertyIdArray_addAllValues: procedure(self: PspPropertyIdArray; values: PspPropertyId; offset: Integer; count: Integer); cdecl;
  spPropertyIdArray_removeAt: procedure(self: PspPropertyIdArray; index: Integer); cdecl;
  spPropertyIdArray_contains: function(self: PspPropertyIdArray; value: spPropertyId): Integer; cdecl;
  spPropertyIdArray_pop: function(self: PspPropertyIdArray): spPropertyId; cdecl;
  spPropertyIdArray_peek: function(self: PspPropertyIdArray): spPropertyId; cdecl;
  spTimelineArray_create: function(initialCapacity: Integer): PspTimelineArray; cdecl;
  spTimelineArray_dispose: procedure(self: PspTimelineArray); cdecl;
  spTimelineArray_clear: procedure(self: PspTimelineArray); cdecl;
  spTimelineArray_setSize: function(self: PspTimelineArray; newSize: Integer): PspTimelineArray; cdecl;
  spTimelineArray_ensureCapacity: procedure(self: PspTimelineArray; newCapacity: Integer); cdecl;
  spTimelineArray_add: procedure(self: PspTimelineArray; value: PspTimeline); cdecl;
  spTimelineArray_addAll: procedure(self: PspTimelineArray; other: PspTimelineArray); cdecl;
  spTimelineArray_addAllValues: procedure(self: PspTimelineArray; values: PPspTimeline; offset: Integer; count: Integer); cdecl;
  spTimelineArray_removeAt: procedure(self: PspTimelineArray; index: Integer); cdecl;
  spTimelineArray_contains: function(self: PspTimelineArray; value: PspTimeline): Integer; cdecl;
  spTimelineArray_pop: function(self: PspTimelineArray): PspTimeline; cdecl;
  spTimelineArray_peek: function(self: PspTimelineArray): PspTimeline; cdecl;
  spAnimation_create: function(const name: PUTF8Char; timelines: PspTimelineArray; duration: Single): PspAnimation; cdecl;
  spAnimation_dispose: procedure(self: PspAnimation); cdecl;
  spAnimation_hasTimeline: function(self: PspAnimation; ids: PspPropertyId; idsCount: Integer): Integer; cdecl;
  spAnimation_apply: procedure(const self: PspAnimation; skeleton: PspSkeleton; lastTime: Single; time: Single; loop: Integer; events: PPspEvent; eventsCount: PInteger; alpha: Single; blend: spMixBlend; direction: spMixDirection); cdecl;
  spTimeline_dispose: procedure(self: PspTimeline); cdecl;
  spTimeline_apply: procedure(self: PspTimeline; skeleton: PspSkeleton; lastTime: Single; time: Single; firedEvents: PPspEvent; eventsCount: PInteger; alpha: Single; blend: spMixBlend; direction: spMixDirection); cdecl;
  spTimeline_setBezier: procedure(self: PspTimeline; bezier: Integer; frame: Integer; value: Single; time1: Single; value1: Single; cx1: Single; cy1: Single; cx2: Single; cy2: Single; time2: Single; value2: Single); cdecl;
  spTimeline_getDuration: function(const self: PspTimeline): Single; cdecl;
  spCurveTimeline_setLinear: procedure(self: PspCurveTimeline; frameIndex: Integer); cdecl;
  spCurveTimeline_setStepped: procedure(self: PspCurveTimeline; frameIndex: Integer); cdecl;
  spCurveTimeline1_setFrame: procedure(self: PspCurveTimeline1; frame: Integer; time: Single; value: Single); cdecl;
  spCurveTimeline1_getCurveValue: function(self: PspCurveTimeline1; time: Single): Single; cdecl;
  spCurveTimeline1_getRelativeValue: function(timeline: PspCurveTimeline1; time: Single; alpha: Single; blend: spMixBlend; current: Single; setup: Single): Single; cdecl;
  spCurveTimeline1_getAbsoluteValue: function(timeline: PspCurveTimeline1; time: Single; alpha: Single; blend: spMixBlend; current: Single; setup: Single): Single; cdecl;
  spCurveTimeline1_getAbsoluteValue2: function(timeline: PspCurveTimeline1; time: Single; alpha: Single; blend: spMixBlend; current: Single; setup: Single; value: Single): Single; cdecl;
  spCurveTimeline1_getScaleValue: function(timeline: PspCurveTimeline1; time: Single; alpha: Single; blend: spMixBlend; direction: spMixDirection; current: Single; setup: Single): Single; cdecl;
  spCurveTimeline2_setFrame: procedure(self: PspCurveTimeline1; frame: Integer; time: Single; value1: Single; value2: Single); cdecl;
  spRotateTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspRotateTimeline; cdecl;
  spRotateTimeline_setFrame: procedure(self: PspRotateTimeline; frameIndex: Integer; time: Single; angle: Single); cdecl;
  spTranslateTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspTranslateTimeline; cdecl;
  spTranslateTimeline_setFrame: procedure(self: PspTranslateTimeline; frameIndex: Integer; time: Single; x: Single; y: Single); cdecl;
  spTranslateXTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspTranslateXTimeline; cdecl;
  spTranslateXTimeline_setFrame: procedure(self: PspTranslateXTimeline; frame: Integer; time: Single; x: Single); cdecl;
  spTranslateYTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspTranslateYTimeline; cdecl;
  spTranslateYTimeline_setFrame: procedure(self: PspTranslateYTimeline; frame: Integer; time: Single; y: Single); cdecl;
  spScaleTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspScaleTimeline; cdecl;
  spScaleTimeline_setFrame: procedure(self: PspScaleTimeline; frameIndex: Integer; time: Single; x: Single; y: Single); cdecl;
  spScaleXTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspScaleXTimeline; cdecl;
  spScaleXTimeline_setFrame: procedure(self: PspScaleXTimeline; frame: Integer; time: Single; x: Single); cdecl;
  spScaleYTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspScaleYTimeline; cdecl;
  spScaleYTimeline_setFrame: procedure(self: PspScaleYTimeline; frame: Integer; time: Single; y: Single); cdecl;
  spShearTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspShearTimeline; cdecl;
  spShearTimeline_setFrame: procedure(self: PspShearTimeline; frameIndex: Integer; time: Single; x: Single; y: Single); cdecl;
  spShearXTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspShearXTimeline; cdecl;
  spShearXTimeline_setFrame: procedure(self: PspShearXTimeline; frame: Integer; time: Single; x: Single); cdecl;
  spShearYTimeline_create: function(frameCount: Integer; bezierCount: Integer; boneIndex: Integer): PspShearYTimeline; cdecl;
  spShearYTimeline_setFrame: procedure(self: PspShearYTimeline; frame: Integer; time: Single; x: Single); cdecl;
  spRGBATimeline_create: function(framesCount: Integer; bezierCount: Integer; slotIndex: Integer): PspRGBATimeline; cdecl;
  spRGBATimeline_setFrame: procedure(self: PspRGBATimeline; frameIndex: Integer; time: Single; r: Single; g: Single; b: Single; a: Single); cdecl;
  spRGBTimeline_create: function(framesCount: Integer; bezierCount: Integer; slotIndex: Integer): PspRGBTimeline; cdecl;
  spRGBTimeline_setFrame: procedure(self: PspRGBTimeline; frameIndex: Integer; time: Single; r: Single; g: Single; b: Single); cdecl;
  spAlphaTimeline_create: function(frameCount: Integer; bezierCount: Integer; slotIndex: Integer): PspAlphaTimeline; cdecl;
  spAlphaTimeline_setFrame: procedure(self: PspAlphaTimeline; frame: Integer; time: Single; x: Single); cdecl;
  spRGBA2Timeline_create: function(framesCount: Integer; bezierCount: Integer; slotIndex: Integer): PspRGBA2Timeline; cdecl;
  spRGBA2Timeline_setFrame: procedure(self: PspRGBA2Timeline; frameIndex: Integer; time: Single; r: Single; g: Single; b: Single; a: Single; r2: Single; g2: Single; b2: Single); cdecl;
  spRGB2Timeline_create: function(framesCount: Integer; bezierCount: Integer; slotIndex: Integer): PspRGB2Timeline; cdecl;
  spRGB2Timeline_setFrame: procedure(self: PspRGB2Timeline; frameIndex: Integer; time: Single; r: Single; g: Single; b: Single; r2: Single; g2: Single; b2: Single); cdecl;
  spAttachmentTimeline_create: function(framesCount: Integer; SlotIndex: Integer): PspAttachmentTimeline; cdecl;
  spAttachmentTimeline_setFrame: procedure(self: PspAttachmentTimeline; frameIndex: Integer; time: Single; const attachmentName: PUTF8Char); cdecl;
  spDeformTimeline_create: function(framesCount: Integer; frameVerticesCount: Integer; bezierCount: Integer; slotIndex: Integer; attachment: PspVertexAttachment): PspDeformTimeline; cdecl;
  spDeformTimeline_setFrame: procedure(self: PspDeformTimeline; frameIndex: Integer; time: Single; vertices: PSingle); cdecl;
  spSequenceTimeline_create: function(framesCount: Integer; slotIndex: Integer; attachment: PspAttachment): PspSequenceTimeline; cdecl;
  spSequenceTimeline_setFrame: procedure(self: PspSequenceTimeline; frameIndex: Integer; time: Single; mode: Integer; index: Integer; delay: Single); cdecl;
  spEventTimeline_create: function(framesCount: Integer): PspEventTimeline; cdecl;
  spEventTimeline_setFrame: procedure(self: PspEventTimeline; frameIndex: Integer; event: PspEvent); cdecl;
  spDrawOrderTimeline_create: function(framesCount: Integer; slotsCount: Integer): PspDrawOrderTimeline; cdecl;
  spDrawOrderTimeline_setFrame: procedure(self: PspDrawOrderTimeline; frameIndex: Integer; time: Single; const drawOrder: PInteger); cdecl;
  spInheritTimeline_create: function(framesCount: Integer; boneIndex: Integer): PspInheritTimeline; cdecl;
  spInheritTimeline_setFrame: procedure(self: PspInheritTimeline; frameIndex: Integer; time: Single; inherit: spInherit); cdecl;
  spIkConstraintTimeline_create: function(framesCount: Integer; bezierCount: Integer; transformConstraintIndex: Integer): PspIkConstraintTimeline; cdecl;
  spIkConstraintTimeline_setFrame: procedure(self: PspIkConstraintTimeline; frameIndex: Integer; time: Single; mix: Single; softness: Single; bendDirection: Integer; compress: Integer; stretch: Integer); cdecl;
  spTransformConstraintTimeline_create: function(framesCount: Integer; bezierCount: Integer; transformConstraintIndex: Integer): PspTransformConstraintTimeline; cdecl;
  spTransformConstraintTimeline_setFrame: procedure(self: PspTransformConstraintTimeline; frameIndex: Integer; time: Single; mixRotate: Single; mixX: Single; mixY: Single; mixScaleX: Single; mixScaleY: Single; mixShearY: Single); cdecl;
  spPathConstraintPositionTimeline_create: function(framesCount: Integer; bezierCount: Integer; pathConstraintIndex: Integer): PspPathConstraintPositionTimeline; cdecl;
  spPathConstraintPositionTimeline_setFrame: procedure(self: PspPathConstraintPositionTimeline; frameIndex: Integer; time: Single; value: Single); cdecl;
  spPathConstraintSpacingTimeline_create: function(framesCount: Integer; bezierCount: Integer; pathConstraintIndex: Integer): PspPathConstraintSpacingTimeline; cdecl;
  spPathConstraintSpacingTimeline_setFrame: procedure(self: PspPathConstraintSpacingTimeline; frameIndex: Integer; time: Single; value: Single); cdecl;
  spPathConstraintMixTimeline_create: function(framesCount: Integer; bezierCount: Integer; pathConstraintIndex: Integer): PspPathConstraintMixTimeline; cdecl;
  spPathConstraintMixTimeline_setFrame: procedure(self: PspPathConstraintMixTimeline; frameIndex: Integer; time: Single; mixRotate: Single; mixX: Single; mixY: Single); cdecl;
  spPhysicsConstraintTimeline_create: function(framesCount: Integer; bezierCount: Integer; physicsConstraintIndex: Integer; &type: spTimelineType): PspPhysicsConstraintTimeline; cdecl;
  spPhysicsConstraintTimeline_setFrame: procedure(self: PspPhysicsConstraintTimeline; frame: Integer; time: Single; value: Single); cdecl;
  spPhysicsConstraintResetTimeline_create: function(framesCount: Integer; boneIndex: Integer): PspPhysicsConstraintResetTimeline; cdecl;
  spPhysicsConstraintResetTimeline_setFrame: procedure(self: PspPhysicsConstraintResetTimeline; frameIndex: Integer; time: Single); cdecl;
  spIkConstraintData_create: function(const name: PUTF8Char): PspIkConstraintData; cdecl;
  spIkConstraintData_dispose: procedure(self: PspIkConstraintData); cdecl;
  spTransformConstraintData_create: function(const name: PUTF8Char): PspTransformConstraintData; cdecl;
  spTransformConstraintData_dispose: procedure(self: PspTransformConstraintData); cdecl;
  spPathConstraintData_create: function(const name: PUTF8Char): PspPathConstraintData; cdecl;
  spPathConstraintData_dispose: procedure(self: PspPathConstraintData); cdecl;
  spPhysicsConstraintData_create: function(const name: PUTF8Char): PspPhysicsConstraintData; cdecl;
  spPhysicsConstraintData_dispose: procedure(self: PspPhysicsConstraintData); cdecl;
  spBoneDataArray_create: function(initialCapacity: Integer): PspBoneDataArray; cdecl;
  spBoneDataArray_dispose: procedure(self: PspBoneDataArray); cdecl;
  spBoneDataArray_clear: procedure(self: PspBoneDataArray); cdecl;
  spBoneDataArray_setSize: function(self: PspBoneDataArray; newSize: Integer): PspBoneDataArray; cdecl;
  spBoneDataArray_ensureCapacity: procedure(self: PspBoneDataArray; newCapacity: Integer); cdecl;
  spBoneDataArray_add: procedure(self: PspBoneDataArray; value: PspBoneData); cdecl;
  spBoneDataArray_addAll: procedure(self: PspBoneDataArray; other: PspBoneDataArray); cdecl;
  spBoneDataArray_addAllValues: procedure(self: PspBoneDataArray; values: PPspBoneData; offset: Integer; count: Integer); cdecl;
  spBoneDataArray_removeAt: procedure(self: PspBoneDataArray; index: Integer); cdecl;
  spBoneDataArray_contains: function(self: PspBoneDataArray; value: PspBoneData): Integer; cdecl;
  spBoneDataArray_pop: function(self: PspBoneDataArray): PspBoneData; cdecl;
  spBoneDataArray_peek: function(self: PspBoneDataArray): PspBoneData; cdecl;
  spIkConstraintDataArray_create: function(initialCapacity: Integer): PspIkConstraintDataArray; cdecl;
  spIkConstraintDataArray_dispose: procedure(self: PspIkConstraintDataArray); cdecl;
  spIkConstraintDataArray_clear: procedure(self: PspIkConstraintDataArray); cdecl;
  spIkConstraintDataArray_setSize: function(self: PspIkConstraintDataArray; newSize: Integer): PspIkConstraintDataArray; cdecl;
  spIkConstraintDataArray_ensureCapacity: procedure(self: PspIkConstraintDataArray; newCapacity: Integer); cdecl;
  spIkConstraintDataArray_add: procedure(self: PspIkConstraintDataArray; value: PspIkConstraintData); cdecl;
  spIkConstraintDataArray_addAll: procedure(self: PspIkConstraintDataArray; other: PspIkConstraintDataArray); cdecl;
  spIkConstraintDataArray_addAllValues: procedure(self: PspIkConstraintDataArray; values: PPspIkConstraintData; offset: Integer; count: Integer); cdecl;
  spIkConstraintDataArray_removeAt: procedure(self: PspIkConstraintDataArray; index: Integer); cdecl;
  spIkConstraintDataArray_contains: function(self: PspIkConstraintDataArray; value: PspIkConstraintData): Integer; cdecl;
  spIkConstraintDataArray_pop: function(self: PspIkConstraintDataArray): PspIkConstraintData; cdecl;
  spIkConstraintDataArray_peek: function(self: PspIkConstraintDataArray): PspIkConstraintData; cdecl;
  spTransformConstraintDataArray_create: function(initialCapacity: Integer): PspTransformConstraintDataArray; cdecl;
  spTransformConstraintDataArray_dispose: procedure(self: PspTransformConstraintDataArray); cdecl;
  spTransformConstraintDataArray_clear: procedure(self: PspTransformConstraintDataArray); cdecl;
  spTransformConstraintDataArray_setSize: function(self: PspTransformConstraintDataArray; newSize: Integer): PspTransformConstraintDataArray; cdecl;
  spTransformConstraintDataArray_ensureCapacity: procedure(self: PspTransformConstraintDataArray; newCapacity: Integer); cdecl;
  spTransformConstraintDataArray_add: procedure(self: PspTransformConstraintDataArray; value: PspTransformConstraintData); cdecl;
  spTransformConstraintDataArray_addAll: procedure(self: PspTransformConstraintDataArray; other: PspTransformConstraintDataArray); cdecl;
  spTransformConstraintDataArray_addAllValues: procedure(self: PspTransformConstraintDataArray; values: PPspTransformConstraintData; offset: Integer; count: Integer); cdecl;
  spTransformConstraintDataArray_removeAt: procedure(self: PspTransformConstraintDataArray; index: Integer); cdecl;
  spTransformConstraintDataArray_contains: function(self: PspTransformConstraintDataArray; value: PspTransformConstraintData): Integer; cdecl;
  spTransformConstraintDataArray_pop: function(self: PspTransformConstraintDataArray): PspTransformConstraintData; cdecl;
  spTransformConstraintDataArray_peek: function(self: PspTransformConstraintDataArray): PspTransformConstraintData; cdecl;
  spPathConstraintDataArray_create: function(initialCapacity: Integer): PspPathConstraintDataArray; cdecl;
  spPathConstraintDataArray_dispose: procedure(self: PspPathConstraintDataArray); cdecl;
  spPathConstraintDataArray_clear: procedure(self: PspPathConstraintDataArray); cdecl;
  spPathConstraintDataArray_setSize: function(self: PspPathConstraintDataArray; newSize: Integer): PspPathConstraintDataArray; cdecl;
  spPathConstraintDataArray_ensureCapacity: procedure(self: PspPathConstraintDataArray; newCapacity: Integer); cdecl;
  spPathConstraintDataArray_add: procedure(self: PspPathConstraintDataArray; value: PspPathConstraintData); cdecl;
  spPathConstraintDataArray_addAll: procedure(self: PspPathConstraintDataArray; other: PspPathConstraintDataArray); cdecl;
  spPathConstraintDataArray_addAllValues: procedure(self: PspPathConstraintDataArray; values: PPspPathConstraintData; offset: Integer; count: Integer); cdecl;
  spPathConstraintDataArray_removeAt: procedure(self: PspPathConstraintDataArray; index: Integer); cdecl;
  spPathConstraintDataArray_contains: function(self: PspPathConstraintDataArray; value: PspPathConstraintData): Integer; cdecl;
  spPathConstraintDataArray_pop: function(self: PspPathConstraintDataArray): PspPathConstraintData; cdecl;
  spPathConstraintDataArray_peek: function(self: PspPathConstraintDataArray): PspPathConstraintData; cdecl;
  spPhysicsConstraintDataArray_create: function(initialCapacity: Integer): PspPhysicsConstraintDataArray; cdecl;
  spPhysicsConstraintDataArray_dispose: procedure(self: PspPhysicsConstraintDataArray); cdecl;
  spPhysicsConstraintDataArray_clear: procedure(self: PspPhysicsConstraintDataArray); cdecl;
  spPhysicsConstraintDataArray_setSize: function(self: PspPhysicsConstraintDataArray; newSize: Integer): PspPhysicsConstraintDataArray; cdecl;
  spPhysicsConstraintDataArray_ensureCapacity: procedure(self: PspPhysicsConstraintDataArray; newCapacity: Integer); cdecl;
  spPhysicsConstraintDataArray_add: procedure(self: PspPhysicsConstraintDataArray; value: PspPhysicsConstraintData); cdecl;
  spPhysicsConstraintDataArray_addAll: procedure(self: PspPhysicsConstraintDataArray; other: PspPhysicsConstraintDataArray); cdecl;
  spPhysicsConstraintDataArray_addAllValues: procedure(self: PspPhysicsConstraintDataArray; values: PPspPhysicsConstraintData; offset: Integer; count: Integer); cdecl;
  spPhysicsConstraintDataArray_removeAt: procedure(self: PspPhysicsConstraintDataArray; index: Integer); cdecl;
  spPhysicsConstraintDataArray_contains: function(self: PspPhysicsConstraintDataArray; value: PspPhysicsConstraintData): Integer; cdecl;
  spPhysicsConstraintDataArray_pop: function(self: PspPhysicsConstraintDataArray): PspPhysicsConstraintData; cdecl;
  spPhysicsConstraintDataArray_peek: function(self: PspPhysicsConstraintDataArray): PspPhysicsConstraintData; cdecl;
  spSkin_create: function(const name: PUTF8Char): PspSkin; cdecl;
  spSkin_dispose: procedure(self: PspSkin); cdecl;
  spSkin_setAttachment: procedure(self: PspSkin; slotIndex: Integer; const name: PUTF8Char; attachment: PspAttachment); cdecl;
  spSkin_getAttachment: function(const self: PspSkin; slotIndex: Integer; const name: PUTF8Char): PspAttachment; cdecl;
  spSkin_getAttachmentName: function(const self: PspSkin; slotIndex: Integer; attachmentIndex: Integer): PUTF8Char; cdecl;
  spSkin_attachAll: procedure(const self: PspSkin; skeleton: PspSkeleton; const oldspSkin: PspSkin); cdecl;
  spSkin_addSkin: procedure(self: PspSkin; const other: PspSkin); cdecl;
  spSkin_copySkin: procedure(self: PspSkin; const other: PspSkin); cdecl;
  spSkin_getAttachments: function(const self: PspSkin): PspSkinEntry; cdecl;
  spSkin_clear: procedure(self: PspSkin); cdecl;
  spSkeletonData_create: function(): PspSkeletonData; cdecl;
  spSkeletonData_dispose: procedure(self: PspSkeletonData); cdecl;
  spSkeletonData_findBone: function(const self: PspSkeletonData; const boneName: PUTF8Char): PspBoneData; cdecl;
  spSkeletonData_findSlot: function(const self: PspSkeletonData; const slotName: PUTF8Char): PspSlotData; cdecl;
  spSkeletonData_findSkin: function(const self: PspSkeletonData; const skinName: PUTF8Char): PspSkin; cdecl;
  spSkeletonData_findEvent: function(const self: PspSkeletonData; const eventName: PUTF8Char): PspEventData; cdecl;
  spSkeletonData_findAnimation: function(const self: PspSkeletonData; const animationName: PUTF8Char): PspAnimation; cdecl;
  spSkeletonData_findIkConstraint: function(const self: PspSkeletonData; const constraintName: PUTF8Char): PspIkConstraintData; cdecl;
  spSkeletonData_findTransformConstraint: function(const self: PspSkeletonData; const constraintName: PUTF8Char): PspTransformConstraintData; cdecl;
  spSkeletonData_findPathConstraint: function(const self: PspSkeletonData; const constraintName: PUTF8Char): PspPathConstraintData; cdecl;
  spSkeletonData_findPhysicsConstraint: function(const self: PspSkeletonData; const constraintName: PUTF8Char): PspPhysicsConstraintData; cdecl;
  spAnimationStateData_create: function(skeletonData: PspSkeletonData): PspAnimationStateData; cdecl;
  spAnimationStateData_dispose: procedure(self: PspAnimationStateData); cdecl;
  spAnimationStateData_setMixByName: procedure(self: PspAnimationStateData; const fromName: PUTF8Char; const toName: PUTF8Char; duration: Single); cdecl;
  spAnimationStateData_setMix: procedure(self: PspAnimationStateData; from: PspAnimation; &to: PspAnimation; duration: Single); cdecl;
  spAnimationStateData_getMix: function(self: PspAnimationStateData; from: PspAnimation; &to: PspAnimation): Single; cdecl;
  spTrackEntryArray_create: function(initialCapacity: Integer): PspTrackEntryArray; cdecl;
  spTrackEntryArray_dispose: procedure(self: PspTrackEntryArray); cdecl;
  spTrackEntryArray_clear: procedure(self: PspTrackEntryArray); cdecl;
  spTrackEntryArray_setSize: function(self: PspTrackEntryArray; newSize: Integer): PspTrackEntryArray; cdecl;
  spTrackEntryArray_ensureCapacity: procedure(self: PspTrackEntryArray; newCapacity: Integer); cdecl;
  spTrackEntryArray_add: procedure(self: PspTrackEntryArray; value: PspTrackEntry); cdecl;
  spTrackEntryArray_addAll: procedure(self: PspTrackEntryArray; other: PspTrackEntryArray); cdecl;
  spTrackEntryArray_addAllValues: procedure(self: PspTrackEntryArray; values: PPspTrackEntry; offset: Integer; count: Integer); cdecl;
  spTrackEntryArray_removeAt: procedure(self: PspTrackEntryArray; index: Integer); cdecl;
  spTrackEntryArray_contains: function(self: PspTrackEntryArray; value: PspTrackEntry): Integer; cdecl;
  spTrackEntryArray_pop: function(self: PspTrackEntryArray): PspTrackEntry; cdecl;
  spTrackEntryArray_peek: function(self: PspTrackEntryArray): PspTrackEntry; cdecl;
  spAnimationState_create: function(data: PspAnimationStateData): PspAnimationState; cdecl;
  spAnimationState_dispose: procedure(self: PspAnimationState); cdecl;
  spAnimationState_update: procedure(self: PspAnimationState; delta: Single); cdecl;
  spAnimationState_apply: function(self: PspAnimationState; skeleton: PspSkeleton): Integer; cdecl;
  spAnimationState_clearTracks: procedure(self: PspAnimationState); cdecl;
  spAnimationState_clearTrack: procedure(self: PspAnimationState; trackIndex: Integer); cdecl;
  spAnimationState_setAnimationByName: function(self: PspAnimationState; trackIndex: Integer; const animationName: PUTF8Char; loop: Integer): PspTrackEntry; cdecl;
  spAnimationState_setAnimation: function(self: PspAnimationState; trackIndex: Integer; animation: PspAnimation; loop: Integer): PspTrackEntry; cdecl;
  spAnimationState_addAnimationByName: function(self: PspAnimationState; trackIndex: Integer; const animationName: PUTF8Char; loop: Integer; delay: Single): PspTrackEntry; cdecl;
  spAnimationState_addAnimation: function(self: PspAnimationState; trackIndex: Integer; animation: PspAnimation; loop: Integer; delay: Single): PspTrackEntry; cdecl;
  spAnimationState_setEmptyAnimation: function(self: PspAnimationState; trackIndex: Integer; mixDuration: Single): PspTrackEntry; cdecl;
  spAnimationState_addEmptyAnimation: function(self: PspAnimationState; trackIndex: Integer; mixDuration: Single; delay: Single): PspTrackEntry; cdecl;
  spAnimationState_setEmptyAnimations: procedure(self: PspAnimationState; mixDuration: Single); cdecl;
  spAnimationState_getCurrent: function(self: PspAnimationState; trackIndex: Integer): PspTrackEntry; cdecl;
  spAnimationState_clearListenerNotifications: procedure(self: PspAnimationState); cdecl;
  spTrackEntry_getAnimationTime: function(entry: PspTrackEntry): Single; cdecl;
  spTrackEntry_resetRotationDirections: procedure(entry: PspTrackEntry); cdecl;
  spTrackEntry_getTrackComplete: function(entry: PspTrackEntry): Single; cdecl;
  spTrackEntry_setMixDuration: procedure(entry: PspTrackEntry; mixDuration: Single; delay: Single); cdecl;
  spTrackEntry_wasApplied: function(entry: PspTrackEntry): Integer; cdecl;
  spTrackEntry_isNextReady: function(entry: PspTrackEntry): Integer; cdecl;
  spAnimationState_clearNext: procedure(self: PspAnimationState; entry: PspTrackEntry); cdecl;
  spAnimationState_disposeStatics: procedure(); cdecl;
  spAttachmentLoader_dispose: procedure(self: PspAttachmentLoader); cdecl;
  spAttachmentLoader_createAttachment: function(self: PspAttachmentLoader; skin: PspSkin; &type: spAttachmentType; const name: PUTF8Char; const path: PUTF8Char; sequence: PspSequence): PspAttachment; cdecl;
  spAttachmentLoader_configureAttachment: procedure(self: PspAttachmentLoader; attachment: PspAttachment); cdecl;
  spAttachmentLoader_disposeAttachment: procedure(self: PspAttachmentLoader; attachment: PspAttachment); cdecl;
  spAtlasAttachmentLoader_create: function(atlas: PspAtlas): PspAtlasAttachmentLoader; cdecl;
  spRegionAttachment_create: function(const name: PUTF8Char): PspRegionAttachment; cdecl;
  spRegionAttachment_updateRegion: procedure(self: PspRegionAttachment); cdecl;
  spRegionAttachment_computeWorldVertices: procedure(self: PspRegionAttachment; slot: PspSlot; vertices: PSingle; offset: Integer; stride: Integer); cdecl;
  spMeshAttachment_create: function(const name: PUTF8Char): PspMeshAttachment; cdecl;
  spMeshAttachment_updateRegion: procedure(self: PspMeshAttachment); cdecl;
  spMeshAttachment_setParentMesh: procedure(self: PspMeshAttachment; parentMesh: PspMeshAttachment); cdecl;
  spMeshAttachment_newLinkedMesh: function(self: PspMeshAttachment): PspMeshAttachment; cdecl;
  spBoundingBoxAttachment_create: function(const name: PUTF8Char): PspBoundingBoxAttachment; cdecl;
  _spClippingAttachment_dispose: procedure(self: PspAttachment); cdecl;
  spClippingAttachment_create: function(const name: PUTF8Char): PspClippingAttachment; cdecl;
  spPointAttachment_create: function(const name: PUTF8Char): PspPointAttachment; cdecl;
  spPointAttachment_computeWorldPosition: procedure(self: PspPointAttachment; bone: PspBone; x: PSingle; y: PSingle); cdecl;
  spPointAttachment_computeWorldRotation: function(self: PspPointAttachment; bone: PspBone): Single; cdecl;
  spIkConstraint_create: function(data: PspIkConstraintData; const skeleton: PspSkeleton): PspIkConstraint; cdecl;
  spIkConstraint_dispose: procedure(self: PspIkConstraint); cdecl;
  spIkConstraint_update: procedure(self: PspIkConstraint); cdecl;
  spIkConstraint_setToSetupPose: procedure(self: PspIkConstraint); cdecl;
  spIkConstraint_apply1: procedure(bone: PspBone; targetX: Single; targetY: Single; compress: Integer; stretch: Integer; uniform: Integer; alpha: Single); cdecl;
  spIkConstraint_apply2: procedure(parent: PspBone; child: PspBone; targetX: Single; targetY: Single; bendDirection: Integer; stretch: Integer; uniform: Integer; softness: Single; alpha: Single); cdecl;
  spTransformConstraint_create: function(data: PspTransformConstraintData; const skeleton: PspSkeleton): PspTransformConstraint; cdecl;
  spTransformConstraint_dispose: procedure(self: PspTransformConstraint); cdecl;
  spTransformConstraint_update: procedure(self: PspTransformConstraint); cdecl;
  spTransformConstraint_setToSetupPose: procedure(self: PspTransformConstraint); cdecl;
  spPathAttachment_create: function(const name: PUTF8Char): PspPathAttachment; cdecl;
  spPathConstraint_create: function(data: PspPathConstraintData; const skeleton: PspSkeleton): PspPathConstraint; cdecl;
  spPathConstraint_dispose: procedure(self: PspPathConstraint); cdecl;
  spPathConstraint_update: procedure(self: PspPathConstraint); cdecl;
  spPathConstraint_setToSetupPose: procedure(self: PspPathConstraint); cdecl;
  spPathConstraint_computeWorldPositions: function(self: PspPathConstraint; path: PspPathAttachment; spacesCount: Integer; tangents: Integer): PSingle; cdecl;
  spPhysicsConstraint_create: function(data: PspPhysicsConstraintData; skeleton: PspSkeleton): PspPhysicsConstraint; cdecl;
  spPhysicsConstraint_dispose: procedure(self: PspPhysicsConstraint); cdecl;
  spPhysicsConstraint_reset: procedure(self: PspPhysicsConstraint); cdecl;
  spPhysicsConstraint_setToSetupPose: procedure(self: PspPhysicsConstraint); cdecl;
  spPhysicsConstraint_update: procedure(self: PspPhysicsConstraint; physics: spPhysics); cdecl;
  spPhysicsConstraint_rotate: procedure(self: PspPhysicsConstraint; x: Single; y: Single; degrees: Single); cdecl;
  spPhysicsConstraint_translate: procedure(self: PspPhysicsConstraint; x: Single; y: Single); cdecl;
  spSkeleton_create: function(data: PspSkeletonData): PspSkeleton; cdecl;
  spSkeleton_dispose: procedure(self: PspSkeleton); cdecl;
  spSkeleton_updateCache: procedure(self: PspSkeleton); cdecl;
  spSkeleton_updateWorldTransform: procedure(const self: PspSkeleton; physics: spPhysics); cdecl;
  spSkeleton_update: procedure(self: PspSkeleton; delta: Single); cdecl;
  spSkeleton_setToSetupPose: procedure(const self: PspSkeleton); cdecl;
  spSkeleton_setBonesToSetupPose: procedure(const self: PspSkeleton); cdecl;
  spSkeleton_setSlotsToSetupPose: procedure(const self: PspSkeleton); cdecl;
  spSkeleton_findBone: function(const self: PspSkeleton; const boneName: PUTF8Char): PspBone; cdecl;
  spSkeleton_findSlot: function(const self: PspSkeleton; const slotName: PUTF8Char): PspSlot; cdecl;
  spSkeleton_setSkin: procedure(self: PspSkeleton; skin: PspSkin); cdecl;
  spSkeleton_setSkinByName: function(self: PspSkeleton; const skinName: PUTF8Char): Integer; cdecl;
  spSkeleton_getAttachmentForSlotName: function(const self: PspSkeleton; const slotName: PUTF8Char; const attachmentName: PUTF8Char): PspAttachment; cdecl;
  spSkeleton_getAttachmentForSlotIndex: function(const self: PspSkeleton; slotIndex: Integer; const attachmentName: PUTF8Char): PspAttachment; cdecl;
  spSkeleton_setAttachment: function(self: PspSkeleton; const slotName: PUTF8Char; const attachmentName: PUTF8Char): Integer; cdecl;
  spSkeleton_findIkConstraint: function(const self: PspSkeleton; const constraintName: PUTF8Char): PspIkConstraint; cdecl;
  spSkeleton_findTransformConstraint: function(const self: PspSkeleton; const constraintName: PUTF8Char): PspTransformConstraint; cdecl;
  spSkeleton_findPathConstraint: function(const self: PspSkeleton; const constraintName: PUTF8Char): PspPathConstraint; cdecl;
  spSkeleton_findPhysicsConstraint: function(const self: PspSkeleton; const constraintName: PUTF8Char): PspPhysicsConstraint; cdecl;
  spSkeleton_physicsTranslate: procedure(self: PspSkeleton; x: Single; y: Single); cdecl;
  spSkeleton_physicsRotate: procedure(self: PspSkeleton; x: Single; y: Single; degrees: Single); cdecl;
  spPolygon_create: function(capacity: Integer): PspPolygon; cdecl;
  spPolygon_dispose: procedure(self: PspPolygon); cdecl;
  spPolygon_containsPoint: function(polygon: PspPolygon; x: Single; y: Single): Integer; cdecl;
  spPolygon_intersectsSegment: function(polygon: PspPolygon; x1: Single; y1: Single; x2: Single; y2: Single): Integer; cdecl;
  spSkeletonBounds_create: function(): PspSkeletonBounds; cdecl;
  spSkeletonBounds_dispose: procedure(self: PspSkeletonBounds); cdecl;
  spSkeletonBounds_update: procedure(self: PspSkeletonBounds; skeleton: PspSkeleton; updateAabb: Integer); cdecl;
  spSkeletonBounds_aabbContainsPoint: function(self: PspSkeletonBounds; x: Single; y: Single): Integer; cdecl;
  spSkeletonBounds_aabbIntersectsSegment: function(self: PspSkeletonBounds; x1: Single; y1: Single; x2: Single; y2: Single): Integer; cdecl;
  spSkeletonBounds_aabbIntersectsSkeleton: function(self: PspSkeletonBounds; bounds: PspSkeletonBounds): Integer; cdecl;
  spSkeletonBounds_containsPoint: function(self: PspSkeletonBounds; x: Single; y: Single): PspBoundingBoxAttachment; cdecl;
  spSkeletonBounds_intersectsSegment: function(self: PspSkeletonBounds; x1: Single; y1: Single; x2: Single; y2: Single): PspBoundingBoxAttachment; cdecl;
  spSkeletonBounds_getPolygon: function(self: PspSkeletonBounds; boundingBox: PspBoundingBoxAttachment): PspPolygon; cdecl;
  spSkeletonBinary_createWithLoader: function(attachmentLoader: PspAttachmentLoader): PspSkeletonBinary; cdecl;
  spSkeletonBinary_create: function(atlas: PspAtlas): PspSkeletonBinary; cdecl;
  spSkeletonBinary_dispose: procedure(self: PspSkeletonBinary); cdecl;
  spSkeletonBinary_readSkeletonData: function(self: PspSkeletonBinary; const binary: PByte; const length: Integer): PspSkeletonData; cdecl;
  spSkeletonBinary_readSkeletonDataFile: function(self: PspSkeletonBinary; const path: PUTF8Char): PspSkeletonData; cdecl;
  spSkeletonJson_createWithLoader: function(attachmentLoader: PspAttachmentLoader): PspSkeletonJson; cdecl;
  spSkeletonJson_create: function(atlas: PspAtlas): PspSkeletonJson; cdecl;
  spSkeletonJson_dispose: procedure(self: PspSkeletonJson); cdecl;
  spSkeletonJson_readSkeletonData: function(self: PspSkeletonJson; const json: PUTF8Char): PspSkeletonData; cdecl;
  spSkeletonJson_readSkeletonDataFile: function(self: PspSkeletonJson; const path: PUTF8Char): PspSkeletonData; cdecl;
  spTriangulator_create: function(): PspTriangulator; cdecl;
  spTriangulator_triangulate: function(self: PspTriangulator; verticesArray: PspFloatArray): PspShortArray; cdecl;
  spTriangulator_decompose: function(self: PspTriangulator; verticesArray: PspFloatArray; triangles: PspShortArray): PspArrayFloatArray; cdecl;
  spTriangulator_dispose: procedure(self: PspTriangulator); cdecl;
  spSkeletonClipping_create: function(): PspSkeletonClipping; cdecl;
  spSkeletonClipping_clipStart: function(self: PspSkeletonClipping; slot: PspSlot; clip: PspClippingAttachment): Integer; cdecl;
  spSkeletonClipping_clipEnd: procedure(self: PspSkeletonClipping; slot: PspSlot); cdecl;
  spSkeletonClipping_clipEnd2: procedure(self: PspSkeletonClipping); cdecl;
  spSkeletonClipping_isClipping: function(self: PspSkeletonClipping): Integer; cdecl;
  spSkeletonClipping_clipTriangles: procedure(self: PspSkeletonClipping; vertices: PSingle; verticesLength: Integer; triangles: PWord; trianglesLength: Integer; uvs: PSingle; stride: Integer); cdecl;
  spSkeletonClipping_dispose: procedure(self: PspSkeletonClipping); cdecl;
  glfwInit: function(): Integer; cdecl;
  glfwTerminate: procedure(); cdecl;
  glfwInitHint: procedure(hint: Integer; value: Integer); cdecl;
  glfwInitAllocator: procedure(const allocator: PGLFWallocator); cdecl;
  glfwGetVersion: procedure(major: PInteger; minor: PInteger; rev: PInteger); cdecl;
  glfwGetVersionString: function(): PUTF8Char; cdecl;
  glfwGetError: function(description: PPUTF8Char): Integer; cdecl;
  glfwSetErrorCallback: function(callback: GLFWerrorfun): GLFWerrorfun; cdecl;
  glfwGetPlatform: function(): Integer; cdecl;
  glfwPlatformSupported: function(&platform: Integer): Integer; cdecl;
  glfwGetMonitors: function(count: PInteger): PPGLFWmonitor; cdecl;
  glfwGetPrimaryMonitor: function(): PGLFWmonitor; cdecl;
  glfwGetMonitorPos: procedure(monitor: PGLFWmonitor; xpos: PInteger; ypos: PInteger); cdecl;
  glfwGetMonitorWorkarea: procedure(monitor: PGLFWmonitor; xpos: PInteger; ypos: PInteger; width: PInteger; height: PInteger); cdecl;
  glfwGetMonitorPhysicalSize: procedure(monitor: PGLFWmonitor; widthMM: PInteger; heightMM: PInteger); cdecl;
  glfwGetMonitorContentScale: procedure(monitor: PGLFWmonitor; xscale: PSingle; yscale: PSingle); cdecl;
  glfwGetMonitorName: function(monitor: PGLFWmonitor): PUTF8Char; cdecl;
  glfwSetMonitorUserPointer: procedure(monitor: PGLFWmonitor; pointer: Pointer); cdecl;
  glfwGetMonitorUserPointer: function(monitor: PGLFWmonitor): Pointer; cdecl;
  glfwSetMonitorCallback: function(callback: GLFWmonitorfun): GLFWmonitorfun; cdecl;
  glfwGetVideoModes: function(monitor: PGLFWmonitor; count: PInteger): PGLFWvidmode; cdecl;
  glfwGetVideoMode: function(monitor: PGLFWmonitor): PGLFWvidmode; cdecl;
  glfwSetGamma: procedure(monitor: PGLFWmonitor; gamma: Single); cdecl;
  glfwGetGammaRamp: function(monitor: PGLFWmonitor): PGLFWgammaramp; cdecl;
  glfwSetGammaRamp: procedure(monitor: PGLFWmonitor; const ramp: PGLFWgammaramp); cdecl;
  glfwDefaultWindowHints: procedure(); cdecl;
  glfwWindowHint: procedure(hint: Integer; value: Integer); cdecl;
  glfwWindowHintString: procedure(hint: Integer; const value: PUTF8Char); cdecl;
  glfwCreateWindow: function(width: Integer; height: Integer; const title: PUTF8Char; monitor: PGLFWmonitor; share: PGLFWwindow): PGLFWwindow; cdecl;
  glfwDestroyWindow: procedure(window: PGLFWwindow); cdecl;
  glfwWindowShouldClose: function(window: PGLFWwindow): Integer; cdecl;
  glfwSetWindowShouldClose: procedure(window: PGLFWwindow; value: Integer); cdecl;
  glfwGetWindowTitle: function(window: PGLFWwindow): PUTF8Char; cdecl;
  glfwSetWindowTitle: procedure(window: PGLFWwindow; const title: PUTF8Char); cdecl;
  glfwSetWindowIcon: procedure(window: PGLFWwindow; count: Integer; const images: PGLFWimage); cdecl;
  glfwGetWindowPos: procedure(window: PGLFWwindow; xpos: PInteger; ypos: PInteger); cdecl;
  glfwSetWindowPos: procedure(window: PGLFWwindow; xpos: Integer; ypos: Integer); cdecl;
  glfwGetWindowSize: procedure(window: PGLFWwindow; width: PInteger; height: PInteger); cdecl;
  glfwSetWindowSizeLimits: procedure(window: PGLFWwindow; minwidth: Integer; minheight: Integer; maxwidth: Integer; maxheight: Integer); cdecl;
  glfwSetWindowAspectRatio: procedure(window: PGLFWwindow; numer: Integer; denom: Integer); cdecl;
  glfwSetWindowSize: procedure(window: PGLFWwindow; width: Integer; height: Integer); cdecl;
  glfwGetFramebufferSize: procedure(window: PGLFWwindow; width: PInteger; height: PInteger); cdecl;
  glfwGetWindowFrameSize: procedure(window: PGLFWwindow; left: PInteger; top: PInteger; right: PInteger; bottom: PInteger); cdecl;
  glfwGetWindowContentScale: procedure(window: PGLFWwindow; xscale: PSingle; yscale: PSingle); cdecl;
  glfwGetWindowOpacity: function(window: PGLFWwindow): Single; cdecl;
  glfwSetWindowOpacity: procedure(window: PGLFWwindow; opacity: Single); cdecl;
  glfwIconifyWindow: procedure(window: PGLFWwindow); cdecl;
  glfwRestoreWindow: procedure(window: PGLFWwindow); cdecl;
  glfwMaximizeWindow: procedure(window: PGLFWwindow); cdecl;
  glfwShowWindow: procedure(window: PGLFWwindow); cdecl;
  glfwHideWindow: procedure(window: PGLFWwindow); cdecl;
  glfwFocusWindow: procedure(window: PGLFWwindow); cdecl;
  glfwRequestWindowAttention: procedure(window: PGLFWwindow); cdecl;
  glfwGetWindowMonitor: function(window: PGLFWwindow): PGLFWmonitor; cdecl;
  glfwSetWindowMonitor: procedure(window: PGLFWwindow; monitor: PGLFWmonitor; xpos: Integer; ypos: Integer; width: Integer; height: Integer; refreshRate: Integer); cdecl;
  glfwGetWindowAttrib: function(window: PGLFWwindow; attrib: Integer): Integer; cdecl;
  glfwSetWindowAttrib: procedure(window: PGLFWwindow; attrib: Integer; value: Integer); cdecl;
  glfwSetWindowUserPointer: procedure(window: PGLFWwindow; pointer: Pointer); cdecl;
  glfwGetWindowUserPointer: function(window: PGLFWwindow): Pointer; cdecl;
  glfwSetWindowPosCallback: function(window: PGLFWwindow; callback: GLFWwindowposfun): GLFWwindowposfun; cdecl;
  glfwSetWindowSizeCallback: function(window: PGLFWwindow; callback: GLFWwindowsizefun): GLFWwindowsizefun; cdecl;
  glfwSetWindowCloseCallback: function(window: PGLFWwindow; callback: GLFWwindowclosefun): GLFWwindowclosefun; cdecl;
  glfwSetWindowRefreshCallback: function(window: PGLFWwindow; callback: GLFWwindowrefreshfun): GLFWwindowrefreshfun; cdecl;
  glfwSetWindowFocusCallback: function(window: PGLFWwindow; callback: GLFWwindowfocusfun): GLFWwindowfocusfun; cdecl;
  glfwSetWindowIconifyCallback: function(window: PGLFWwindow; callback: GLFWwindowiconifyfun): GLFWwindowiconifyfun; cdecl;
  glfwSetWindowMaximizeCallback: function(window: PGLFWwindow; callback: GLFWwindowmaximizefun): GLFWwindowmaximizefun; cdecl;
  glfwSetFramebufferSizeCallback: function(window: PGLFWwindow; callback: GLFWframebuffersizefun): GLFWframebuffersizefun; cdecl;
  glfwSetWindowContentScaleCallback: function(window: PGLFWwindow; callback: GLFWwindowcontentscalefun): GLFWwindowcontentscalefun; cdecl;
  glfwPollEvents: procedure(); cdecl;
  glfwWaitEvents: procedure(); cdecl;
  glfwWaitEventsTimeout: procedure(timeout: Double); cdecl;
  glfwPostEmptyEvent: procedure(); cdecl;
  glfwGetInputMode: function(window: PGLFWwindow; mode: Integer): Integer; cdecl;
  glfwSetInputMode: procedure(window: PGLFWwindow; mode: Integer; value: Integer); cdecl;
  glfwRawMouseMotionSupported: function(): Integer; cdecl;
  glfwGetKeyName: function(key: Integer; scancode: Integer): PUTF8Char; cdecl;
  glfwGetKeyScancode: function(key: Integer): Integer; cdecl;
  glfwGetKey: function(window: PGLFWwindow; key: Integer): Integer; cdecl;
  glfwGetMouseButton: function(window: PGLFWwindow; button: Integer): Integer; cdecl;
  glfwGetCursorPos: procedure(window: PGLFWwindow; xpos: PDouble; ypos: PDouble); cdecl;
  glfwSetCursorPos: procedure(window: PGLFWwindow; xpos: Double; ypos: Double); cdecl;
  glfwCreateCursor: function(const image: PGLFWimage; xhot: Integer; yhot: Integer): PGLFWcursor; cdecl;
  glfwCreateStandardCursor: function(shape: Integer): PGLFWcursor; cdecl;
  glfwDestroyCursor: procedure(cursor: PGLFWcursor); cdecl;
  glfwSetCursor: procedure(window: PGLFWwindow; cursor: PGLFWcursor); cdecl;
  glfwSetKeyCallback: function(window: PGLFWwindow; callback: GLFWkeyfun): GLFWkeyfun; cdecl;
  glfwSetCharCallback: function(window: PGLFWwindow; callback: GLFWcharfun): GLFWcharfun; cdecl;
  glfwSetCharModsCallback: function(window: PGLFWwindow; callback: GLFWcharmodsfun): GLFWcharmodsfun; cdecl;
  glfwSetMouseButtonCallback: function(window: PGLFWwindow; callback: GLFWmousebuttonfun): GLFWmousebuttonfun; cdecl;
  glfwSetCursorPosCallback: function(window: PGLFWwindow; callback: GLFWcursorposfun): GLFWcursorposfun; cdecl;
  glfwSetCursorEnterCallback: function(window: PGLFWwindow; callback: GLFWcursorenterfun): GLFWcursorenterfun; cdecl;
  glfwSetScrollCallback: function(window: PGLFWwindow; callback: GLFWscrollfun): GLFWscrollfun; cdecl;
  glfwSetDropCallback: function(window: PGLFWwindow; callback: GLFWdropfun): GLFWdropfun; cdecl;
  glfwJoystickPresent: function(jid: Integer): Integer; cdecl;
  glfwGetJoystickAxes: function(jid: Integer; count: PInteger): PSingle; cdecl;
  glfwGetJoystickButtons: function(jid: Integer; count: PInteger): PByte; cdecl;
  glfwGetJoystickHats: function(jid: Integer; count: PInteger): PByte; cdecl;
  glfwGetJoystickName: function(jid: Integer): PUTF8Char; cdecl;
  glfwGetJoystickGUID: function(jid: Integer): PUTF8Char; cdecl;
  glfwSetJoystickUserPointer: procedure(jid: Integer; pointer: Pointer); cdecl;
  glfwGetJoystickUserPointer: function(jid: Integer): Pointer; cdecl;
  glfwJoystickIsGamepad: function(jid: Integer): Integer; cdecl;
  glfwSetJoystickCallback: function(callback: GLFWjoystickfun): GLFWjoystickfun; cdecl;
  glfwUpdateGamepadMappings: function(const &string: PUTF8Char): Integer; cdecl;
  glfwGetGamepadName: function(jid: Integer): PUTF8Char; cdecl;
  glfwGetGamepadState: function(jid: Integer; state: PGLFWgamepadstate): Integer; cdecl;
  glfwSetClipboardString: procedure(window: PGLFWwindow; const &string: PUTF8Char); cdecl;
  glfwGetClipboardString: function(window: PGLFWwindow): PUTF8Char; cdecl;
  glfwGetTime: function(): Double; cdecl;
  glfwSetTime: procedure(time: Double); cdecl;
  glfwGetTimerValue: function(): UInt64; cdecl;
  glfwGetTimerFrequency: function(): UInt64; cdecl;
  glfwMakeContextCurrent: procedure(window: PGLFWwindow); cdecl;
  glfwGetCurrentContext: function(): PGLFWwindow; cdecl;
  glfwSwapBuffers: procedure(window: PGLFWwindow); cdecl;
  glfwSwapInterval: procedure(interval: Integer); cdecl;
  glfwExtensionSupported: function(const extension: PUTF8Char): Integer; cdecl;
  glfwGetProcAddress: function(const procname: PUTF8Char): GLFWglproc; cdecl;
  glfwVulkanSupported: function(): Integer; cdecl;
  glfwGetRequiredInstanceExtensions: function(count: PUInt32): PPUTF8Char; cdecl;
  spGlfwVertexArray_create: function(initialCapacity: Integer): PspGlfwVertexArray; cdecl;
  spGlfwVertexArray_dispose: procedure(self: PspGlfwVertexArray); cdecl;
  spGlfwVertexArray_clear: procedure(self: PspGlfwVertexArray); cdecl;
  spGlfwVertexArray_setSize: function(self: PspGlfwVertexArray; newSize: Integer): PspGlfwVertexArray; cdecl;
  spGlfwVertexArray_ensureCapacity: procedure(self: PspGlfwVertexArray; newCapacity: Integer); cdecl;
  spGlfwVertexArray_add: procedure(self: PspGlfwVertexArray; value: Single); cdecl;
  spGlfwVertexArray_addAll: procedure(self: PspGlfwVertexArray; other: PspGlfwVertexArray); cdecl;
  spGlfwVertexArray_addAllValues: procedure(self: PspGlfwVertexArray; values: PSingle; offset: Integer; count: Integer); cdecl;
  spGlfwVertexArray_removeAt: procedure(self: PspGlfwVertexArray; index: Integer); cdecl;
  spGlfwVertexArray_pop: function(self: PspGlfwVertexArray): Single; cdecl;
  spGlfwVertexArray_peek: function(self: PspGlfwVertexArray): Single; cdecl;
  spAtlasPage_setCallbacks: procedure(createCallback: spAtlasPage_createTexture_cb; disposeCallback: spAtlasPage_disposeTexture_cb; userData: Pointer); cdecl;
  spSkeletonDrawable_create: function(skeletonData: PspSkeletonData; stateData: PspAnimationStateData): PspSkeletonDrawable; cdecl;
  spSkeletonDrawable_dispose: procedure(self: PspSkeletonDrawable); cdecl;
  spSkeletonDrawable_update: procedure(self: PspSkeletonDrawable; deltaTime: Single; physics: spPhysics); cdecl;
  spSkeletonDrawable_draw: procedure(self: PspSkeletonDrawable; window: PGLFWwindow); cdecl;
  glfwGetWin32Adapter: function(monitor: PGLFWmonitor): PUTF8Char; cdecl;
  glfwGetWin32Monitor: function(monitor: PGLFWmonitor): PUTF8Char; cdecl;
  glfwGetWin32Window: function(window: PGLFWwindow): HWND; cdecl;
  stbi_load_from_memory: function(const buffer: Pstbi_uc; len: Integer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_uc; cdecl;
  stbi_load_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_uc; cdecl;
  stbi_load: function(const filename: PUTF8Char; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_uc; cdecl;
  stbi_load_from_file: function(f: PPointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_uc; cdecl;
  stbi_load_gif_from_memory: function(const buffer: Pstbi_uc; len: Integer; delays: PPInteger; x: PInteger; y: PInteger; z: PInteger; comp: PInteger; req_comp: Integer): Pstbi_uc; cdecl;
  stbi_load_16_from_memory: function(const buffer: Pstbi_uc; len: Integer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_us; cdecl;
  stbi_load_16_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_us; cdecl;
  stbi_load_16: function(const filename: PUTF8Char; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_us; cdecl;
  stbi_load_from_file_16: function(f: PPointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): Pstbi_us; cdecl;
  stbi_loadf_from_memory: function(const buffer: Pstbi_uc; len: Integer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): PSingle; cdecl;
  stbi_loadf_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): PSingle; cdecl;
  stbi_loadf: function(const filename: PUTF8Char; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): PSingle; cdecl;
  stbi_loadf_from_file: function(f: PPointer; x: PInteger; y: PInteger; channels_in_file: PInteger; desired_channels: Integer): PSingle; cdecl;
  stbi_hdr_to_ldr_gamma: procedure(gamma: Single); cdecl;
  stbi_hdr_to_ldr_scale: procedure(scale: Single); cdecl;
  stbi_ldr_to_hdr_gamma: procedure(gamma: Single); cdecl;
  stbi_ldr_to_hdr_scale: procedure(scale: Single); cdecl;
  stbi_is_hdr_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer): Integer; cdecl;
  stbi_is_hdr_from_memory: function(const buffer: Pstbi_uc; len: Integer): Integer; cdecl;
  stbi_is_hdr: function(const filename: PUTF8Char): Integer; cdecl;
  stbi_is_hdr_from_file: function(f: PPointer): Integer; cdecl;
  stbi_failure_reason: function(): PUTF8Char; cdecl;
  stbi_image_free: procedure(retval_from_stbi_load: Pointer); cdecl;
  stbi_info_from_memory: function(const buffer: Pstbi_uc; len: Integer; x: PInteger; y: PInteger; comp: PInteger): Integer; cdecl;
  stbi_info_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer; x: PInteger; y: PInteger; comp: PInteger): Integer; cdecl;
  stbi_is_16_bit_from_memory: function(const buffer: Pstbi_uc; len: Integer): Integer; cdecl;
  stbi_is_16_bit_from_callbacks: function(const clbk: Pstbi_io_callbacks; user: Pointer): Integer; cdecl;
  stbi_info: function(const filename: PUTF8Char; x: PInteger; y: PInteger; comp: PInteger): Integer; cdecl;
  stbi_info_from_file: function(f: PPointer; x: PInteger; y: PInteger; comp: PInteger): Integer; cdecl;
  stbi_is_16_bit: function(const filename: PUTF8Char): Integer; cdecl;
  stbi_is_16_bit_from_file: function(f: PPointer): Integer; cdecl;
  stbi_set_unpremultiply_on_load: procedure(flag_true_if_should_unpremultiply: Integer); cdecl;
  stbi_convert_iphone_png_to_rgb: procedure(flag_true_if_should_convert: Integer); cdecl;
  stbi_set_flip_vertically_on_load: procedure(flag_true_if_should_flip: Integer); cdecl;
  stbi_zlib_decode_malloc_guesssize: function(const buffer: PUTF8Char; len: Integer; initial_size: Integer; outlen: PInteger): PUTF8Char; cdecl;
  stbi_zlib_decode_malloc_guesssize_headerflag: function(const buffer: PUTF8Char; len: Integer; initial_size: Integer; outlen: PInteger; parse_header: Integer): PUTF8Char; cdecl;
  stbi_zlib_decode_malloc: function(const buffer: PUTF8Char; len: Integer; outlen: PInteger): PUTF8Char; cdecl;
  stbi_zlib_decode_buffer: function(obuffer: PUTF8Char; olen: Integer; const ibuffer: PUTF8Char; ilen: Integer): Integer; cdecl;
  stbi_zlib_decode_noheader_malloc: function(const buffer: PUTF8Char; len: Integer; outlen: PInteger): PUTF8Char; cdecl;
  stbi_zlib_decode_noheader_buffer: function(obuffer: PUTF8Char; olen: Integer; const ibuffer: PUTF8Char; ilen: Integer): Integer; cdecl;
  stbi_write_png: function(const filename: PUTF8Char; w: Integer; h: Integer; comp: Integer; const data: Pointer; stride_in_bytes: Integer): Integer; cdecl;
  stbi_write_bmp: function(const filename: PUTF8Char; w: Integer; h: Integer; comp: Integer; const data: Pointer): Integer; cdecl;
  stbi_write_tga: function(const filename: PUTF8Char; w: Integer; h: Integer; comp: Integer; const data: Pointer): Integer; cdecl;
  stbi_write_hdr: function(const filename: PUTF8Char; w: Integer; h: Integer; comp: Integer; const data: PSingle): Integer; cdecl;
  stbi_write_jpg: function(const filename: PUTF8Char; x: Integer; y: Integer; comp: Integer; const data: Pointer; quality: Integer): Integer; cdecl;
  stbi_write_png_to_func: function(func: Pstbi_write_func; context: Pointer; w: Integer; h: Integer; comp: Integer; const data: Pointer; stride_in_bytes: Integer): Integer; cdecl;
  stbi_write_bmp_to_func: function(func: Pstbi_write_func; context: Pointer; w: Integer; h: Integer; comp: Integer; const data: Pointer): Integer; cdecl;
  stbi_write_tga_to_func: function(func: Pstbi_write_func; context: Pointer; w: Integer; h: Integer; comp: Integer; const data: Pointer): Integer; cdecl;
  stbi_write_hdr_to_func: function(func: Pstbi_write_func; context: Pointer; w: Integer; h: Integer; comp: Integer; const data: PSingle): Integer; cdecl;
  stbi_write_jpg_to_func: function(func: Pstbi_write_func; context: Pointer; x: Integer; y: Integer; comp: Integer; const data: Pointer; quality: Integer): Integer; cdecl;
  stbi_flip_vertically_on_write: procedure(flip_boolean: Integer); cdecl;
  stbrp_pack_rects: function(context: Pstbrp_context; rects: Pstbrp_rect; num_rects: Integer): Integer; cdecl;
  stbrp_init_target: procedure(context: Pstbrp_context; width: Integer; height: Integer; nodes: Pstbrp_node; num_nodes: Integer); cdecl;
  stbrp_setup_allow_out_of_mem: procedure(context: Pstbrp_context; allow_out_of_mem: Integer); cdecl;
  stbrp_setup_heuristic: procedure(context: Pstbrp_context; heuristic: Integer); cdecl;
  stbtt_BakeFontBitmap: function(const data: PByte; offset: Integer; pixel_height: Single; pixels: PByte; pw: Integer; ph: Integer; first_char: Integer; num_chars: Integer; chardata: Pstbtt_bakedchar): Integer; cdecl;
  stbtt_GetBakedQuad: procedure(const chardata: Pstbtt_bakedchar; pw: Integer; ph: Integer; char_index: Integer; xpos: PSingle; ypos: PSingle; q: Pstbtt_aligned_quad; opengl_fillrule: Integer); cdecl;
  stbtt_GetScaledFontVMetrics: procedure(const fontdata: PByte; index: Integer; size: Single; ascent: PSingle; descent: PSingle; lineGap: PSingle); cdecl;
  stbtt_PackBegin: function(spc: Pstbtt_pack_context; pixels: PByte; width: Integer; height: Integer; stride_in_bytes: Integer; padding: Integer; alloc_context: Pointer): Integer; cdecl;
  stbtt_PackEnd: procedure(spc: Pstbtt_pack_context); cdecl;
  stbtt_PackFontRange: function(spc: Pstbtt_pack_context; const fontdata: PByte; font_index: Integer; font_size: Single; first_unicode_char_in_range: Integer; num_chars_in_range: Integer; chardata_for_range: Pstbtt_packedchar): Integer; cdecl;
  stbtt_PackFontRanges: function(spc: Pstbtt_pack_context; const fontdata: PByte; font_index: Integer; ranges: Pstbtt_pack_range; num_ranges: Integer): Integer; cdecl;
  stbtt_PackSetOversampling: procedure(spc: Pstbtt_pack_context; h_oversample: Cardinal; v_oversample: Cardinal); cdecl;
  stbtt_PackSetSkipMissingCodepoints: procedure(spc: Pstbtt_pack_context; skip: Integer); cdecl;
  stbtt_GetPackedQuad: procedure(const chardata: Pstbtt_packedchar; pw: Integer; ph: Integer; char_index: Integer; xpos: PSingle; ypos: PSingle; q: Pstbtt_aligned_quad; align_to_integer: Integer); cdecl;
  stbtt_PackFontRangesGatherRects: function(spc: Pstbtt_pack_context; const info: Pstbtt_fontinfo; ranges: Pstbtt_pack_range; num_ranges: Integer; rects: Pstbrp_rect): Integer; cdecl;
  stbtt_PackFontRangesPackRects: procedure(spc: Pstbtt_pack_context; rects: Pstbrp_rect; num_rects: Integer); cdecl;
  stbtt_PackFontRangesRenderIntoRects: function(spc: Pstbtt_pack_context; const info: Pstbtt_fontinfo; ranges: Pstbtt_pack_range; num_ranges: Integer; rects: Pstbrp_rect): Integer; cdecl;
  stbtt_GetNumberOfFonts: function(const data: PByte): Integer; cdecl;
  stbtt_GetFontOffsetForIndex: function(const data: PByte; index: Integer): Integer; cdecl;
  stbtt_InitFont: function(info: Pstbtt_fontinfo; const data: PByte; offset: Integer): Integer; cdecl;
  stbtt_FindGlyphIndex: function(const info: Pstbtt_fontinfo; unicode_codepoint: Integer): Integer; cdecl;
  stbtt_ScaleForPixelHeight: function(const info: Pstbtt_fontinfo; pixels: Single): Single; cdecl;
  stbtt_ScaleForMappingEmToPixels: function(const info: Pstbtt_fontinfo; pixels: Single): Single; cdecl;
  stbtt_GetFontVMetrics: procedure(const info: Pstbtt_fontinfo; ascent: PInteger; descent: PInteger; lineGap: PInteger); cdecl;
  stbtt_GetFontVMetricsOS2: function(const info: Pstbtt_fontinfo; typoAscent: PInteger; typoDescent: PInteger; typoLineGap: PInteger): Integer; cdecl;
  stbtt_GetFontBoundingBox: procedure(const info: Pstbtt_fontinfo; x0: PInteger; y0: PInteger; x1: PInteger; y1: PInteger); cdecl;
  stbtt_GetCodepointHMetrics: procedure(const info: Pstbtt_fontinfo; codepoint: Integer; advanceWidth: PInteger; leftSideBearing: PInteger); cdecl;
  stbtt_GetCodepointKernAdvance: function(const info: Pstbtt_fontinfo; ch1: Integer; ch2: Integer): Integer; cdecl;
  stbtt_GetCodepointBox: function(const info: Pstbtt_fontinfo; codepoint: Integer; x0: PInteger; y0: PInteger; x1: PInteger; y1: PInteger): Integer; cdecl;
  stbtt_GetGlyphHMetrics: procedure(const info: Pstbtt_fontinfo; glyph_index: Integer; advanceWidth: PInteger; leftSideBearing: PInteger); cdecl;
  stbtt_GetGlyphKernAdvance: function(const info: Pstbtt_fontinfo; glyph1: Integer; glyph2: Integer): Integer; cdecl;
  stbtt_GetGlyphBox: function(const info: Pstbtt_fontinfo; glyph_index: Integer; x0: PInteger; y0: PInteger; x1: PInteger; y1: PInteger): Integer; cdecl;
  stbtt_GetKerningTableLength: function(const info: Pstbtt_fontinfo): Integer; cdecl;
  stbtt_GetKerningTable: function(const info: Pstbtt_fontinfo; table: Pstbtt_kerningentry; table_length: Integer): Integer; cdecl;
  stbtt_IsGlyphEmpty: function(const info: Pstbtt_fontinfo; glyph_index: Integer): Integer; cdecl;
  stbtt_GetCodepointShape: function(const info: Pstbtt_fontinfo; unicode_codepoint: Integer; vertices: PPstbtt_vertex): Integer; cdecl;
  stbtt_GetGlyphShape: function(const info: Pstbtt_fontinfo; glyph_index: Integer; vertices: PPstbtt_vertex): Integer; cdecl;
  stbtt_FreeShape: procedure(const info: Pstbtt_fontinfo; vertices: Pstbtt_vertex); cdecl;
  stbtt_FindSVGDoc: function(const info: Pstbtt_fontinfo; gl: Integer): PByte; cdecl;
  stbtt_GetCodepointSVG: function(const info: Pstbtt_fontinfo; unicode_codepoint: Integer; svg: PPUTF8Char): Integer; cdecl;
  stbtt_GetGlyphSVG: function(const info: Pstbtt_fontinfo; gl: Integer; svg: PPUTF8Char): Integer; cdecl;
  stbtt_FreeBitmap: procedure(bitmap: PByte; userdata: Pointer); cdecl;
  stbtt_GetCodepointBitmap: function(const info: Pstbtt_fontinfo; scale_x: Single; scale_y: Single; codepoint: Integer; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_GetCodepointBitmapSubpixel: function(const info: Pstbtt_fontinfo; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; codepoint: Integer; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_MakeCodepointBitmap: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; codepoint: Integer); cdecl;
  stbtt_MakeCodepointBitmapSubpixel: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; codepoint: Integer); cdecl;
  stbtt_MakeCodepointBitmapSubpixelPrefilter: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; oversample_x: Integer; oversample_y: Integer; sub_x: PSingle; sub_y: PSingle; codepoint: Integer); cdecl;
  stbtt_GetCodepointBitmapBox: procedure(const font: Pstbtt_fontinfo; codepoint: Integer; scale_x: Single; scale_y: Single; ix0: PInteger; iy0: PInteger; ix1: PInteger; iy1: PInteger); cdecl;
  stbtt_GetCodepointBitmapBoxSubpixel: procedure(const font: Pstbtt_fontinfo; codepoint: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; ix0: PInteger; iy0: PInteger; ix1: PInteger; iy1: PInteger); cdecl;
  stbtt_GetGlyphBitmap: function(const info: Pstbtt_fontinfo; scale_x: Single; scale_y: Single; glyph: Integer; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_GetGlyphBitmapSubpixel: function(const info: Pstbtt_fontinfo; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; glyph: Integer; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_MakeGlyphBitmap: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; glyph: Integer); cdecl;
  stbtt_MakeGlyphBitmapSubpixel: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; glyph: Integer); cdecl;
  stbtt_MakeGlyphBitmapSubpixelPrefilter: procedure(const info: Pstbtt_fontinfo; output: PByte; out_w: Integer; out_h: Integer; out_stride: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; oversample_x: Integer; oversample_y: Integer; sub_x: PSingle; sub_y: PSingle; glyph: Integer); cdecl;
  stbtt_GetGlyphBitmapBox: procedure(const font: Pstbtt_fontinfo; glyph: Integer; scale_x: Single; scale_y: Single; ix0: PInteger; iy0: PInteger; ix1: PInteger; iy1: PInteger); cdecl;
  stbtt_GetGlyphBitmapBoxSubpixel: procedure(const font: Pstbtt_fontinfo; glyph: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; ix0: PInteger; iy0: PInteger; ix1: PInteger; iy1: PInteger); cdecl;
  stbtt_Rasterize: procedure(result: Pstbtt__bitmap; flatness_in_pixels: Single; vertices: Pstbtt_vertex; num_verts: Integer; scale_x: Single; scale_y: Single; shift_x: Single; shift_y: Single; x_off: Integer; y_off: Integer; invert: Integer; userdata: Pointer); cdecl;
  stbtt_FreeSDF: procedure(bitmap: PByte; userdata: Pointer); cdecl;
  stbtt_GetGlyphSDF: function(const info: Pstbtt_fontinfo; scale: Single; glyph: Integer; padding: Integer; onedge_value: Byte; pixel_dist_scale: Single; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_GetCodepointSDF: function(const info: Pstbtt_fontinfo; scale: Single; codepoint: Integer; padding: Integer; onedge_value: Byte; pixel_dist_scale: Single; width: PInteger; height: PInteger; xoff: PInteger; yoff: PInteger): PByte; cdecl;
  stbtt_FindMatchingFont: function(const fontdata: PByte; const name: PUTF8Char; flags: Integer): Integer; cdecl;
  stbtt_CompareUTF8toUTF16_bigendian: function(const s1: PUTF8Char; len1: Integer; const s2: PUTF8Char; len2: Integer): Integer; cdecl;
  stbtt_GetFontNameString: function(const font: Pstbtt_fontinfo; length: PInteger; platformID: Integer; encodingID: Integer; languageID: Integer; nameID: Integer): PUTF8Char; cdecl;
  initGL: function(): Integer; cdecl;
  c2CircletoCircle: function(A: c2Circle; B: c2Circle): Integer; cdecl;
  c2CircletoAABB: function(A: c2Circle; B: c2AABB): Integer; cdecl;
  c2CircletoCapsule: function(A: c2Circle; B: c2Capsule): Integer; cdecl;
  c2AABBtoAABB: function(A: c2AABB; B: c2AABB): Integer; cdecl;
  c2AABBtoCapsule: function(A: c2AABB; B: c2Capsule): Integer; cdecl;
  c2CapsuletoCapsule: function(A: c2Capsule; B: c2Capsule): Integer; cdecl;
  c2CircletoPoly: function(A: c2Circle; const B: Pc2Poly; const bx: Pc2x): Integer; cdecl;
  c2AABBtoPoly: function(A: c2AABB; const B: Pc2Poly; const bx: Pc2x): Integer; cdecl;
  c2CapsuletoPoly: function(A: c2Capsule; const B: Pc2Poly; const bx: Pc2x): Integer; cdecl;
  c2PolytoPoly: function(const A: Pc2Poly; const ax: Pc2x; const B: Pc2Poly; const bx: Pc2x): Integer; cdecl;
  c2RaytoCircle: function(A: c2Ray; B: c2Circle; &out: Pc2Raycast): Integer; cdecl;
  c2RaytoAABB: function(A: c2Ray; B: c2AABB; &out: Pc2Raycast): Integer; cdecl;
  c2RaytoCapsule: function(A: c2Ray; B: c2Capsule; &out: Pc2Raycast): Integer; cdecl;
  c2RaytoPoly: function(A: c2Ray; const B: Pc2Poly; const bx_ptr: Pc2x; &out: Pc2Raycast): Integer; cdecl;
  c2CircletoCircleManifold: procedure(A: c2Circle; B: c2Circle; m: Pc2Manifold); cdecl;
  c2CircletoAABBManifold: procedure(A: c2Circle; B: c2AABB; m: Pc2Manifold); cdecl;
  c2CircletoCapsuleManifold: procedure(A: c2Circle; B: c2Capsule; m: Pc2Manifold); cdecl;
  c2AABBtoAABBManifold: procedure(A: c2AABB; B: c2AABB; m: Pc2Manifold); cdecl;
  c2AABBtoCapsuleManifold: procedure(A: c2AABB; B: c2Capsule; m: Pc2Manifold); cdecl;
  c2CapsuletoCapsuleManifold: procedure(A: c2Capsule; B: c2Capsule; m: Pc2Manifold); cdecl;
  c2CircletoPolyManifold: procedure(A: c2Circle; const B: Pc2Poly; const bx: Pc2x; m: Pc2Manifold); cdecl;
  c2AABBtoPolyManifold: procedure(A: c2AABB; const B: Pc2Poly; const bx: Pc2x; m: Pc2Manifold); cdecl;
  c2CapsuletoPolyManifold: procedure(A: c2Capsule; const B: Pc2Poly; const bx: Pc2x; m: Pc2Manifold); cdecl;
  c2PolytoPolyManifold: procedure(const A: Pc2Poly; const ax: Pc2x; const B: Pc2Poly; const bx: Pc2x; m: Pc2Manifold); cdecl;
  c2GJK: function(const A: Pointer; typeA: C2_TYPE; const ax_ptr: Pc2x; const B: Pointer; typeB: C2_TYPE; const bx_ptr: Pc2x; outA: Pc2v; outB: Pc2v; use_radius: Integer; iterations: PInteger; cache: Pc2GJKCache): Single; cdecl;
  c2TOI: function(const A: Pointer; typeA: C2_TYPE; const ax_ptr: Pc2x; vA: c2v; const B: Pointer; typeB: C2_TYPE; const bx_ptr: Pc2x; vB: c2v; use_radius: Integer): c2TOIResult; cdecl;
  c2Inflate: procedure(shape: Pointer; &type: C2_TYPE; skin_factor: Single); cdecl;
  c2Hull: function(verts: Pc2v; count: Integer): Integer; cdecl;
  c2Norms: procedure(verts: Pc2v; norms: Pc2v; count: Integer); cdecl;
  c2MakePoly: procedure(p: Pc2Poly); cdecl;
  c2Collided: function(const A: Pointer; const ax: Pc2x; typeA: C2_TYPE; const B: Pointer; const bx: Pc2x; typeB: C2_TYPE): Integer; cdecl;
  c2Collide: procedure(const A: Pointer; const ax: Pc2x; typeA: C2_TYPE; const B: Pointer; const bx: Pc2x; typeB: C2_TYPE; m: Pc2Manifold); cdecl;
  c2CastRay: function(A: c2Ray; const B: Pointer; const bx: Pc2x; typeB: C2_TYPE; &out: Pc2Raycast): Integer; cdecl;
  plm_create_with_memory: function(bytes: PUInt8; length: NativeUInt; free_when_done: Integer): Pplm_t; cdecl;
  plm_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_t; cdecl;
  plm_destroy: procedure(self: Pplm_t); cdecl;
  plm_has_headers: function(self: Pplm_t): Integer; cdecl;
  plm_probe: function(self: Pplm_t; probesize: NativeUInt): Integer; cdecl;
  plm_get_video_enabled: function(self: Pplm_t): Integer; cdecl;
  plm_set_video_enabled: procedure(self: Pplm_t; enabled: Integer); cdecl;
  plm_get_num_video_streams: function(self: Pplm_t): Integer; cdecl;
  plm_get_width: function(self: Pplm_t): Integer; cdecl;
  plm_get_height: function(self: Pplm_t): Integer; cdecl;
  plm_get_pixel_aspect_ratio: function(self: Pplm_t): Double; cdecl;
  plm_get_framerate: function(self: Pplm_t): Double; cdecl;
  plm_get_audio_enabled: function(self: Pplm_t): Integer; cdecl;
  plm_set_audio_enabled: procedure(self: Pplm_t; enabled: Integer); cdecl;
  plm_get_num_audio_streams: function(self: Pplm_t): Integer; cdecl;
  plm_set_audio_stream: procedure(self: Pplm_t; stream_index: Integer); cdecl;
  plm_get_samplerate: function(self: Pplm_t): Integer; cdecl;
  plm_get_audio_lead_time: function(self: Pplm_t): Double; cdecl;
  plm_set_audio_lead_time: procedure(self: Pplm_t; lead_time: Double); cdecl;
  plm_get_time: function(self: Pplm_t): Double; cdecl;
  plm_get_duration: function(self: Pplm_t): Double; cdecl;
  plm_rewind: procedure(self: Pplm_t); cdecl;
  plm_get_loop: function(self: Pplm_t): Integer; cdecl;
  plm_set_loop: procedure(self: Pplm_t; loop: Integer); cdecl;
  plm_has_ended: function(self: Pplm_t): Integer; cdecl;
  plm_set_video_decode_callback: procedure(self: Pplm_t; fp: plm_video_decode_callback; user: Pointer); cdecl;
  plm_set_audio_decode_callback: procedure(self: Pplm_t; fp: plm_audio_decode_callback; user: Pointer); cdecl;
  plm_decode: procedure(self: Pplm_t; seconds: Double); cdecl;
  plm_decode_video: function(self: Pplm_t): Pplm_frame_t; cdecl;
  plm_decode_audio: function(self: Pplm_t): Pplm_samples_t; cdecl;
  plm_seek: function(self: Pplm_t; time: Double; seek_exact: Integer): Integer; cdecl;
  plm_seek_frame: function(self: Pplm_t; time: Double; seek_exact: Integer): Pplm_frame_t; cdecl;
  plm_buffer_create_with_callbacks: function(load_callback: plm_buffer_load_callback; seek_callback: plm_buffer_seek_callback; tell_callback: plm_buffer_tell_callback; length: NativeUInt; user: Pointer): Pplm_buffer_t; cdecl;
  plm_buffer_create_with_memory: function(bytes: PUInt8; length: NativeUInt; free_when_done: Integer): Pplm_buffer_t; cdecl;
  plm_buffer_create_with_capacity: function(capacity: NativeUInt): Pplm_buffer_t; cdecl;
  plm_buffer_create_for_appending: function(initial_capacity: NativeUInt): Pplm_buffer_t; cdecl;
  plm_buffer_destroy: procedure(self: Pplm_buffer_t); cdecl;
  plm_buffer_write: function(self: Pplm_buffer_t; bytes: PUInt8; length: NativeUInt): NativeUInt; cdecl;
  plm_buffer_signal_end: procedure(self: Pplm_buffer_t); cdecl;
  plm_buffer_set_load_callback: procedure(self: Pplm_buffer_t; fp: plm_buffer_load_callback; user: Pointer); cdecl;
  plm_buffer_rewind: procedure(self: Pplm_buffer_t); cdecl;
  plm_buffer_get_size: function(self: Pplm_buffer_t): NativeUInt; cdecl;
  plm_buffer_get_remaining: function(self: Pplm_buffer_t): NativeUInt; cdecl;
  plm_buffer_has_ended: function(self: Pplm_buffer_t): Integer; cdecl;
  plm_demux_create: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_demux_t; cdecl;
  plm_demux_destroy: procedure(self: Pplm_demux_t); cdecl;
  plm_demux_has_headers: function(self: Pplm_demux_t): Integer; cdecl;
  plm_demux_probe: function(self: Pplm_demux_t; probesize: NativeUInt): Integer; cdecl;
  plm_demux_get_num_video_streams: function(self: Pplm_demux_t): Integer; cdecl;
  plm_demux_get_num_audio_streams: function(self: Pplm_demux_t): Integer; cdecl;
  plm_demux_rewind: procedure(self: Pplm_demux_t); cdecl;
  plm_demux_has_ended: function(self: Pplm_demux_t): Integer; cdecl;
  plm_demux_seek: function(self: Pplm_demux_t; time: Double; &type: Integer; force_intra: Integer): Pplm_packet_t; cdecl;
  plm_demux_get_start_time: function(self: Pplm_demux_t; &type: Integer): Double; cdecl;
  plm_demux_get_duration: function(self: Pplm_demux_t; &type: Integer): Double; cdecl;
  plm_demux_decode: function(self: Pplm_demux_t): Pplm_packet_t; cdecl;
  plm_video_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_video_t; cdecl;
  plm_video_destroy: procedure(self: Pplm_video_t); cdecl;
  plm_video_has_header: function(self: Pplm_video_t): Integer; cdecl;
  plm_video_get_framerate: function(self: Pplm_video_t): Double; cdecl;
  plm_video_get_pixel_aspect_ratio: function(self: Pplm_video_t): Double; cdecl;
  plm_video_get_width: function(self: Pplm_video_t): Integer; cdecl;
  plm_video_get_height: function(self: Pplm_video_t): Integer; cdecl;
  plm_video_set_no_delay: procedure(self: Pplm_video_t; no_delay: Integer); cdecl;
  plm_video_get_time: function(self: Pplm_video_t): Double; cdecl;
  plm_video_set_time: procedure(self: Pplm_video_t; time: Double); cdecl;
  plm_video_rewind: procedure(self: Pplm_video_t); cdecl;
  plm_video_has_ended: function(self: Pplm_video_t): Integer; cdecl;
  plm_video_decode: function(self: Pplm_video_t): Pplm_frame_t; cdecl;
  plm_frame_to_rgb: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_frame_to_bgr: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_frame_to_rgba: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_frame_to_bgra: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_frame_to_argb: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_frame_to_abgr: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;
  plm_audio_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_audio_t; cdecl;
  plm_audio_destroy: procedure(self: Pplm_audio_t); cdecl;
  plm_audio_has_header: function(self: Pplm_audio_t): Integer; cdecl;
  plm_audio_get_samplerate: function(self: Pplm_audio_t): Integer; cdecl;
  plm_audio_get_time: function(self: Pplm_audio_t): Double; cdecl;
  plm_audio_set_time: procedure(self: Pplm_audio_t; time: Double); cdecl;
  plm_audio_rewind: procedure(self: Pplm_audio_t); cdecl;
  plm_audio_has_ended: function(self: Pplm_audio_t): Integer; cdecl;
  plm_audio_decode: function(self: Pplm_audio_t): Pplm_samples_t; cdecl;
  ma_version: procedure(pMajor: Pma_uint32; pMinor: Pma_uint32; pRevision: Pma_uint32); cdecl;
  ma_version_string: function(): PUTF8Char; cdecl;
  ma_log_callback_init: function(onLog: ma_log_callback_proc; pUserData: Pointer): ma_log_callback; cdecl;
  ma_log_init: function(const pAllocationCallbacks: Pma_allocation_callbacks; pLog: Pma_log): ma_result; cdecl;
  ma_log_uninit: procedure(pLog: Pma_log); cdecl;
  ma_log_register_callback: function(pLog: Pma_log; callback: ma_log_callback): ma_result; cdecl;
  ma_log_unregister_callback: function(pLog: Pma_log; callback: ma_log_callback): ma_result; cdecl;
  ma_log_post: function(pLog: Pma_log; level: ma_uint32; const pMessage: PUTF8Char): ma_result; cdecl;
  ma_log_postv: function(pLog: Pma_log; level: ma_uint32; const pFormat: PUTF8Char; args: Pointer): ma_result; cdecl;
  ma_log_postf: function(pLog: Pma_log; level: ma_uint32; const pFormat: PUTF8Char): ma_result varargs; cdecl;
  ma_biquad_config_init: function(format: ma_format; channels: ma_uint32; b0: Double; b1: Double; b2: Double; a0: Double; a1: Double; a2: Double): ma_biquad_config; cdecl;
  ma_biquad_get_heap_size: function(const pConfig: Pma_biquad_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_biquad_init_preallocated: function(const pConfig: Pma_biquad_config; pHeap: Pointer; pBQ: Pma_biquad): ma_result; cdecl;
  ma_biquad_init: function(const pConfig: Pma_biquad_config; const pAllocationCallbacks: Pma_allocation_callbacks; pBQ: Pma_biquad): ma_result; cdecl;
  ma_biquad_uninit: procedure(pBQ: Pma_biquad; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_biquad_reinit: function(const pConfig: Pma_biquad_config; pBQ: Pma_biquad): ma_result; cdecl;
  ma_biquad_clear_cache: function(pBQ: Pma_biquad): ma_result; cdecl;
  ma_biquad_process_pcm_frames: function(pBQ: Pma_biquad; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_biquad_get_latency: function(const pBQ: Pma_biquad): ma_uint32; cdecl;
  ma_lpf1_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double): ma_lpf1_config; cdecl;
  ma_lpf2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; q: Double): ma_lpf2_config; cdecl;
  ma_lpf1_get_heap_size: function(const pConfig: Pma_lpf1_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_lpf1_init_preallocated: function(const pConfig: Pma_lpf1_config; pHeap: Pointer; pLPF: Pma_lpf1): ma_result; cdecl;
  ma_lpf1_init: function(const pConfig: Pma_lpf1_config; const pAllocationCallbacks: Pma_allocation_callbacks; pLPF: Pma_lpf1): ma_result; cdecl;
  ma_lpf1_uninit: procedure(pLPF: Pma_lpf1; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_lpf1_reinit: function(const pConfig: Pma_lpf1_config; pLPF: Pma_lpf1): ma_result; cdecl;
  ma_lpf1_clear_cache: function(pLPF: Pma_lpf1): ma_result; cdecl;
  ma_lpf1_process_pcm_frames: function(pLPF: Pma_lpf1; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_lpf1_get_latency: function(const pLPF: Pma_lpf1): ma_uint32; cdecl;
  ma_lpf2_get_heap_size: function(const pConfig: Pma_lpf2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_lpf2_init_preallocated: function(const pConfig: Pma_lpf2_config; pHeap: Pointer; pHPF: Pma_lpf2): ma_result; cdecl;
  ma_lpf2_init: function(const pConfig: Pma_lpf2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pLPF: Pma_lpf2): ma_result; cdecl;
  ma_lpf2_uninit: procedure(pLPF: Pma_lpf2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_lpf2_reinit: function(const pConfig: Pma_lpf2_config; pLPF: Pma_lpf2): ma_result; cdecl;
  ma_lpf2_clear_cache: function(pLPF: Pma_lpf2): ma_result; cdecl;
  ma_lpf2_process_pcm_frames: function(pLPF: Pma_lpf2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_lpf2_get_latency: function(const pLPF: Pma_lpf2): ma_uint32; cdecl;
  ma_lpf_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_lpf_config; cdecl;
  ma_lpf_get_heap_size: function(const pConfig: Pma_lpf_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_lpf_init_preallocated: function(const pConfig: Pma_lpf_config; pHeap: Pointer; pLPF: Pma_lpf): ma_result; cdecl;
  ma_lpf_init: function(const pConfig: Pma_lpf_config; const pAllocationCallbacks: Pma_allocation_callbacks; pLPF: Pma_lpf): ma_result; cdecl;
  ma_lpf_uninit: procedure(pLPF: Pma_lpf; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_lpf_reinit: function(const pConfig: Pma_lpf_config; pLPF: Pma_lpf): ma_result; cdecl;
  ma_lpf_clear_cache: function(pLPF: Pma_lpf): ma_result; cdecl;
  ma_lpf_process_pcm_frames: function(pLPF: Pma_lpf; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_lpf_get_latency: function(const pLPF: Pma_lpf): ma_uint32; cdecl;
  ma_hpf1_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double): ma_hpf1_config; cdecl;
  ma_hpf2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; q: Double): ma_hpf2_config; cdecl;
  ma_hpf1_get_heap_size: function(const pConfig: Pma_hpf1_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_hpf1_init_preallocated: function(const pConfig: Pma_hpf1_config; pHeap: Pointer; pLPF: Pma_hpf1): ma_result; cdecl;
  ma_hpf1_init: function(const pConfig: Pma_hpf1_config; const pAllocationCallbacks: Pma_allocation_callbacks; pHPF: Pma_hpf1): ma_result; cdecl;
  ma_hpf1_uninit: procedure(pHPF: Pma_hpf1; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hpf1_reinit: function(const pConfig: Pma_hpf1_config; pHPF: Pma_hpf1): ma_result; cdecl;
  ma_hpf1_process_pcm_frames: function(pHPF: Pma_hpf1; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_hpf1_get_latency: function(const pHPF: Pma_hpf1): ma_uint32; cdecl;
  ma_hpf2_get_heap_size: function(const pConfig: Pma_hpf2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_hpf2_init_preallocated: function(const pConfig: Pma_hpf2_config; pHeap: Pointer; pHPF: Pma_hpf2): ma_result; cdecl;
  ma_hpf2_init: function(const pConfig: Pma_hpf2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pHPF: Pma_hpf2): ma_result; cdecl;
  ma_hpf2_uninit: procedure(pHPF: Pma_hpf2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hpf2_reinit: function(const pConfig: Pma_hpf2_config; pHPF: Pma_hpf2): ma_result; cdecl;
  ma_hpf2_process_pcm_frames: function(pHPF: Pma_hpf2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_hpf2_get_latency: function(const pHPF: Pma_hpf2): ma_uint32; cdecl;
  ma_hpf_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_hpf_config; cdecl;
  ma_hpf_get_heap_size: function(const pConfig: Pma_hpf_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_hpf_init_preallocated: function(const pConfig: Pma_hpf_config; pHeap: Pointer; pLPF: Pma_hpf): ma_result; cdecl;
  ma_hpf_init: function(const pConfig: Pma_hpf_config; const pAllocationCallbacks: Pma_allocation_callbacks; pHPF: Pma_hpf): ma_result; cdecl;
  ma_hpf_uninit: procedure(pHPF: Pma_hpf; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hpf_reinit: function(const pConfig: Pma_hpf_config; pHPF: Pma_hpf): ma_result; cdecl;
  ma_hpf_process_pcm_frames: function(pHPF: Pma_hpf; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_hpf_get_latency: function(const pHPF: Pma_hpf): ma_uint32; cdecl;
  ma_bpf2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; q: Double): ma_bpf2_config; cdecl;
  ma_bpf2_get_heap_size: function(const pConfig: Pma_bpf2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_bpf2_init_preallocated: function(const pConfig: Pma_bpf2_config; pHeap: Pointer; pBPF: Pma_bpf2): ma_result; cdecl;
  ma_bpf2_init: function(const pConfig: Pma_bpf2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pBPF: Pma_bpf2): ma_result; cdecl;
  ma_bpf2_uninit: procedure(pBPF: Pma_bpf2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_bpf2_reinit: function(const pConfig: Pma_bpf2_config; pBPF: Pma_bpf2): ma_result; cdecl;
  ma_bpf2_process_pcm_frames: function(pBPF: Pma_bpf2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_bpf2_get_latency: function(const pBPF: Pma_bpf2): ma_uint32; cdecl;
  ma_bpf_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_bpf_config; cdecl;
  ma_bpf_get_heap_size: function(const pConfig: Pma_bpf_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_bpf_init_preallocated: function(const pConfig: Pma_bpf_config; pHeap: Pointer; pBPF: Pma_bpf): ma_result; cdecl;
  ma_bpf_init: function(const pConfig: Pma_bpf_config; const pAllocationCallbacks: Pma_allocation_callbacks; pBPF: Pma_bpf): ma_result; cdecl;
  ma_bpf_uninit: procedure(pBPF: Pma_bpf; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_bpf_reinit: function(const pConfig: Pma_bpf_config; pBPF: Pma_bpf): ma_result; cdecl;
  ma_bpf_process_pcm_frames: function(pBPF: Pma_bpf; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_bpf_get_latency: function(const pBPF: Pma_bpf): ma_uint32; cdecl;
  ma_notch2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; q: Double; frequency: Double): ma_notch2_config; cdecl;
  ma_notch2_get_heap_size: function(const pConfig: Pma_notch2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_notch2_init_preallocated: function(const pConfig: Pma_notch2_config; pHeap: Pointer; pFilter: Pma_notch2): ma_result; cdecl;
  ma_notch2_init: function(const pConfig: Pma_notch2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pFilter: Pma_notch2): ma_result; cdecl;
  ma_notch2_uninit: procedure(pFilter: Pma_notch2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_notch2_reinit: function(const pConfig: Pma_notch2_config; pFilter: Pma_notch2): ma_result; cdecl;
  ma_notch2_process_pcm_frames: function(pFilter: Pma_notch2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_notch2_get_latency: function(const pFilter: Pma_notch2): ma_uint32; cdecl;
  ma_peak2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; q: Double; frequency: Double): ma_peak2_config; cdecl;
  ma_peak2_get_heap_size: function(const pConfig: Pma_peak2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_peak2_init_preallocated: function(const pConfig: Pma_peak2_config; pHeap: Pointer; pFilter: Pma_peak2): ma_result; cdecl;
  ma_peak2_init: function(const pConfig: Pma_peak2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pFilter: Pma_peak2): ma_result; cdecl;
  ma_peak2_uninit: procedure(pFilter: Pma_peak2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_peak2_reinit: function(const pConfig: Pma_peak2_config; pFilter: Pma_peak2): ma_result; cdecl;
  ma_peak2_process_pcm_frames: function(pFilter: Pma_peak2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_peak2_get_latency: function(const pFilter: Pma_peak2): ma_uint32; cdecl;
  ma_loshelf2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; shelfSlope: Double; frequency: Double): ma_loshelf2_config; cdecl;
  ma_loshelf2_get_heap_size: function(const pConfig: Pma_loshelf2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_loshelf2_init_preallocated: function(const pConfig: Pma_loshelf2_config; pHeap: Pointer; pFilter: Pma_loshelf2): ma_result; cdecl;
  ma_loshelf2_init: function(const pConfig: Pma_loshelf2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pFilter: Pma_loshelf2): ma_result; cdecl;
  ma_loshelf2_uninit: procedure(pFilter: Pma_loshelf2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_loshelf2_reinit: function(const pConfig: Pma_loshelf2_config; pFilter: Pma_loshelf2): ma_result; cdecl;
  ma_loshelf2_process_pcm_frames: function(pFilter: Pma_loshelf2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_loshelf2_get_latency: function(const pFilter: Pma_loshelf2): ma_uint32; cdecl;
  ma_hishelf2_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; shelfSlope: Double; frequency: Double): ma_hishelf2_config; cdecl;
  ma_hishelf2_get_heap_size: function(const pConfig: Pma_hishelf2_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_hishelf2_init_preallocated: function(const pConfig: Pma_hishelf2_config; pHeap: Pointer; pFilter: Pma_hishelf2): ma_result; cdecl;
  ma_hishelf2_init: function(const pConfig: Pma_hishelf2_config; const pAllocationCallbacks: Pma_allocation_callbacks; pFilter: Pma_hishelf2): ma_result; cdecl;
  ma_hishelf2_uninit: procedure(pFilter: Pma_hishelf2; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hishelf2_reinit: function(const pConfig: Pma_hishelf2_config; pFilter: Pma_hishelf2): ma_result; cdecl;
  ma_hishelf2_process_pcm_frames: function(pFilter: Pma_hishelf2; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_hishelf2_get_latency: function(const pFilter: Pma_hishelf2): ma_uint32; cdecl;
  ma_delay_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; delayInFrames: ma_uint32; decay: Single): ma_delay_config; cdecl;
  ma_delay_init: function(const pConfig: Pma_delay_config; const pAllocationCallbacks: Pma_allocation_callbacks; pDelay: Pma_delay): ma_result; cdecl;
  ma_delay_uninit: procedure(pDelay: Pma_delay; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_delay_process_pcm_frames: function(pDelay: Pma_delay; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint32): ma_result; cdecl;
  ma_delay_set_wet: procedure(pDelay: Pma_delay; value: Single); cdecl;
  ma_delay_get_wet: function(const pDelay: Pma_delay): Single; cdecl;
  ma_delay_set_dry: procedure(pDelay: Pma_delay; value: Single); cdecl;
  ma_delay_get_dry: function(const pDelay: Pma_delay): Single; cdecl;
  ma_delay_set_decay: procedure(pDelay: Pma_delay; value: Single); cdecl;
  ma_delay_get_decay: function(const pDelay: Pma_delay): Single; cdecl;
  ma_gainer_config_init: function(channels: ma_uint32; smoothTimeInFrames: ma_uint32): ma_gainer_config; cdecl;
  ma_gainer_get_heap_size: function(const pConfig: Pma_gainer_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_gainer_init_preallocated: function(const pConfig: Pma_gainer_config; pHeap: Pointer; pGainer: Pma_gainer): ma_result; cdecl;
  ma_gainer_init: function(const pConfig: Pma_gainer_config; const pAllocationCallbacks: Pma_allocation_callbacks; pGainer: Pma_gainer): ma_result; cdecl;
  ma_gainer_uninit: procedure(pGainer: Pma_gainer; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_gainer_process_pcm_frames: function(pGainer: Pma_gainer; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_gainer_set_gain: function(pGainer: Pma_gainer; newGain: Single): ma_result; cdecl;
  ma_gainer_set_gains: function(pGainer: Pma_gainer; pNewGains: PSingle): ma_result; cdecl;
  ma_gainer_set_master_volume: function(pGainer: Pma_gainer; volume: Single): ma_result; cdecl;
  ma_gainer_get_master_volume: function(const pGainer: Pma_gainer; pVolume: PSingle): ma_result; cdecl;
  ma_panner_config_init: function(format: ma_format; channels: ma_uint32): ma_panner_config; cdecl;
  ma_panner_init: function(const pConfig: Pma_panner_config; pPanner: Pma_panner): ma_result; cdecl;
  ma_panner_process_pcm_frames: function(pPanner: Pma_panner; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_panner_set_mode: procedure(pPanner: Pma_panner; mode: ma_pan_mode); cdecl;
  ma_panner_get_mode: function(const pPanner: Pma_panner): ma_pan_mode; cdecl;
  ma_panner_set_pan: procedure(pPanner: Pma_panner; pan: Single); cdecl;
  ma_panner_get_pan: function(const pPanner: Pma_panner): Single; cdecl;
  ma_fader_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32): ma_fader_config; cdecl;
  ma_fader_init: function(const pConfig: Pma_fader_config; pFader: Pma_fader): ma_result; cdecl;
  ma_fader_process_pcm_frames: function(pFader: Pma_fader; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_fader_get_data_format: procedure(const pFader: Pma_fader; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32); cdecl;
  ma_fader_set_fade: procedure(pFader: Pma_fader; volumeBeg: Single; volumeEnd: Single; lengthInFrames: ma_uint64); cdecl;
  ma_fader_set_fade_ex: procedure(pFader: Pma_fader; volumeBeg: Single; volumeEnd: Single; lengthInFrames: ma_uint64; startOffsetInFrames: ma_int64); cdecl;
  ma_fader_get_current_volume: function(const pFader: Pma_fader): Single; cdecl;
  ma_spatializer_listener_config_init: function(channelsOut: ma_uint32): ma_spatializer_listener_config; cdecl;
  ma_spatializer_listener_get_heap_size: function(const pConfig: Pma_spatializer_listener_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_spatializer_listener_init_preallocated: function(const pConfig: Pma_spatializer_listener_config; pHeap: Pointer; pListener: Pma_spatializer_listener): ma_result; cdecl;
  ma_spatializer_listener_init: function(const pConfig: Pma_spatializer_listener_config; const pAllocationCallbacks: Pma_allocation_callbacks; pListener: Pma_spatializer_listener): ma_result; cdecl;
  ma_spatializer_listener_uninit: procedure(pListener: Pma_spatializer_listener; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_spatializer_listener_get_channel_map: function(pListener: Pma_spatializer_listener): Pma_channel; cdecl;
  ma_spatializer_listener_set_cone: procedure(pListener: Pma_spatializer_listener; innerAngleInRadians: Single; outerAngleInRadians: Single; outerGain: Single); cdecl;
  ma_spatializer_listener_get_cone: procedure(const pListener: Pma_spatializer_listener; pInnerAngleInRadians: PSingle; pOuterAngleInRadians: PSingle; pOuterGain: PSingle); cdecl;
  ma_spatializer_listener_set_position: procedure(pListener: Pma_spatializer_listener; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_listener_get_position: function(const pListener: Pma_spatializer_listener): ma_vec3f; cdecl;
  ma_spatializer_listener_set_direction: procedure(pListener: Pma_spatializer_listener; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_listener_get_direction: function(const pListener: Pma_spatializer_listener): ma_vec3f; cdecl;
  ma_spatializer_listener_set_velocity: procedure(pListener: Pma_spatializer_listener; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_listener_get_velocity: function(const pListener: Pma_spatializer_listener): ma_vec3f; cdecl;
  ma_spatializer_listener_set_speed_of_sound: procedure(pListener: Pma_spatializer_listener; speedOfSound: Single); cdecl;
  ma_spatializer_listener_get_speed_of_sound: function(const pListener: Pma_spatializer_listener): Single; cdecl;
  ma_spatializer_listener_set_world_up: procedure(pListener: Pma_spatializer_listener; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_listener_get_world_up: function(const pListener: Pma_spatializer_listener): ma_vec3f; cdecl;
  ma_spatializer_listener_set_enabled: procedure(pListener: Pma_spatializer_listener; isEnabled: ma_bool32); cdecl;
  ma_spatializer_listener_is_enabled: function(const pListener: Pma_spatializer_listener): ma_bool32; cdecl;
  ma_spatializer_config_init: function(channelsIn: ma_uint32; channelsOut: ma_uint32): ma_spatializer_config; cdecl;
  ma_spatializer_get_heap_size: function(const pConfig: Pma_spatializer_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_spatializer_init_preallocated: function(const pConfig: Pma_spatializer_config; pHeap: Pointer; pSpatializer: Pma_spatializer): ma_result; cdecl;
  ma_spatializer_init: function(const pConfig: Pma_spatializer_config; const pAllocationCallbacks: Pma_allocation_callbacks; pSpatializer: Pma_spatializer): ma_result; cdecl;
  ma_spatializer_uninit: procedure(pSpatializer: Pma_spatializer; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_spatializer_process_pcm_frames: function(pSpatializer: Pma_spatializer; pListener: Pma_spatializer_listener; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_spatializer_set_master_volume: function(pSpatializer: Pma_spatializer; volume: Single): ma_result; cdecl;
  ma_spatializer_get_master_volume: function(const pSpatializer: Pma_spatializer; pVolume: PSingle): ma_result; cdecl;
  ma_spatializer_get_input_channels: function(const pSpatializer: Pma_spatializer): ma_uint32; cdecl;
  ma_spatializer_get_output_channels: function(const pSpatializer: Pma_spatializer): ma_uint32; cdecl;
  ma_spatializer_set_attenuation_model: procedure(pSpatializer: Pma_spatializer; attenuationModel: ma_attenuation_model); cdecl;
  ma_spatializer_get_attenuation_model: function(const pSpatializer: Pma_spatializer): ma_attenuation_model; cdecl;
  ma_spatializer_set_positioning: procedure(pSpatializer: Pma_spatializer; positioning: ma_positioning); cdecl;
  ma_spatializer_get_positioning: function(const pSpatializer: Pma_spatializer): ma_positioning; cdecl;
  ma_spatializer_set_rolloff: procedure(pSpatializer: Pma_spatializer; rolloff: Single); cdecl;
  ma_spatializer_get_rolloff: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_min_gain: procedure(pSpatializer: Pma_spatializer; minGain: Single); cdecl;
  ma_spatializer_get_min_gain: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_max_gain: procedure(pSpatializer: Pma_spatializer; maxGain: Single); cdecl;
  ma_spatializer_get_max_gain: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_min_distance: procedure(pSpatializer: Pma_spatializer; minDistance: Single); cdecl;
  ma_spatializer_get_min_distance: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_max_distance: procedure(pSpatializer: Pma_spatializer; maxDistance: Single); cdecl;
  ma_spatializer_get_max_distance: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_cone: procedure(pSpatializer: Pma_spatializer; innerAngleInRadians: Single; outerAngleInRadians: Single; outerGain: Single); cdecl;
  ma_spatializer_get_cone: procedure(const pSpatializer: Pma_spatializer; pInnerAngleInRadians: PSingle; pOuterAngleInRadians: PSingle; pOuterGain: PSingle); cdecl;
  ma_spatializer_set_doppler_factor: procedure(pSpatializer: Pma_spatializer; dopplerFactor: Single); cdecl;
  ma_spatializer_get_doppler_factor: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_directional_attenuation_factor: procedure(pSpatializer: Pma_spatializer; directionalAttenuationFactor: Single); cdecl;
  ma_spatializer_get_directional_attenuation_factor: function(const pSpatializer: Pma_spatializer): Single; cdecl;
  ma_spatializer_set_position: procedure(pSpatializer: Pma_spatializer; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_get_position: function(const pSpatializer: Pma_spatializer): ma_vec3f; cdecl;
  ma_spatializer_set_direction: procedure(pSpatializer: Pma_spatializer; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_get_direction: function(const pSpatializer: Pma_spatializer): ma_vec3f; cdecl;
  ma_spatializer_set_velocity: procedure(pSpatializer: Pma_spatializer; x: Single; y: Single; z: Single); cdecl;
  ma_spatializer_get_velocity: function(const pSpatializer: Pma_spatializer): ma_vec3f; cdecl;
  ma_spatializer_get_relative_position_and_direction: procedure(const pSpatializer: Pma_spatializer; const pListener: Pma_spatializer_listener; pRelativePos: Pma_vec3f; pRelativeDir: Pma_vec3f); cdecl;
  ma_linear_resampler_config_init: function(format: ma_format; channels: ma_uint32; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_linear_resampler_config; cdecl;
  ma_linear_resampler_get_heap_size: function(const pConfig: Pma_linear_resampler_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_linear_resampler_init_preallocated: function(const pConfig: Pma_linear_resampler_config; pHeap: Pointer; pResampler: Pma_linear_resampler): ma_result; cdecl;
  ma_linear_resampler_init: function(const pConfig: Pma_linear_resampler_config; const pAllocationCallbacks: Pma_allocation_callbacks; pResampler: Pma_linear_resampler): ma_result; cdecl;
  ma_linear_resampler_uninit: procedure(pResampler: Pma_linear_resampler; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_linear_resampler_process_pcm_frames: function(pResampler: Pma_linear_resampler; const pFramesIn: Pointer; pFrameCountIn: Pma_uint64; pFramesOut: Pointer; pFrameCountOut: Pma_uint64): ma_result; cdecl;
  ma_linear_resampler_set_rate: function(pResampler: Pma_linear_resampler; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_result; cdecl;
  ma_linear_resampler_set_rate_ratio: function(pResampler: Pma_linear_resampler; ratioInOut: Single): ma_result; cdecl;
  ma_linear_resampler_get_input_latency: function(const pResampler: Pma_linear_resampler): ma_uint64; cdecl;
  ma_linear_resampler_get_output_latency: function(const pResampler: Pma_linear_resampler): ma_uint64; cdecl;
  ma_linear_resampler_get_required_input_frame_count: function(const pResampler: Pma_linear_resampler; outputFrameCount: ma_uint64; pInputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_linear_resampler_get_expected_output_frame_count: function(const pResampler: Pma_linear_resampler; inputFrameCount: ma_uint64; pOutputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_linear_resampler_reset: function(pResampler: Pma_linear_resampler): ma_result; cdecl;
  ma_resampler_config_init: function(format: ma_format; channels: ma_uint32; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32; algorithm: ma_resample_algorithm): ma_resampler_config; cdecl;
  ma_resampler_get_heap_size: function(const pConfig: Pma_resampler_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_resampler_init_preallocated: function(const pConfig: Pma_resampler_config; pHeap: Pointer; pResampler: Pma_resampler): ma_result; cdecl;
  ma_resampler_init: function(const pConfig: Pma_resampler_config; const pAllocationCallbacks: Pma_allocation_callbacks; pResampler: Pma_resampler): ma_result; cdecl;
  ma_resampler_uninit: procedure(pResampler: Pma_resampler; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_resampler_process_pcm_frames: function(pResampler: Pma_resampler; const pFramesIn: Pointer; pFrameCountIn: Pma_uint64; pFramesOut: Pointer; pFrameCountOut: Pma_uint64): ma_result; cdecl;
  ma_resampler_set_rate: function(pResampler: Pma_resampler; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_result; cdecl;
  ma_resampler_set_rate_ratio: function(pResampler: Pma_resampler; ratio: Single): ma_result; cdecl;
  ma_resampler_get_input_latency: function(const pResampler: Pma_resampler): ma_uint64; cdecl;
  ma_resampler_get_output_latency: function(const pResampler: Pma_resampler): ma_uint64; cdecl;
  ma_resampler_get_required_input_frame_count: function(const pResampler: Pma_resampler; outputFrameCount: ma_uint64; pInputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_resampler_get_expected_output_frame_count: function(const pResampler: Pma_resampler; inputFrameCount: ma_uint64; pOutputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_resampler_reset: function(pResampler: Pma_resampler): ma_result; cdecl;
  ma_channel_converter_config_init: function(format: ma_format; channelsIn: ma_uint32; const pChannelMapIn: Pma_channel; channelsOut: ma_uint32; const pChannelMapOut: Pma_channel; mixingMode: ma_channel_mix_mode): ma_channel_converter_config; cdecl;
  ma_channel_converter_get_heap_size: function(const pConfig: Pma_channel_converter_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_channel_converter_init_preallocated: function(const pConfig: Pma_channel_converter_config; pHeap: Pointer; pConverter: Pma_channel_converter): ma_result; cdecl;
  ma_channel_converter_init: function(const pConfig: Pma_channel_converter_config; const pAllocationCallbacks: Pma_allocation_callbacks; pConverter: Pma_channel_converter): ma_result; cdecl;
  ma_channel_converter_uninit: procedure(pConverter: Pma_channel_converter; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_channel_converter_process_pcm_frames: function(pConverter: Pma_channel_converter; pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64): ma_result; cdecl;
  ma_channel_converter_get_input_channel_map: function(const pConverter: Pma_channel_converter; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_channel_converter_get_output_channel_map: function(const pConverter: Pma_channel_converter; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_data_converter_config_init_default: function(): ma_data_converter_config; cdecl;
  ma_data_converter_config_init: function(formatIn: ma_format; formatOut: ma_format; channelsIn: ma_uint32; channelsOut: ma_uint32; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_data_converter_config; cdecl;
  ma_data_converter_get_heap_size: function(const pConfig: Pma_data_converter_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_data_converter_init_preallocated: function(const pConfig: Pma_data_converter_config; pHeap: Pointer; pConverter: Pma_data_converter): ma_result; cdecl;
  ma_data_converter_init: function(const pConfig: Pma_data_converter_config; const pAllocationCallbacks: Pma_allocation_callbacks; pConverter: Pma_data_converter): ma_result; cdecl;
  ma_data_converter_uninit: procedure(pConverter: Pma_data_converter; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_data_converter_process_pcm_frames: function(pConverter: Pma_data_converter; const pFramesIn: Pointer; pFrameCountIn: Pma_uint64; pFramesOut: Pointer; pFrameCountOut: Pma_uint64): ma_result; cdecl;
  ma_data_converter_set_rate: function(pConverter: Pma_data_converter; sampleRateIn: ma_uint32; sampleRateOut: ma_uint32): ma_result; cdecl;
  ma_data_converter_set_rate_ratio: function(pConverter: Pma_data_converter; ratioInOut: Single): ma_result; cdecl;
  ma_data_converter_get_input_latency: function(const pConverter: Pma_data_converter): ma_uint64; cdecl;
  ma_data_converter_get_output_latency: function(const pConverter: Pma_data_converter): ma_uint64; cdecl;
  ma_data_converter_get_required_input_frame_count: function(const pConverter: Pma_data_converter; outputFrameCount: ma_uint64; pInputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_data_converter_get_expected_output_frame_count: function(const pConverter: Pma_data_converter; inputFrameCount: ma_uint64; pOutputFrameCount: Pma_uint64): ma_result; cdecl;
  ma_data_converter_get_input_channel_map: function(const pConverter: Pma_data_converter; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_data_converter_get_output_channel_map: function(const pConverter: Pma_data_converter; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_data_converter_reset: function(pConverter: Pma_data_converter): ma_result; cdecl;
  ma_pcm_u8_to_s16: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_u8_to_s24: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_u8_to_s32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_u8_to_f32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s16_to_u8: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s16_to_s24: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s16_to_s32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s16_to_f32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s24_to_u8: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s24_to_s16: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s24_to_s32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s24_to_f32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s32_to_u8: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s32_to_s16: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s32_to_s24: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_s32_to_f32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_f32_to_u8: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_f32_to_s16: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_f32_to_s24: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_f32_to_s32: procedure(pOut: Pointer; const pIn: Pointer; count: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_pcm_convert: procedure(pOut: Pointer; formatOut: ma_format; const pIn: Pointer; formatIn: ma_format; sampleCount: ma_uint64; ditherMode: ma_dither_mode); cdecl;
  ma_convert_pcm_frames_format: procedure(pOut: Pointer; formatOut: ma_format; const pIn: Pointer; formatIn: ma_format; frameCount: ma_uint64; channels: ma_uint32; ditherMode: ma_dither_mode); cdecl;
  ma_deinterleave_pcm_frames: procedure(format: ma_format; channels: ma_uint32; frameCount: ma_uint64; const pInterleavedPCMFrames: Pointer; ppDeinterleavedPCMFrames: PPointer); cdecl;
  ma_interleave_pcm_frames: procedure(format: ma_format; channels: ma_uint32; frameCount: ma_uint64; ppDeinterleavedPCMFrames: PPointer; pInterleavedPCMFrames: Pointer); cdecl;
  ma_channel_map_get_channel: function(const pChannelMap: Pma_channel; channelCount: ma_uint32; channelIndex: ma_uint32): ma_channel; cdecl;
  ma_channel_map_init_blank: procedure(pChannelMap: Pma_channel; channels: ma_uint32); cdecl;
  ma_channel_map_init_standard: procedure(standardChannelMap: ma_standard_channel_map; pChannelMap: Pma_channel; channelMapCap: NativeUInt; channels: ma_uint32); cdecl;
  ma_channel_map_copy: procedure(pOut: Pma_channel; const pIn: Pma_channel; channels: ma_uint32); cdecl;
  ma_channel_map_copy_or_default: procedure(pOut: Pma_channel; channelMapCapOut: NativeUInt; const pIn: Pma_channel; channels: ma_uint32); cdecl;
  ma_channel_map_is_valid: function(const pChannelMap: Pma_channel; channels: ma_uint32): ma_bool32; cdecl;
  ma_channel_map_is_equal: function(const pChannelMapA: Pma_channel; const pChannelMapB: Pma_channel; channels: ma_uint32): ma_bool32; cdecl;
  ma_channel_map_is_blank: function(const pChannelMap: Pma_channel; channels: ma_uint32): ma_bool32; cdecl;
  ma_channel_map_contains_channel_position: function(channels: ma_uint32; const pChannelMap: Pma_channel; channelPosition: ma_channel): ma_bool32; cdecl;
  ma_channel_map_find_channel_position: function(channels: ma_uint32; const pChannelMap: Pma_channel; channelPosition: ma_channel; pChannelIndex: Pma_uint32): ma_bool32; cdecl;
  ma_channel_map_to_string: function(const pChannelMap: Pma_channel; channels: ma_uint32; pBufferOut: PUTF8Char; bufferCap: NativeUInt): NativeUInt; cdecl;
  ma_channel_position_to_string: function(channel: ma_channel): PUTF8Char; cdecl;
  ma_convert_frames: function(pOut: Pointer; frameCountOut: ma_uint64; formatOut: ma_format; channelsOut: ma_uint32; sampleRateOut: ma_uint32; const pIn: Pointer; frameCountIn: ma_uint64; formatIn: ma_format; channelsIn: ma_uint32; sampleRateIn: ma_uint32): ma_uint64; cdecl;
  ma_convert_frames_ex: function(pOut: Pointer; frameCountOut: ma_uint64; const pIn: Pointer; frameCountIn: ma_uint64; const pConfig: Pma_data_converter_config): ma_uint64; cdecl;
  ma_data_source_config_init: function(): ma_data_source_config; cdecl;
  ma_data_source_init: function(const pConfig: Pma_data_source_config; pDataSource: Pma_data_source): ma_result; cdecl;
  ma_data_source_uninit: procedure(pDataSource: Pma_data_source); cdecl;
  ma_data_source_read_pcm_frames: function(pDataSource: Pma_data_source; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_data_source_seek_pcm_frames: function(pDataSource: Pma_data_source; frameCount: ma_uint64; pFramesSeeked: Pma_uint64): ma_result; cdecl;
  ma_data_source_seek_to_pcm_frame: function(pDataSource: Pma_data_source; frameIndex: ma_uint64): ma_result; cdecl;
  ma_data_source_get_data_format: function(pDataSource: Pma_data_source; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_data_source_get_cursor_in_pcm_frames: function(pDataSource: Pma_data_source; pCursor: Pma_uint64): ma_result; cdecl;
  ma_data_source_get_length_in_pcm_frames: function(pDataSource: Pma_data_source; pLength: Pma_uint64): ma_result; cdecl;
  ma_data_source_get_cursor_in_seconds: function(pDataSource: Pma_data_source; pCursor: PSingle): ma_result; cdecl;
  ma_data_source_get_length_in_seconds: function(pDataSource: Pma_data_source; pLength: PSingle): ma_result; cdecl;
  ma_data_source_set_looping: function(pDataSource: Pma_data_source; isLooping: ma_bool32): ma_result; cdecl;
  ma_data_source_is_looping: function(const pDataSource: Pma_data_source): ma_bool32; cdecl;
  ma_data_source_set_range_in_pcm_frames: function(pDataSource: Pma_data_source; rangeBegInFrames: ma_uint64; rangeEndInFrames: ma_uint64): ma_result; cdecl;
  ma_data_source_get_range_in_pcm_frames: procedure(const pDataSource: Pma_data_source; pRangeBegInFrames: Pma_uint64; pRangeEndInFrames: Pma_uint64); cdecl;
  ma_data_source_set_loop_point_in_pcm_frames: function(pDataSource: Pma_data_source; loopBegInFrames: ma_uint64; loopEndInFrames: ma_uint64): ma_result; cdecl;
  ma_data_source_get_loop_point_in_pcm_frames: procedure(const pDataSource: Pma_data_source; pLoopBegInFrames: Pma_uint64; pLoopEndInFrames: Pma_uint64); cdecl;
  ma_data_source_set_current: function(pDataSource: Pma_data_source; pCurrentDataSource: Pma_data_source): ma_result; cdecl;
  ma_data_source_get_current: function(const pDataSource: Pma_data_source): Pma_data_source; cdecl;
  ma_data_source_set_next: function(pDataSource: Pma_data_source; pNextDataSource: Pma_data_source): ma_result; cdecl;
  ma_data_source_get_next: function(const pDataSource: Pma_data_source): Pma_data_source; cdecl;
  ma_data_source_set_next_callback: function(pDataSource: Pma_data_source; onGetNext: ma_data_source_get_next_proc): ma_result; cdecl;
  ma_data_source_get_next_callback: function(const pDataSource: Pma_data_source): ma_data_source_get_next_proc; cdecl;
  ma_audio_buffer_ref_init: function(format: ma_format; channels: ma_uint32; const pData: Pointer; sizeInFrames: ma_uint64; pAudioBufferRef: Pma_audio_buffer_ref): ma_result; cdecl;
  ma_audio_buffer_ref_uninit: procedure(pAudioBufferRef: Pma_audio_buffer_ref); cdecl;
  ma_audio_buffer_ref_set_data: function(pAudioBufferRef: Pma_audio_buffer_ref; const pData: Pointer; sizeInFrames: ma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_read_pcm_frames: function(pAudioBufferRef: Pma_audio_buffer_ref; pFramesOut: Pointer; frameCount: ma_uint64; loop: ma_bool32): ma_uint64; cdecl;
  ma_audio_buffer_ref_seek_to_pcm_frame: function(pAudioBufferRef: Pma_audio_buffer_ref; frameIndex: ma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_map: function(pAudioBufferRef: Pma_audio_buffer_ref; ppFramesOut: PPointer; pFrameCount: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_unmap: function(pAudioBufferRef: Pma_audio_buffer_ref; frameCount: ma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_at_end: function(const pAudioBufferRef: Pma_audio_buffer_ref): ma_bool32; cdecl;
  ma_audio_buffer_ref_get_cursor_in_pcm_frames: function(const pAudioBufferRef: Pma_audio_buffer_ref; pCursor: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_get_length_in_pcm_frames: function(const pAudioBufferRef: Pma_audio_buffer_ref; pLength: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_ref_get_available_frames: function(const pAudioBufferRef: Pma_audio_buffer_ref; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_config_init: function(format: ma_format; channels: ma_uint32; sizeInFrames: ma_uint64; const pData: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks): ma_audio_buffer_config; cdecl;
  ma_audio_buffer_init: function(const pConfig: Pma_audio_buffer_config; pAudioBuffer: Pma_audio_buffer): ma_result; cdecl;
  ma_audio_buffer_init_copy: function(const pConfig: Pma_audio_buffer_config; pAudioBuffer: Pma_audio_buffer): ma_result; cdecl;
  ma_audio_buffer_alloc_and_init: function(const pConfig: Pma_audio_buffer_config; ppAudioBuffer: PPma_audio_buffer): ma_result; cdecl;
  ma_audio_buffer_uninit: procedure(pAudioBuffer: Pma_audio_buffer); cdecl;
  ma_audio_buffer_uninit_and_free: procedure(pAudioBuffer: Pma_audio_buffer); cdecl;
  ma_audio_buffer_read_pcm_frames: function(pAudioBuffer: Pma_audio_buffer; pFramesOut: Pointer; frameCount: ma_uint64; loop: ma_bool32): ma_uint64; cdecl;
  ma_audio_buffer_seek_to_pcm_frame: function(pAudioBuffer: Pma_audio_buffer; frameIndex: ma_uint64): ma_result; cdecl;
  ma_audio_buffer_map: function(pAudioBuffer: Pma_audio_buffer; ppFramesOut: PPointer; pFrameCount: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_unmap: function(pAudioBuffer: Pma_audio_buffer; frameCount: ma_uint64): ma_result; cdecl;
  ma_audio_buffer_at_end: function(const pAudioBuffer: Pma_audio_buffer): ma_bool32; cdecl;
  ma_audio_buffer_get_cursor_in_pcm_frames: function(const pAudioBuffer: Pma_audio_buffer; pCursor: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_get_length_in_pcm_frames: function(const pAudioBuffer: Pma_audio_buffer; pLength: Pma_uint64): ma_result; cdecl;
  ma_audio_buffer_get_available_frames: function(const pAudioBuffer: Pma_audio_buffer; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_paged_audio_buffer_data_init: function(format: ma_format; channels: ma_uint32; pData: Pma_paged_audio_buffer_data): ma_result; cdecl;
  ma_paged_audio_buffer_data_uninit: procedure(pData: Pma_paged_audio_buffer_data; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_paged_audio_buffer_data_get_head: function(pData: Pma_paged_audio_buffer_data): Pma_paged_audio_buffer_page; cdecl;
  ma_paged_audio_buffer_data_get_tail: function(pData: Pma_paged_audio_buffer_data): Pma_paged_audio_buffer_page; cdecl;
  ma_paged_audio_buffer_data_get_length_in_pcm_frames: function(pData: Pma_paged_audio_buffer_data; pLength: Pma_uint64): ma_result; cdecl;
  ma_paged_audio_buffer_data_allocate_page: function(pData: Pma_paged_audio_buffer_data; pageSizeInFrames: ma_uint64; const pInitialData: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks; ppPage: PPma_paged_audio_buffer_page): ma_result; cdecl;
  ma_paged_audio_buffer_data_free_page: function(pData: Pma_paged_audio_buffer_data; pPage: Pma_paged_audio_buffer_page; const pAllocationCallbacks: Pma_allocation_callbacks): ma_result; cdecl;
  ma_paged_audio_buffer_data_append_page: function(pData: Pma_paged_audio_buffer_data; pPage: Pma_paged_audio_buffer_page): ma_result; cdecl;
  ma_paged_audio_buffer_data_allocate_and_append_page: function(pData: Pma_paged_audio_buffer_data; pageSizeInFrames: ma_uint32; const pInitialData: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks): ma_result; cdecl;
  ma_paged_audio_buffer_config_init: function(pData: Pma_paged_audio_buffer_data): ma_paged_audio_buffer_config; cdecl;
  ma_paged_audio_buffer_init: function(const pConfig: Pma_paged_audio_buffer_config; pPagedAudioBuffer: Pma_paged_audio_buffer): ma_result; cdecl;
  ma_paged_audio_buffer_uninit: procedure(pPagedAudioBuffer: Pma_paged_audio_buffer); cdecl;
  ma_paged_audio_buffer_read_pcm_frames: function(pPagedAudioBuffer: Pma_paged_audio_buffer; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_paged_audio_buffer_seek_to_pcm_frame: function(pPagedAudioBuffer: Pma_paged_audio_buffer; frameIndex: ma_uint64): ma_result; cdecl;
  ma_paged_audio_buffer_get_cursor_in_pcm_frames: function(pPagedAudioBuffer: Pma_paged_audio_buffer; pCursor: Pma_uint64): ma_result; cdecl;
  ma_paged_audio_buffer_get_length_in_pcm_frames: function(pPagedAudioBuffer: Pma_paged_audio_buffer; pLength: Pma_uint64): ma_result; cdecl;
  ma_rb_init_ex: function(subbufferSizeInBytes: NativeUInt; subbufferCount: NativeUInt; subbufferStrideInBytes: NativeUInt; pOptionalPreallocatedBuffer: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks; pRB: Pma_rb): ma_result; cdecl;
  ma_rb_init: function(bufferSizeInBytes: NativeUInt; pOptionalPreallocatedBuffer: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks; pRB: Pma_rb): ma_result; cdecl;
  ma_rb_uninit: procedure(pRB: Pma_rb); cdecl;
  ma_rb_reset: procedure(pRB: Pma_rb); cdecl;
  ma_rb_acquire_read: function(pRB: Pma_rb; pSizeInBytes: PNativeUInt; ppBufferOut: PPointer): ma_result; cdecl;
  ma_rb_commit_read: function(pRB: Pma_rb; sizeInBytes: NativeUInt): ma_result; cdecl;
  ma_rb_acquire_write: function(pRB: Pma_rb; pSizeInBytes: PNativeUInt; ppBufferOut: PPointer): ma_result; cdecl;
  ma_rb_commit_write: function(pRB: Pma_rb; sizeInBytes: NativeUInt): ma_result; cdecl;
  ma_rb_seek_read: function(pRB: Pma_rb; offsetInBytes: NativeUInt): ma_result; cdecl;
  ma_rb_seek_write: function(pRB: Pma_rb; offsetInBytes: NativeUInt): ma_result; cdecl;
  ma_rb_pointer_distance: function(pRB: Pma_rb): ma_int32; cdecl;
  ma_rb_available_read: function(pRB: Pma_rb): ma_uint32; cdecl;
  ma_rb_available_write: function(pRB: Pma_rb): ma_uint32; cdecl;
  ma_rb_get_subbuffer_size: function(pRB: Pma_rb): NativeUInt; cdecl;
  ma_rb_get_subbuffer_stride: function(pRB: Pma_rb): NativeUInt; cdecl;
  ma_rb_get_subbuffer_offset: function(pRB: Pma_rb; subbufferIndex: NativeUInt): NativeUInt; cdecl;
  ma_rb_get_subbuffer_ptr: function(pRB: Pma_rb; subbufferIndex: NativeUInt; pBuffer: Pointer): Pointer; cdecl;
  ma_pcm_rb_init_ex: function(format: ma_format; channels: ma_uint32; subbufferSizeInFrames: ma_uint32; subbufferCount: ma_uint32; subbufferStrideInFrames: ma_uint32; pOptionalPreallocatedBuffer: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks; pRB: Pma_pcm_rb): ma_result; cdecl;
  ma_pcm_rb_init: function(format: ma_format; channels: ma_uint32; bufferSizeInFrames: ma_uint32; pOptionalPreallocatedBuffer: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks; pRB: Pma_pcm_rb): ma_result; cdecl;
  ma_pcm_rb_uninit: procedure(pRB: Pma_pcm_rb); cdecl;
  ma_pcm_rb_reset: procedure(pRB: Pma_pcm_rb); cdecl;
  ma_pcm_rb_acquire_read: function(pRB: Pma_pcm_rb; pSizeInFrames: Pma_uint32; ppBufferOut: PPointer): ma_result; cdecl;
  ma_pcm_rb_commit_read: function(pRB: Pma_pcm_rb; sizeInFrames: ma_uint32): ma_result; cdecl;
  ma_pcm_rb_acquire_write: function(pRB: Pma_pcm_rb; pSizeInFrames: Pma_uint32; ppBufferOut: PPointer): ma_result; cdecl;
  ma_pcm_rb_commit_write: function(pRB: Pma_pcm_rb; sizeInFrames: ma_uint32): ma_result; cdecl;
  ma_pcm_rb_seek_read: function(pRB: Pma_pcm_rb; offsetInFrames: ma_uint32): ma_result; cdecl;
  ma_pcm_rb_seek_write: function(pRB: Pma_pcm_rb; offsetInFrames: ma_uint32): ma_result; cdecl;
  ma_pcm_rb_pointer_distance: function(pRB: Pma_pcm_rb): ma_int32; cdecl;
  ma_pcm_rb_available_read: function(pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_available_write: function(pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_get_subbuffer_size: function(pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_get_subbuffer_stride: function(pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_get_subbuffer_offset: function(pRB: Pma_pcm_rb; subbufferIndex: ma_uint32): ma_uint32; cdecl;
  ma_pcm_rb_get_subbuffer_ptr: function(pRB: Pma_pcm_rb; subbufferIndex: ma_uint32; pBuffer: Pointer): Pointer; cdecl;
  ma_pcm_rb_get_format: function(const pRB: Pma_pcm_rb): ma_format; cdecl;
  ma_pcm_rb_get_channels: function(const pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_get_sample_rate: function(const pRB: Pma_pcm_rb): ma_uint32; cdecl;
  ma_pcm_rb_set_sample_rate: procedure(pRB: Pma_pcm_rb; sampleRate: ma_uint32); cdecl;
  ma_duplex_rb_init: function(captureFormat: ma_format; captureChannels: ma_uint32; sampleRate: ma_uint32; captureInternalSampleRate: ma_uint32; captureInternalPeriodSizeInFrames: ma_uint32; const pAllocationCallbacks: Pma_allocation_callbacks; pRB: Pma_duplex_rb): ma_result; cdecl;
  ma_duplex_rb_uninit: function(pRB: Pma_duplex_rb): ma_result; cdecl;
  ma_result_description: function(result: ma_result): PUTF8Char; cdecl;
  ma_malloc: function(sz: NativeUInt; const pAllocationCallbacks: Pma_allocation_callbacks): Pointer; cdecl;
  ma_calloc: function(sz: NativeUInt; const pAllocationCallbacks: Pma_allocation_callbacks): Pointer; cdecl;
  ma_realloc: function(p: Pointer; sz: NativeUInt; const pAllocationCallbacks: Pma_allocation_callbacks): Pointer; cdecl;
  ma_free: procedure(p: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_aligned_malloc: function(sz: NativeUInt; alignment: NativeUInt; const pAllocationCallbacks: Pma_allocation_callbacks): Pointer; cdecl;
  ma_aligned_free: procedure(p: Pointer; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_get_format_name: function(format: ma_format): PUTF8Char; cdecl;
  ma_blend_f32: procedure(pOut: PSingle; pInA: PSingle; pInB: PSingle; factor: Single; channels: ma_uint32); cdecl;
  ma_get_bytes_per_sample: function(format: ma_format): ma_uint32; cdecl;
  ma_log_level_to_string: function(logLevel: ma_uint32): PUTF8Char; cdecl;
  ma_spinlock_lock: function(pSpinlock: Pma_spinlock): ma_result; cdecl;
  ma_spinlock_lock_noyield: function(pSpinlock: Pma_spinlock): ma_result; cdecl;
  ma_spinlock_unlock: function(pSpinlock: Pma_spinlock): ma_result; cdecl;
  ma_mutex_init: function(pMutex: Pma_mutex): ma_result; cdecl;
  ma_mutex_uninit: procedure(pMutex: Pma_mutex); cdecl;
  ma_mutex_lock: procedure(pMutex: Pma_mutex); cdecl;
  ma_mutex_unlock: procedure(pMutex: Pma_mutex); cdecl;
  ma_event_init: function(pEvent: Pma_event): ma_result; cdecl;
  ma_event_uninit: procedure(pEvent: Pma_event); cdecl;
  ma_event_wait: function(pEvent: Pma_event): ma_result; cdecl;
  ma_event_signal: function(pEvent: Pma_event): ma_result; cdecl;
  ma_fence_init: function(pFence: Pma_fence): ma_result; cdecl;
  ma_fence_uninit: procedure(pFence: Pma_fence); cdecl;
  ma_fence_acquire: function(pFence: Pma_fence): ma_result; cdecl;
  ma_fence_release: function(pFence: Pma_fence): ma_result; cdecl;
  ma_fence_wait: function(pFence: Pma_fence): ma_result; cdecl;
  ma_async_notification_signal: function(pNotification: Pma_async_notification): ma_result; cdecl;
  ma_async_notification_poll_init: function(pNotificationPoll: Pma_async_notification_poll): ma_result; cdecl;
  ma_async_notification_poll_is_signalled: function(const pNotificationPoll: Pma_async_notification_poll): ma_bool32; cdecl;
  ma_async_notification_event_init: function(pNotificationEvent: Pma_async_notification_event): ma_result; cdecl;
  ma_async_notification_event_uninit: function(pNotificationEvent: Pma_async_notification_event): ma_result; cdecl;
  ma_async_notification_event_wait: function(pNotificationEvent: Pma_async_notification_event): ma_result; cdecl;
  ma_async_notification_event_signal: function(pNotificationEvent: Pma_async_notification_event): ma_result; cdecl;
  ma_slot_allocator_config_init: function(capacity: ma_uint32): ma_slot_allocator_config; cdecl;
  ma_slot_allocator_get_heap_size: function(const pConfig: Pma_slot_allocator_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_slot_allocator_init_preallocated: function(const pConfig: Pma_slot_allocator_config; pHeap: Pointer; pAllocator: Pma_slot_allocator): ma_result; cdecl;
  ma_slot_allocator_init: function(const pConfig: Pma_slot_allocator_config; const pAllocationCallbacks: Pma_allocation_callbacks; pAllocator: Pma_slot_allocator): ma_result; cdecl;
  ma_slot_allocator_uninit: procedure(pAllocator: Pma_slot_allocator; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_slot_allocator_alloc: function(pAllocator: Pma_slot_allocator; pSlot: Pma_uint64): ma_result; cdecl;
  ma_slot_allocator_free: function(pAllocator: Pma_slot_allocator; slot: ma_uint64): ma_result; cdecl;
  ma_job_init: function(code: ma_uint16): ma_job; cdecl;
  ma_job_process: function(pJob: Pma_job): ma_result; cdecl;
  ma_job_queue_config_init: function(flags: ma_uint32; capacity: ma_uint32): ma_job_queue_config; cdecl;
  ma_job_queue_get_heap_size: function(const pConfig: Pma_job_queue_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_job_queue_init_preallocated: function(const pConfig: Pma_job_queue_config; pHeap: Pointer; pQueue: Pma_job_queue): ma_result; cdecl;
  ma_job_queue_init: function(const pConfig: Pma_job_queue_config; const pAllocationCallbacks: Pma_allocation_callbacks; pQueue: Pma_job_queue): ma_result; cdecl;
  ma_job_queue_uninit: procedure(pQueue: Pma_job_queue; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_job_queue_post: function(pQueue: Pma_job_queue; const pJob: Pma_job): ma_result; cdecl;
  ma_job_queue_next: function(pQueue: Pma_job_queue; pJob: Pma_job): ma_result; cdecl;
  ma_device_job_thread_config_init: function(): ma_device_job_thread_config; cdecl;
  ma_device_job_thread_init: function(const pConfig: Pma_device_job_thread_config; const pAllocationCallbacks: Pma_allocation_callbacks; pJobThread: Pma_device_job_thread): ma_result; cdecl;
  ma_device_job_thread_uninit: procedure(pJobThread: Pma_device_job_thread; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_device_job_thread_post: function(pJobThread: Pma_device_job_thread; const pJob: Pma_job): ma_result; cdecl;
  ma_device_job_thread_next: function(pJobThread: Pma_device_job_thread; pJob: Pma_job): ma_result; cdecl;
  ma_context_config_init: function(): ma_context_config; cdecl;
  ma_context_init: function(backends: Pma_backend; backendCount: ma_uint32; const pConfig: Pma_context_config; pContext: Pma_context): ma_result; cdecl;
  ma_context_uninit: function(pContext: Pma_context): ma_result; cdecl;
  ma_context_sizeof: function(): NativeUInt; cdecl;
  ma_context_get_log: function(pContext: Pma_context): Pma_log; cdecl;
  ma_context_enumerate_devices: function(pContext: Pma_context; callback: ma_enum_devices_callback_proc; pUserData: Pointer): ma_result; cdecl;
  ma_context_get_devices: function(pContext: Pma_context; ppPlaybackDeviceInfos: PPma_device_info; pPlaybackDeviceCount: Pma_uint32; ppCaptureDeviceInfos: PPma_device_info; pCaptureDeviceCount: Pma_uint32): ma_result; cdecl;
  ma_context_get_device_info: function(pContext: Pma_context; deviceType: ma_device_type; const pDeviceID: Pma_device_id; pDeviceInfo: Pma_device_info): ma_result; cdecl;
  ma_context_is_loopback_supported: function(pContext: Pma_context): ma_bool32; cdecl;
  ma_device_config_init: function(deviceType: ma_device_type): ma_device_config; cdecl;
  ma_device_init: function(pContext: Pma_context; const pConfig: Pma_device_config; pDevice: Pma_device): ma_result; cdecl;
  ma_device_init_ex: function(backends: Pma_backend; backendCount: ma_uint32; const pContextConfig: Pma_context_config; const pConfig: Pma_device_config; pDevice: Pma_device): ma_result; cdecl;
  ma_device_uninit: procedure(pDevice: Pma_device); cdecl;
  ma_device_get_context: function(pDevice: Pma_device): Pma_context; cdecl;
  ma_device_get_log: function(pDevice: Pma_device): Pma_log; cdecl;
  ma_device_get_info: function(pDevice: Pma_device; &type: ma_device_type; pDeviceInfo: Pma_device_info): ma_result; cdecl;
  ma_device_get_name: function(pDevice: Pma_device; &type: ma_device_type; pName: PUTF8Char; nameCap: NativeUInt; pLengthNotIncludingNullTerminator: PNativeUInt): ma_result; cdecl;
  ma_device_start: function(pDevice: Pma_device): ma_result; cdecl;
  ma_device_stop: function(pDevice: Pma_device): ma_result; cdecl;
  ma_device_is_started: function(const pDevice: Pma_device): ma_bool32; cdecl;
  ma_device_get_state: function(const pDevice: Pma_device): ma_device_state; cdecl;
  ma_device_post_init: function(pDevice: Pma_device; deviceType: ma_device_type; const pPlaybackDescriptor: Pma_device_descriptor; const pCaptureDescriptor: Pma_device_descriptor): ma_result; cdecl;
  ma_device_set_master_volume: function(pDevice: Pma_device; volume: Single): ma_result; cdecl;
  ma_device_get_master_volume: function(pDevice: Pma_device; pVolume: PSingle): ma_result; cdecl;
  ma_device_set_master_volume_db: function(pDevice: Pma_device; gainDB: Single): ma_result; cdecl;
  ma_device_get_master_volume_db: function(pDevice: Pma_device; pGainDB: PSingle): ma_result; cdecl;
  ma_device_handle_backend_data_callback: function(pDevice: Pma_device; pOutput: Pointer; const pInput: Pointer; frameCount: ma_uint32): ma_result; cdecl;
  ma_calculate_buffer_size_in_frames_from_descriptor: function(const pDescriptor: Pma_device_descriptor; nativeSampleRate: ma_uint32; performanceProfile: ma_performance_profile): ma_uint32; cdecl;
  ma_get_backend_name: function(backend: ma_backend): PUTF8Char; cdecl;
  ma_get_backend_from_name: function(const pBackendName: PUTF8Char; pBackend: Pma_backend): ma_result; cdecl;
  ma_is_backend_enabled: function(backend: ma_backend): ma_bool32; cdecl;
  ma_get_enabled_backends: function(pBackends: Pma_backend; backendCap: NativeUInt; pBackendCount: PNativeUInt): ma_result; cdecl;
  ma_is_loopback_supported: function(backend: ma_backend): ma_bool32; cdecl;
  ma_calculate_buffer_size_in_milliseconds_from_frames: function(bufferSizeInFrames: ma_uint32; sampleRate: ma_uint32): ma_uint32; cdecl;
  ma_calculate_buffer_size_in_frames_from_milliseconds: function(bufferSizeInMilliseconds: ma_uint32; sampleRate: ma_uint32): ma_uint32; cdecl;
  ma_copy_pcm_frames: procedure(dst: Pointer; const src: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32); cdecl;
  ma_silence_pcm_frames: procedure(p: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32); cdecl;
  ma_offset_pcm_frames_ptr: function(p: Pointer; offsetInFrames: ma_uint64; format: ma_format; channels: ma_uint32): Pointer; cdecl;
  ma_offset_pcm_frames_const_ptr: function(const p: Pointer; offsetInFrames: ma_uint64; format: ma_format; channels: ma_uint32): Pointer; cdecl;
  ma_clip_samples_u8: procedure(pDst: Pma_uint8; const pSrc: Pma_int16; count: ma_uint64); cdecl;
  ma_clip_samples_s16: procedure(pDst: Pma_int16; const pSrc: Pma_int32; count: ma_uint64); cdecl;
  ma_clip_samples_s24: procedure(pDst: Pma_uint8; const pSrc: Pma_int64; count: ma_uint64); cdecl;
  ma_clip_samples_s32: procedure(pDst: Pma_int32; const pSrc: Pma_int64; count: ma_uint64); cdecl;
  ma_clip_samples_f32: procedure(pDst: PSingle; const pSrc: PSingle; count: ma_uint64); cdecl;
  ma_clip_pcm_frames: procedure(pDst: Pointer; const pSrc: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32); cdecl;
  ma_copy_and_apply_volume_factor_u8: procedure(pSamplesOut: Pma_uint8; const pSamplesIn: Pma_uint8; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_s16: procedure(pSamplesOut: Pma_int16; const pSamplesIn: Pma_int16; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_s24: procedure(pSamplesOut: Pointer; const pSamplesIn: Pointer; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_s32: procedure(pSamplesOut: Pma_int32; const pSamplesIn: Pma_int32; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_f32: procedure(pSamplesOut: PSingle; const pSamplesIn: PSingle; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_apply_volume_factor_u8: procedure(pSamples: Pma_uint8; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_apply_volume_factor_s16: procedure(pSamples: Pma_int16; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_apply_volume_factor_s24: procedure(pSamples: Pointer; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_apply_volume_factor_s32: procedure(pSamples: Pma_int32; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_apply_volume_factor_f32: procedure(pSamples: PSingle; sampleCount: ma_uint64; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames_u8: procedure(pFramesOut: Pma_uint8; const pFramesIn: Pma_uint8; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames_s16: procedure(pFramesOut: Pma_int16; const pFramesIn: Pma_int16; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames_s24: procedure(pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames_s32: procedure(pFramesOut: Pma_int32; const pFramesIn: Pma_int32; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames_f32: procedure(pFramesOut: PSingle; const pFramesIn: PSingle; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_pcm_frames: procedure(pFramesOut: Pointer; const pFramesIn: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames_u8: procedure(pFrames: Pma_uint8; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames_s16: procedure(pFrames: Pma_int16; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames_s24: procedure(pFrames: Pointer; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames_s32: procedure(pFrames: Pma_int32; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames_f32: procedure(pFrames: PSingle; frameCount: ma_uint64; channels: ma_uint32; factor: Single); cdecl;
  ma_apply_volume_factor_pcm_frames: procedure(pFrames: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32; factor: Single); cdecl;
  ma_copy_and_apply_volume_factor_per_channel_f32: procedure(pFramesOut: PSingle; const pFramesIn: PSingle; frameCount: ma_uint64; channels: ma_uint32; pChannelGains: PSingle); cdecl;
  ma_copy_and_apply_volume_and_clip_samples_u8: procedure(pDst: Pma_uint8; const pSrc: Pma_int16; count: ma_uint64; volume: Single); cdecl;
  ma_copy_and_apply_volume_and_clip_samples_s16: procedure(pDst: Pma_int16; const pSrc: Pma_int32; count: ma_uint64; volume: Single); cdecl;
  ma_copy_and_apply_volume_and_clip_samples_s24: procedure(pDst: Pma_uint8; const pSrc: Pma_int64; count: ma_uint64; volume: Single); cdecl;
  ma_copy_and_apply_volume_and_clip_samples_s32: procedure(pDst: Pma_int32; const pSrc: Pma_int64; count: ma_uint64; volume: Single); cdecl;
  ma_copy_and_apply_volume_and_clip_samples_f32: procedure(pDst: PSingle; const pSrc: PSingle; count: ma_uint64; volume: Single); cdecl;
  ma_copy_and_apply_volume_and_clip_pcm_frames: procedure(pDst: Pointer; const pSrc: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32; volume: Single); cdecl;
  ma_volume_linear_to_db: function(factor: Single): Single; cdecl;
  ma_volume_db_to_linear: function(gain: Single): Single; cdecl;
  ma_mix_pcm_frames_f32: function(pDst: PSingle; const pSrc: PSingle; frameCount: ma_uint64; channels: ma_uint32; volume: Single): ma_result; cdecl;
  ma_vfs_open: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; openMode: ma_uint32; pFile: Pma_vfs_file): ma_result; cdecl;
  ma_vfs_open_w: function(pVFS: Pma_vfs; const pFilePath: PWideChar; openMode: ma_uint32; pFile: Pma_vfs_file): ma_result; cdecl;
  ma_vfs_close: function(pVFS: Pma_vfs; &file: ma_vfs_file): ma_result; cdecl;
  ma_vfs_read: function(pVFS: Pma_vfs; &file: ma_vfs_file; pDst: Pointer; sizeInBytes: NativeUInt; pBytesRead: PNativeUInt): ma_result; cdecl;
  ma_vfs_write: function(pVFS: Pma_vfs; &file: ma_vfs_file; const pSrc: Pointer; sizeInBytes: NativeUInt; pBytesWritten: PNativeUInt): ma_result; cdecl;
  ma_vfs_seek: function(pVFS: Pma_vfs; &file: ma_vfs_file; offset: ma_int64; origin: ma_seek_origin): ma_result; cdecl;
  ma_vfs_tell: function(pVFS: Pma_vfs; &file: ma_vfs_file; pCursor: Pma_int64): ma_result; cdecl;
  ma_vfs_info: function(pVFS: Pma_vfs; &file: ma_vfs_file; pInfo: Pma_file_info): ma_result; cdecl;
  ma_vfs_open_and_read_file: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; ppData: PPointer; pSize: PNativeUInt; const pAllocationCallbacks: Pma_allocation_callbacks): ma_result; cdecl;
  ma_default_vfs_init: function(pVFS: Pma_default_vfs; const pAllocationCallbacks: Pma_allocation_callbacks): ma_result; cdecl;
  ma_decoding_backend_config_init: function(preferredFormat: ma_format; seekPointCount: ma_uint32): ma_decoding_backend_config; cdecl;
  ma_decoder_config_init: function(outputFormat: ma_format; outputChannels: ma_uint32; outputSampleRate: ma_uint32): ma_decoder_config; cdecl;
  ma_decoder_config_init_default: function(): ma_decoder_config; cdecl;
  ma_decoder_init: function(onRead: ma_decoder_read_proc; onSeek: ma_decoder_seek_proc; pUserData: Pointer; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_init_memory: function(const pData: Pointer; dataSize: NativeUInt; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_init_vfs: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_init_vfs_w: function(pVFS: Pma_vfs; const pFilePath: PWideChar; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_init_file: function(const pFilePath: PUTF8Char; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_init_file_w: function(const pFilePath: PWideChar; const pConfig: Pma_decoder_config; pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_uninit: function(pDecoder: Pma_decoder): ma_result; cdecl;
  ma_decoder_read_pcm_frames: function(pDecoder: Pma_decoder; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_decoder_seek_to_pcm_frame: function(pDecoder: Pma_decoder; frameIndex: ma_uint64): ma_result; cdecl;
  ma_decoder_get_data_format: function(pDecoder: Pma_decoder; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_decoder_get_cursor_in_pcm_frames: function(pDecoder: Pma_decoder; pCursor: Pma_uint64): ma_result; cdecl;
  ma_decoder_get_length_in_pcm_frames: function(pDecoder: Pma_decoder; pLength: Pma_uint64): ma_result; cdecl;
  ma_decoder_get_available_frames: function(pDecoder: Pma_decoder; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_decode_from_vfs: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; pConfig: Pma_decoder_config; pFrameCountOut: Pma_uint64; ppPCMFramesOut: PPointer): ma_result; cdecl;
  ma_decode_file: function(const pFilePath: PUTF8Char; pConfig: Pma_decoder_config; pFrameCountOut: Pma_uint64; ppPCMFramesOut: PPointer): ma_result; cdecl;
  ma_decode_memory: function(const pData: Pointer; dataSize: NativeUInt; pConfig: Pma_decoder_config; pFrameCountOut: Pma_uint64; ppPCMFramesOut: PPointer): ma_result; cdecl;
  ma_encoder_config_init: function(encodingFormat: ma_encoding_format; format: ma_format; channels: ma_uint32; sampleRate: ma_uint32): ma_encoder_config; cdecl;
  ma_encoder_init: function(onWrite: ma_encoder_write_proc; onSeek: ma_encoder_seek_proc; pUserData: Pointer; const pConfig: Pma_encoder_config; pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_init_vfs: function(pVFS: Pma_vfs; const pFilePath: PUTF8Char; const pConfig: Pma_encoder_config; pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_init_vfs_w: function(pVFS: Pma_vfs; const pFilePath: PWideChar; const pConfig: Pma_encoder_config; pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_init_file: function(const pFilePath: PUTF8Char; const pConfig: Pma_encoder_config; pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_init_file_w: function(const pFilePath: PWideChar; const pConfig: Pma_encoder_config; pEncoder: Pma_encoder): ma_result; cdecl;
  ma_encoder_uninit: procedure(pEncoder: Pma_encoder); cdecl;
  ma_encoder_write_pcm_frames: function(pEncoder: Pma_encoder; const pFramesIn: Pointer; frameCount: ma_uint64; pFramesWritten: Pma_uint64): ma_result; cdecl;
  ma_waveform_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; &type: ma_waveform_type; amplitude: Double; frequency: Double): ma_waveform_config; cdecl;
  ma_waveform_init: function(const pConfig: Pma_waveform_config; pWaveform: Pma_waveform): ma_result; cdecl;
  ma_waveform_uninit: procedure(pWaveform: Pma_waveform); cdecl;
  ma_waveform_read_pcm_frames: function(pWaveform: Pma_waveform; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_waveform_seek_to_pcm_frame: function(pWaveform: Pma_waveform; frameIndex: ma_uint64): ma_result; cdecl;
  ma_waveform_set_amplitude: function(pWaveform: Pma_waveform; amplitude: Double): ma_result; cdecl;
  ma_waveform_set_frequency: function(pWaveform: Pma_waveform; frequency: Double): ma_result; cdecl;
  ma_waveform_set_type: function(pWaveform: Pma_waveform; &type: ma_waveform_type): ma_result; cdecl;
  ma_waveform_set_sample_rate: function(pWaveform: Pma_waveform; sampleRate: ma_uint32): ma_result; cdecl;
  ma_pulsewave_config_init: function(format: ma_format; channels: ma_uint32; sampleRate: ma_uint32; dutyCycle: Double; amplitude: Double; frequency: Double): ma_pulsewave_config; cdecl;
  ma_pulsewave_init: function(const pConfig: Pma_pulsewave_config; pWaveform: Pma_pulsewave): ma_result; cdecl;
  ma_pulsewave_uninit: procedure(pWaveform: Pma_pulsewave); cdecl;
  ma_pulsewave_read_pcm_frames: function(pWaveform: Pma_pulsewave; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_pulsewave_seek_to_pcm_frame: function(pWaveform: Pma_pulsewave; frameIndex: ma_uint64): ma_result; cdecl;
  ma_pulsewave_set_amplitude: function(pWaveform: Pma_pulsewave; amplitude: Double): ma_result; cdecl;
  ma_pulsewave_set_frequency: function(pWaveform: Pma_pulsewave; frequency: Double): ma_result; cdecl;
  ma_pulsewave_set_sample_rate: function(pWaveform: Pma_pulsewave; sampleRate: ma_uint32): ma_result; cdecl;
  ma_pulsewave_set_duty_cycle: function(pWaveform: Pma_pulsewave; dutyCycle: Double): ma_result; cdecl;
  ma_noise_config_init: function(format: ma_format; channels: ma_uint32; &type: ma_noise_type; seed: ma_int32; amplitude: Double): ma_noise_config; cdecl;
  ma_noise_get_heap_size: function(const pConfig: Pma_noise_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_noise_init_preallocated: function(const pConfig: Pma_noise_config; pHeap: Pointer; pNoise: Pma_noise): ma_result; cdecl;
  ma_noise_init: function(const pConfig: Pma_noise_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNoise: Pma_noise): ma_result; cdecl;
  ma_noise_uninit: procedure(pNoise: Pma_noise; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_noise_read_pcm_frames: function(pNoise: Pma_noise; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_noise_set_amplitude: function(pNoise: Pma_noise; amplitude: Double): ma_result; cdecl;
  ma_noise_set_seed: function(pNoise: Pma_noise; seed: ma_int32): ma_result; cdecl;
  ma_noise_set_type: function(pNoise: Pma_noise; &type: ma_noise_type): ma_result; cdecl;
  ma_resource_manager_pipeline_notifications_init: function(): ma_resource_manager_pipeline_notifications; cdecl;
  ma_resource_manager_data_source_config_init: function(): ma_resource_manager_data_source_config; cdecl;
  ma_resource_manager_config_init: function(): ma_resource_manager_config; cdecl;
  ma_resource_manager_init: function(const pConfig: Pma_resource_manager_config; pResourceManager: Pma_resource_manager): ma_result; cdecl;
  ma_resource_manager_uninit: procedure(pResourceManager: Pma_resource_manager); cdecl;
  ma_resource_manager_get_log: function(pResourceManager: Pma_resource_manager): Pma_log; cdecl;
  ma_resource_manager_register_file: function(pResourceManager: Pma_resource_manager; const pFilePath: PUTF8Char; flags: ma_uint32): ma_result; cdecl;
  ma_resource_manager_register_file_w: function(pResourceManager: Pma_resource_manager; const pFilePath: PWideChar; flags: ma_uint32): ma_result; cdecl;
  ma_resource_manager_register_decoded_data: function(pResourceManager: Pma_resource_manager; const pName: PUTF8Char; const pData: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32; sampleRate: ma_uint32): ma_result; cdecl;
  ma_resource_manager_register_decoded_data_w: function(pResourceManager: Pma_resource_manager; const pName: PWideChar; const pData: Pointer; frameCount: ma_uint64; format: ma_format; channels: ma_uint32; sampleRate: ma_uint32): ma_result; cdecl;
  ma_resource_manager_register_encoded_data: function(pResourceManager: Pma_resource_manager; const pName: PUTF8Char; const pData: Pointer; sizeInBytes: NativeUInt): ma_result; cdecl;
  ma_resource_manager_register_encoded_data_w: function(pResourceManager: Pma_resource_manager; const pName: PWideChar; const pData: Pointer; sizeInBytes: NativeUInt): ma_result; cdecl;
  ma_resource_manager_unregister_file: function(pResourceManager: Pma_resource_manager; const pFilePath: PUTF8Char): ma_result; cdecl;
  ma_resource_manager_unregister_file_w: function(pResourceManager: Pma_resource_manager; const pFilePath: PWideChar): ma_result; cdecl;
  ma_resource_manager_unregister_data: function(pResourceManager: Pma_resource_manager; const pName: PUTF8Char): ma_result; cdecl;
  ma_resource_manager_unregister_data_w: function(pResourceManager: Pma_resource_manager; const pName: PWideChar): ma_result; cdecl;
  ma_resource_manager_data_buffer_init_ex: function(pResourceManager: Pma_resource_manager; const pConfig: Pma_resource_manager_data_source_config; pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_init: function(pResourceManager: Pma_resource_manager; const pFilePath: PUTF8Char; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_init_w: function(pResourceManager: Pma_resource_manager; const pFilePath: PWideChar; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_init_copy: function(pResourceManager: Pma_resource_manager; const pExistingDataBuffer: Pma_resource_manager_data_buffer; pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_uninit: function(pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_read_pcm_frames: function(pDataBuffer: Pma_resource_manager_data_buffer; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_buffer_seek_to_pcm_frame: function(pDataBuffer: Pma_resource_manager_data_buffer; frameIndex: ma_uint64): ma_result; cdecl;
  ma_resource_manager_data_buffer_get_data_format: function(pDataBuffer: Pma_resource_manager_data_buffer; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_resource_manager_data_buffer_get_cursor_in_pcm_frames: function(pDataBuffer: Pma_resource_manager_data_buffer; pCursor: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_buffer_get_length_in_pcm_frames: function(pDataBuffer: Pma_resource_manager_data_buffer; pLength: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_buffer_result: function(const pDataBuffer: Pma_resource_manager_data_buffer): ma_result; cdecl;
  ma_resource_manager_data_buffer_set_looping: function(pDataBuffer: Pma_resource_manager_data_buffer; isLooping: ma_bool32): ma_result; cdecl;
  ma_resource_manager_data_buffer_is_looping: function(const pDataBuffer: Pma_resource_manager_data_buffer): ma_bool32; cdecl;
  ma_resource_manager_data_buffer_get_available_frames: function(pDataBuffer: Pma_resource_manager_data_buffer; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_stream_init_ex: function(pResourceManager: Pma_resource_manager; const pConfig: Pma_resource_manager_data_source_config; pDataStream: Pma_resource_manager_data_stream): ma_result; cdecl;
  ma_resource_manager_data_stream_init: function(pResourceManager: Pma_resource_manager; const pFilePath: PUTF8Char; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataStream: Pma_resource_manager_data_stream): ma_result; cdecl;
  ma_resource_manager_data_stream_init_w: function(pResourceManager: Pma_resource_manager; const pFilePath: PWideChar; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataStream: Pma_resource_manager_data_stream): ma_result; cdecl;
  ma_resource_manager_data_stream_uninit: function(pDataStream: Pma_resource_manager_data_stream): ma_result; cdecl;
  ma_resource_manager_data_stream_read_pcm_frames: function(pDataStream: Pma_resource_manager_data_stream; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_stream_seek_to_pcm_frame: function(pDataStream: Pma_resource_manager_data_stream; frameIndex: ma_uint64): ma_result; cdecl;
  ma_resource_manager_data_stream_get_data_format: function(pDataStream: Pma_resource_manager_data_stream; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_resource_manager_data_stream_get_cursor_in_pcm_frames: function(pDataStream: Pma_resource_manager_data_stream; pCursor: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_stream_get_length_in_pcm_frames: function(pDataStream: Pma_resource_manager_data_stream; pLength: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_stream_result: function(const pDataStream: Pma_resource_manager_data_stream): ma_result; cdecl;
  ma_resource_manager_data_stream_set_looping: function(pDataStream: Pma_resource_manager_data_stream; isLooping: ma_bool32): ma_result; cdecl;
  ma_resource_manager_data_stream_is_looping: function(const pDataStream: Pma_resource_manager_data_stream): ma_bool32; cdecl;
  ma_resource_manager_data_stream_get_available_frames: function(pDataStream: Pma_resource_manager_data_stream; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_source_init_ex: function(pResourceManager: Pma_resource_manager; const pConfig: Pma_resource_manager_data_source_config; pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_init: function(pResourceManager: Pma_resource_manager; const pName: PUTF8Char; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_init_w: function(pResourceManager: Pma_resource_manager; const pName: PWideChar; flags: ma_uint32; const pNotifications: Pma_resource_manager_pipeline_notifications; pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_init_copy: function(pResourceManager: Pma_resource_manager; const pExistingDataSource: Pma_resource_manager_data_source; pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_uninit: function(pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_read_pcm_frames: function(pDataSource: Pma_resource_manager_data_source; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_source_seek_to_pcm_frame: function(pDataSource: Pma_resource_manager_data_source; frameIndex: ma_uint64): ma_result; cdecl;
  ma_resource_manager_data_source_get_data_format: function(pDataSource: Pma_resource_manager_data_source; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_resource_manager_data_source_get_cursor_in_pcm_frames: function(pDataSource: Pma_resource_manager_data_source; pCursor: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_source_get_length_in_pcm_frames: function(pDataSource: Pma_resource_manager_data_source; pLength: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_data_source_result: function(const pDataSource: Pma_resource_manager_data_source): ma_result; cdecl;
  ma_resource_manager_data_source_set_looping: function(pDataSource: Pma_resource_manager_data_source; isLooping: ma_bool32): ma_result; cdecl;
  ma_resource_manager_data_source_is_looping: function(const pDataSource: Pma_resource_manager_data_source): ma_bool32; cdecl;
  ma_resource_manager_data_source_get_available_frames: function(pDataSource: Pma_resource_manager_data_source; pAvailableFrames: Pma_uint64): ma_result; cdecl;
  ma_resource_manager_post_job: function(pResourceManager: Pma_resource_manager; const pJob: Pma_job): ma_result; cdecl;
  ma_resource_manager_post_job_quit: function(pResourceManager: Pma_resource_manager): ma_result; cdecl;
  ma_resource_manager_next_job: function(pResourceManager: Pma_resource_manager; pJob: Pma_job): ma_result; cdecl;
  ma_resource_manager_process_job: function(pResourceManager: Pma_resource_manager; pJob: Pma_job): ma_result; cdecl;
  ma_resource_manager_process_next_job: function(pResourceManager: Pma_resource_manager): ma_result; cdecl;
  ma_node_config_init: function(): ma_node_config; cdecl;
  ma_node_get_heap_size: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_node_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_node_init_preallocated: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_node_config; pHeap: Pointer; pNode: Pma_node): ma_result; cdecl;
  ma_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_node): ma_result; cdecl;
  ma_node_uninit: procedure(pNode: Pma_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_node_get_node_graph: function(const pNode: Pma_node): Pma_node_graph; cdecl;
  ma_node_get_input_bus_count: function(const pNode: Pma_node): ma_uint32; cdecl;
  ma_node_get_output_bus_count: function(const pNode: Pma_node): ma_uint32; cdecl;
  ma_node_get_input_channels: function(const pNode: Pma_node; inputBusIndex: ma_uint32): ma_uint32; cdecl;
  ma_node_get_output_channels: function(const pNode: Pma_node; outputBusIndex: ma_uint32): ma_uint32; cdecl;
  ma_node_attach_output_bus: function(pNode: Pma_node; outputBusIndex: ma_uint32; pOtherNode: Pma_node; otherNodeInputBusIndex: ma_uint32): ma_result; cdecl;
  ma_node_detach_output_bus: function(pNode: Pma_node; outputBusIndex: ma_uint32): ma_result; cdecl;
  ma_node_detach_all_output_buses: function(pNode: Pma_node): ma_result; cdecl;
  ma_node_set_output_bus_volume: function(pNode: Pma_node; outputBusIndex: ma_uint32; volume: Single): ma_result; cdecl;
  ma_node_get_output_bus_volume: function(const pNode: Pma_node; outputBusIndex: ma_uint32): Single; cdecl;
  ma_node_set_state: function(pNode: Pma_node; state: ma_node_state): ma_result; cdecl;
  ma_node_get_state: function(const pNode: Pma_node): ma_node_state; cdecl;
  ma_node_set_state_time: function(pNode: Pma_node; state: ma_node_state; globalTime: ma_uint64): ma_result; cdecl;
  ma_node_get_state_time: function(const pNode: Pma_node; state: ma_node_state): ma_uint64; cdecl;
  ma_node_get_state_by_time: function(const pNode: Pma_node; globalTime: ma_uint64): ma_node_state; cdecl;
  ma_node_get_state_by_time_range: function(const pNode: Pma_node; globalTimeBeg: ma_uint64; globalTimeEnd: ma_uint64): ma_node_state; cdecl;
  ma_node_get_time: function(const pNode: Pma_node): ma_uint64; cdecl;
  ma_node_set_time: function(pNode: Pma_node; localTime: ma_uint64): ma_result; cdecl;
  ma_node_graph_config_init: function(channels: ma_uint32): ma_node_graph_config; cdecl;
  ma_node_graph_init: function(const pConfig: Pma_node_graph_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNodeGraph: Pma_node_graph): ma_result; cdecl;
  ma_node_graph_uninit: procedure(pNodeGraph: Pma_node_graph; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_node_graph_get_endpoint: function(pNodeGraph: Pma_node_graph): Pma_node; cdecl;
  ma_node_graph_read_pcm_frames: function(pNodeGraph: Pma_node_graph; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_node_graph_get_channels: function(const pNodeGraph: Pma_node_graph): ma_uint32; cdecl;
  ma_node_graph_get_time: function(const pNodeGraph: Pma_node_graph): ma_uint64; cdecl;
  ma_node_graph_set_time: function(pNodeGraph: Pma_node_graph; globalTime: ma_uint64): ma_result; cdecl;
  ma_data_source_node_config_init: function(pDataSource: Pma_data_source): ma_data_source_node_config; cdecl;
  ma_data_source_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_data_source_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pDataSourceNode: Pma_data_source_node): ma_result; cdecl;
  ma_data_source_node_uninit: procedure(pDataSourceNode: Pma_data_source_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_data_source_node_set_looping: function(pDataSourceNode: Pma_data_source_node; isLooping: ma_bool32): ma_result; cdecl;
  ma_data_source_node_is_looping: function(pDataSourceNode: Pma_data_source_node): ma_bool32; cdecl;
  ma_splitter_node_config_init: function(channels: ma_uint32): ma_splitter_node_config; cdecl;
  ma_splitter_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_splitter_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pSplitterNode: Pma_splitter_node): ma_result; cdecl;
  ma_splitter_node_uninit: procedure(pSplitterNode: Pma_splitter_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_biquad_node_config_init: function(channels: ma_uint32; b0: Single; b1: Single; b2: Single; a0: Single; a1: Single; a2: Single): ma_biquad_node_config; cdecl;
  ma_biquad_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_biquad_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_biquad_node): ma_result; cdecl;
  ma_biquad_node_reinit: function(const pConfig: Pma_biquad_config; pNode: Pma_biquad_node): ma_result; cdecl;
  ma_biquad_node_uninit: procedure(pNode: Pma_biquad_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_lpf_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_lpf_node_config; cdecl;
  ma_lpf_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_lpf_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_lpf_node): ma_result; cdecl;
  ma_lpf_node_reinit: function(const pConfig: Pma_lpf_config; pNode: Pma_lpf_node): ma_result; cdecl;
  ma_lpf_node_uninit: procedure(pNode: Pma_lpf_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hpf_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_hpf_node_config; cdecl;
  ma_hpf_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_hpf_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_hpf_node): ma_result; cdecl;
  ma_hpf_node_reinit: function(const pConfig: Pma_hpf_config; pNode: Pma_hpf_node): ma_result; cdecl;
  ma_hpf_node_uninit: procedure(pNode: Pma_hpf_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_bpf_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; cutoffFrequency: Double; order: ma_uint32): ma_bpf_node_config; cdecl;
  ma_bpf_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_bpf_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_bpf_node): ma_result; cdecl;
  ma_bpf_node_reinit: function(const pConfig: Pma_bpf_config; pNode: Pma_bpf_node): ma_result; cdecl;
  ma_bpf_node_uninit: procedure(pNode: Pma_bpf_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_notch_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; q: Double; frequency: Double): ma_notch_node_config; cdecl;
  ma_notch_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_notch_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_notch_node): ma_result; cdecl;
  ma_notch_node_reinit: function(const pConfig: Pma_notch_config; pNode: Pma_notch_node): ma_result; cdecl;
  ma_notch_node_uninit: procedure(pNode: Pma_notch_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_peak_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; q: Double; frequency: Double): ma_peak_node_config; cdecl;
  ma_peak_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_peak_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_peak_node): ma_result; cdecl;
  ma_peak_node_reinit: function(const pConfig: Pma_peak_config; pNode: Pma_peak_node): ma_result; cdecl;
  ma_peak_node_uninit: procedure(pNode: Pma_peak_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_loshelf_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; q: Double; frequency: Double): ma_loshelf_node_config; cdecl;
  ma_loshelf_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_loshelf_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_loshelf_node): ma_result; cdecl;
  ma_loshelf_node_reinit: function(const pConfig: Pma_loshelf_config; pNode: Pma_loshelf_node): ma_result; cdecl;
  ma_loshelf_node_uninit: procedure(pNode: Pma_loshelf_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_hishelf_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; gainDB: Double; q: Double; frequency: Double): ma_hishelf_node_config; cdecl;
  ma_hishelf_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_hishelf_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pNode: Pma_hishelf_node): ma_result; cdecl;
  ma_hishelf_node_reinit: function(const pConfig: Pma_hishelf_config; pNode: Pma_hishelf_node): ma_result; cdecl;
  ma_hishelf_node_uninit: procedure(pNode: Pma_hishelf_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_delay_node_config_init: function(channels: ma_uint32; sampleRate: ma_uint32; delayInFrames: ma_uint32; decay: Single): ma_delay_node_config; cdecl;
  ma_delay_node_init: function(pNodeGraph: Pma_node_graph; const pConfig: Pma_delay_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pDelayNode: Pma_delay_node): ma_result; cdecl;
  ma_delay_node_uninit: procedure(pDelayNode: Pma_delay_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_delay_node_set_wet: procedure(pDelayNode: Pma_delay_node; value: Single); cdecl;
  ma_delay_node_get_wet: function(const pDelayNode: Pma_delay_node): Single; cdecl;
  ma_delay_node_set_dry: procedure(pDelayNode: Pma_delay_node; value: Single); cdecl;
  ma_delay_node_get_dry: function(const pDelayNode: Pma_delay_node): Single; cdecl;
  ma_delay_node_set_decay: procedure(pDelayNode: Pma_delay_node; value: Single); cdecl;
  ma_delay_node_get_decay: function(const pDelayNode: Pma_delay_node): Single; cdecl;
  ma_engine_node_config_init: function(pEngine: Pma_engine; &type: ma_engine_node_type; flags: ma_uint32): ma_engine_node_config; cdecl;
  ma_engine_node_get_heap_size: function(const pConfig: Pma_engine_node_config; pHeapSizeInBytes: PNativeUInt): ma_result; cdecl;
  ma_engine_node_init_preallocated: function(const pConfig: Pma_engine_node_config; pHeap: Pointer; pEngineNode: Pma_engine_node): ma_result; cdecl;
  ma_engine_node_init: function(const pConfig: Pma_engine_node_config; const pAllocationCallbacks: Pma_allocation_callbacks; pEngineNode: Pma_engine_node): ma_result; cdecl;
  ma_engine_node_uninit: procedure(pEngineNode: Pma_engine_node; const pAllocationCallbacks: Pma_allocation_callbacks); cdecl;
  ma_sound_config_init: function(): ma_sound_config; cdecl;
  ma_sound_config_init_2: function(pEngine: Pma_engine): ma_sound_config; cdecl;
  ma_sound_group_config_init: function(): ma_sound_group_config; cdecl;
  ma_sound_group_config_init_2: function(pEngine: Pma_engine): ma_sound_group_config; cdecl;
  ma_engine_config_init: function(): ma_engine_config; cdecl;
  ma_engine_init: function(const pConfig: Pma_engine_config; pEngine: Pma_engine): ma_result; cdecl;
  ma_engine_uninit: procedure(pEngine: Pma_engine); cdecl;
  ma_engine_read_pcm_frames: function(pEngine: Pma_engine; pFramesOut: Pointer; frameCount: ma_uint64; pFramesRead: Pma_uint64): ma_result; cdecl;
  ma_engine_get_node_graph: function(pEngine: Pma_engine): Pma_node_graph; cdecl;
  ma_engine_get_resource_manager: function(pEngine: Pma_engine): Pma_resource_manager; cdecl;
  ma_engine_get_device: function(pEngine: Pma_engine): Pma_device; cdecl;
  ma_engine_get_log: function(pEngine: Pma_engine): Pma_log; cdecl;
  ma_engine_get_endpoint: function(pEngine: Pma_engine): Pma_node; cdecl;
  ma_engine_get_time_in_pcm_frames: function(const pEngine: Pma_engine): ma_uint64; cdecl;
  ma_engine_get_time_in_milliseconds: function(const pEngine: Pma_engine): ma_uint64; cdecl;
  ma_engine_set_time_in_pcm_frames: function(pEngine: Pma_engine; globalTime: ma_uint64): ma_result; cdecl;
  ma_engine_set_time_in_milliseconds: function(pEngine: Pma_engine; globalTime: ma_uint64): ma_result; cdecl;
  ma_engine_get_time: function(const pEngine: Pma_engine): ma_uint64; cdecl;
  ma_engine_set_time: function(pEngine: Pma_engine; globalTime: ma_uint64): ma_result; cdecl;
  ma_engine_get_channels: function(const pEngine: Pma_engine): ma_uint32; cdecl;
  ma_engine_get_sample_rate: function(const pEngine: Pma_engine): ma_uint32; cdecl;
  ma_engine_start: function(pEngine: Pma_engine): ma_result; cdecl;
  ma_engine_stop: function(pEngine: Pma_engine): ma_result; cdecl;
  ma_engine_set_volume: function(pEngine: Pma_engine; volume: Single): ma_result; cdecl;
  ma_engine_get_volume: function(pEngine: Pma_engine): Single; cdecl;
  ma_engine_set_gain_db: function(pEngine: Pma_engine; gainDB: Single): ma_result; cdecl;
  ma_engine_get_gain_db: function(pEngine: Pma_engine): Single; cdecl;
  ma_engine_get_listener_count: function(const pEngine: Pma_engine): ma_uint32; cdecl;
  ma_engine_find_closest_listener: function(const pEngine: Pma_engine; absolutePosX: Single; absolutePosY: Single; absolutePosZ: Single): ma_uint32; cdecl;
  ma_engine_listener_set_position: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; x: Single; y: Single; z: Single); cdecl;
  ma_engine_listener_get_position: function(const pEngine: Pma_engine; listenerIndex: ma_uint32): ma_vec3f; cdecl;
  ma_engine_listener_set_direction: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; x: Single; y: Single; z: Single); cdecl;
  ma_engine_listener_get_direction: function(const pEngine: Pma_engine; listenerIndex: ma_uint32): ma_vec3f; cdecl;
  ma_engine_listener_set_velocity: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; x: Single; y: Single; z: Single); cdecl;
  ma_engine_listener_get_velocity: function(const pEngine: Pma_engine; listenerIndex: ma_uint32): ma_vec3f; cdecl;
  ma_engine_listener_set_cone: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; innerAngleInRadians: Single; outerAngleInRadians: Single; outerGain: Single); cdecl;
  ma_engine_listener_get_cone: procedure(const pEngine: Pma_engine; listenerIndex: ma_uint32; pInnerAngleInRadians: PSingle; pOuterAngleInRadians: PSingle; pOuterGain: PSingle); cdecl;
  ma_engine_listener_set_world_up: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; x: Single; y: Single; z: Single); cdecl;
  ma_engine_listener_get_world_up: function(const pEngine: Pma_engine; listenerIndex: ma_uint32): ma_vec3f; cdecl;
  ma_engine_listener_set_enabled: procedure(pEngine: Pma_engine; listenerIndex: ma_uint32; isEnabled: ma_bool32); cdecl;
  ma_engine_listener_is_enabled: function(const pEngine: Pma_engine; listenerIndex: ma_uint32): ma_bool32; cdecl;
  ma_engine_play_sound_ex: function(pEngine: Pma_engine; const pFilePath: PUTF8Char; pNode: Pma_node; nodeInputBusIndex: ma_uint32): ma_result; cdecl;
  ma_engine_play_sound: function(pEngine: Pma_engine; const pFilePath: PUTF8Char; pGroup: Pma_sound_group): ma_result; cdecl;
  ma_sound_init_from_file: function(pEngine: Pma_engine; const pFilePath: PUTF8Char; flags: ma_uint32; pGroup: Pma_sound_group; pDoneFence: Pma_fence; pSound: Pma_sound): ma_result; cdecl;
  ma_sound_init_from_file_w: function(pEngine: Pma_engine; const pFilePath: PWideChar; flags: ma_uint32; pGroup: Pma_sound_group; pDoneFence: Pma_fence; pSound: Pma_sound): ma_result; cdecl;
  ma_sound_init_copy: function(pEngine: Pma_engine; const pExistingSound: Pma_sound; flags: ma_uint32; pGroup: Pma_sound_group; pSound: Pma_sound): ma_result; cdecl;
  ma_sound_init_from_data_source: function(pEngine: Pma_engine; pDataSource: Pma_data_source; flags: ma_uint32; pGroup: Pma_sound_group; pSound: Pma_sound): ma_result; cdecl;
  ma_sound_init_ex: function(pEngine: Pma_engine; const pConfig: Pma_sound_config; pSound: Pma_sound): ma_result; cdecl;
  ma_sound_uninit: procedure(pSound: Pma_sound); cdecl;
  ma_sound_get_engine: function(const pSound: Pma_sound): Pma_engine; cdecl;
  ma_sound_get_data_source: function(const pSound: Pma_sound): Pma_data_source; cdecl;
  ma_sound_start: function(pSound: Pma_sound): ma_result; cdecl;
  ma_sound_stop: function(pSound: Pma_sound): ma_result; cdecl;
  ma_sound_stop_with_fade_in_pcm_frames: function(pSound: Pma_sound; fadeLengthInFrames: ma_uint64): ma_result; cdecl;
  ma_sound_stop_with_fade_in_milliseconds: function(pSound: Pma_sound; fadeLengthInFrames: ma_uint64): ma_result; cdecl;
  ma_sound_set_volume: procedure(pSound: Pma_sound; volume: Single); cdecl;
  ma_sound_get_volume: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_pan: procedure(pSound: Pma_sound; pan: Single); cdecl;
  ma_sound_get_pan: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_pan_mode: procedure(pSound: Pma_sound; panMode: ma_pan_mode); cdecl;
  ma_sound_get_pan_mode: function(const pSound: Pma_sound): ma_pan_mode; cdecl;
  ma_sound_set_pitch: procedure(pSound: Pma_sound; pitch: Single); cdecl;
  ma_sound_get_pitch: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_spatialization_enabled: procedure(pSound: Pma_sound; enabled: ma_bool32); cdecl;
  ma_sound_is_spatialization_enabled: function(const pSound: Pma_sound): ma_bool32; cdecl;
  ma_sound_set_pinned_listener_index: procedure(pSound: Pma_sound; listenerIndex: ma_uint32); cdecl;
  ma_sound_get_pinned_listener_index: function(const pSound: Pma_sound): ma_uint32; cdecl;
  ma_sound_get_listener_index: function(const pSound: Pma_sound): ma_uint32; cdecl;
  ma_sound_get_direction_to_listener: function(const pSound: Pma_sound): ma_vec3f; cdecl;
  ma_sound_set_position: procedure(pSound: Pma_sound; x: Single; y: Single; z: Single); cdecl;
  ma_sound_get_position: function(const pSound: Pma_sound): ma_vec3f; cdecl;
  ma_sound_set_direction: procedure(pSound: Pma_sound; x: Single; y: Single; z: Single); cdecl;
  ma_sound_get_direction: function(const pSound: Pma_sound): ma_vec3f; cdecl;
  ma_sound_set_velocity: procedure(pSound: Pma_sound; x: Single; y: Single; z: Single); cdecl;
  ma_sound_get_velocity: function(const pSound: Pma_sound): ma_vec3f; cdecl;
  ma_sound_set_attenuation_model: procedure(pSound: Pma_sound; attenuationModel: ma_attenuation_model); cdecl;
  ma_sound_get_attenuation_model: function(const pSound: Pma_sound): ma_attenuation_model; cdecl;
  ma_sound_set_positioning: procedure(pSound: Pma_sound; positioning: ma_positioning); cdecl;
  ma_sound_get_positioning: function(const pSound: Pma_sound): ma_positioning; cdecl;
  ma_sound_set_rolloff: procedure(pSound: Pma_sound; rolloff: Single); cdecl;
  ma_sound_get_rolloff: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_min_gain: procedure(pSound: Pma_sound; minGain: Single); cdecl;
  ma_sound_get_min_gain: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_max_gain: procedure(pSound: Pma_sound; maxGain: Single); cdecl;
  ma_sound_get_max_gain: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_min_distance: procedure(pSound: Pma_sound; minDistance: Single); cdecl;
  ma_sound_get_min_distance: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_max_distance: procedure(pSound: Pma_sound; maxDistance: Single); cdecl;
  ma_sound_get_max_distance: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_cone: procedure(pSound: Pma_sound; innerAngleInRadians: Single; outerAngleInRadians: Single; outerGain: Single); cdecl;
  ma_sound_get_cone: procedure(const pSound: Pma_sound; pInnerAngleInRadians: PSingle; pOuterAngleInRadians: PSingle; pOuterGain: PSingle); cdecl;
  ma_sound_set_doppler_factor: procedure(pSound: Pma_sound; dopplerFactor: Single); cdecl;
  ma_sound_get_doppler_factor: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_directional_attenuation_factor: procedure(pSound: Pma_sound; directionalAttenuationFactor: Single); cdecl;
  ma_sound_get_directional_attenuation_factor: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_fade_in_pcm_frames: procedure(pSound: Pma_sound; volumeBeg: Single; volumeEnd: Single; fadeLengthInFrames: ma_uint64); cdecl;
  ma_sound_set_fade_in_milliseconds: procedure(pSound: Pma_sound; volumeBeg: Single; volumeEnd: Single; fadeLengthInMilliseconds: ma_uint64); cdecl;
  ma_sound_set_fade_start_in_pcm_frames: procedure(pSound: Pma_sound; volumeBeg: Single; volumeEnd: Single; fadeLengthInFrames: ma_uint64; absoluteGlobalTimeInFrames: ma_uint64); cdecl;
  ma_sound_set_fade_start_in_milliseconds: procedure(pSound: Pma_sound; volumeBeg: Single; volumeEnd: Single; fadeLengthInMilliseconds: ma_uint64; absoluteGlobalTimeInMilliseconds: ma_uint64); cdecl;
  ma_sound_get_current_fade_volume: function(const pSound: Pma_sound): Single; cdecl;
  ma_sound_set_start_time_in_pcm_frames: procedure(pSound: Pma_sound; absoluteGlobalTimeInFrames: ma_uint64); cdecl;
  ma_sound_set_start_time_in_milliseconds: procedure(pSound: Pma_sound; absoluteGlobalTimeInMilliseconds: ma_uint64); cdecl;
  ma_sound_set_stop_time_in_pcm_frames: procedure(pSound: Pma_sound; absoluteGlobalTimeInFrames: ma_uint64); cdecl;
  ma_sound_set_stop_time_in_milliseconds: procedure(pSound: Pma_sound; absoluteGlobalTimeInMilliseconds: ma_uint64); cdecl;
  ma_sound_set_stop_time_with_fade_in_pcm_frames: procedure(pSound: Pma_sound; stopAbsoluteGlobalTimeInFrames: ma_uint64; fadeLengthInFrames: ma_uint64); cdecl;
  ma_sound_set_stop_time_with_fade_in_milliseconds: procedure(pSound: Pma_sound; stopAbsoluteGlobalTimeInMilliseconds: ma_uint64; fadeLengthInMilliseconds: ma_uint64); cdecl;
  ma_sound_is_playing: function(const pSound: Pma_sound): ma_bool32; cdecl;
  ma_sound_get_time_in_pcm_frames: function(const pSound: Pma_sound): ma_uint64; cdecl;
  ma_sound_get_time_in_milliseconds: function(const pSound: Pma_sound): ma_uint64; cdecl;
  ma_sound_set_looping: procedure(pSound: Pma_sound; isLooping: ma_bool32); cdecl;
  ma_sound_is_looping: function(const pSound: Pma_sound): ma_bool32; cdecl;
  ma_sound_at_end: function(const pSound: Pma_sound): ma_bool32; cdecl;
  ma_sound_seek_to_pcm_frame: function(pSound: Pma_sound; frameIndex: ma_uint64): ma_result; cdecl;
  ma_sound_get_data_format: function(pSound: Pma_sound; pFormat: Pma_format; pChannels: Pma_uint32; pSampleRate: Pma_uint32; pChannelMap: Pma_channel; channelMapCap: NativeUInt): ma_result; cdecl;
  ma_sound_get_cursor_in_pcm_frames: function(pSound: Pma_sound; pCursor: Pma_uint64): ma_result; cdecl;
  ma_sound_get_length_in_pcm_frames: function(pSound: Pma_sound; pLength: Pma_uint64): ma_result; cdecl;
  ma_sound_get_cursor_in_seconds: function(pSound: Pma_sound; pCursor: PSingle): ma_result; cdecl;
  ma_sound_get_length_in_seconds: function(pSound: Pma_sound; pLength: PSingle): ma_result; cdecl;
  ma_sound_set_end_callback: function(pSound: Pma_sound; callback: ma_sound_end_proc; pUserData: Pointer): ma_result; cdecl;
  ma_sound_group_init: function(pEngine: Pma_engine; flags: ma_uint32; pParentGroup: Pma_sound_group; pGroup: Pma_sound_group): ma_result; cdecl;
  ma_sound_group_init_ex: function(pEngine: Pma_engine; const pConfig: Pma_sound_group_config; pGroup: Pma_sound_group): ma_result; cdecl;
  ma_sound_group_uninit: procedure(pGroup: Pma_sound_group); cdecl;
  ma_sound_group_get_engine: function(const pGroup: Pma_sound_group): Pma_engine; cdecl;
  ma_sound_group_start: function(pGroup: Pma_sound_group): ma_result; cdecl;
  ma_sound_group_stop: function(pGroup: Pma_sound_group): ma_result; cdecl;
  ma_sound_group_set_volume: procedure(pGroup: Pma_sound_group; volume: Single); cdecl;
  ma_sound_group_get_volume: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_pan: procedure(pGroup: Pma_sound_group; pan: Single); cdecl;
  ma_sound_group_get_pan: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_pan_mode: procedure(pGroup: Pma_sound_group; panMode: ma_pan_mode); cdecl;
  ma_sound_group_get_pan_mode: function(const pGroup: Pma_sound_group): ma_pan_mode; cdecl;
  ma_sound_group_set_pitch: procedure(pGroup: Pma_sound_group; pitch: Single); cdecl;
  ma_sound_group_get_pitch: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_spatialization_enabled: procedure(pGroup: Pma_sound_group; enabled: ma_bool32); cdecl;
  ma_sound_group_is_spatialization_enabled: function(const pGroup: Pma_sound_group): ma_bool32; cdecl;
  ma_sound_group_set_pinned_listener_index: procedure(pGroup: Pma_sound_group; listenerIndex: ma_uint32); cdecl;
  ma_sound_group_get_pinned_listener_index: function(const pGroup: Pma_sound_group): ma_uint32; cdecl;
  ma_sound_group_get_listener_index: function(const pGroup: Pma_sound_group): ma_uint32; cdecl;
  ma_sound_group_get_direction_to_listener: function(const pGroup: Pma_sound_group): ma_vec3f; cdecl;
  ma_sound_group_set_position: procedure(pGroup: Pma_sound_group; x: Single; y: Single; z: Single); cdecl;
  ma_sound_group_get_position: function(const pGroup: Pma_sound_group): ma_vec3f; cdecl;
  ma_sound_group_set_direction: procedure(pGroup: Pma_sound_group; x: Single; y: Single; z: Single); cdecl;
  ma_sound_group_get_direction: function(const pGroup: Pma_sound_group): ma_vec3f; cdecl;
  ma_sound_group_set_velocity: procedure(pGroup: Pma_sound_group; x: Single; y: Single; z: Single); cdecl;
  ma_sound_group_get_velocity: function(const pGroup: Pma_sound_group): ma_vec3f; cdecl;
  ma_sound_group_set_attenuation_model: procedure(pGroup: Pma_sound_group; attenuationModel: ma_attenuation_model); cdecl;
  ma_sound_group_get_attenuation_model: function(const pGroup: Pma_sound_group): ma_attenuation_model; cdecl;
  ma_sound_group_set_positioning: procedure(pGroup: Pma_sound_group; positioning: ma_positioning); cdecl;
  ma_sound_group_get_positioning: function(const pGroup: Pma_sound_group): ma_positioning; cdecl;
  ma_sound_group_set_rolloff: procedure(pGroup: Pma_sound_group; rolloff: Single); cdecl;
  ma_sound_group_get_rolloff: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_min_gain: procedure(pGroup: Pma_sound_group; minGain: Single); cdecl;
  ma_sound_group_get_min_gain: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_max_gain: procedure(pGroup: Pma_sound_group; maxGain: Single); cdecl;
  ma_sound_group_get_max_gain: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_min_distance: procedure(pGroup: Pma_sound_group; minDistance: Single); cdecl;
  ma_sound_group_get_min_distance: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_max_distance: procedure(pGroup: Pma_sound_group; maxDistance: Single); cdecl;
  ma_sound_group_get_max_distance: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_cone: procedure(pGroup: Pma_sound_group; innerAngleInRadians: Single; outerAngleInRadians: Single; outerGain: Single); cdecl;
  ma_sound_group_get_cone: procedure(const pGroup: Pma_sound_group; pInnerAngleInRadians: PSingle; pOuterAngleInRadians: PSingle; pOuterGain: PSingle); cdecl;
  ma_sound_group_set_doppler_factor: procedure(pGroup: Pma_sound_group; dopplerFactor: Single); cdecl;
  ma_sound_group_get_doppler_factor: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_directional_attenuation_factor: procedure(pGroup: Pma_sound_group; directionalAttenuationFactor: Single); cdecl;
  ma_sound_group_get_directional_attenuation_factor: function(const pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_fade_in_pcm_frames: procedure(pGroup: Pma_sound_group; volumeBeg: Single; volumeEnd: Single; fadeLengthInFrames: ma_uint64); cdecl;
  ma_sound_group_set_fade_in_milliseconds: procedure(pGroup: Pma_sound_group; volumeBeg: Single; volumeEnd: Single; fadeLengthInMilliseconds: ma_uint64); cdecl;
  ma_sound_group_get_current_fade_volume: function(pGroup: Pma_sound_group): Single; cdecl;
  ma_sound_group_set_start_time_in_pcm_frames: procedure(pGroup: Pma_sound_group; absoluteGlobalTimeInFrames: ma_uint64); cdecl;
  ma_sound_group_set_start_time_in_milliseconds: procedure(pGroup: Pma_sound_group; absoluteGlobalTimeInMilliseconds: ma_uint64); cdecl;
  ma_sound_group_set_stop_time_in_pcm_frames: procedure(pGroup: Pma_sound_group; absoluteGlobalTimeInFrames: ma_uint64); cdecl;
  ma_sound_group_set_stop_time_in_milliseconds: procedure(pGroup: Pma_sound_group; absoluteGlobalTimeInMilliseconds: ma_uint64); cdecl;
  ma_sound_group_is_playing: function(const pGroup: Pma_sound_group): ma_bool32; cdecl;
  ma_sound_group_get_time_in_pcm_frames: function(const pGroup: Pma_sound_group): ma_uint64; cdecl;
  crc32: function(crc: uLong; const buf: PBytef; len: uInt): uLong; cdecl;
  unzOpen64: function(const path: Pointer): unzFile; cdecl;
  unzLocateFile: function(&file: unzFile; const szFileName: PUTF8Char; iCaseSensitivity: Integer): Integer; cdecl;
  unzClose: function(&file: unzFile): Integer; cdecl;
  unzOpenCurrentFilePassword: function(&file: unzFile; const password: PUTF8Char): Integer; cdecl;
  unzGetCurrentFileInfo64: function(&file: unzFile; pfile_info: Punz_file_info64; szFileName: PUTF8Char; fileNameBufferSize: uLong; extraField: Pointer; extraFieldBufferSize: uLong; szComment: PUTF8Char; commentBufferSize: uLong): Integer; cdecl;
  unzReadCurrentFile: function(&file: unzFile; buf: voidp; len: Cardinal): Integer; cdecl;
  unzCloseCurrentFile: function(&file: unzFile): Integer; cdecl;
  unztell64: function(&file: unzFile): UInt64; cdecl;
  zipOpen64: function(const pathname: Pointer; append: Integer): zipFile; cdecl;
  zipOpenNewFileInZip3_64: function(&file: zipFile; const filename: PUTF8Char; const zipfi: Pzip_fileinfo; const extrafield_local: Pointer; size_extrafield_local: uInt; const extrafield_global: Pointer; size_extrafield_global: uInt; const comment: PUTF8Char; method: Integer; level: Integer; raw: Integer; windowBits: Integer; memLevel: Integer; strategy: Integer; const password: PUTF8Char; crcForCrypting: uLong; zip64: Integer): Integer; cdecl;
  zipWriteInFileInZip: function(&file: zipFile; const buf: Pointer; len: Cardinal): Integer; cdecl;
  zipCloseFileInZip: function(&file: zipFile): Integer; cdecl;
  zipClose: function(&file: zipFile; const global_comment: PUTF8Char): Integer; cdecl;
  sqlite3_libversion: function(): PUTF8Char; cdecl;
  sqlite3_sourceid: function(): PUTF8Char; cdecl;
  sqlite3_libversion_number: function(): Integer; cdecl;
  sqlite3_compileoption_used: function(const zOptName: PUTF8Char): Integer; cdecl;
  sqlite3_compileoption_get: function(N: Integer): PUTF8Char; cdecl;
  sqlite3_threadsafe: function(): Integer; cdecl;
  sqlite3_close: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_close_v2: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_exec: function(p1: Psqlite3; const sql: PUTF8Char; callback: sqlite3_exec_callback; p4: Pointer; errmsg: PPUTF8Char): Integer; cdecl;
  sqlite3_initialize: function(): Integer; cdecl;
  sqlite3_shutdown: function(): Integer; cdecl;
  sqlite3_os_init: function(): Integer; cdecl;
  sqlite3_os_end: function(): Integer; cdecl;
  sqlite3_config: function(p1: Integer): Integer varargs; cdecl;
  sqlite3_db_config: function(p1: Psqlite3; op: Integer): Integer varargs; cdecl;
  sqlite3_extended_result_codes: function(p1: Psqlite3; onoff: Integer): Integer; cdecl;
  sqlite3_last_insert_rowid: function(p1: Psqlite3): sqlite3_int64; cdecl;
  sqlite3_set_last_insert_rowid: procedure(p1: Psqlite3; p2: sqlite3_int64); cdecl;
  sqlite3_changes: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_changes64: function(p1: Psqlite3): sqlite3_int64; cdecl;
  sqlite3_total_changes: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_total_changes64: function(p1: Psqlite3): sqlite3_int64; cdecl;
  sqlite3_interrupt: procedure(p1: Psqlite3); cdecl;
  sqlite3_is_interrupted: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_complete: function(const sql: PUTF8Char): Integer; cdecl;
  sqlite3_complete16: function(const sql: Pointer): Integer; cdecl;
  sqlite3_busy_handler: function(p1: Psqlite3; p2: sqlite3_busy_handler_; p3: Pointer): Integer; cdecl;
  sqlite3_busy_timeout: function(p1: Psqlite3; ms: Integer): Integer; cdecl;
  sqlite3_get_table: function(db: Psqlite3; const zSql: PUTF8Char; pazResult: PPPUTF8Char; pnRow: PInteger; pnColumn: PInteger; pzErrmsg: PPUTF8Char): Integer; cdecl;
  sqlite3_free_table: procedure(result: PPUTF8Char); cdecl;
  sqlite3_mprintf: function(const p1: PUTF8Char): PUTF8Char varargs; cdecl;
  sqlite3_vmprintf: function(const p1: PUTF8Char; p2: Pointer): PUTF8Char; cdecl;
  sqlite3_snprintf: function(p1: Integer; p2: PUTF8Char; const p3: PUTF8Char): PUTF8Char varargs; cdecl;
  sqlite3_vsnprintf: function(p1: Integer; p2: PUTF8Char; const p3: PUTF8Char; p4: Pointer): PUTF8Char; cdecl;
  sqlite3_malloc: function(p1: Integer): Pointer; cdecl;
  sqlite3_malloc64: function(p1: sqlite3_uint64): Pointer; cdecl;
  sqlite3_realloc: function(p1: Pointer; p2: Integer): Pointer; cdecl;
  sqlite3_realloc64: function(p1: Pointer; p2: sqlite3_uint64): Pointer; cdecl;
  sqlite3_free: procedure(p1: Pointer); cdecl;
  sqlite3_msize: function(p1: Pointer): sqlite3_uint64; cdecl;
  sqlite3_memory_used: function(): sqlite3_int64; cdecl;
  sqlite3_memory_highwater: function(resetFlag: Integer): sqlite3_int64; cdecl;
  sqlite3_randomness: procedure(N: Integer; P: Pointer); cdecl;
  sqlite3_set_authorizer: function(p1: Psqlite3; xAuth: sqlite3_set_authorizer_xAuth; pUserData: Pointer): Integer; cdecl;
  sqlite3_trace: function(p1: Psqlite3; xTrace: sqlite3_trace_xTrace; p3: Pointer): Pointer; cdecl;
  sqlite3_profile: function(p1: Psqlite3; xProfile: sqlite3_profile_xProfile; p3: Pointer): Pointer; cdecl;
  sqlite3_trace_v2: function(p1: Psqlite3; uMask: Cardinal; xCallback: sqlite3_trace_v2_xCallback; pCtx: Pointer): Integer; cdecl;
  sqlite3_progress_handler: procedure(p1: Psqlite3; p2: Integer; p3: sqlite3_progress_handler_; p4: Pointer); cdecl;
  sqlite3_open: function(const filename: PUTF8Char; ppDb: PPsqlite3): Integer; cdecl;
  sqlite3_open16: function(const filename: Pointer; ppDb: PPsqlite3): Integer; cdecl;
  sqlite3_open_v2: function(const filename: PUTF8Char; ppDb: PPsqlite3; flags: Integer; const zVfs: PUTF8Char): Integer; cdecl;
  sqlite3_uri_parameter: function(z: sqlite3_filename; const zParam: PUTF8Char): PUTF8Char; cdecl;
  sqlite3_uri_boolean: function(z: sqlite3_filename; const zParam: PUTF8Char; bDefault: Integer): Integer; cdecl;
  sqlite3_uri_int64: function(p1: sqlite3_filename; const p2: PUTF8Char; p3: sqlite3_int64): sqlite3_int64; cdecl;
  sqlite3_uri_key: function(z: sqlite3_filename; N: Integer): PUTF8Char; cdecl;
  sqlite3_filename_database: function(p1: sqlite3_filename): PUTF8Char; cdecl;
  sqlite3_filename_journal: function(p1: sqlite3_filename): PUTF8Char; cdecl;
  sqlite3_filename_wal: function(p1: sqlite3_filename): PUTF8Char; cdecl;
  sqlite3_database_file_object: function(const p1: PUTF8Char): Psqlite3_file; cdecl;
  sqlite3_create_filename: function(const zDatabase: PUTF8Char; const zJournal: PUTF8Char; const zWal: PUTF8Char; nParam: Integer; azParam: PPUTF8Char): sqlite3_filename; cdecl;
  sqlite3_free_filename: procedure(p1: sqlite3_filename); cdecl;
  sqlite3_errcode: function(db: Psqlite3): Integer; cdecl;
  sqlite3_extended_errcode: function(db: Psqlite3): Integer; cdecl;
  sqlite3_errmsg: function(p1: Psqlite3): PUTF8Char; cdecl;
  sqlite3_errmsg16: function(p1: Psqlite3): Pointer; cdecl;
  sqlite3_errstr: function(p1: Integer): PUTF8Char; cdecl;
  sqlite3_error_offset: function(db: Psqlite3): Integer; cdecl;
  sqlite3_limit: function(p1: Psqlite3; id: Integer; newVal: Integer): Integer; cdecl;
  sqlite3_prepare: function(db: Psqlite3; const zSql: PUTF8Char; nByte: Integer; ppStmt: PPsqlite3_stmt; pzTail: PPUTF8Char): Integer; cdecl;
  sqlite3_prepare_v2: function(db: Psqlite3; const zSql: PUTF8Char; nByte: Integer; ppStmt: PPsqlite3_stmt; pzTail: PPUTF8Char): Integer; cdecl;
  sqlite3_prepare_v3: function(db: Psqlite3; const zSql: PUTF8Char; nByte: Integer; prepFlags: Cardinal; ppStmt: PPsqlite3_stmt; pzTail: PPUTF8Char): Integer; cdecl;
  sqlite3_prepare16: function(db: Psqlite3; const zSql: Pointer; nByte: Integer; ppStmt: PPsqlite3_stmt; pzTail: PPointer): Integer; cdecl;
  sqlite3_prepare16_v2: function(db: Psqlite3; const zSql: Pointer; nByte: Integer; ppStmt: PPsqlite3_stmt; pzTail: PPointer): Integer; cdecl;
  sqlite3_prepare16_v3: function(db: Psqlite3; const zSql: Pointer; nByte: Integer; prepFlags: Cardinal; ppStmt: PPsqlite3_stmt; pzTail: PPointer): Integer; cdecl;
  sqlite3_sql: function(pStmt: Psqlite3_stmt): PUTF8Char; cdecl;
  sqlite3_expanded_sql: function(pStmt: Psqlite3_stmt): PUTF8Char; cdecl;
  sqlite3_stmt_readonly: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_stmt_isexplain: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_stmt_explain: function(pStmt: Psqlite3_stmt; eMode: Integer): Integer; cdecl;
  sqlite3_stmt_busy: function(p1: Psqlite3_stmt): Integer; cdecl;
  sqlite3_bind_blob: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; n: Integer; p5: sqlite3_bind_blob_): Integer; cdecl;
  sqlite3_bind_blob64: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; p4: sqlite3_uint64; p5: sqlite3_bind_blob64_): Integer; cdecl;
  sqlite3_bind_double: function(p1: Psqlite3_stmt; p2: Integer; p3: Double): Integer; cdecl;
  sqlite3_bind_int: function(p1: Psqlite3_stmt; p2: Integer; p3: Integer): Integer; cdecl;
  sqlite3_bind_int64: function(p1: Psqlite3_stmt; p2: Integer; p3: sqlite3_int64): Integer; cdecl;
  sqlite3_bind_null: function(p1: Psqlite3_stmt; p2: Integer): Integer; cdecl;
  sqlite3_bind_text: function(p1: Psqlite3_stmt; p2: Integer; const p3: PUTF8Char; p4: Integer; p5: sqlite3_bind_text_): Integer; cdecl;
  sqlite3_bind_text16: function(p1: Psqlite3_stmt; p2: Integer; const p3: Pointer; p4: Integer; p5: sqlite3_bind_text16_): Integer; cdecl;
  sqlite3_bind_text64: function(p1: Psqlite3_stmt; p2: Integer; const p3: PUTF8Char; p4: sqlite3_uint64; p5: sqlite3_bind_text64_; encoding: Byte): Integer; cdecl;
  sqlite3_bind_value: function(p1: Psqlite3_stmt; p2: Integer; const p3: Psqlite3_value): Integer; cdecl;
  sqlite3_bind_pointer: function(p1: Psqlite3_stmt; p2: Integer; p3: Pointer; const p4: PUTF8Char; p5: sqlite3_bind_pointer_): Integer; cdecl;
  sqlite3_bind_zeroblob: function(p1: Psqlite3_stmt; p2: Integer; n: Integer): Integer; cdecl;
  sqlite3_bind_zeroblob64: function(p1: Psqlite3_stmt; p2: Integer; p3: sqlite3_uint64): Integer; cdecl;
  sqlite3_bind_parameter_count: function(p1: Psqlite3_stmt): Integer; cdecl;
  sqlite3_bind_parameter_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
  sqlite3_bind_parameter_index: function(p1: Psqlite3_stmt; const zName: PUTF8Char): Integer; cdecl;
  sqlite3_clear_bindings: function(p1: Psqlite3_stmt): Integer; cdecl;
  sqlite3_column_count: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_column_name: function(p1: Psqlite3_stmt; N: Integer): PUTF8Char; cdecl;
  sqlite3_column_name16: function(p1: Psqlite3_stmt; N: Integer): Pointer; cdecl;
  sqlite3_column_database_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
  sqlite3_column_database_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
  sqlite3_column_table_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
  sqlite3_column_table_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
  sqlite3_column_origin_name: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
  sqlite3_column_origin_name16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
  sqlite3_column_decltype: function(p1: Psqlite3_stmt; p2: Integer): PUTF8Char; cdecl;
  sqlite3_column_decltype16: function(p1: Psqlite3_stmt; p2: Integer): Pointer; cdecl;
  sqlite3_step: function(p1: Psqlite3_stmt): Integer; cdecl;
  sqlite3_data_count: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_column_blob: function(p1: Psqlite3_stmt; iCol: Integer): Pointer; cdecl;
  sqlite3_column_double: function(p1: Psqlite3_stmt; iCol: Integer): Double; cdecl;
  sqlite3_column_int: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
  sqlite3_column_int64: function(p1: Psqlite3_stmt; iCol: Integer): sqlite3_int64; cdecl;
  sqlite3_column_text: function(p1: Psqlite3_stmt; iCol: Integer): PByte; cdecl;
  sqlite3_column_text16: function(p1: Psqlite3_stmt; iCol: Integer): Pointer; cdecl;
  sqlite3_column_value: function(p1: Psqlite3_stmt; iCol: Integer): Psqlite3_value; cdecl;
  sqlite3_column_bytes: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
  sqlite3_column_bytes16: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
  sqlite3_column_type: function(p1: Psqlite3_stmt; iCol: Integer): Integer; cdecl;
  sqlite3_finalize: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_reset: function(pStmt: Psqlite3_stmt): Integer; cdecl;
  sqlite3_create_function: function(db: Psqlite3; const zFunctionName: PUTF8Char; nArg: Integer; eTextRep: Integer; pApp: Pointer; xFunc: sqlite3_create_function_xFunc; xStep: sqlite3_create_function_xStep; xFinal: sqlite3_create_function_xFinal): Integer; cdecl;
  sqlite3_create_function16: function(db: Psqlite3; const zFunctionName: Pointer; nArg: Integer; eTextRep: Integer; pApp: Pointer; xFunc: sqlite3_create_function16_xFunc; xStep: sqlite3_create_function16_xStep; xFinal: sqlite3_create_function16_xFinal): Integer; cdecl;
  sqlite3_create_function_v2: function(db: Psqlite3; const zFunctionName: PUTF8Char; nArg: Integer; eTextRep: Integer; pApp: Pointer; xFunc: sqlite3_create_function_v2_xFunc; xStep: sqlite3_create_function_v2_xStep; xFinal: sqlite3_create_function_v2_xFinal; xDestroy: sqlite3_create_function_v2_xDestroy): Integer; cdecl;
  sqlite3_create_window_function: function(db: Psqlite3; const zFunctionName: PUTF8Char; nArg: Integer; eTextRep: Integer; pApp: Pointer; xStep: sqlite3_create_window_function_xStep; xFinal: sqlite3_create_window_function_xFinal; xValue: sqlite3_create_window_function_xValue; xInverse: sqlite3_create_window_function_xInverse; xDestroy: sqlite3_create_window_function_xDestroy): Integer; cdecl;
  sqlite3_aggregate_count: function(p1: Psqlite3_context): Integer; cdecl;
  sqlite3_expired: function(p1: Psqlite3_stmt): Integer; cdecl;
  sqlite3_transfer_bindings: function(p1: Psqlite3_stmt; p2: Psqlite3_stmt): Integer; cdecl;
  sqlite3_global_recover: function(): Integer; cdecl;
  sqlite3_thread_cleanup: procedure(); cdecl;
  sqlite3_memory_alarm: function(p1: sqlite3_memory_alarm_; p2: Pointer; p3: sqlite3_int64): Integer; cdecl;
  sqlite3_value_blob: function(p1: Psqlite3_value): Pointer; cdecl;
  sqlite3_value_double: function(p1: Psqlite3_value): Double; cdecl;
  sqlite3_value_int: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_int64: function(p1: Psqlite3_value): sqlite3_int64; cdecl;
  sqlite3_value_pointer: function(p1: Psqlite3_value; const p2: PUTF8Char): Pointer; cdecl;
  sqlite3_value_text: function(p1: Psqlite3_value): PByte; cdecl;
  sqlite3_value_text16: function(p1: Psqlite3_value): Pointer; cdecl;
  sqlite3_value_text16le: function(p1: Psqlite3_value): Pointer; cdecl;
  sqlite3_value_text16be: function(p1: Psqlite3_value): Pointer; cdecl;
  sqlite3_value_bytes: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_bytes16: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_type: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_numeric_type: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_nochange: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_frombind: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_encoding: function(p1: Psqlite3_value): Integer; cdecl;
  sqlite3_value_subtype: function(p1: Psqlite3_value): Cardinal; cdecl;
  sqlite3_value_dup: function(const p1: Psqlite3_value): Psqlite3_value; cdecl;
  sqlite3_value_free: procedure(p1: Psqlite3_value); cdecl;
  sqlite3_aggregate_context: function(p1: Psqlite3_context; nBytes: Integer): Pointer; cdecl;
  sqlite3_user_data: function(p1: Psqlite3_context): Pointer; cdecl;
  sqlite3_context_db_handle: function(p1: Psqlite3_context): Psqlite3; cdecl;
  sqlite3_get_auxdata: function(p1: Psqlite3_context; N: Integer): Pointer; cdecl;
  sqlite3_set_auxdata: procedure(p1: Psqlite3_context; N: Integer; p3: Pointer; p4: sqlite3_set_auxdata_); cdecl;
  sqlite3_get_clientdata: function(p1: Psqlite3; const p2: PUTF8Char): Pointer; cdecl;
  sqlite3_set_clientdata: function(p1: Psqlite3; const p2: PUTF8Char; p3: Pointer; p4: sqlite3_set_clientdata_): Integer; cdecl;
  sqlite3_result_blob: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: sqlite3_result_blob_); cdecl;
  sqlite3_result_blob64: procedure(p1: Psqlite3_context; const p2: Pointer; p3: sqlite3_uint64; p4: sqlite3_result_blob64_); cdecl;
  sqlite3_result_double: procedure(p1: Psqlite3_context; p2: Double); cdecl;
  sqlite3_result_error: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: Integer); cdecl;
  sqlite3_result_error16: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer); cdecl;
  sqlite3_result_error_toobig: procedure(p1: Psqlite3_context); cdecl;
  sqlite3_result_error_nomem: procedure(p1: Psqlite3_context); cdecl;
  sqlite3_result_error_code: procedure(p1: Psqlite3_context; p2: Integer); cdecl;
  sqlite3_result_int: procedure(p1: Psqlite3_context; p2: Integer); cdecl;
  sqlite3_result_int64: procedure(p1: Psqlite3_context; p2: sqlite3_int64); cdecl;
  sqlite3_result_null: procedure(p1: Psqlite3_context); cdecl;
  sqlite3_result_text: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: Integer; p4: sqlite3_result_text_); cdecl;
  sqlite3_result_text64: procedure(p1: Psqlite3_context; const p2: PUTF8Char; p3: sqlite3_uint64; p4: sqlite3_result_text64_; encoding: Byte); cdecl;
  sqlite3_result_text16: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: sqlite3_result_text16_); cdecl;
  sqlite3_result_text16le: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: sqlite3_result_text16le_); cdecl;
  sqlite3_result_text16be: procedure(p1: Psqlite3_context; const p2: Pointer; p3: Integer; p4: sqlite3_result_text16be_); cdecl;
  sqlite3_result_value: procedure(p1: Psqlite3_context; p2: Psqlite3_value); cdecl;
  sqlite3_result_pointer: procedure(p1: Psqlite3_context; p2: Pointer; const p3: PUTF8Char; p4: sqlite3_result_pointer_); cdecl;
  sqlite3_result_zeroblob: procedure(p1: Psqlite3_context; n: Integer); cdecl;
  sqlite3_result_zeroblob64: function(p1: Psqlite3_context; n: sqlite3_uint64): Integer; cdecl;
  sqlite3_result_subtype: procedure(p1: Psqlite3_context; p2: Cardinal); cdecl;
  sqlite3_create_collation: function(p1: Psqlite3; const zName: PUTF8Char; eTextRep: Integer; pArg: Pointer; xCompare: sqlite3_create_collation_xCompare): Integer; cdecl;
  sqlite3_create_collation_v2: function(p1: Psqlite3; const zName: PUTF8Char; eTextRep: Integer; pArg: Pointer; xCompare: sqlite3_create_collation_v2_xCompare; xDestroy: sqlite3_create_collation_v2_xDestroy): Integer; cdecl;
  sqlite3_create_collation16: function(p1: Psqlite3; const zName: Pointer; eTextRep: Integer; pArg: Pointer; xCompare: sqlite3_create_collation16_xCompare): Integer; cdecl;
  sqlite3_collation_needed: function(p1: Psqlite3; p2: Pointer; p3: sqlite3_collation_needed_): Integer; cdecl;
  sqlite3_collation_needed16: function(p1: Psqlite3; p2: Pointer; p3: sqlite3_collation_needed16_): Integer; cdecl;
  sqlite3_sleep: function(p1: Integer): Integer; cdecl;
  sqlite3_win32_set_directory: function(&type: Longword; zValue: Pointer): Integer; cdecl;
  sqlite3_win32_set_directory8: function(&type: Longword; const zValue: PUTF8Char): Integer; cdecl;
  sqlite3_win32_set_directory16: function(&type: Longword; const zValue: Pointer): Integer; cdecl;
  sqlite3_get_autocommit: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_db_handle: function(p1: Psqlite3_stmt): Psqlite3; cdecl;
  sqlite3_db_name: function(db: Psqlite3; N: Integer): PUTF8Char; cdecl;
  sqlite3_db_filename: function(db: Psqlite3; const zDbName: PUTF8Char): sqlite3_filename; cdecl;
  sqlite3_db_readonly: function(db: Psqlite3; const zDbName: PUTF8Char): Integer; cdecl;
  sqlite3_txn_state: function(p1: Psqlite3; const zSchema: PUTF8Char): Integer; cdecl;
  sqlite3_next_stmt: function(pDb: Psqlite3; pStmt: Psqlite3_stmt): Psqlite3_stmt; cdecl;
  sqlite3_commit_hook: function(p1: Psqlite3; p2: sqlite3_commit_hook_; p3: Pointer): Pointer; cdecl;
  sqlite3_rollback_hook: function(p1: Psqlite3; p2: sqlite3_rollback_hook_; p3: Pointer): Pointer; cdecl;
  sqlite3_autovacuum_pages: function(db: Psqlite3; p2: sqlite3_autovacuum_pages_1; p3: Pointer; p4: sqlite3_autovacuum_pages_2): Integer; cdecl;
  sqlite3_update_hook: function(p1: Psqlite3; p2: sqlite3_update_hook_; p3: Pointer): Pointer; cdecl;
  sqlite3_enable_shared_cache: function(p1: Integer): Integer; cdecl;
  sqlite3_release_memory: function(p1: Integer): Integer; cdecl;
  sqlite3_db_release_memory: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_soft_heap_limit64: function(N: sqlite3_int64): sqlite3_int64; cdecl;
  sqlite3_hard_heap_limit64: function(N: sqlite3_int64): sqlite3_int64; cdecl;
  sqlite3_soft_heap_limit: procedure(N: Integer); cdecl;
  sqlite3_table_column_metadata: function(db: Psqlite3; const zDbName: PUTF8Char; const zTableName: PUTF8Char; const zColumnName: PUTF8Char; pzDataType: PPUTF8Char; pzCollSeq: PPUTF8Char; pNotNull: PInteger; pPrimaryKey: PInteger; pAutoinc: PInteger): Integer; cdecl;
  sqlite3_auto_extension: function(xEntryPoint: sqlite3_auto_extension_xEntryPoint): Integer; cdecl;
  sqlite3_cancel_auto_extension: function(xEntryPoint: sqlite3_cancel_auto_extension_xEntryPoint): Integer; cdecl;
  sqlite3_reset_auto_extension: procedure(); cdecl;
  sqlite3_create_module: function(db: Psqlite3; const zName: PUTF8Char; const p: Psqlite3_module; pClientData: Pointer): Integer; cdecl;
  sqlite3_create_module_v2: function(db: Psqlite3; const zName: PUTF8Char; const p: Psqlite3_module; pClientData: Pointer; xDestroy: sqlite3_create_module_v2_xDestroy): Integer; cdecl;
  sqlite3_drop_modules: function(db: Psqlite3; azKeep: PPUTF8Char): Integer; cdecl;
  sqlite3_declare_vtab: function(p1: Psqlite3; const zSQL: PUTF8Char): Integer; cdecl;
  sqlite3_overload_function: function(p1: Psqlite3; const zFuncName: PUTF8Char; nArg: Integer): Integer; cdecl;
  sqlite3_blob_open: function(p1: Psqlite3; const zDb: PUTF8Char; const zTable: PUTF8Char; const zColumn: PUTF8Char; iRow: sqlite3_int64; flags: Integer; ppBlob: PPsqlite3_blob): Integer; cdecl;
  sqlite3_blob_reopen: function(p1: Psqlite3_blob; p2: sqlite3_int64): Integer; cdecl;
  sqlite3_blob_close: function(p1: Psqlite3_blob): Integer; cdecl;
  sqlite3_blob_bytes: function(p1: Psqlite3_blob): Integer; cdecl;
  sqlite3_blob_read: function(p1: Psqlite3_blob; Z: Pointer; N: Integer; iOffset: Integer): Integer; cdecl;
  sqlite3_blob_write: function(p1: Psqlite3_blob; const z: Pointer; n: Integer; iOffset: Integer): Integer; cdecl;
  sqlite3_vfs_find: function(const zVfsName: PUTF8Char): Psqlite3_vfs; cdecl;
  sqlite3_vfs_register: function(p1: Psqlite3_vfs; makeDflt: Integer): Integer; cdecl;
  sqlite3_vfs_unregister: function(p1: Psqlite3_vfs): Integer; cdecl;
  sqlite3_mutex_alloc: function(p1: Integer): Psqlite3_mutex; cdecl;
  sqlite3_mutex_free: procedure(p1: Psqlite3_mutex); cdecl;
  sqlite3_mutex_enter: procedure(p1: Psqlite3_mutex); cdecl;
  sqlite3_mutex_try: function(p1: Psqlite3_mutex): Integer; cdecl;
  sqlite3_mutex_leave: procedure(p1: Psqlite3_mutex); cdecl;
  sqlite3_db_mutex: function(p1: Psqlite3): Psqlite3_mutex; cdecl;
  sqlite3_file_control: function(p1: Psqlite3; const zDbName: PUTF8Char; op: Integer; p4: Pointer): Integer; cdecl;
  sqlite3_test_control: function(op: Integer): Integer varargs; cdecl;
  sqlite3_keyword_count: function(): Integer; cdecl;
  sqlite3_keyword_name: function(p1: Integer; p2: PPUTF8Char; p3: PInteger): Integer; cdecl;
  sqlite3_keyword_check: function(const p1: PUTF8Char; p2: Integer): Integer; cdecl;
  sqlite3_str_new: function(p1: Psqlite3): Psqlite3_str; cdecl;
  sqlite3_str_finish: function(p1: Psqlite3_str): PUTF8Char; cdecl;
  sqlite3_str_appendf: procedure(p1: Psqlite3_str; const zFormat: PUTF8Char) varargs; cdecl;
  sqlite3_str_vappendf: procedure(p1: Psqlite3_str; const zFormat: PUTF8Char; p3: Pointer); cdecl;
  sqlite3_str_append: procedure(p1: Psqlite3_str; const zIn: PUTF8Char; N: Integer); cdecl;
  sqlite3_str_appendall: procedure(p1: Psqlite3_str; const zIn: PUTF8Char); cdecl;
  sqlite3_str_appendchar: procedure(p1: Psqlite3_str; N: Integer; C: UTF8Char); cdecl;
  sqlite3_str_reset: procedure(p1: Psqlite3_str); cdecl;
  sqlite3_str_errcode: function(p1: Psqlite3_str): Integer; cdecl;
  sqlite3_str_length: function(p1: Psqlite3_str): Integer; cdecl;
  sqlite3_str_value: function(p1: Psqlite3_str): PUTF8Char; cdecl;
  sqlite3_status: function(op: Integer; pCurrent: PInteger; pHighwater: PInteger; resetFlag: Integer): Integer; cdecl;
  sqlite3_status64: function(op: Integer; pCurrent: Psqlite3_int64; pHighwater: Psqlite3_int64; resetFlag: Integer): Integer; cdecl;
  sqlite3_db_status: function(p1: Psqlite3; op: Integer; pCur: PInteger; pHiwtr: PInteger; resetFlg: Integer): Integer; cdecl;
  sqlite3_stmt_status: function(p1: Psqlite3_stmt; op: Integer; resetFlg: Integer): Integer; cdecl;
  sqlite3_backup_init: function(pDest: Psqlite3; const zDestName: PUTF8Char; pSource: Psqlite3; const zSourceName: PUTF8Char): Psqlite3_backup; cdecl;
  sqlite3_backup_step: function(p: Psqlite3_backup; nPage: Integer): Integer; cdecl;
  sqlite3_backup_finish: function(p: Psqlite3_backup): Integer; cdecl;
  sqlite3_backup_remaining: function(p: Psqlite3_backup): Integer; cdecl;
  sqlite3_backup_pagecount: function(p: Psqlite3_backup): Integer; cdecl;
  sqlite3_stricmp: function(const p1: PUTF8Char; const p2: PUTF8Char): Integer; cdecl;
  sqlite3_strnicmp: function(const p1: PUTF8Char; const p2: PUTF8Char; p3: Integer): Integer; cdecl;
  sqlite3_strglob: function(const zGlob: PUTF8Char; const zStr: PUTF8Char): Integer; cdecl;
  sqlite3_strlike: function(const zGlob: PUTF8Char; const zStr: PUTF8Char; cEsc: Cardinal): Integer; cdecl;
  sqlite3_log: procedure(iErrCode: Integer; const zFormat: PUTF8Char) varargs; cdecl;
  sqlite3_wal_hook: function(p1: Psqlite3; p2: sqlite3_wal_hook_; p3: Pointer): Pointer; cdecl;
  sqlite3_wal_autocheckpoint: function(db: Psqlite3; N: Integer): Integer; cdecl;
  sqlite3_wal_checkpoint: function(db: Psqlite3; const zDb: PUTF8Char): Integer; cdecl;
  sqlite3_wal_checkpoint_v2: function(db: Psqlite3; const zDb: PUTF8Char; eMode: Integer; pnLog: PInteger; pnCkpt: PInteger): Integer; cdecl;
  sqlite3_vtab_config: function(p1: Psqlite3; op: Integer): Integer varargs; cdecl;
  sqlite3_vtab_on_conflict: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_vtab_nochange: function(p1: Psqlite3_context): Integer; cdecl;
  sqlite3_vtab_collation: function(p1: Psqlite3_index_info; p2: Integer): PUTF8Char; cdecl;
  sqlite3_vtab_distinct: function(p1: Psqlite3_index_info): Integer; cdecl;
  sqlite3_vtab_in: function(p1: Psqlite3_index_info; iCons: Integer; bHandle: Integer): Integer; cdecl;
  sqlite3_vtab_in_first: function(pVal: Psqlite3_value; ppOut: PPsqlite3_value): Integer; cdecl;
  sqlite3_vtab_in_next: function(pVal: Psqlite3_value; ppOut: PPsqlite3_value): Integer; cdecl;
  sqlite3_vtab_rhs_value: function(p1: Psqlite3_index_info; p2: Integer; ppVal: PPsqlite3_value): Integer; cdecl;
  sqlite3_db_cacheflush: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_system_errno: function(p1: Psqlite3): Integer; cdecl;
  sqlite3_serialize: function(db: Psqlite3; const zSchema: PUTF8Char; piSize: Psqlite3_int64; mFlags: Cardinal): PByte; cdecl;
  sqlite3_deserialize: function(db: Psqlite3; const zSchema: PUTF8Char; pData: PByte; szDb: sqlite3_int64; szBuf: sqlite3_int64; mFlags: Cardinal): Integer; cdecl;
  ImVec2_ImVec2_Nil: function(): PImVec2; cdecl;
  ImVec2_destroy: procedure(self: PImVec2); cdecl;
  ImVec2_ImVec2_Float: function(_x: Single; _y: Single): PImVec2; cdecl;
  ImVec4_ImVec4_Nil: function(): PImVec4; cdecl;
  ImVec4_destroy: procedure(self: PImVec4); cdecl;
  ImVec4_ImVec4_Float: function(_x: Single; _y: Single; _z: Single; _w: Single): PImVec4; cdecl;
  igCreateContext: function(shared_font_atlas: PImFontAtlas): PImGuiContext; cdecl;
  igDestroyContext: procedure(ctx: PImGuiContext); cdecl;
  igGetCurrentContext: function(): PImGuiContext; cdecl;
  igSetCurrentContext: procedure(ctx: PImGuiContext); cdecl;
  igGetIO: function(): PImGuiIO; cdecl;
  igGetPlatformIO: function(): PImGuiPlatformIO; cdecl;
  igGetStyle: function(): PImGuiStyle; cdecl;
  igNewFrame: procedure(); cdecl;
  igEndFrame: procedure(); cdecl;
  igRender: procedure(); cdecl;
  igGetDrawData: function(): PImDrawData; cdecl;
  igShowDemoWindow: procedure(p_open: PBoolean); cdecl;
  igShowMetricsWindow: procedure(p_open: PBoolean); cdecl;
  igShowDebugLogWindow: procedure(p_open: PBoolean); cdecl;
  igShowIDStackToolWindow: procedure(p_open: PBoolean); cdecl;
  igShowAboutWindow: procedure(p_open: PBoolean); cdecl;
  igShowStyleEditor: procedure(ref: PImGuiStyle); cdecl;
  igShowStyleSelector: function(const &label: PUTF8Char): Boolean; cdecl;
  igShowFontSelector: procedure(const &label: PUTF8Char); cdecl;
  igShowUserGuide: procedure(); cdecl;
  igGetVersion: function(): PUTF8Char; cdecl;
  igStyleColorsDark: procedure(dst: PImGuiStyle); cdecl;
  igStyleColorsLight: procedure(dst: PImGuiStyle); cdecl;
  igStyleColorsClassic: procedure(dst: PImGuiStyle); cdecl;
  igBegin: function(const name: PUTF8Char; p_open: PBoolean; flags: ImGuiWindowFlags): Boolean; cdecl;
  igEnd: procedure(); cdecl;
  igBeginChild_Str: function(const str_id: PUTF8Char; size: ImVec2; child_flags: ImGuiChildFlags; window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igBeginChild_ID: function(id: ImGuiID; size: ImVec2; child_flags: ImGuiChildFlags; window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igEndChild: procedure(); cdecl;
  igIsWindowAppearing: function(): Boolean; cdecl;
  igIsWindowCollapsed: function(): Boolean; cdecl;
  igIsWindowFocused: function(flags: ImGuiFocusedFlags): Boolean; cdecl;
  igIsWindowHovered: function(flags: ImGuiHoveredFlags): Boolean; cdecl;
  igGetWindowDrawList: function(): PImDrawList; cdecl;
  igGetWindowDpiScale: function(): Single; cdecl;
  igGetWindowPos: procedure(pOut: PImVec2); cdecl;
  igGetWindowSize: procedure(pOut: PImVec2); cdecl;
  igGetWindowWidth: function(): Single; cdecl;
  igGetWindowHeight: function(): Single; cdecl;
  igGetWindowViewport: function(): PImGuiViewport; cdecl;
  igSetNextWindowPos: procedure(pos: ImVec2; cond: ImGuiCond; pivot: ImVec2); cdecl;
  igSetNextWindowSize: procedure(size: ImVec2; cond: ImGuiCond); cdecl;
  igSetNextWindowSizeConstraints: procedure(size_min: ImVec2; size_max: ImVec2; custom_callback: ImGuiSizeCallback; custom_callback_data: Pointer); cdecl;
  igSetNextWindowContentSize: procedure(size: ImVec2); cdecl;
  igSetNextWindowCollapsed: procedure(collapsed: Boolean; cond: ImGuiCond); cdecl;
  igSetNextWindowFocus: procedure(); cdecl;
  igSetNextWindowScroll: procedure(scroll: ImVec2); cdecl;
  igSetNextWindowBgAlpha: procedure(alpha: Single); cdecl;
  igSetNextWindowViewport: procedure(viewport_id: ImGuiID); cdecl;
  igSetWindowPos_Vec2: procedure(pos: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowSize_Vec2: procedure(size: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowCollapsed_Bool: procedure(collapsed: Boolean; cond: ImGuiCond); cdecl;
  igSetWindowFocus_Nil: procedure(); cdecl;
  igSetWindowFontScale: procedure(scale: Single); cdecl;
  igSetWindowPos_Str: procedure(const name: PUTF8Char; pos: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowSize_Str: procedure(const name: PUTF8Char; size: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowCollapsed_Str: procedure(const name: PUTF8Char; collapsed: Boolean; cond: ImGuiCond); cdecl;
  igSetWindowFocus_Str: procedure(const name: PUTF8Char); cdecl;
  igGetScrollX: function(): Single; cdecl;
  igGetScrollY: function(): Single; cdecl;
  igSetScrollX_Float: procedure(scroll_x: Single); cdecl;
  igSetScrollY_Float: procedure(scroll_y: Single); cdecl;
  igGetScrollMaxX: function(): Single; cdecl;
  igGetScrollMaxY: function(): Single; cdecl;
  igSetScrollHereX: procedure(center_x_ratio: Single); cdecl;
  igSetScrollHereY: procedure(center_y_ratio: Single); cdecl;
  igSetScrollFromPosX_Float: procedure(local_x: Single; center_x_ratio: Single); cdecl;
  igSetScrollFromPosY_Float: procedure(local_y: Single; center_y_ratio: Single); cdecl;
  igPushFont: procedure(font: PImFont); cdecl;
  igPopFont: procedure(); cdecl;
  igPushStyleColor_U32: procedure(idx: ImGuiCol; col: ImU32); cdecl;
  igPushStyleColor_Vec4: procedure(idx: ImGuiCol; col: ImVec4); cdecl;
  igPopStyleColor: procedure(count: Integer); cdecl;
  igPushStyleVar_Float: procedure(idx: ImGuiStyleVar; val: Single); cdecl;
  igPushStyleVar_Vec2: procedure(idx: ImGuiStyleVar; val: ImVec2); cdecl;
  igPushStyleVarX: procedure(idx: ImGuiStyleVar; val_x: Single); cdecl;
  igPushStyleVarY: procedure(idx: ImGuiStyleVar; val_y: Single); cdecl;
  igPopStyleVar: procedure(count: Integer); cdecl;
  igPushItemFlag: procedure(option: ImGuiItemFlags; enabled: Boolean); cdecl;
  igPopItemFlag: procedure(); cdecl;
  igPushItemWidth: procedure(item_width: Single); cdecl;
  igPopItemWidth: procedure(); cdecl;
  igSetNextItemWidth: procedure(item_width: Single); cdecl;
  igCalcItemWidth: function(): Single; cdecl;
  igPushTextWrapPos: procedure(wrap_local_pos_x: Single); cdecl;
  igPopTextWrapPos: procedure(); cdecl;
  igGetFont: function(): PImFont; cdecl;
  igGetFontSize: function(): Single; cdecl;
  igGetFontTexUvWhitePixel: procedure(pOut: PImVec2); cdecl;
  igGetColorU32_Col: function(idx: ImGuiCol; alpha_mul: Single): ImU32; cdecl;
  igGetColorU32_Vec4: function(col: ImVec4): ImU32; cdecl;
  igGetColorU32_U32: function(col: ImU32; alpha_mul: Single): ImU32; cdecl;
  igGetStyleColorVec4: function(idx: ImGuiCol): PImVec4; cdecl;
  igGetCursorScreenPos: procedure(pOut: PImVec2); cdecl;
  igSetCursorScreenPos: procedure(pos: ImVec2); cdecl;
  igGetContentRegionAvail: procedure(pOut: PImVec2); cdecl;
  igGetCursorPos: procedure(pOut: PImVec2); cdecl;
  igGetCursorPosX: function(): Single; cdecl;
  igGetCursorPosY: function(): Single; cdecl;
  igSetCursorPos: procedure(local_pos: ImVec2); cdecl;
  igSetCursorPosX: procedure(local_x: Single); cdecl;
  igSetCursorPosY: procedure(local_y: Single); cdecl;
  igGetCursorStartPos: procedure(pOut: PImVec2); cdecl;
  igSeparator: procedure(); cdecl;
  igSameLine: procedure(offset_from_start_x: Single; spacing: Single); cdecl;
  igNewLine: procedure(); cdecl;
  igSpacing: procedure(); cdecl;
  igDummy: procedure(size: ImVec2); cdecl;
  igIndent: procedure(indent_w: Single); cdecl;
  igUnindent: procedure(indent_w: Single); cdecl;
  igBeginGroup: procedure(); cdecl;
  igEndGroup: procedure(); cdecl;
  igAlignTextToFramePadding: procedure(); cdecl;
  igGetTextLineHeight: function(): Single; cdecl;
  igGetTextLineHeightWithSpacing: function(): Single; cdecl;
  igGetFrameHeight: function(): Single; cdecl;
  igGetFrameHeightWithSpacing: function(): Single; cdecl;
  igPushID_Str: procedure(const str_id: PUTF8Char); cdecl;
  igPushID_StrStr: procedure(const str_id_begin: PUTF8Char; const str_id_end: PUTF8Char); cdecl;
  igPushID_Ptr: procedure(const ptr_id: Pointer); cdecl;
  igPushID_Int: procedure(int_id: Integer); cdecl;
  igPopID: procedure(); cdecl;
  igGetID_Str: function(const str_id: PUTF8Char): ImGuiID; cdecl;
  igGetID_StrStr: function(const str_id_begin: PUTF8Char; const str_id_end: PUTF8Char): ImGuiID; cdecl;
  igGetID_Ptr: function(const ptr_id: Pointer): ImGuiID; cdecl;
  igGetID_Int: function(int_id: Integer): ImGuiID; cdecl;
  igTextUnformatted: procedure(const text: PUTF8Char; const text_end: PUTF8Char); cdecl;
  igText: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igTextV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igTextColored: procedure(col: ImVec4; const fmt: PUTF8Char) varargs; cdecl;
  igTextColoredV: procedure(col: ImVec4; const fmt: PUTF8Char; args: Pointer); cdecl;
  igTextDisabled: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igTextDisabledV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igTextWrapped: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igTextWrappedV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igLabelText: procedure(const &label: PUTF8Char; const fmt: PUTF8Char) varargs; cdecl;
  igLabelTextV: procedure(const &label: PUTF8Char; const fmt: PUTF8Char; args: Pointer); cdecl;
  igBulletText: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igBulletTextV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igSeparatorText: procedure(const &label: PUTF8Char); cdecl;
  igButton: function(const &label: PUTF8Char; size: ImVec2): Boolean; cdecl;
  igSmallButton: function(const &label: PUTF8Char): Boolean; cdecl;
  igInvisibleButton: function(const str_id: PUTF8Char; size: ImVec2; flags: ImGuiButtonFlags): Boolean; cdecl;
  igArrowButton: function(const str_id: PUTF8Char; dir: ImGuiDir): Boolean; cdecl;
  igCheckbox: function(const &label: PUTF8Char; v: PBoolean): Boolean; cdecl;
  igCheckboxFlags_IntPtr: function(const &label: PUTF8Char; flags: PInteger; flags_value: Integer): Boolean; cdecl;
  igCheckboxFlags_UintPtr: function(const &label: PUTF8Char; flags: PCardinal; flags_value: Cardinal): Boolean; cdecl;
  igRadioButton_Bool: function(const &label: PUTF8Char; active: Boolean): Boolean; cdecl;
  igRadioButton_IntPtr: function(const &label: PUTF8Char; v: PInteger; v_button: Integer): Boolean; cdecl;
  igProgressBar: procedure(fraction: Single; size_arg: ImVec2; const overlay: PUTF8Char); cdecl;
  igBullet: procedure(); cdecl;
  igTextLink: function(const &label: PUTF8Char): Boolean; cdecl;
  igTextLinkOpenURL: procedure(const &label: PUTF8Char; const url: PUTF8Char); cdecl;
  igImage: procedure(user_texture_id: ImTextureID; image_size: ImVec2; uv0: ImVec2; uv1: ImVec2; tint_col: ImVec4; border_col: ImVec4); cdecl;
  igImageButton: function(const str_id: PUTF8Char; user_texture_id: ImTextureID; image_size: ImVec2; uv0: ImVec2; uv1: ImVec2; bg_col: ImVec4; tint_col: ImVec4): Boolean; cdecl;
  igBeginCombo: function(const &label: PUTF8Char; const preview_value: PUTF8Char; flags: ImGuiComboFlags): Boolean; cdecl;
  igEndCombo: procedure(); cdecl;
  igCombo_Str_arr: function(const &label: PUTF8Char; current_item: PInteger; items: PPUTF8Char; items_count: Integer; popup_max_height_in_items: Integer): Boolean; cdecl;
  igCombo_Str: function(const &label: PUTF8Char; current_item: PInteger; const items_separated_by_zeros: PUTF8Char; popup_max_height_in_items: Integer): Boolean; cdecl;
  igCombo_FnStrPtr: function(const &label: PUTF8Char; current_item: PInteger; getter: igCombo_FnStrPtr_getter; user_data: Pointer; items_count: Integer; popup_max_height_in_items: Integer): Boolean; cdecl;
  igDragFloat: function(const &label: PUTF8Char; v: PSingle; v_speed: Single; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragFloat2: function(const &label: PUTF8Char; v: PSingle; v_speed: Single; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragFloat3: function(const &label: PUTF8Char; v: PSingle; v_speed: Single; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragFloat4: function(const &label: PUTF8Char; v: PSingle; v_speed: Single; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragFloatRange2: function(const &label: PUTF8Char; v_current_min: PSingle; v_current_max: PSingle; v_speed: Single; v_min: Single; v_max: Single; const format: PUTF8Char; const format_max: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragInt: function(const &label: PUTF8Char; v: PInteger; v_speed: Single; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragInt2: function(const &label: PUTF8Char; v: PInteger; v_speed: Single; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragInt3: function(const &label: PUTF8Char; v: PInteger; v_speed: Single; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragInt4: function(const &label: PUTF8Char; v: PInteger; v_speed: Single; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragIntRange2: function(const &label: PUTF8Char; v_current_min: PInteger; v_current_max: PInteger; v_speed: Single; v_min: Integer; v_max: Integer; const format: PUTF8Char; const format_max: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragScalar: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; v_speed: Single; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igDragScalarN: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; components: Integer; v_speed: Single; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderFloat: function(const &label: PUTF8Char; v: PSingle; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderFloat2: function(const &label: PUTF8Char; v: PSingle; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderFloat3: function(const &label: PUTF8Char; v: PSingle; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderFloat4: function(const &label: PUTF8Char; v: PSingle; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderAngle: function(const &label: PUTF8Char; v_rad: PSingle; v_degrees_min: Single; v_degrees_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderInt: function(const &label: PUTF8Char; v: PInteger; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderInt2: function(const &label: PUTF8Char; v: PInteger; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderInt3: function(const &label: PUTF8Char; v: PInteger; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderInt4: function(const &label: PUTF8Char; v: PInteger; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderScalar: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderScalarN: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; components: Integer; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igVSliderFloat: function(const &label: PUTF8Char; size: ImVec2; v: PSingle; v_min: Single; v_max: Single; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igVSliderInt: function(const &label: PUTF8Char; size: ImVec2; v: PInteger; v_min: Integer; v_max: Integer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igVSliderScalar: function(const &label: PUTF8Char; size: ImVec2; data_type: ImGuiDataType; p_data: Pointer; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igInputText: function(const &label: PUTF8Char; buf: PUTF8Char; buf_size: NativeUInt; flags: ImGuiInputTextFlags; callback: ImGuiInputTextCallback; user_data: Pointer): Boolean; cdecl;
  igInputTextMultiline: function(const &label: PUTF8Char; buf: PUTF8Char; buf_size: NativeUInt; size: ImVec2; flags: ImGuiInputTextFlags; callback: ImGuiInputTextCallback; user_data: Pointer): Boolean; cdecl;
  igInputTextWithHint: function(const &label: PUTF8Char; const hint: PUTF8Char; buf: PUTF8Char; buf_size: NativeUInt; flags: ImGuiInputTextFlags; callback: ImGuiInputTextCallback; user_data: Pointer): Boolean; cdecl;
  igInputFloat: function(const &label: PUTF8Char; v: PSingle; step: Single; step_fast: Single; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputFloat2: function(const &label: PUTF8Char; v: PSingle; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputFloat3: function(const &label: PUTF8Char; v: PSingle; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputFloat4: function(const &label: PUTF8Char; v: PSingle; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputInt: function(const &label: PUTF8Char; v: PInteger; step: Integer; step_fast: Integer; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputInt2: function(const &label: PUTF8Char; v: PInteger; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputInt3: function(const &label: PUTF8Char; v: PInteger; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputInt4: function(const &label: PUTF8Char; v: PInteger; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputDouble: function(const &label: PUTF8Char; v: PDouble; step: Double; step_fast: Double; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputScalar: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; const p_step: Pointer; const p_step_fast: Pointer; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igInputScalarN: function(const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; components: Integer; const p_step: Pointer; const p_step_fast: Pointer; const format: PUTF8Char; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igColorEdit3: function(const &label: PUTF8Char; col: PSingle; flags: ImGuiColorEditFlags): Boolean; cdecl;
  igColorEdit4: function(const &label: PUTF8Char; col: PSingle; flags: ImGuiColorEditFlags): Boolean; cdecl;
  igColorPicker3: function(const &label: PUTF8Char; col: PSingle; flags: ImGuiColorEditFlags): Boolean; cdecl;
  igColorPicker4: function(const &label: PUTF8Char; col: PSingle; flags: ImGuiColorEditFlags; const ref_col: PSingle): Boolean; cdecl;
  igColorButton: function(const desc_id: PUTF8Char; col: ImVec4; flags: ImGuiColorEditFlags; size: ImVec2): Boolean; cdecl;
  igSetColorEditOptions: procedure(flags: ImGuiColorEditFlags); cdecl;
  igTreeNode_Str: function(const &label: PUTF8Char): Boolean; cdecl;
  igTreeNode_StrStr: function(const str_id: PUTF8Char; const fmt: PUTF8Char): Boolean varargs; cdecl;
  igTreeNode_Ptr: function(const ptr_id: Pointer; const fmt: PUTF8Char): Boolean varargs; cdecl;
  igTreeNodeV_Str: function(const str_id: PUTF8Char; const fmt: PUTF8Char; args: Pointer): Boolean; cdecl;
  igTreeNodeV_Ptr: function(const ptr_id: Pointer; const fmt: PUTF8Char; args: Pointer): Boolean; cdecl;
  igTreeNodeEx_Str: function(const &label: PUTF8Char; flags: ImGuiTreeNodeFlags): Boolean; cdecl;
  igTreeNodeEx_StrStr: function(const str_id: PUTF8Char; flags: ImGuiTreeNodeFlags; const fmt: PUTF8Char): Boolean varargs; cdecl;
  igTreeNodeEx_Ptr: function(const ptr_id: Pointer; flags: ImGuiTreeNodeFlags; const fmt: PUTF8Char): Boolean varargs; cdecl;
  igTreeNodeExV_Str: function(const str_id: PUTF8Char; flags: ImGuiTreeNodeFlags; const fmt: PUTF8Char; args: Pointer): Boolean; cdecl;
  igTreeNodeExV_Ptr: function(const ptr_id: Pointer; flags: ImGuiTreeNodeFlags; const fmt: PUTF8Char; args: Pointer): Boolean; cdecl;
  igTreePush_Str: procedure(const str_id: PUTF8Char); cdecl;
  igTreePush_Ptr: procedure(const ptr_id: Pointer); cdecl;
  igTreePop: procedure(); cdecl;
  igGetTreeNodeToLabelSpacing: function(): Single; cdecl;
  igCollapsingHeader_TreeNodeFlags: function(const &label: PUTF8Char; flags: ImGuiTreeNodeFlags): Boolean; cdecl;
  igCollapsingHeader_BoolPtr: function(const &label: PUTF8Char; p_visible: PBoolean; flags: ImGuiTreeNodeFlags): Boolean; cdecl;
  igSetNextItemOpen: procedure(is_open: Boolean; cond: ImGuiCond); cdecl;
  igSetNextItemStorageID: procedure(storage_id: ImGuiID); cdecl;
  igSelectable_Bool: function(const &label: PUTF8Char; selected: Boolean; flags: ImGuiSelectableFlags; size: ImVec2): Boolean; cdecl;
  igSelectable_BoolPtr: function(const &label: PUTF8Char; p_selected: PBoolean; flags: ImGuiSelectableFlags; size: ImVec2): Boolean; cdecl;
  igBeginMultiSelect: function(flags: ImGuiMultiSelectFlags; selection_size: Integer; items_count: Integer): PImGuiMultiSelectIO; cdecl;
  igEndMultiSelect: function(): PImGuiMultiSelectIO; cdecl;
  igSetNextItemSelectionUserData: procedure(selection_user_data: ImGuiSelectionUserData); cdecl;
  igIsItemToggledSelection: function(): Boolean; cdecl;
  igBeginListBox: function(const &label: PUTF8Char; size: ImVec2): Boolean; cdecl;
  igEndListBox: procedure(); cdecl;
  igListBox_Str_arr: function(const &label: PUTF8Char; current_item: PInteger; items: PPUTF8Char; items_count: Integer; height_in_items: Integer): Boolean; cdecl;
  igListBox_FnStrPtr: function(const &label: PUTF8Char; current_item: PInteger; getter: igListBox_FnStrPtr_getter; user_data: Pointer; items_count: Integer; height_in_items: Integer): Boolean; cdecl;
  igPlotLines_FloatPtr: procedure(const &label: PUTF8Char; const values: PSingle; values_count: Integer; values_offset: Integer; const overlay_text: PUTF8Char; scale_min: Single; scale_max: Single; graph_size: ImVec2; stride: Integer); cdecl;
  igPlotLines_FnFloatPtr: procedure(const &label: PUTF8Char; values_getter: igPlotLines_FnFloatPtr_values_getter; data: Pointer; values_count: Integer; values_offset: Integer; const overlay_text: PUTF8Char; scale_min: Single; scale_max: Single; graph_size: ImVec2); cdecl;
  igPlotHistogram_FloatPtr: procedure(const &label: PUTF8Char; const values: PSingle; values_count: Integer; values_offset: Integer; const overlay_text: PUTF8Char; scale_min: Single; scale_max: Single; graph_size: ImVec2; stride: Integer); cdecl;
  igPlotHistogram_FnFloatPtr: procedure(const &label: PUTF8Char; values_getter: igPlotHistogram_FnFloatPtr_values_getter; data: Pointer; values_count: Integer; values_offset: Integer; const overlay_text: PUTF8Char; scale_min: Single; scale_max: Single; graph_size: ImVec2); cdecl;
  igValue_Bool: procedure(const prefix: PUTF8Char; b: Boolean); cdecl;
  igValue_Int: procedure(const prefix: PUTF8Char; v: Integer); cdecl;
  igValue_Uint: procedure(const prefix: PUTF8Char; v: Cardinal); cdecl;
  igValue_Float: procedure(const prefix: PUTF8Char; v: Single; const float_format: PUTF8Char); cdecl;
  igBeginMenuBar: function(): Boolean; cdecl;
  igEndMenuBar: procedure(); cdecl;
  igBeginMainMenuBar: function(): Boolean; cdecl;
  igEndMainMenuBar: procedure(); cdecl;
  igBeginMenu: function(const &label: PUTF8Char; enabled: Boolean): Boolean; cdecl;
  igEndMenu: procedure(); cdecl;
  igMenuItem_Bool: function(const &label: PUTF8Char; const shortcut: PUTF8Char; selected: Boolean; enabled: Boolean): Boolean; cdecl;
  igMenuItem_BoolPtr: function(const &label: PUTF8Char; const shortcut: PUTF8Char; p_selected: PBoolean; enabled: Boolean): Boolean; cdecl;
  igBeginTooltip: function(): Boolean; cdecl;
  igEndTooltip: procedure(); cdecl;
  igSetTooltip: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igSetTooltipV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igBeginItemTooltip: function(): Boolean; cdecl;
  igSetItemTooltip: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igSetItemTooltipV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igBeginPopup: function(const str_id: PUTF8Char; flags: ImGuiWindowFlags): Boolean; cdecl;
  igBeginPopupModal: function(const name: PUTF8Char; p_open: PBoolean; flags: ImGuiWindowFlags): Boolean; cdecl;
  igEndPopup: procedure(); cdecl;
  igOpenPopup_Str: procedure(const str_id: PUTF8Char; popup_flags: ImGuiPopupFlags); cdecl;
  igOpenPopup_ID: procedure(id: ImGuiID; popup_flags: ImGuiPopupFlags); cdecl;
  igOpenPopupOnItemClick: procedure(const str_id: PUTF8Char; popup_flags: ImGuiPopupFlags); cdecl;
  igCloseCurrentPopup: procedure(); cdecl;
  igBeginPopupContextItem: function(const str_id: PUTF8Char; popup_flags: ImGuiPopupFlags): Boolean; cdecl;
  igBeginPopupContextWindow: function(const str_id: PUTF8Char; popup_flags: ImGuiPopupFlags): Boolean; cdecl;
  igBeginPopupContextVoid: function(const str_id: PUTF8Char; popup_flags: ImGuiPopupFlags): Boolean; cdecl;
  igIsPopupOpen_Str: function(const str_id: PUTF8Char; flags: ImGuiPopupFlags): Boolean; cdecl;
  igBeginTable: function(const str_id: PUTF8Char; columns: Integer; flags: ImGuiTableFlags; outer_size: ImVec2; inner_width: Single): Boolean; cdecl;
  igEndTable: procedure(); cdecl;
  igTableNextRow: procedure(row_flags: ImGuiTableRowFlags; min_row_height: Single); cdecl;
  igTableNextColumn: function(): Boolean; cdecl;
  igTableSetColumnIndex: function(column_n: Integer): Boolean; cdecl;
  igTableSetupColumn: procedure(const &label: PUTF8Char; flags: ImGuiTableColumnFlags; init_width_or_weight: Single; user_id: ImGuiID); cdecl;
  igTableSetupScrollFreeze: procedure(cols: Integer; rows: Integer); cdecl;
  igTableHeader: procedure(const &label: PUTF8Char); cdecl;
  igTableHeadersRow: procedure(); cdecl;
  igTableAngledHeadersRow: procedure(); cdecl;
  igTableGetSortSpecs: function(): PImGuiTableSortSpecs; cdecl;
  igTableGetColumnCount: function(): Integer; cdecl;
  igTableGetColumnIndex: function(): Integer; cdecl;
  igTableGetRowIndex: function(): Integer; cdecl;
  igTableGetColumnName_Int: function(column_n: Integer): PUTF8Char; cdecl;
  igTableGetColumnFlags: function(column_n: Integer): ImGuiTableColumnFlags; cdecl;
  igTableSetColumnEnabled: procedure(column_n: Integer; v: Boolean); cdecl;
  igTableGetHoveredColumn: function(): Integer; cdecl;
  igTableSetBgColor: procedure(target: ImGuiTableBgTarget; color: ImU32; column_n: Integer); cdecl;
  igColumns: procedure(count: Integer; const id: PUTF8Char; borders: Boolean); cdecl;
  igNextColumn: procedure(); cdecl;
  igGetColumnIndex: function(): Integer; cdecl;
  igGetColumnWidth: function(column_index: Integer): Single; cdecl;
  igSetColumnWidth: procedure(column_index: Integer; width: Single); cdecl;
  igGetColumnOffset: function(column_index: Integer): Single; cdecl;
  igSetColumnOffset: procedure(column_index: Integer; offset_x: Single); cdecl;
  igGetColumnsCount: function(): Integer; cdecl;
  igBeginTabBar: function(const str_id: PUTF8Char; flags: ImGuiTabBarFlags): Boolean; cdecl;
  igEndTabBar: procedure(); cdecl;
  igBeginTabItem: function(const &label: PUTF8Char; p_open: PBoolean; flags: ImGuiTabItemFlags): Boolean; cdecl;
  igEndTabItem: procedure(); cdecl;
  igTabItemButton: function(const &label: PUTF8Char; flags: ImGuiTabItemFlags): Boolean; cdecl;
  igSetTabItemClosed: procedure(const tab_or_docked_window_label: PUTF8Char); cdecl;
  igDockSpace: function(dockspace_id: ImGuiID; size: ImVec2; flags: ImGuiDockNodeFlags; const window_class: PImGuiWindowClass): ImGuiID; cdecl;
  igDockSpaceOverViewport: function(dockspace_id: ImGuiID; const viewport: PImGuiViewport; flags: ImGuiDockNodeFlags; const window_class: PImGuiWindowClass): ImGuiID; cdecl;
  igSetNextWindowDockID: procedure(dock_id: ImGuiID; cond: ImGuiCond); cdecl;
  igSetNextWindowClass: procedure(const window_class: PImGuiWindowClass); cdecl;
  igGetWindowDockID: function(): ImGuiID; cdecl;
  igIsWindowDocked: function(): Boolean; cdecl;
  igLogToTTY: procedure(auto_open_depth: Integer); cdecl;
  igLogToFile: procedure(auto_open_depth: Integer; const filename: PUTF8Char); cdecl;
  igLogToClipboard: procedure(auto_open_depth: Integer); cdecl;
  igLogFinish: procedure(); cdecl;
  igLogButtons: procedure(); cdecl;
  igLogTextV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igBeginDragDropSource: function(flags: ImGuiDragDropFlags): Boolean; cdecl;
  igSetDragDropPayload: function(const &type: PUTF8Char; const data: Pointer; sz: NativeUInt; cond: ImGuiCond): Boolean; cdecl;
  igEndDragDropSource: procedure(); cdecl;
  igBeginDragDropTarget: function(): Boolean; cdecl;
  igAcceptDragDropPayload: function(const &type: PUTF8Char; flags: ImGuiDragDropFlags): PImGuiPayload; cdecl;
  igEndDragDropTarget: procedure(); cdecl;
  igGetDragDropPayload: function(): PImGuiPayload; cdecl;
  igBeginDisabled: procedure(disabled: Boolean); cdecl;
  igEndDisabled: procedure(); cdecl;
  igPushClipRect: procedure(clip_rect_min: ImVec2; clip_rect_max: ImVec2; intersect_with_current_clip_rect: Boolean); cdecl;
  igPopClipRect: procedure(); cdecl;
  igSetItemDefaultFocus: procedure(); cdecl;
  igSetKeyboardFocusHere: procedure(offset: Integer); cdecl;
  igSetNavCursorVisible: procedure(visible: Boolean); cdecl;
  igSetNextItemAllowOverlap: procedure(); cdecl;
  igIsItemHovered: function(flags: ImGuiHoveredFlags): Boolean; cdecl;
  igIsItemActive: function(): Boolean; cdecl;
  igIsItemFocused: function(): Boolean; cdecl;
  igIsItemClicked: function(mouse_button: ImGuiMouseButton): Boolean; cdecl;
  igIsItemVisible: function(): Boolean; cdecl;
  igIsItemEdited: function(): Boolean; cdecl;
  igIsItemActivated: function(): Boolean; cdecl;
  igIsItemDeactivated: function(): Boolean; cdecl;
  igIsItemDeactivatedAfterEdit: function(): Boolean; cdecl;
  igIsItemToggledOpen: function(): Boolean; cdecl;
  igIsAnyItemHovered: function(): Boolean; cdecl;
  igIsAnyItemActive: function(): Boolean; cdecl;
  igIsAnyItemFocused: function(): Boolean; cdecl;
  igGetItemID: function(): ImGuiID; cdecl;
  igGetItemRectMin: procedure(pOut: PImVec2); cdecl;
  igGetItemRectMax: procedure(pOut: PImVec2); cdecl;
  igGetItemRectSize: procedure(pOut: PImVec2); cdecl;
  igGetMainViewport: function(): PImGuiViewport; cdecl;
  igGetBackgroundDrawList: function(viewport: PImGuiViewport): PImDrawList; cdecl;
  igGetForegroundDrawList_ViewportPtr: function(viewport: PImGuiViewport): PImDrawList; cdecl;
  igIsRectVisible_Nil: function(size: ImVec2): Boolean; cdecl;
  igIsRectVisible_Vec2: function(rect_min: ImVec2; rect_max: ImVec2): Boolean; cdecl;
  igGetTime: function(): Double; cdecl;
  igGetFrameCount: function(): Integer; cdecl;
  igGetDrawListSharedData: function(): PImDrawListSharedData; cdecl;
  igGetStyleColorName: function(idx: ImGuiCol): PUTF8Char; cdecl;
  igSetStateStorage: procedure(storage: PImGuiStorage); cdecl;
  igGetStateStorage: function(): PImGuiStorage; cdecl;
  igCalcTextSize: procedure(pOut: PImVec2; const text: PUTF8Char; const text_end: PUTF8Char; hide_text_after_double_hash: Boolean; wrap_width: Single); cdecl;
  igColorConvertU32ToFloat4: procedure(pOut: PImVec4; &in: ImU32); cdecl;
  igColorConvertFloat4ToU32: function(&in: ImVec4): ImU32; cdecl;
  igColorConvertRGBtoHSV: procedure(r: Single; g: Single; b: Single; out_h: PSingle; out_s: PSingle; out_v: PSingle); cdecl;
  igColorConvertHSVtoRGB: procedure(h: Single; s: Single; v: Single; out_r: PSingle; out_g: PSingle; out_b: PSingle); cdecl;
  igIsKeyDown_Nil: function(key: ImGuiKey): Boolean; cdecl;
  igIsKeyPressed_Bool: function(key: ImGuiKey; &repeat: Boolean): Boolean; cdecl;
  igIsKeyReleased_Nil: function(key: ImGuiKey): Boolean; cdecl;
  igIsKeyChordPressed_Nil: function(key_chord: ImGuiKeyChord): Boolean; cdecl;
  igGetKeyPressedAmount: function(key: ImGuiKey; repeat_delay: Single; rate: Single): Integer; cdecl;
  igGetKeyName: function(key: ImGuiKey): PUTF8Char; cdecl;
  igSetNextFrameWantCaptureKeyboard: procedure(want_capture_keyboard: Boolean); cdecl;
  igShortcut_Nil: function(key_chord: ImGuiKeyChord; flags: ImGuiInputFlags): Boolean; cdecl;
  igSetNextItemShortcut: procedure(key_chord: ImGuiKeyChord; flags: ImGuiInputFlags); cdecl;
  igSetItemKeyOwner_Nil: procedure(key: ImGuiKey); cdecl;
  igIsMouseDown_Nil: function(button: ImGuiMouseButton): Boolean; cdecl;
  igIsMouseClicked_Bool: function(button: ImGuiMouseButton; &repeat: Boolean): Boolean; cdecl;
  igIsMouseReleased_Nil: function(button: ImGuiMouseButton): Boolean; cdecl;
  igIsMouseDoubleClicked_Nil: function(button: ImGuiMouseButton): Boolean; cdecl;
  igIsMouseReleasedWithDelay: function(button: ImGuiMouseButton; delay: Single): Boolean; cdecl;
  igGetMouseClickedCount: function(button: ImGuiMouseButton): Integer; cdecl;
  igIsMouseHoveringRect: function(r_min: ImVec2; r_max: ImVec2; clip: Boolean): Boolean; cdecl;
  igIsMousePosValid: function(const mouse_pos: PImVec2): Boolean; cdecl;
  igIsAnyMouseDown: function(): Boolean; cdecl;
  igGetMousePos: procedure(pOut: PImVec2); cdecl;
  igGetMousePosOnOpeningCurrentPopup: procedure(pOut: PImVec2); cdecl;
  igIsMouseDragging: function(button: ImGuiMouseButton; lock_threshold: Single): Boolean; cdecl;
  igGetMouseDragDelta: procedure(pOut: PImVec2; button: ImGuiMouseButton; lock_threshold: Single); cdecl;
  igResetMouseDragDelta: procedure(button: ImGuiMouseButton); cdecl;
  igGetMouseCursor: function(): ImGuiMouseCursor; cdecl;
  igSetMouseCursor: procedure(cursor_type: ImGuiMouseCursor); cdecl;
  igSetNextFrameWantCaptureMouse: procedure(want_capture_mouse: Boolean); cdecl;
  igGetClipboardText: function(): PUTF8Char; cdecl;
  igSetClipboardText: procedure(const text: PUTF8Char); cdecl;
  igLoadIniSettingsFromDisk: procedure(const ini_filename: PUTF8Char); cdecl;
  igLoadIniSettingsFromMemory: procedure(const ini_data: PUTF8Char; ini_size: NativeUInt); cdecl;
  igSaveIniSettingsToDisk: procedure(const ini_filename: PUTF8Char); cdecl;
  igSaveIniSettingsToMemory: function(out_ini_size: PNativeUInt): PUTF8Char; cdecl;
  igDebugTextEncoding: procedure(const text: PUTF8Char); cdecl;
  igDebugFlashStyleColor: procedure(idx: ImGuiCol); cdecl;
  igDebugStartItemPicker: procedure(); cdecl;
  igDebugCheckVersionAndDataLayout: function(const version_str: PUTF8Char; sz_io: NativeUInt; sz_style: NativeUInt; sz_vec2: NativeUInt; sz_vec4: NativeUInt; sz_drawvert: NativeUInt; sz_drawidx: NativeUInt): Boolean; cdecl;
  igDebugLog: procedure(const fmt: PUTF8Char) varargs; cdecl;
  igDebugLogV: procedure(const fmt: PUTF8Char; args: Pointer); cdecl;
  igSetAllocatorFunctions: procedure(alloc_func: ImGuiMemAllocFunc; free_func: ImGuiMemFreeFunc; user_data: Pointer); cdecl;
  igGetAllocatorFunctions: procedure(p_alloc_func: PImGuiMemAllocFunc; p_free_func: PImGuiMemFreeFunc; p_user_data: PPointer); cdecl;
  igMemAlloc: function(size: NativeUInt): Pointer; cdecl;
  igMemFree: procedure(ptr: Pointer); cdecl;
  igUpdatePlatformWindows: procedure(); cdecl;
  igRenderPlatformWindowsDefault: procedure(platform_render_arg: Pointer; renderer_render_arg: Pointer); cdecl;
  igDestroyPlatformWindows: procedure(); cdecl;
  igFindViewportByID: function(id: ImGuiID): PImGuiViewport; cdecl;
  igFindViewportByPlatformHandle: function(platform_handle: Pointer): PImGuiViewport; cdecl;
  ImGuiTableSortSpecs_ImGuiTableSortSpecs: function(): PImGuiTableSortSpecs; cdecl;
  ImGuiTableSortSpecs_destroy: procedure(self: PImGuiTableSortSpecs); cdecl;
  ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs: function(): PImGuiTableColumnSortSpecs; cdecl;
  ImGuiTableColumnSortSpecs_destroy: procedure(self: PImGuiTableColumnSortSpecs); cdecl;
  ImGuiStyle_ImGuiStyle: function(): PImGuiStyle; cdecl;
  ImGuiStyle_destroy: procedure(self: PImGuiStyle); cdecl;
  ImGuiStyle_ScaleAllSizes: procedure(self: PImGuiStyle; scale_factor: Single); cdecl;
  ImGuiIO_AddKeyEvent: procedure(self: PImGuiIO; key: ImGuiKey; down: Boolean); cdecl;
  ImGuiIO_AddKeyAnalogEvent: procedure(self: PImGuiIO; key: ImGuiKey; down: Boolean; v: Single); cdecl;
  ImGuiIO_AddMousePosEvent: procedure(self: PImGuiIO; x: Single; y: Single); cdecl;
  ImGuiIO_AddMouseButtonEvent: procedure(self: PImGuiIO; button: Integer; down: Boolean); cdecl;
  ImGuiIO_AddMouseWheelEvent: procedure(self: PImGuiIO; wheel_x: Single; wheel_y: Single); cdecl;
  ImGuiIO_AddMouseSourceEvent: procedure(self: PImGuiIO; source: ImGuiMouseSource); cdecl;
  ImGuiIO_AddMouseViewportEvent: procedure(self: PImGuiIO; id: ImGuiID); cdecl;
  ImGuiIO_AddFocusEvent: procedure(self: PImGuiIO; focused: Boolean); cdecl;
  ImGuiIO_AddInputCharacter: procedure(self: PImGuiIO; c: Cardinal); cdecl;
  ImGuiIO_AddInputCharacterUTF16: procedure(self: PImGuiIO; c: ImWchar16); cdecl;
  ImGuiIO_AddInputCharactersUTF8: procedure(self: PImGuiIO; const str: PUTF8Char); cdecl;
  ImGuiIO_SetKeyEventNativeData: procedure(self: PImGuiIO; key: ImGuiKey; native_keycode: Integer; native_scancode: Integer; native_legacy_index: Integer); cdecl;
  ImGuiIO_SetAppAcceptingEvents: procedure(self: PImGuiIO; accepting_events: Boolean); cdecl;
  ImGuiIO_ClearEventsQueue: procedure(self: PImGuiIO); cdecl;
  ImGuiIO_ClearInputKeys: procedure(self: PImGuiIO); cdecl;
  ImGuiIO_ClearInputMouse: procedure(self: PImGuiIO); cdecl;
  ImGuiIO_ImGuiIO: function(): PImGuiIO; cdecl;
  ImGuiIO_destroy: procedure(self: PImGuiIO); cdecl;
  ImGuiInputTextCallbackData_ImGuiInputTextCallbackData: function(): PImGuiInputTextCallbackData; cdecl;
  ImGuiInputTextCallbackData_destroy: procedure(self: PImGuiInputTextCallbackData); cdecl;
  ImGuiInputTextCallbackData_DeleteChars: procedure(self: PImGuiInputTextCallbackData; pos: Integer; bytes_count: Integer); cdecl;
  ImGuiInputTextCallbackData_InsertChars: procedure(self: PImGuiInputTextCallbackData; pos: Integer; const text: PUTF8Char; const text_end: PUTF8Char); cdecl;
  ImGuiInputTextCallbackData_SelectAll: procedure(self: PImGuiInputTextCallbackData); cdecl;
  ImGuiInputTextCallbackData_ClearSelection: procedure(self: PImGuiInputTextCallbackData); cdecl;
  ImGuiInputTextCallbackData_HasSelection: function(self: PImGuiInputTextCallbackData): Boolean; cdecl;
  ImGuiWindowClass_ImGuiWindowClass: function(): PImGuiWindowClass; cdecl;
  ImGuiWindowClass_destroy: procedure(self: PImGuiWindowClass); cdecl;
  ImGuiPayload_ImGuiPayload: function(): PImGuiPayload; cdecl;
  ImGuiPayload_destroy: procedure(self: PImGuiPayload); cdecl;
  ImGuiPayload_Clear: procedure(self: PImGuiPayload); cdecl;
  ImGuiPayload_IsDataType: function(self: PImGuiPayload; const &type: PUTF8Char): Boolean; cdecl;
  ImGuiPayload_IsPreview: function(self: PImGuiPayload): Boolean; cdecl;
  ImGuiPayload_IsDelivery: function(self: PImGuiPayload): Boolean; cdecl;
  ImGuiOnceUponAFrame_ImGuiOnceUponAFrame: function(): PImGuiOnceUponAFrame; cdecl;
  ImGuiOnceUponAFrame_destroy: procedure(self: PImGuiOnceUponAFrame); cdecl;
  ImGuiTextFilter_ImGuiTextFilter: function(const default_filter: PUTF8Char): PImGuiTextFilter; cdecl;
  ImGuiTextFilter_destroy: procedure(self: PImGuiTextFilter); cdecl;
  ImGuiTextFilter_Draw: function(self: PImGuiTextFilter; const &label: PUTF8Char; width: Single): Boolean; cdecl;
  ImGuiTextFilter_PassFilter: function(self: PImGuiTextFilter; const text: PUTF8Char; const text_end: PUTF8Char): Boolean; cdecl;
  ImGuiTextFilter_Build: procedure(self: PImGuiTextFilter); cdecl;
  ImGuiTextFilter_Clear: procedure(self: PImGuiTextFilter); cdecl;
  ImGuiTextFilter_IsActive: function(self: PImGuiTextFilter): Boolean; cdecl;
  ImGuiTextRange_ImGuiTextRange_Nil: function(): PImGuiTextRange; cdecl;
  ImGuiTextRange_destroy: procedure(self: PImGuiTextRange); cdecl;
  ImGuiTextRange_ImGuiTextRange_Str: function(const _b: PUTF8Char; const _e: PUTF8Char): PImGuiTextRange; cdecl;
  ImGuiTextRange_empty: function(self: PImGuiTextRange): Boolean; cdecl;
  ImGuiTextRange_split: procedure(self: PImGuiTextRange; separator: UTF8Char; &out: PImVector_ImGuiTextRange); cdecl;
  ImGuiTextBuffer_ImGuiTextBuffer: function(): PImGuiTextBuffer; cdecl;
  ImGuiTextBuffer_destroy: procedure(self: PImGuiTextBuffer); cdecl;
  ImGuiTextBuffer_begin: function(self: PImGuiTextBuffer): PUTF8Char; cdecl;
  ImGuiTextBuffer_end: function(self: PImGuiTextBuffer): PUTF8Char; cdecl;
  ImGuiTextBuffer_size: function(self: PImGuiTextBuffer): Integer; cdecl;
  ImGuiTextBuffer_empty: function(self: PImGuiTextBuffer): Boolean; cdecl;
  ImGuiTextBuffer_clear: procedure(self: PImGuiTextBuffer); cdecl;
  ImGuiTextBuffer_reserve: procedure(self: PImGuiTextBuffer; capacity: Integer); cdecl;
  ImGuiTextBuffer_c_str: function(self: PImGuiTextBuffer): PUTF8Char; cdecl;
  ImGuiTextBuffer_append: procedure(self: PImGuiTextBuffer; const str: PUTF8Char; const str_end: PUTF8Char); cdecl;
  ImGuiTextBuffer_appendfv: procedure(self: PImGuiTextBuffer; const fmt: PUTF8Char; args: Pointer); cdecl;
  ImGuiStoragePair_ImGuiStoragePair_Int: function(_key: ImGuiID; _val: Integer): PImGuiStoragePair; cdecl;
  ImGuiStoragePair_destroy: procedure(self: PImGuiStoragePair); cdecl;
  ImGuiStoragePair_ImGuiStoragePair_Float: function(_key: ImGuiID; _val: Single): PImGuiStoragePair; cdecl;
  ImGuiStoragePair_ImGuiStoragePair_Ptr: function(_key: ImGuiID; _val: Pointer): PImGuiStoragePair; cdecl;
  ImGuiStorage_Clear: procedure(self: PImGuiStorage); cdecl;
  ImGuiStorage_GetInt: function(self: PImGuiStorage; key: ImGuiID; default_val: Integer): Integer; cdecl;
  ImGuiStorage_SetInt: procedure(self: PImGuiStorage; key: ImGuiID; val: Integer); cdecl;
  ImGuiStorage_GetBool: function(self: PImGuiStorage; key: ImGuiID; default_val: Boolean): Boolean; cdecl;
  ImGuiStorage_SetBool: procedure(self: PImGuiStorage; key: ImGuiID; val: Boolean); cdecl;
  ImGuiStorage_GetFloat: function(self: PImGuiStorage; key: ImGuiID; default_val: Single): Single; cdecl;
  ImGuiStorage_SetFloat: procedure(self: PImGuiStorage; key: ImGuiID; val: Single); cdecl;
  ImGuiStorage_GetVoidPtr: function(self: PImGuiStorage; key: ImGuiID): Pointer; cdecl;
  ImGuiStorage_SetVoidPtr: procedure(self: PImGuiStorage; key: ImGuiID; val: Pointer); cdecl;
  ImGuiStorage_GetIntRef: function(self: PImGuiStorage; key: ImGuiID; default_val: Integer): PInteger; cdecl;
  ImGuiStorage_GetBoolRef: function(self: PImGuiStorage; key: ImGuiID; default_val: Boolean): PBoolean; cdecl;
  ImGuiStorage_GetFloatRef: function(self: PImGuiStorage; key: ImGuiID; default_val: Single): PSingle; cdecl;
  ImGuiStorage_GetVoidPtrRef: function(self: PImGuiStorage; key: ImGuiID; default_val: Pointer): PPointer; cdecl;
  ImGuiStorage_BuildSortByKey: procedure(self: PImGuiStorage); cdecl;
  ImGuiStorage_SetAllInt: procedure(self: PImGuiStorage; val: Integer); cdecl;
  ImGuiListClipper_ImGuiListClipper: function(): PImGuiListClipper; cdecl;
  ImGuiListClipper_destroy: procedure(self: PImGuiListClipper); cdecl;
  ImGuiListClipper_Begin: procedure(self: PImGuiListClipper; items_count: Integer; items_height: Single); cdecl;
  ImGuiListClipper_End: procedure(self: PImGuiListClipper); cdecl;
  ImGuiListClipper_Step: function(self: PImGuiListClipper): Boolean; cdecl;
  ImGuiListClipper_IncludeItemByIndex: procedure(self: PImGuiListClipper; item_index: Integer); cdecl;
  ImGuiListClipper_IncludeItemsByIndex: procedure(self: PImGuiListClipper; item_begin: Integer; item_end: Integer); cdecl;
  ImGuiListClipper_SeekCursorForItem: procedure(self: PImGuiListClipper; item_index: Integer); cdecl;
  ImColor_ImColor_Nil: function(): PImColor; cdecl;
  ImColor_destroy: procedure(self: PImColor); cdecl;
  ImColor_ImColor_Float: function(r: Single; g: Single; b: Single; a: Single): PImColor; cdecl;
  ImColor_ImColor_Vec4: function(col: ImVec4): PImColor; cdecl;
  ImColor_ImColor_Int: function(r: Integer; g: Integer; b: Integer; a: Integer): PImColor; cdecl;
  ImColor_ImColor_U32: function(rgba: ImU32): PImColor; cdecl;
  ImColor_SetHSV: procedure(self: PImColor; h: Single; s: Single; v: Single; a: Single); cdecl;
  ImColor_HSV: procedure(pOut: PImColor; h: Single; s: Single; v: Single; a: Single); cdecl;
  ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage: function(): PImGuiSelectionBasicStorage; cdecl;
  ImGuiSelectionBasicStorage_destroy: procedure(self: PImGuiSelectionBasicStorage); cdecl;
  ImGuiSelectionBasicStorage_ApplyRequests: procedure(self: PImGuiSelectionBasicStorage; ms_io: PImGuiMultiSelectIO); cdecl;
  ImGuiSelectionBasicStorage_Contains: function(self: PImGuiSelectionBasicStorage; id: ImGuiID): Boolean; cdecl;
  ImGuiSelectionBasicStorage_Clear: procedure(self: PImGuiSelectionBasicStorage); cdecl;
  ImGuiSelectionBasicStorage_Swap: procedure(self: PImGuiSelectionBasicStorage; r: PImGuiSelectionBasicStorage); cdecl;
  ImGuiSelectionBasicStorage_SetItemSelected: procedure(self: PImGuiSelectionBasicStorage; id: ImGuiID; selected: Boolean); cdecl;
  ImGuiSelectionBasicStorage_GetNextSelectedItem: function(self: PImGuiSelectionBasicStorage; opaque_it: PPointer; out_id: PImGuiID): Boolean; cdecl;
  ImGuiSelectionBasicStorage_GetStorageIdFromIndex: function(self: PImGuiSelectionBasicStorage; idx: Integer): ImGuiID; cdecl;
  ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage: function(): PImGuiSelectionExternalStorage; cdecl;
  ImGuiSelectionExternalStorage_destroy: procedure(self: PImGuiSelectionExternalStorage); cdecl;
  ImGuiSelectionExternalStorage_ApplyRequests: procedure(self: PImGuiSelectionExternalStorage; ms_io: PImGuiMultiSelectIO); cdecl;
  ImDrawCmd_ImDrawCmd: function(): PImDrawCmd; cdecl;
  ImDrawCmd_destroy: procedure(self: PImDrawCmd); cdecl;
  ImDrawCmd_GetTexID: function(self: PImDrawCmd): ImTextureID; cdecl;
  ImDrawListSplitter_ImDrawListSplitter: function(): PImDrawListSplitter; cdecl;
  ImDrawListSplitter_destroy: procedure(self: PImDrawListSplitter); cdecl;
  ImDrawListSplitter_Clear: procedure(self: PImDrawListSplitter); cdecl;
  ImDrawListSplitter_ClearFreeMemory: procedure(self: PImDrawListSplitter); cdecl;
  ImDrawListSplitter_Split: procedure(self: PImDrawListSplitter; draw_list: PImDrawList; count: Integer); cdecl;
  ImDrawListSplitter_Merge: procedure(self: PImDrawListSplitter; draw_list: PImDrawList); cdecl;
  ImDrawListSplitter_SetCurrentChannel: procedure(self: PImDrawListSplitter; draw_list: PImDrawList; channel_idx: Integer); cdecl;
  ImDrawList_ImDrawList: function(shared_data: PImDrawListSharedData): PImDrawList; cdecl;
  ImDrawList_destroy: procedure(self: PImDrawList); cdecl;
  ImDrawList_PushClipRect: procedure(self: PImDrawList; clip_rect_min: ImVec2; clip_rect_max: ImVec2; intersect_with_current_clip_rect: Boolean); cdecl;
  ImDrawList_PushClipRectFullScreen: procedure(self: PImDrawList); cdecl;
  ImDrawList_PopClipRect: procedure(self: PImDrawList); cdecl;
  ImDrawList_PushTextureID: procedure(self: PImDrawList; texture_id: ImTextureID); cdecl;
  ImDrawList_PopTextureID: procedure(self: PImDrawList); cdecl;
  ImDrawList_GetClipRectMin: procedure(pOut: PImVec2; self: PImDrawList); cdecl;
  ImDrawList_GetClipRectMax: procedure(pOut: PImVec2; self: PImDrawList); cdecl;
  ImDrawList_AddLine: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; col: ImU32; thickness: Single); cdecl;
  ImDrawList_AddRect: procedure(self: PImDrawList; p_min: ImVec2; p_max: ImVec2; col: ImU32; rounding: Single; flags: ImDrawFlags; thickness: Single); cdecl;
  ImDrawList_AddRectFilled: procedure(self: PImDrawList; p_min: ImVec2; p_max: ImVec2; col: ImU32; rounding: Single; flags: ImDrawFlags); cdecl;
  ImDrawList_AddRectFilledMultiColor: procedure(self: PImDrawList; p_min: ImVec2; p_max: ImVec2; col_upr_left: ImU32; col_upr_right: ImU32; col_bot_right: ImU32; col_bot_left: ImU32); cdecl;
  ImDrawList_AddQuad: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; col: ImU32; thickness: Single); cdecl;
  ImDrawList_AddQuadFilled: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; col: ImU32); cdecl;
  ImDrawList_AddTriangle: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; col: ImU32; thickness: Single); cdecl;
  ImDrawList_AddTriangleFilled: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; col: ImU32); cdecl;
  ImDrawList_AddCircle: procedure(self: PImDrawList; center: ImVec2; radius: Single; col: ImU32; num_segments: Integer; thickness: Single); cdecl;
  ImDrawList_AddCircleFilled: procedure(self: PImDrawList; center: ImVec2; radius: Single; col: ImU32; num_segments: Integer); cdecl;
  ImDrawList_AddNgon: procedure(self: PImDrawList; center: ImVec2; radius: Single; col: ImU32; num_segments: Integer; thickness: Single); cdecl;
  ImDrawList_AddNgonFilled: procedure(self: PImDrawList; center: ImVec2; radius: Single; col: ImU32; num_segments: Integer); cdecl;
  ImDrawList_AddEllipse: procedure(self: PImDrawList; center: ImVec2; radius: ImVec2; col: ImU32; rot: Single; num_segments: Integer; thickness: Single); cdecl;
  ImDrawList_AddEllipseFilled: procedure(self: PImDrawList; center: ImVec2; radius: ImVec2; col: ImU32; rot: Single; num_segments: Integer); cdecl;
  ImDrawList_AddText_Vec2: procedure(self: PImDrawList; pos: ImVec2; col: ImU32; const text_begin: PUTF8Char; const text_end: PUTF8Char); cdecl;
  ImDrawList_AddText_FontPtr: procedure(self: PImDrawList; font: PImFont; font_size: Single; pos: ImVec2; col: ImU32; const text_begin: PUTF8Char; const text_end: PUTF8Char; wrap_width: Single; const cpu_fine_clip_rect: PImVec4); cdecl;
  ImDrawList_AddBezierCubic: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; col: ImU32; thickness: Single; num_segments: Integer); cdecl;
  ImDrawList_AddBezierQuadratic: procedure(self: PImDrawList; p1: ImVec2; p2: ImVec2; p3: ImVec2; col: ImU32; thickness: Single; num_segments: Integer); cdecl;
  ImDrawList_AddPolyline: procedure(self: PImDrawList; const points: PImVec2; num_points: Integer; col: ImU32; flags: ImDrawFlags; thickness: Single); cdecl;
  ImDrawList_AddConvexPolyFilled: procedure(self: PImDrawList; const points: PImVec2; num_points: Integer; col: ImU32); cdecl;
  ImDrawList_AddConcavePolyFilled: procedure(self: PImDrawList; const points: PImVec2; num_points: Integer; col: ImU32); cdecl;
  ImDrawList_AddImage: procedure(self: PImDrawList; user_texture_id: ImTextureID; p_min: ImVec2; p_max: ImVec2; uv_min: ImVec2; uv_max: ImVec2; col: ImU32); cdecl;
  ImDrawList_AddImageQuad: procedure(self: PImDrawList; user_texture_id: ImTextureID; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; uv1: ImVec2; uv2: ImVec2; uv3: ImVec2; uv4: ImVec2; col: ImU32); cdecl;
  ImDrawList_AddImageRounded: procedure(self: PImDrawList; user_texture_id: ImTextureID; p_min: ImVec2; p_max: ImVec2; uv_min: ImVec2; uv_max: ImVec2; col: ImU32; rounding: Single; flags: ImDrawFlags); cdecl;
  ImDrawList_PathClear: procedure(self: PImDrawList); cdecl;
  ImDrawList_PathLineTo: procedure(self: PImDrawList; pos: ImVec2); cdecl;
  ImDrawList_PathLineToMergeDuplicate: procedure(self: PImDrawList; pos: ImVec2); cdecl;
  ImDrawList_PathFillConvex: procedure(self: PImDrawList; col: ImU32); cdecl;
  ImDrawList_PathFillConcave: procedure(self: PImDrawList; col: ImU32); cdecl;
  ImDrawList_PathStroke: procedure(self: PImDrawList; col: ImU32; flags: ImDrawFlags; thickness: Single); cdecl;
  ImDrawList_PathArcTo: procedure(self: PImDrawList; center: ImVec2; radius: Single; a_min: Single; a_max: Single; num_segments: Integer); cdecl;
  ImDrawList_PathArcToFast: procedure(self: PImDrawList; center: ImVec2; radius: Single; a_min_of_12: Integer; a_max_of_12: Integer); cdecl;
  ImDrawList_PathEllipticalArcTo: procedure(self: PImDrawList; center: ImVec2; radius: ImVec2; rot: Single; a_min: Single; a_max: Single; num_segments: Integer); cdecl;
  ImDrawList_PathBezierCubicCurveTo: procedure(self: PImDrawList; p2: ImVec2; p3: ImVec2; p4: ImVec2; num_segments: Integer); cdecl;
  ImDrawList_PathBezierQuadraticCurveTo: procedure(self: PImDrawList; p2: ImVec2; p3: ImVec2; num_segments: Integer); cdecl;
  ImDrawList_PathRect: procedure(self: PImDrawList; rect_min: ImVec2; rect_max: ImVec2; rounding: Single; flags: ImDrawFlags); cdecl;
  ImDrawList_AddCallback: procedure(self: PImDrawList; callback: ImDrawCallback; userdata: Pointer; userdata_size: NativeUInt); cdecl;
  ImDrawList_AddDrawCmd: procedure(self: PImDrawList); cdecl;
  ImDrawList_CloneOutput: function(self: PImDrawList): PImDrawList; cdecl;
  ImDrawList_ChannelsSplit: procedure(self: PImDrawList; count: Integer); cdecl;
  ImDrawList_ChannelsMerge: procedure(self: PImDrawList); cdecl;
  ImDrawList_ChannelsSetCurrent: procedure(self: PImDrawList; n: Integer); cdecl;
  ImDrawList_PrimReserve: procedure(self: PImDrawList; idx_count: Integer; vtx_count: Integer); cdecl;
  ImDrawList_PrimUnreserve: procedure(self: PImDrawList; idx_count: Integer; vtx_count: Integer); cdecl;
  ImDrawList_PrimRect: procedure(self: PImDrawList; a: ImVec2; b: ImVec2; col: ImU32); cdecl;
  ImDrawList_PrimRectUV: procedure(self: PImDrawList; a: ImVec2; b: ImVec2; uv_a: ImVec2; uv_b: ImVec2; col: ImU32); cdecl;
  ImDrawList_PrimQuadUV: procedure(self: PImDrawList; a: ImVec2; b: ImVec2; c: ImVec2; d: ImVec2; uv_a: ImVec2; uv_b: ImVec2; uv_c: ImVec2; uv_d: ImVec2; col: ImU32); cdecl;
  ImDrawList_PrimWriteVtx: procedure(self: PImDrawList; pos: ImVec2; uv: ImVec2; col: ImU32); cdecl;
  ImDrawList_PrimWriteIdx: procedure(self: PImDrawList; idx: ImDrawIdx); cdecl;
  ImDrawList_PrimVtx: procedure(self: PImDrawList; pos: ImVec2; uv: ImVec2; col: ImU32); cdecl;
  ImDrawList__ResetForNewFrame: procedure(self: PImDrawList); cdecl;
  ImDrawList__ClearFreeMemory: procedure(self: PImDrawList); cdecl;
  ImDrawList__PopUnusedDrawCmd: procedure(self: PImDrawList); cdecl;
  ImDrawList__TryMergeDrawCmds: procedure(self: PImDrawList); cdecl;
  ImDrawList__OnChangedClipRect: procedure(self: PImDrawList); cdecl;
  ImDrawList__OnChangedTextureID: procedure(self: PImDrawList); cdecl;
  ImDrawList__OnChangedVtxOffset: procedure(self: PImDrawList); cdecl;
  ImDrawList__SetTextureID: procedure(self: PImDrawList; texture_id: ImTextureID); cdecl;
  ImDrawList__CalcCircleAutoSegmentCount: function(self: PImDrawList; radius: Single): Integer; cdecl;
  ImDrawList__PathArcToFastEx: procedure(self: PImDrawList; center: ImVec2; radius: Single; a_min_sample: Integer; a_max_sample: Integer; a_step: Integer); cdecl;
  ImDrawList__PathArcToN: procedure(self: PImDrawList; center: ImVec2; radius: Single; a_min: Single; a_max: Single; num_segments: Integer); cdecl;
  ImDrawData_ImDrawData: function(): PImDrawData; cdecl;
  ImDrawData_destroy: procedure(self: PImDrawData); cdecl;
  ImDrawData_Clear: procedure(self: PImDrawData); cdecl;
  ImDrawData_AddDrawList: procedure(self: PImDrawData; draw_list: PImDrawList); cdecl;
  ImDrawData_DeIndexAllBuffers: procedure(self: PImDrawData); cdecl;
  ImDrawData_ScaleClipRects: procedure(self: PImDrawData; fb_scale: ImVec2); cdecl;
  ImFontConfig_ImFontConfig: function(): PImFontConfig; cdecl;
  ImFontConfig_destroy: procedure(self: PImFontConfig); cdecl;
  ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder: function(): PImFontGlyphRangesBuilder; cdecl;
  ImFontGlyphRangesBuilder_destroy: procedure(self: PImFontGlyphRangesBuilder); cdecl;
  ImFontGlyphRangesBuilder_Clear: procedure(self: PImFontGlyphRangesBuilder); cdecl;
  ImFontGlyphRangesBuilder_GetBit: function(self: PImFontGlyphRangesBuilder; n: NativeUInt): Boolean; cdecl;
  ImFontGlyphRangesBuilder_SetBit: procedure(self: PImFontGlyphRangesBuilder; n: NativeUInt); cdecl;
  ImFontGlyphRangesBuilder_AddChar: procedure(self: PImFontGlyphRangesBuilder; c: ImWchar); cdecl;
  ImFontGlyphRangesBuilder_AddText: procedure(self: PImFontGlyphRangesBuilder; const text: PUTF8Char; const text_end: PUTF8Char); cdecl;
  ImFontGlyphRangesBuilder_AddRanges: procedure(self: PImFontGlyphRangesBuilder; const ranges: PImWchar); cdecl;
  ImFontGlyphRangesBuilder_BuildRanges: procedure(self: PImFontGlyphRangesBuilder; out_ranges: PImVector_ImWchar); cdecl;
  ImFontAtlasCustomRect_ImFontAtlasCustomRect: function(): PImFontAtlasCustomRect; cdecl;
  ImFontAtlasCustomRect_destroy: procedure(self: PImFontAtlasCustomRect); cdecl;
  ImFontAtlasCustomRect_IsPacked: function(self: PImFontAtlasCustomRect): Boolean; cdecl;
  ImFontAtlas_ImFontAtlas: function(): PImFontAtlas; cdecl;
  ImFontAtlas_destroy: procedure(self: PImFontAtlas); cdecl;
  ImFontAtlas_AddFont: function(self: PImFontAtlas; const font_cfg: PImFontConfig): PImFont; cdecl;
  ImFontAtlas_AddFontDefault: function(self: PImFontAtlas; const font_cfg: PImFontConfig): PImFont; cdecl;
  ImFontAtlas_AddFontFromFileTTF: function(self: PImFontAtlas; const filename: PUTF8Char; size_pixels: Single; const font_cfg: PImFontConfig; const glyph_ranges: PImWchar): PImFont; cdecl;
  ImFontAtlas_AddFontFromMemoryTTF: function(self: PImFontAtlas; font_data: Pointer; font_data_size: Integer; size_pixels: Single; const font_cfg: PImFontConfig; const glyph_ranges: PImWchar): PImFont; cdecl;
  ImFontAtlas_AddFontFromMemoryCompressedTTF: function(self: PImFontAtlas; const compressed_font_data: Pointer; compressed_font_data_size: Integer; size_pixels: Single; const font_cfg: PImFontConfig; const glyph_ranges: PImWchar): PImFont; cdecl;
  ImFontAtlas_AddFontFromMemoryCompressedBase85TTF: function(self: PImFontAtlas; const compressed_font_data_base85: PUTF8Char; size_pixels: Single; const font_cfg: PImFontConfig; const glyph_ranges: PImWchar): PImFont; cdecl;
  ImFontAtlas_ClearInputData: procedure(self: PImFontAtlas); cdecl;
  ImFontAtlas_ClearFonts: procedure(self: PImFontAtlas); cdecl;
  ImFontAtlas_ClearTexData: procedure(self: PImFontAtlas); cdecl;
  ImFontAtlas_Clear: procedure(self: PImFontAtlas); cdecl;
  ImFontAtlas_Build: function(self: PImFontAtlas): Boolean; cdecl;
  ImFontAtlas_GetTexDataAsAlpha8: procedure(self: PImFontAtlas; out_pixels: PPByte; out_width: PInteger; out_height: PInteger; out_bytes_per_pixel: PInteger); cdecl;
  ImFontAtlas_GetTexDataAsRGBA32: procedure(self: PImFontAtlas; out_pixels: PPByte; out_width: PInteger; out_height: PInteger; out_bytes_per_pixel: PInteger); cdecl;
  ImFontAtlas_IsBuilt: function(self: PImFontAtlas): Boolean; cdecl;
  ImFontAtlas_SetTexID: procedure(self: PImFontAtlas; id: ImTextureID); cdecl;
  ImFontAtlas_GetGlyphRangesDefault: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesGreek: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesKorean: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesJapanese: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesChineseFull: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesCyrillic: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesThai: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_GetGlyphRangesVietnamese: function(self: PImFontAtlas): PImWchar; cdecl;
  ImFontAtlas_AddCustomRectRegular: function(self: PImFontAtlas; width: Integer; height: Integer): Integer; cdecl;
  ImFontAtlas_AddCustomRectFontGlyph: function(self: PImFontAtlas; font: PImFont; id: ImWchar; width: Integer; height: Integer; advance_x: Single; offset: ImVec2): Integer; cdecl;
  ImFontAtlas_GetCustomRectByIndex: function(self: PImFontAtlas; index: Integer): PImFontAtlasCustomRect; cdecl;
  ImFontAtlas_CalcCustomRectUV: procedure(self: PImFontAtlas; const rect: PImFontAtlasCustomRect; out_uv_min: PImVec2; out_uv_max: PImVec2); cdecl;
  ImFontAtlas_GetMouseCursorTexData: function(self: PImFontAtlas; cursor: ImGuiMouseCursor; out_offset: PImVec2; out_size: PImVec2; out_uv_border: PImVec2; out_uv_fill: PImVec2): Boolean; cdecl;
  ImFont_ImFont: function(): PImFont; cdecl;
  ImFont_destroy: procedure(self: PImFont); cdecl;
  ImFont_FindGlyph: function(self: PImFont; c: ImWchar): PImFontGlyph; cdecl;
  ImFont_FindGlyphNoFallback: function(self: PImFont; c: ImWchar): PImFontGlyph; cdecl;
  ImFont_GetCharAdvance: function(self: PImFont; c: ImWchar): Single; cdecl;
  ImFont_IsLoaded: function(self: PImFont): Boolean; cdecl;
  ImFont_GetDebugName: function(self: PImFont): PUTF8Char; cdecl;
  ImFont_CalcTextSizeA: procedure(pOut: PImVec2; self: PImFont; size: Single; max_width: Single; wrap_width: Single; const text_begin: PUTF8Char; const text_end: PUTF8Char; remaining: PPUTF8Char); cdecl;
  ImFont_CalcWordWrapPositionA: function(self: PImFont; scale: Single; const text: PUTF8Char; const text_end: PUTF8Char; wrap_width: Single): PUTF8Char; cdecl;
  ImFont_RenderChar: procedure(self: PImFont; draw_list: PImDrawList; size: Single; pos: ImVec2; col: ImU32; c: ImWchar); cdecl;
  ImFont_RenderText: procedure(self: PImFont; draw_list: PImDrawList; size: Single; pos: ImVec2; col: ImU32; clip_rect: ImVec4; const text_begin: PUTF8Char; const text_end: PUTF8Char; wrap_width: Single; cpu_fine_clip: Boolean); cdecl;
  ImFont_BuildLookupTable: procedure(self: PImFont); cdecl;
  ImFont_ClearOutputData: procedure(self: PImFont); cdecl;
  ImFont_GrowIndex: procedure(self: PImFont; new_size: Integer); cdecl;
  ImFont_AddGlyph: procedure(self: PImFont; const src_cfg: PImFontConfig; c: ImWchar; x0: Single; y0: Single; x1: Single; y1: Single; u0: Single; v0: Single; u1: Single; v1: Single; advance_x: Single); cdecl;
  ImFont_AddRemapChar: procedure(self: PImFont; dst: ImWchar; src: ImWchar; overwrite_dst: Boolean); cdecl;
  ImFont_SetGlyphVisible: procedure(self: PImFont; c: ImWchar; visible: Boolean); cdecl;
  ImFont_IsGlyphRangeUnused: function(self: PImFont; c_begin: Cardinal; c_last: Cardinal): Boolean; cdecl;
  ImGuiViewport_ImGuiViewport: function(): PImGuiViewport; cdecl;
  ImGuiViewport_destroy: procedure(self: PImGuiViewport); cdecl;
  ImGuiViewport_GetCenter: procedure(pOut: PImVec2; self: PImGuiViewport); cdecl;
  ImGuiViewport_GetWorkCenter: procedure(pOut: PImVec2; self: PImGuiViewport); cdecl;
  ImGuiPlatformIO_ImGuiPlatformIO: function(): PImGuiPlatformIO; cdecl;
  ImGuiPlatformIO_destroy: procedure(self: PImGuiPlatformIO); cdecl;
  ImGuiPlatformMonitor_ImGuiPlatformMonitor: function(): PImGuiPlatformMonitor; cdecl;
  ImGuiPlatformMonitor_destroy: procedure(self: PImGuiPlatformMonitor); cdecl;
  ImGuiPlatformImeData_ImGuiPlatformImeData: function(): PImGuiPlatformImeData; cdecl;
  ImGuiPlatformImeData_destroy: procedure(self: PImGuiPlatformImeData); cdecl;
  igImHashData: function(const data: Pointer; data_size: NativeUInt; seed: ImGuiID): ImGuiID; cdecl;
  igImHashStr: function(const data: PUTF8Char; data_size: NativeUInt; seed: ImGuiID): ImGuiID; cdecl;
  igImQsort: procedure(base: Pointer; count: NativeUInt; size_of_element: NativeUInt; compare_func: igImQsort_compare_func); cdecl;
  igImAlphaBlendColors: function(col_a: ImU32; col_b: ImU32): ImU32; cdecl;
  igImIsPowerOfTwo_Int: function(v: Integer): Boolean; cdecl;
  igImIsPowerOfTwo_U64: function(v: ImU64): Boolean; cdecl;
  igImUpperPowerOfTwo: function(v: Integer): Integer; cdecl;
  igImStricmp: function(const str1: PUTF8Char; const str2: PUTF8Char): Integer; cdecl;
  igImStrnicmp: function(const str1: PUTF8Char; const str2: PUTF8Char; count: NativeUInt): Integer; cdecl;
  igImStrncpy: procedure(dst: PUTF8Char; const src: PUTF8Char; count: NativeUInt); cdecl;
  igImStrdup: function(const str: PUTF8Char): PUTF8Char; cdecl;
  igImStrdupcpy: function(dst: PUTF8Char; p_dst_size: PNativeUInt; const str: PUTF8Char): PUTF8Char; cdecl;
  igImStrchrRange: function(const str_begin: PUTF8Char; const str_end: PUTF8Char; c: UTF8Char): PUTF8Char; cdecl;
  igImStreolRange: function(const str: PUTF8Char; const str_end: PUTF8Char): PUTF8Char; cdecl;
  igImStristr: function(const haystack: PUTF8Char; const haystack_end: PUTF8Char; const needle: PUTF8Char; const needle_end: PUTF8Char): PUTF8Char; cdecl;
  igImStrTrimBlanks: procedure(str: PUTF8Char); cdecl;
  igImStrSkipBlank: function(const str: PUTF8Char): PUTF8Char; cdecl;
  igImStrlenW: function(const str: PImWchar): Integer; cdecl;
  igImStrbol: function(const buf_mid_line: PUTF8Char; const buf_begin: PUTF8Char): PUTF8Char; cdecl;
  igImToUpper: function(c: UTF8Char): UTF8Char; cdecl;
  igImCharIsBlankA: function(c: UTF8Char): Boolean; cdecl;
  igImCharIsBlankW: function(c: Cardinal): Boolean; cdecl;
  igImCharIsXdigitA: function(c: UTF8Char): Boolean; cdecl;
  igImFormatString: function(buf: PUTF8Char; buf_size: NativeUInt; const fmt: PUTF8Char): Integer varargs; cdecl;
  igImFormatStringV: function(buf: PUTF8Char; buf_size: NativeUInt; const fmt: PUTF8Char; args: Pointer): Integer; cdecl;
  igImFormatStringToTempBuffer: procedure(out_buf: PPUTF8Char; out_buf_end: PPUTF8Char; const fmt: PUTF8Char) varargs; cdecl;
  igImFormatStringToTempBufferV: procedure(out_buf: PPUTF8Char; out_buf_end: PPUTF8Char; const fmt: PUTF8Char; args: Pointer); cdecl;
  igImParseFormatFindStart: function(const format: PUTF8Char): PUTF8Char; cdecl;
  igImParseFormatFindEnd: function(const format: PUTF8Char): PUTF8Char; cdecl;
  igImParseFormatTrimDecorations: function(const format: PUTF8Char; buf: PUTF8Char; buf_size: NativeUInt): PUTF8Char; cdecl;
  igImParseFormatSanitizeForPrinting: procedure(const fmt_in: PUTF8Char; fmt_out: PUTF8Char; fmt_out_size: NativeUInt); cdecl;
  igImParseFormatSanitizeForScanning: function(const fmt_in: PUTF8Char; fmt_out: PUTF8Char; fmt_out_size: NativeUInt): PUTF8Char; cdecl;
  igImParseFormatPrecision: function(const format: PUTF8Char; default_value: Integer): Integer; cdecl;
  igImTextCharToUtf8: function(out_buf: PUTF8Char; c: Cardinal): PUTF8Char; cdecl;
  igImTextStrToUtf8: function(out_buf: PUTF8Char; out_buf_size: Integer; const in_text: PImWchar; const in_text_end: PImWchar): Integer; cdecl;
  igImTextCharFromUtf8: function(out_char: PCardinal; const in_text: PUTF8Char; const in_text_end: PUTF8Char): Integer; cdecl;
  igImTextStrFromUtf8: function(out_buf: PImWchar; out_buf_size: Integer; const in_text: PUTF8Char; const in_text_end: PUTF8Char; in_remaining: PPUTF8Char): Integer; cdecl;
  igImTextCountCharsFromUtf8: function(const in_text: PUTF8Char; const in_text_end: PUTF8Char): Integer; cdecl;
  igImTextCountUtf8BytesFromChar: function(const in_text: PUTF8Char; const in_text_end: PUTF8Char): Integer; cdecl;
  igImTextCountUtf8BytesFromStr: function(const in_text: PImWchar; const in_text_end: PImWchar): Integer; cdecl;
  igImTextFindPreviousUtf8Codepoint: function(const in_text_start: PUTF8Char; const in_text_curr: PUTF8Char): PUTF8Char; cdecl;
  igImTextCountLines: function(const in_text: PUTF8Char; const in_text_end: PUTF8Char): Integer; cdecl;
  igImFileOpen: function(const filename: PUTF8Char; const mode: PUTF8Char): ImFileHandle; cdecl;
  igImFileClose: function(&file: ImFileHandle): Boolean; cdecl;
  igImFileGetSize: function(&file: ImFileHandle): ImU64; cdecl;
  igImFileRead: function(data: Pointer; size: ImU64; count: ImU64; &file: ImFileHandle): ImU64; cdecl;
  igImFileWrite: function(const data: Pointer; size: ImU64; count: ImU64; &file: ImFileHandle): ImU64; cdecl;
  igImFileLoadToMemory: function(const filename: PUTF8Char; const mode: PUTF8Char; out_file_size: PNativeUInt; padding_bytes: Integer): Pointer; cdecl;
  igImPow_Float: function(x: Single; y: Single): Single; cdecl;
  igImPow_double: function(x: Double; y: Double): Double; cdecl;
  igImLog_Float: function(x: Single): Single; cdecl;
  igImLog_double: function(x: Double): Double; cdecl;
  igImAbs_Int: function(x: Integer): Integer; cdecl;
  igImAbs_Float: function(x: Single): Single; cdecl;
  igImAbs_double: function(x: Double): Double; cdecl;
  igImSign_Float: function(x: Single): Single; cdecl;
  igImSign_double: function(x: Double): Double; cdecl;
  igImRsqrt_Float: function(x: Single): Single; cdecl;
  igImRsqrt_double: function(x: Double): Double; cdecl;
  igImMin: procedure(pOut: PImVec2; lhs: ImVec2; rhs: ImVec2); cdecl;
  igImMax: procedure(pOut: PImVec2; lhs: ImVec2; rhs: ImVec2); cdecl;
  igImClamp: procedure(pOut: PImVec2; v: ImVec2; mn: ImVec2; mx: ImVec2); cdecl;
  igImLerp_Vec2Float: procedure(pOut: PImVec2; a: ImVec2; b: ImVec2; t: Single); cdecl;
  igImLerp_Vec2Vec2: procedure(pOut: PImVec2; a: ImVec2; b: ImVec2; t: ImVec2); cdecl;
  igImLerp_Vec4: procedure(pOut: PImVec4; a: ImVec4; b: ImVec4; t: Single); cdecl;
  igImSaturate: function(f: Single): Single; cdecl;
  igImLengthSqr_Vec2: function(lhs: ImVec2): Single; cdecl;
  igImLengthSqr_Vec4: function(lhs: ImVec4): Single; cdecl;
  igImInvLength: function(lhs: ImVec2; fail_value: Single): Single; cdecl;
  igImTrunc_Float: function(f: Single): Single; cdecl;
  igImTrunc_Vec2: procedure(pOut: PImVec2; v: ImVec2); cdecl;
  igImFloor_Float: function(f: Single): Single; cdecl;
  igImFloor_Vec2: procedure(pOut: PImVec2; v: ImVec2); cdecl;
  igImModPositive: function(a: Integer; b: Integer): Integer; cdecl;
  igImDot: function(a: ImVec2; b: ImVec2): Single; cdecl;
  igImRotate: procedure(pOut: PImVec2; v: ImVec2; cos_a: Single; sin_a: Single); cdecl;
  igImLinearSweep: function(current: Single; target: Single; speed: Single): Single; cdecl;
  igImLinearRemapClamp: function(s0: Single; s1: Single; d0: Single; d1: Single; x: Single): Single; cdecl;
  igImMul: procedure(pOut: PImVec2; lhs: ImVec2; rhs: ImVec2); cdecl;
  igImIsFloatAboveGuaranteedIntegerPrecision: function(f: Single): Boolean; cdecl;
  igImExponentialMovingAverage: function(avg: Single; sample: Single; n: Integer): Single; cdecl;
  igImBezierCubicCalc: procedure(pOut: PImVec2; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; t: Single); cdecl;
  igImBezierCubicClosestPoint: procedure(pOut: PImVec2; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; p: ImVec2; num_segments: Integer); cdecl;
  igImBezierCubicClosestPointCasteljau: procedure(pOut: PImVec2; p1: ImVec2; p2: ImVec2; p3: ImVec2; p4: ImVec2; p: ImVec2; tess_tol: Single); cdecl;
  igImBezierQuadraticCalc: procedure(pOut: PImVec2; p1: ImVec2; p2: ImVec2; p3: ImVec2; t: Single); cdecl;
  igImLineClosestPoint: procedure(pOut: PImVec2; a: ImVec2; b: ImVec2; p: ImVec2); cdecl;
  igImTriangleContainsPoint: function(a: ImVec2; b: ImVec2; c: ImVec2; p: ImVec2): Boolean; cdecl;
  igImTriangleClosestPoint: procedure(pOut: PImVec2; a: ImVec2; b: ImVec2; c: ImVec2; p: ImVec2); cdecl;
  igImTriangleBarycentricCoords: procedure(a: ImVec2; b: ImVec2; c: ImVec2; p: ImVec2; out_u: PSingle; out_v: PSingle; out_w: PSingle); cdecl;
  igImTriangleArea: function(a: ImVec2; b: ImVec2; c: ImVec2): Single; cdecl;
  igImTriangleIsClockwise: function(a: ImVec2; b: ImVec2; c: ImVec2): Boolean; cdecl;
  ImVec1_ImVec1_Nil: function(): PImVec1; cdecl;
  ImVec1_destroy: procedure(self: PImVec1); cdecl;
  ImVec1_ImVec1_Float: function(_x: Single): PImVec1; cdecl;
  ImVec2ih_ImVec2ih_Nil: function(): PImVec2ih; cdecl;
  ImVec2ih_destroy: procedure(self: PImVec2ih); cdecl;
  ImVec2ih_ImVec2ih_short: function(_x: Smallint; _y: Smallint): PImVec2ih; cdecl;
  ImVec2ih_ImVec2ih_Vec2: function(rhs: ImVec2): PImVec2ih; cdecl;
  ImRect_ImRect_Nil: function(): PImRect; cdecl;
  ImRect_destroy: procedure(self: PImRect); cdecl;
  ImRect_ImRect_Vec2: function(min: ImVec2; max: ImVec2): PImRect; cdecl;
  ImRect_ImRect_Vec4: function(v: ImVec4): PImRect; cdecl;
  ImRect_ImRect_Float: function(x1: Single; y1: Single; x2: Single; y2: Single): PImRect; cdecl;
  ImRect_GetCenter: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_GetSize: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_GetWidth: function(self: PImRect): Single; cdecl;
  ImRect_GetHeight: function(self: PImRect): Single; cdecl;
  ImRect_GetArea: function(self: PImRect): Single; cdecl;
  ImRect_GetTL: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_GetTR: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_GetBL: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_GetBR: procedure(pOut: PImVec2; self: PImRect); cdecl;
  ImRect_Contains_Vec2: function(self: PImRect; p: ImVec2): Boolean; cdecl;
  ImRect_Contains_Rect: function(self: PImRect; r: ImRect): Boolean; cdecl;
  ImRect_ContainsWithPad: function(self: PImRect; p: ImVec2; pad: ImVec2): Boolean; cdecl;
  ImRect_Overlaps: function(self: PImRect; r: ImRect): Boolean; cdecl;
  ImRect_Add_Vec2: procedure(self: PImRect; p: ImVec2); cdecl;
  ImRect_Add_Rect: procedure(self: PImRect; r: ImRect); cdecl;
  ImRect_Expand_Float: procedure(self: PImRect; const amount: Single); cdecl;
  ImRect_Expand_Vec2: procedure(self: PImRect; amount: ImVec2); cdecl;
  ImRect_Translate: procedure(self: PImRect; d: ImVec2); cdecl;
  ImRect_TranslateX: procedure(self: PImRect; dx: Single); cdecl;
  ImRect_TranslateY: procedure(self: PImRect; dy: Single); cdecl;
  ImRect_ClipWith: procedure(self: PImRect; r: ImRect); cdecl;
  ImRect_ClipWithFull: procedure(self: PImRect; r: ImRect); cdecl;
  ImRect_Floor: procedure(self: PImRect); cdecl;
  ImRect_IsInverted: function(self: PImRect): Boolean; cdecl;
  ImRect_ToVec4: procedure(pOut: PImVec4; self: PImRect); cdecl;
  igImBitArrayGetStorageSizeInBytes: function(bitcount: Integer): NativeUInt; cdecl;
  igImBitArrayClearAllBits: procedure(arr: PImU32; bitcount: Integer); cdecl;
  igImBitArrayTestBit: function(const arr: PImU32; n: Integer): Boolean; cdecl;
  igImBitArrayClearBit: procedure(arr: PImU32; n: Integer); cdecl;
  igImBitArraySetBit: procedure(arr: PImU32; n: Integer); cdecl;
  igImBitArraySetBitRange: procedure(arr: PImU32; n: Integer; n2: Integer); cdecl;
  ImBitVector_Create: procedure(self: PImBitVector; sz: Integer); cdecl;
  ImBitVector_Clear: procedure(self: PImBitVector); cdecl;
  ImBitVector_TestBit: function(self: PImBitVector; n: Integer): Boolean; cdecl;
  ImBitVector_SetBit: procedure(self: PImBitVector; n: Integer); cdecl;
  ImBitVector_ClearBit: procedure(self: PImBitVector; n: Integer); cdecl;
  ImGuiTextIndex_clear: procedure(self: PImGuiTextIndex); cdecl;
  ImGuiTextIndex_size: function(self: PImGuiTextIndex): Integer; cdecl;
  ImGuiTextIndex_get_line_begin: function(self: PImGuiTextIndex; const base: PUTF8Char; n: Integer): PUTF8Char; cdecl;
  ImGuiTextIndex_get_line_end: function(self: PImGuiTextIndex; const base: PUTF8Char; n: Integer): PUTF8Char; cdecl;
  ImGuiTextIndex_append: procedure(self: PImGuiTextIndex; const base: PUTF8Char; old_size: Integer; new_size: Integer); cdecl;
  igImLowerBound: function(in_begin: PImGuiStoragePair; in_end: PImGuiStoragePair; key: ImGuiID): PImGuiStoragePair; cdecl;
  ImDrawListSharedData_ImDrawListSharedData: function(): PImDrawListSharedData; cdecl;
  ImDrawListSharedData_destroy: procedure(self: PImDrawListSharedData); cdecl;
  ImDrawListSharedData_SetCircleTessellationMaxError: procedure(self: PImDrawListSharedData; max_error: Single); cdecl;
  ImDrawDataBuilder_ImDrawDataBuilder: function(): PImDrawDataBuilder; cdecl;
  ImDrawDataBuilder_destroy: procedure(self: PImDrawDataBuilder); cdecl;
  ImGuiDataVarInfo_GetVarPtr: function(self: PImGuiDataVarInfo; parent: Pointer): Pointer; cdecl;
  ImGuiStyleMod_ImGuiStyleMod_Int: function(idx: ImGuiStyleVar; v: Integer): PImGuiStyleMod; cdecl;
  ImGuiStyleMod_destroy: procedure(self: PImGuiStyleMod); cdecl;
  ImGuiStyleMod_ImGuiStyleMod_Float: function(idx: ImGuiStyleVar; v: Single): PImGuiStyleMod; cdecl;
  ImGuiStyleMod_ImGuiStyleMod_Vec2: function(idx: ImGuiStyleVar; v: ImVec2): PImGuiStyleMod; cdecl;
  ImGuiComboPreviewData_ImGuiComboPreviewData: function(): PImGuiComboPreviewData; cdecl;
  ImGuiComboPreviewData_destroy: procedure(self: PImGuiComboPreviewData); cdecl;
  ImGuiMenuColumns_ImGuiMenuColumns: function(): PImGuiMenuColumns; cdecl;
  ImGuiMenuColumns_destroy: procedure(self: PImGuiMenuColumns); cdecl;
  ImGuiMenuColumns_Update: procedure(self: PImGuiMenuColumns; spacing: Single; window_reappearing: Boolean); cdecl;
  ImGuiMenuColumns_DeclColumns: function(self: PImGuiMenuColumns; w_icon: Single; w_label: Single; w_shortcut: Single; w_mark: Single): Single; cdecl;
  ImGuiMenuColumns_CalcNextTotalWidth: procedure(self: PImGuiMenuColumns; update_offsets: Boolean); cdecl;
  ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState: function(): PImGuiInputTextDeactivatedState; cdecl;
  ImGuiInputTextDeactivatedState_destroy: procedure(self: PImGuiInputTextDeactivatedState); cdecl;
  ImGuiInputTextDeactivatedState_ClearFreeMemory: procedure(self: PImGuiInputTextDeactivatedState); cdecl;
  ImGuiInputTextState_ImGuiInputTextState: function(): PImGuiInputTextState; cdecl;
  ImGuiInputTextState_destroy: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_ClearText: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_ClearFreeMemory: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_OnKeyPressed: procedure(self: PImGuiInputTextState; key: Integer); cdecl;
  ImGuiInputTextState_OnCharPressed: procedure(self: PImGuiInputTextState; c: Cardinal); cdecl;
  ImGuiInputTextState_CursorAnimReset: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_CursorClamp: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_HasSelection: function(self: PImGuiInputTextState): Boolean; cdecl;
  ImGuiInputTextState_ClearSelection: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_GetCursorPos: function(self: PImGuiInputTextState): Integer; cdecl;
  ImGuiInputTextState_GetSelectionStart: function(self: PImGuiInputTextState): Integer; cdecl;
  ImGuiInputTextState_GetSelectionEnd: function(self: PImGuiInputTextState): Integer; cdecl;
  ImGuiInputTextState_SelectAll: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_ReloadUserBufAndSelectAll: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_ReloadUserBufAndKeepSelection: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiInputTextState_ReloadUserBufAndMoveToEnd: procedure(self: PImGuiInputTextState); cdecl;
  ImGuiNextWindowData_ImGuiNextWindowData: function(): PImGuiNextWindowData; cdecl;
  ImGuiNextWindowData_destroy: procedure(self: PImGuiNextWindowData); cdecl;
  ImGuiNextWindowData_ClearFlags: procedure(self: PImGuiNextWindowData); cdecl;
  ImGuiNextItemData_ImGuiNextItemData: function(): PImGuiNextItemData; cdecl;
  ImGuiNextItemData_destroy: procedure(self: PImGuiNextItemData); cdecl;
  ImGuiNextItemData_ClearFlags: procedure(self: PImGuiNextItemData); cdecl;
  ImGuiLastItemData_ImGuiLastItemData: function(): PImGuiLastItemData; cdecl;
  ImGuiLastItemData_destroy: procedure(self: PImGuiLastItemData); cdecl;
  ImGuiErrorRecoveryState_ImGuiErrorRecoveryState: function(): PImGuiErrorRecoveryState; cdecl;
  ImGuiErrorRecoveryState_destroy: procedure(self: PImGuiErrorRecoveryState); cdecl;
  ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr: function(ptr: Pointer): PImGuiPtrOrIndex; cdecl;
  ImGuiPtrOrIndex_destroy: procedure(self: PImGuiPtrOrIndex); cdecl;
  ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int: function(index: Integer): PImGuiPtrOrIndex; cdecl;
  ImGuiPopupData_ImGuiPopupData: function(): PImGuiPopupData; cdecl;
  ImGuiPopupData_destroy: procedure(self: PImGuiPopupData); cdecl;
  ImGuiInputEvent_ImGuiInputEvent: function(): PImGuiInputEvent; cdecl;
  ImGuiInputEvent_destroy: procedure(self: PImGuiInputEvent); cdecl;
  ImGuiKeyRoutingData_ImGuiKeyRoutingData: function(): PImGuiKeyRoutingData; cdecl;
  ImGuiKeyRoutingData_destroy: procedure(self: PImGuiKeyRoutingData); cdecl;
  ImGuiKeyRoutingTable_ImGuiKeyRoutingTable: function(): PImGuiKeyRoutingTable; cdecl;
  ImGuiKeyRoutingTable_destroy: procedure(self: PImGuiKeyRoutingTable); cdecl;
  ImGuiKeyRoutingTable_Clear: procedure(self: PImGuiKeyRoutingTable); cdecl;
  ImGuiKeyOwnerData_ImGuiKeyOwnerData: function(): PImGuiKeyOwnerData; cdecl;
  ImGuiKeyOwnerData_destroy: procedure(self: PImGuiKeyOwnerData); cdecl;
  ImGuiListClipperRange_FromIndices: function(min: Integer; max: Integer): ImGuiListClipperRange; cdecl;
  ImGuiListClipperRange_FromPositions: function(y1: Single; y2: Single; off_min: Integer; off_max: Integer): ImGuiListClipperRange; cdecl;
  ImGuiListClipperData_ImGuiListClipperData: function(): PImGuiListClipperData; cdecl;
  ImGuiListClipperData_destroy: procedure(self: PImGuiListClipperData); cdecl;
  ImGuiListClipperData_Reset: procedure(self: PImGuiListClipperData; clipper: PImGuiListClipper); cdecl;
  ImGuiNavItemData_ImGuiNavItemData: function(): PImGuiNavItemData; cdecl;
  ImGuiNavItemData_destroy: procedure(self: PImGuiNavItemData); cdecl;
  ImGuiNavItemData_Clear: procedure(self: PImGuiNavItemData); cdecl;
  ImGuiTypingSelectState_ImGuiTypingSelectState: function(): PImGuiTypingSelectState; cdecl;
  ImGuiTypingSelectState_destroy: procedure(self: PImGuiTypingSelectState); cdecl;
  ImGuiTypingSelectState_Clear: procedure(self: PImGuiTypingSelectState); cdecl;
  ImGuiOldColumnData_ImGuiOldColumnData: function(): PImGuiOldColumnData; cdecl;
  ImGuiOldColumnData_destroy: procedure(self: PImGuiOldColumnData); cdecl;
  ImGuiOldColumns_ImGuiOldColumns: function(): PImGuiOldColumns; cdecl;
  ImGuiOldColumns_destroy: procedure(self: PImGuiOldColumns); cdecl;
  ImGuiBoxSelectState_ImGuiBoxSelectState: function(): PImGuiBoxSelectState; cdecl;
  ImGuiBoxSelectState_destroy: procedure(self: PImGuiBoxSelectState); cdecl;
  ImGuiMultiSelectTempData_ImGuiMultiSelectTempData: function(): PImGuiMultiSelectTempData; cdecl;
  ImGuiMultiSelectTempData_destroy: procedure(self: PImGuiMultiSelectTempData); cdecl;
  ImGuiMultiSelectTempData_Clear: procedure(self: PImGuiMultiSelectTempData); cdecl;
  ImGuiMultiSelectTempData_ClearIO: procedure(self: PImGuiMultiSelectTempData); cdecl;
  ImGuiMultiSelectState_ImGuiMultiSelectState: function(): PImGuiMultiSelectState; cdecl;
  ImGuiMultiSelectState_destroy: procedure(self: PImGuiMultiSelectState); cdecl;
  ImGuiDockNode_ImGuiDockNode: function(id: ImGuiID): PImGuiDockNode; cdecl;
  ImGuiDockNode_destroy: procedure(self: PImGuiDockNode); cdecl;
  ImGuiDockNode_IsRootNode: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsDockSpace: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsFloatingNode: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsCentralNode: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsHiddenTabBar: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsNoTabBar: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsSplitNode: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsLeafNode: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_IsEmpty: function(self: PImGuiDockNode): Boolean; cdecl;
  ImGuiDockNode_Rect: procedure(pOut: PImRect; self: PImGuiDockNode); cdecl;
  ImGuiDockNode_SetLocalFlags: procedure(self: PImGuiDockNode; flags: ImGuiDockNodeFlags); cdecl;
  ImGuiDockNode_UpdateMergedFlags: procedure(self: PImGuiDockNode); cdecl;
  ImGuiDockContext_ImGuiDockContext: function(): PImGuiDockContext; cdecl;
  ImGuiDockContext_destroy: procedure(self: PImGuiDockContext); cdecl;
  ImGuiViewportP_ImGuiViewportP: function(): PImGuiViewportP; cdecl;
  ImGuiViewportP_destroy: procedure(self: PImGuiViewportP); cdecl;
  ImGuiViewportP_ClearRequestFlags: procedure(self: PImGuiViewportP); cdecl;
  ImGuiViewportP_CalcWorkRectPos: procedure(pOut: PImVec2; self: PImGuiViewportP; inset_min: ImVec2); cdecl;
  ImGuiViewportP_CalcWorkRectSize: procedure(pOut: PImVec2; self: PImGuiViewportP; inset_min: ImVec2; inset_max: ImVec2); cdecl;
  ImGuiViewportP_UpdateWorkRect: procedure(self: PImGuiViewportP); cdecl;
  ImGuiViewportP_GetMainRect: procedure(pOut: PImRect; self: PImGuiViewportP); cdecl;
  ImGuiViewportP_GetWorkRect: procedure(pOut: PImRect; self: PImGuiViewportP); cdecl;
  ImGuiViewportP_GetBuildWorkRect: procedure(pOut: PImRect; self: PImGuiViewportP); cdecl;
  ImGuiWindowSettings_ImGuiWindowSettings: function(): PImGuiWindowSettings; cdecl;
  ImGuiWindowSettings_destroy: procedure(self: PImGuiWindowSettings); cdecl;
  ImGuiWindowSettings_GetName: function(self: PImGuiWindowSettings): PUTF8Char; cdecl;
  ImGuiSettingsHandler_ImGuiSettingsHandler: function(): PImGuiSettingsHandler; cdecl;
  ImGuiSettingsHandler_destroy: procedure(self: PImGuiSettingsHandler); cdecl;
  ImGuiDebugAllocInfo_ImGuiDebugAllocInfo: function(): PImGuiDebugAllocInfo; cdecl;
  ImGuiDebugAllocInfo_destroy: procedure(self: PImGuiDebugAllocInfo); cdecl;
  ImGuiStackLevelInfo_ImGuiStackLevelInfo: function(): PImGuiStackLevelInfo; cdecl;
  ImGuiStackLevelInfo_destroy: procedure(self: PImGuiStackLevelInfo); cdecl;
  ImGuiIDStackTool_ImGuiIDStackTool: function(): PImGuiIDStackTool; cdecl;
  ImGuiIDStackTool_destroy: procedure(self: PImGuiIDStackTool); cdecl;
  ImGuiContextHook_ImGuiContextHook: function(): PImGuiContextHook; cdecl;
  ImGuiContextHook_destroy: procedure(self: PImGuiContextHook); cdecl;
  ImGuiContext_ImGuiContext: function(shared_font_atlas: PImFontAtlas): PImGuiContext; cdecl;
  ImGuiContext_destroy: procedure(self: PImGuiContext); cdecl;
  ImGuiWindow_ImGuiWindow: function(context: PImGuiContext; const name: PUTF8Char): PImGuiWindow; cdecl;
  ImGuiWindow_destroy: procedure(self: PImGuiWindow); cdecl;
  ImGuiWindow_GetID_Str: function(self: PImGuiWindow; const str: PUTF8Char; const str_end: PUTF8Char): ImGuiID; cdecl;
  ImGuiWindow_GetID_Ptr: function(self: PImGuiWindow; const ptr: Pointer): ImGuiID; cdecl;
  ImGuiWindow_GetID_Int: function(self: PImGuiWindow; n: Integer): ImGuiID; cdecl;
  ImGuiWindow_GetIDFromPos: function(self: PImGuiWindow; p_abs: ImVec2): ImGuiID; cdecl;
  ImGuiWindow_GetIDFromRectangle: function(self: PImGuiWindow; r_abs: ImRect): ImGuiID; cdecl;
  ImGuiWindow_Rect: procedure(pOut: PImRect; self: PImGuiWindow); cdecl;
  ImGuiWindow_CalcFontSize: function(self: PImGuiWindow): Single; cdecl;
  ImGuiWindow_TitleBarRect: procedure(pOut: PImRect; self: PImGuiWindow); cdecl;
  ImGuiWindow_MenuBarRect: procedure(pOut: PImRect; self: PImGuiWindow); cdecl;
  ImGuiTabItem_ImGuiTabItem: function(): PImGuiTabItem; cdecl;
  ImGuiTabItem_destroy: procedure(self: PImGuiTabItem); cdecl;
  ImGuiTabBar_ImGuiTabBar: function(): PImGuiTabBar; cdecl;
  ImGuiTabBar_destroy: procedure(self: PImGuiTabBar); cdecl;
  ImGuiTableColumn_ImGuiTableColumn: function(): PImGuiTableColumn; cdecl;
  ImGuiTableColumn_destroy: procedure(self: PImGuiTableColumn); cdecl;
  ImGuiTableInstanceData_ImGuiTableInstanceData: function(): PImGuiTableInstanceData; cdecl;
  ImGuiTableInstanceData_destroy: procedure(self: PImGuiTableInstanceData); cdecl;
  ImGuiTable_ImGuiTable: function(): PImGuiTable; cdecl;
  ImGuiTable_destroy: procedure(self: PImGuiTable); cdecl;
  ImGuiTableTempData_ImGuiTableTempData: function(): PImGuiTableTempData; cdecl;
  ImGuiTableTempData_destroy: procedure(self: PImGuiTableTempData); cdecl;
  ImGuiTableColumnSettings_ImGuiTableColumnSettings: function(): PImGuiTableColumnSettings; cdecl;
  ImGuiTableColumnSettings_destroy: procedure(self: PImGuiTableColumnSettings); cdecl;
  ImGuiTableSettings_ImGuiTableSettings: function(): PImGuiTableSettings; cdecl;
  ImGuiTableSettings_destroy: procedure(self: PImGuiTableSettings); cdecl;
  ImGuiTableSettings_GetColumnSettings: function(self: PImGuiTableSettings): PImGuiTableColumnSettings; cdecl;
  igGetIOEx: function(ctx: PImGuiContext): PImGuiIO; cdecl;
  igGetPlatformIOEx: function(ctx: PImGuiContext): PImGuiPlatformIO; cdecl;
  igGetCurrentWindowRead: function(): PImGuiWindow; cdecl;
  igGetCurrentWindow: function(): PImGuiWindow; cdecl;
  igFindWindowByID: function(id: ImGuiID): PImGuiWindow; cdecl;
  igFindWindowByName: function(const name: PUTF8Char): PImGuiWindow; cdecl;
  igUpdateWindowParentAndRootLinks: procedure(window: PImGuiWindow; flags: ImGuiWindowFlags; parent_window: PImGuiWindow); cdecl;
  igUpdateWindowSkipRefresh: procedure(window: PImGuiWindow); cdecl;
  igCalcWindowNextAutoFitSize: procedure(pOut: PImVec2; window: PImGuiWindow); cdecl;
  igIsWindowChildOf: function(window: PImGuiWindow; potential_parent: PImGuiWindow; popup_hierarchy: Boolean; dock_hierarchy: Boolean): Boolean; cdecl;
  igIsWindowWithinBeginStackOf: function(window: PImGuiWindow; potential_parent: PImGuiWindow): Boolean; cdecl;
  igIsWindowAbove: function(potential_above: PImGuiWindow; potential_below: PImGuiWindow): Boolean; cdecl;
  igIsWindowNavFocusable: function(window: PImGuiWindow): Boolean; cdecl;
  igSetWindowPos_WindowPtr: procedure(window: PImGuiWindow; pos: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowSize_WindowPtr: procedure(window: PImGuiWindow; size: ImVec2; cond: ImGuiCond); cdecl;
  igSetWindowCollapsed_WindowPtr: procedure(window: PImGuiWindow; collapsed: Boolean; cond: ImGuiCond); cdecl;
  igSetWindowHitTestHole: procedure(window: PImGuiWindow; pos: ImVec2; size: ImVec2); cdecl;
  igSetWindowHiddenAndSkipItemsForCurrentFrame: procedure(window: PImGuiWindow); cdecl;
  igSetWindowParentWindowForFocusRoute: procedure(window: PImGuiWindow; parent_window: PImGuiWindow); cdecl;
  igWindowRectAbsToRel: procedure(pOut: PImRect; window: PImGuiWindow; r: ImRect); cdecl;
  igWindowRectRelToAbs: procedure(pOut: PImRect; window: PImGuiWindow; r: ImRect); cdecl;
  igWindowPosAbsToRel: procedure(pOut: PImVec2; window: PImGuiWindow; p: ImVec2); cdecl;
  igWindowPosRelToAbs: procedure(pOut: PImVec2; window: PImGuiWindow; p: ImVec2); cdecl;
  igFocusWindow: procedure(window: PImGuiWindow; flags: ImGuiFocusRequestFlags); cdecl;
  igFocusTopMostWindowUnderOne: procedure(under_this_window: PImGuiWindow; ignore_window: PImGuiWindow; filter_viewport: PImGuiViewport; flags: ImGuiFocusRequestFlags); cdecl;
  igBringWindowToFocusFront: procedure(window: PImGuiWindow); cdecl;
  igBringWindowToDisplayFront: procedure(window: PImGuiWindow); cdecl;
  igBringWindowToDisplayBack: procedure(window: PImGuiWindow); cdecl;
  igBringWindowToDisplayBehind: procedure(window: PImGuiWindow; above_window: PImGuiWindow); cdecl;
  igFindWindowDisplayIndex: function(window: PImGuiWindow): Integer; cdecl;
  igFindBottomMostVisibleWindowWithinBeginStack: function(window: PImGuiWindow): PImGuiWindow; cdecl;
  igSetNextWindowRefreshPolicy: procedure(flags: ImGuiWindowRefreshFlags); cdecl;
  igSetCurrentFont: procedure(font: PImFont); cdecl;
  igGetDefaultFont: function(): PImFont; cdecl;
  igPushPasswordFont: procedure(); cdecl;
  igGetForegroundDrawList_WindowPtr: function(window: PImGuiWindow): PImDrawList; cdecl;
  igAddDrawListToDrawDataEx: procedure(draw_data: PImDrawData; out_list: PImVector_ImDrawListPtr; draw_list: PImDrawList); cdecl;
  igInitialize: procedure(); cdecl;
  igShutdown: procedure(); cdecl;
  igUpdateInputEvents: procedure(trickle_fast_inputs: Boolean); cdecl;
  igUpdateHoveredWindowAndCaptureFlags: procedure(); cdecl;
  igFindHoveredWindowEx: procedure(pos: ImVec2; find_first_and_in_any_viewport: Boolean; out_hovered_window: PPImGuiWindow; out_hovered_window_under_moving_window: PPImGuiWindow); cdecl;
  igStartMouseMovingWindow: procedure(window: PImGuiWindow); cdecl;
  igStartMouseMovingWindowOrNode: procedure(window: PImGuiWindow; node: PImGuiDockNode; undock: Boolean); cdecl;
  igUpdateMouseMovingWindowNewFrame: procedure(); cdecl;
  igUpdateMouseMovingWindowEndFrame: procedure(); cdecl;
  igAddContextHook: function(context: PImGuiContext; const hook: PImGuiContextHook): ImGuiID; cdecl;
  igRemoveContextHook: procedure(context: PImGuiContext; hook_to_remove: ImGuiID); cdecl;
  igCallContextHooks: procedure(context: PImGuiContext; &type: ImGuiContextHookType); cdecl;
  igTranslateWindowsInViewport: procedure(viewport: PImGuiViewportP; old_pos: ImVec2; new_pos: ImVec2; old_size: ImVec2; new_size: ImVec2); cdecl;
  igScaleWindowsInViewport: procedure(viewport: PImGuiViewportP; scale: Single); cdecl;
  igDestroyPlatformWindow: procedure(viewport: PImGuiViewportP); cdecl;
  igSetWindowViewport: procedure(window: PImGuiWindow; viewport: PImGuiViewportP); cdecl;
  igSetCurrentViewport: procedure(window: PImGuiWindow; viewport: PImGuiViewportP); cdecl;
  igGetViewportPlatformMonitor: function(viewport: PImGuiViewport): PImGuiPlatformMonitor; cdecl;
  igFindHoveredViewportFromPlatformWindowStack: function(mouse_platform_pos: ImVec2): PImGuiViewportP; cdecl;
  igMarkIniSettingsDirty_Nil: procedure(); cdecl;
  igMarkIniSettingsDirty_WindowPtr: procedure(window: PImGuiWindow); cdecl;
  igClearIniSettings: procedure(); cdecl;
  igAddSettingsHandler: procedure(const handler: PImGuiSettingsHandler); cdecl;
  igRemoveSettingsHandler: procedure(const type_name: PUTF8Char); cdecl;
  igFindSettingsHandler: function(const type_name: PUTF8Char): PImGuiSettingsHandler; cdecl;
  igCreateNewWindowSettings: function(const name: PUTF8Char): PImGuiWindowSettings; cdecl;
  igFindWindowSettingsByID: function(id: ImGuiID): PImGuiWindowSettings; cdecl;
  igFindWindowSettingsByWindow: function(window: PImGuiWindow): PImGuiWindowSettings; cdecl;
  igClearWindowSettings: procedure(const name: PUTF8Char); cdecl;
  igLocalizeRegisterEntries: procedure(const entries: PImGuiLocEntry; count: Integer); cdecl;
  igLocalizeGetMsg: function(key: ImGuiLocKey): PUTF8Char; cdecl;
  igSetScrollX_WindowPtr: procedure(window: PImGuiWindow; scroll_x: Single); cdecl;
  igSetScrollY_WindowPtr: procedure(window: PImGuiWindow; scroll_y: Single); cdecl;
  igSetScrollFromPosX_WindowPtr: procedure(window: PImGuiWindow; local_x: Single; center_x_ratio: Single); cdecl;
  igSetScrollFromPosY_WindowPtr: procedure(window: PImGuiWindow; local_y: Single; center_y_ratio: Single); cdecl;
  igScrollToItem: procedure(flags: ImGuiScrollFlags); cdecl;
  igScrollToRect: procedure(window: PImGuiWindow; rect: ImRect; flags: ImGuiScrollFlags); cdecl;
  igScrollToRectEx: procedure(pOut: PImVec2; window: PImGuiWindow; rect: ImRect; flags: ImGuiScrollFlags); cdecl;
  igScrollToBringRectIntoView: procedure(window: PImGuiWindow; rect: ImRect); cdecl;
  igGetItemStatusFlags: function(): ImGuiItemStatusFlags; cdecl;
  igGetItemFlags: function(): ImGuiItemFlags; cdecl;
  igGetActiveID: function(): ImGuiID; cdecl;
  igGetFocusID: function(): ImGuiID; cdecl;
  igSetActiveID: procedure(id: ImGuiID; window: PImGuiWindow); cdecl;
  igSetFocusID: procedure(id: ImGuiID; window: PImGuiWindow); cdecl;
  igClearActiveID: procedure(); cdecl;
  igGetHoveredID: function(): ImGuiID; cdecl;
  igSetHoveredID: procedure(id: ImGuiID); cdecl;
  igKeepAliveID: procedure(id: ImGuiID); cdecl;
  igMarkItemEdited: procedure(id: ImGuiID); cdecl;
  igPushOverrideID: procedure(id: ImGuiID); cdecl;
  igGetIDWithSeed_Str: function(const str_id_begin: PUTF8Char; const str_id_end: PUTF8Char; seed: ImGuiID): ImGuiID; cdecl;
  igGetIDWithSeed_Int: function(n: Integer; seed: ImGuiID): ImGuiID; cdecl;
  igItemSize_Vec2: procedure(size: ImVec2; text_baseline_y: Single); cdecl;
  igItemSize_Rect: procedure(bb: ImRect; text_baseline_y: Single); cdecl;
  igItemAdd: function(bb: ImRect; id: ImGuiID; const nav_bb: PImRect; extra_flags: ImGuiItemFlags): Boolean; cdecl;
  igItemHoverable: function(bb: ImRect; id: ImGuiID; item_flags: ImGuiItemFlags): Boolean; cdecl;
  igIsWindowContentHoverable: function(window: PImGuiWindow; flags: ImGuiHoveredFlags): Boolean; cdecl;
  igIsClippedEx: function(bb: ImRect; id: ImGuiID): Boolean; cdecl;
  igSetLastItemData: procedure(item_id: ImGuiID; item_flags: ImGuiItemFlags; status_flags: ImGuiItemStatusFlags; item_rect: ImRect); cdecl;
  igCalcItemSize: procedure(pOut: PImVec2; size: ImVec2; default_w: Single; default_h: Single); cdecl;
  igCalcWrapWidthForPos: function(pos: ImVec2; wrap_pos_x: Single): Single; cdecl;
  igPushMultiItemsWidths: procedure(components: Integer; width_full: Single); cdecl;
  igShrinkWidths: procedure(items: PImGuiShrinkWidthItem; count: Integer; width_excess: Single); cdecl;
  igGetStyleVarInfo: function(idx: ImGuiStyleVar): PImGuiDataVarInfo; cdecl;
  igBeginDisabledOverrideReenable: procedure(); cdecl;
  igEndDisabledOverrideReenable: procedure(); cdecl;
  igLogBegin: procedure(flags: ImGuiLogFlags; auto_open_depth: Integer); cdecl;
  igLogToBuffer: procedure(auto_open_depth: Integer); cdecl;
  igLogRenderedText: procedure(const ref_pos: PImVec2; const text: PUTF8Char; const text_end: PUTF8Char); cdecl;
  igLogSetNextTextDecoration: procedure(const prefix: PUTF8Char; const suffix: PUTF8Char); cdecl;
  igBeginChildEx: function(const name: PUTF8Char; id: ImGuiID; size_arg: ImVec2; child_flags: ImGuiChildFlags; window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igBeginPopupEx: function(id: ImGuiID; extra_window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igOpenPopupEx: procedure(id: ImGuiID; popup_flags: ImGuiPopupFlags); cdecl;
  igClosePopupToLevel: procedure(remaining: Integer; restore_focus_to_window_under_popup: Boolean); cdecl;
  igClosePopupsOverWindow: procedure(ref_window: PImGuiWindow; restore_focus_to_window_under_popup: Boolean); cdecl;
  igClosePopupsExceptModals: procedure(); cdecl;
  igIsPopupOpen_ID: function(id: ImGuiID; popup_flags: ImGuiPopupFlags): Boolean; cdecl;
  igGetPopupAllowedExtentRect: procedure(pOut: PImRect; window: PImGuiWindow); cdecl;
  igGetTopMostPopupModal: function(): PImGuiWindow; cdecl;
  igGetTopMostAndVisiblePopupModal: function(): PImGuiWindow; cdecl;
  igFindBlockingModal: function(window: PImGuiWindow): PImGuiWindow; cdecl;
  igFindBestWindowPosForPopup: procedure(pOut: PImVec2; window: PImGuiWindow); cdecl;
  igFindBestWindowPosForPopupEx: procedure(pOut: PImVec2; ref_pos: ImVec2; size: ImVec2; last_dir: PImGuiDir; r_outer: ImRect; r_avoid: ImRect; policy: ImGuiPopupPositionPolicy); cdecl;
  igBeginTooltipEx: function(tooltip_flags: ImGuiTooltipFlags; extra_window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igBeginTooltipHidden: function(): Boolean; cdecl;
  igBeginViewportSideBar: function(const name: PUTF8Char; viewport: PImGuiViewport; dir: ImGuiDir; size: Single; window_flags: ImGuiWindowFlags): Boolean; cdecl;
  igBeginMenuEx: function(const &label: PUTF8Char; const icon: PUTF8Char; enabled: Boolean): Boolean; cdecl;
  igMenuItemEx: function(const &label: PUTF8Char; const icon: PUTF8Char; const shortcut: PUTF8Char; selected: Boolean; enabled: Boolean): Boolean; cdecl;
  igBeginComboPopup: function(popup_id: ImGuiID; bb: ImRect; flags: ImGuiComboFlags): Boolean; cdecl;
  igBeginComboPreview: function(): Boolean; cdecl;
  igEndComboPreview: procedure(); cdecl;
  igNavInitWindow: procedure(window: PImGuiWindow; force_reinit: Boolean); cdecl;
  igNavInitRequestApplyResult: procedure(); cdecl;
  igNavMoveRequestButNoResultYet: function(): Boolean; cdecl;
  igNavMoveRequestSubmit: procedure(move_dir: ImGuiDir; clip_dir: ImGuiDir; move_flags: ImGuiNavMoveFlags; scroll_flags: ImGuiScrollFlags); cdecl;
  igNavMoveRequestForward: procedure(move_dir: ImGuiDir; clip_dir: ImGuiDir; move_flags: ImGuiNavMoveFlags; scroll_flags: ImGuiScrollFlags); cdecl;
  igNavMoveRequestResolveWithLastItem: procedure(result: PImGuiNavItemData); cdecl;
  igNavMoveRequestResolveWithPastTreeNode: procedure(result: PImGuiNavItemData; tree_node_data: PImGuiTreeNodeStackData); cdecl;
  igNavMoveRequestCancel: procedure(); cdecl;
  igNavMoveRequestApplyResult: procedure(); cdecl;
  igNavMoveRequestTryWrapping: procedure(window: PImGuiWindow; move_flags: ImGuiNavMoveFlags); cdecl;
  igNavHighlightActivated: procedure(id: ImGuiID); cdecl;
  igNavClearPreferredPosForAxis: procedure(axis: ImGuiAxis); cdecl;
  igSetNavCursorVisibleAfterMove: procedure(); cdecl;
  igNavUpdateCurrentWindowIsScrollPushableX: procedure(); cdecl;
  igSetNavWindow: procedure(window: PImGuiWindow); cdecl;
  igSetNavID: procedure(id: ImGuiID; nav_layer: ImGuiNavLayer; focus_scope_id: ImGuiID; rect_rel: ImRect); cdecl;
  igSetNavFocusScope: procedure(focus_scope_id: ImGuiID); cdecl;
  igFocusItem: procedure(); cdecl;
  igActivateItemByID: procedure(id: ImGuiID); cdecl;
  igIsNamedKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsNamedKeyOrMod: function(key: ImGuiKey): Boolean; cdecl;
  igIsLegacyKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsKeyboardKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsGamepadKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsMouseKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsAliasKey: function(key: ImGuiKey): Boolean; cdecl;
  igIsLRModKey: function(key: ImGuiKey): Boolean; cdecl;
  igFixupKeyChord: function(key_chord: ImGuiKeyChord): ImGuiKeyChord; cdecl;
  igConvertSingleModFlagToKey: function(key: ImGuiKey): ImGuiKey; cdecl;
  igGetKeyData_ContextPtr: function(ctx: PImGuiContext; key: ImGuiKey): PImGuiKeyData; cdecl;
  igGetKeyData_Key: function(key: ImGuiKey): PImGuiKeyData; cdecl;
  igGetKeyChordName: function(key_chord: ImGuiKeyChord): PUTF8Char; cdecl;
  igMouseButtonToKey: function(button: ImGuiMouseButton): ImGuiKey; cdecl;
  igIsMouseDragPastThreshold: function(button: ImGuiMouseButton; lock_threshold: Single): Boolean; cdecl;
  igGetKeyMagnitude2d: procedure(pOut: PImVec2; key_left: ImGuiKey; key_right: ImGuiKey; key_up: ImGuiKey; key_down: ImGuiKey); cdecl;
  igGetNavTweakPressedAmount: function(axis: ImGuiAxis): Single; cdecl;
  igCalcTypematicRepeatAmount: function(t0: Single; t1: Single; repeat_delay: Single; repeat_rate: Single): Integer; cdecl;
  igGetTypematicRepeatRate: procedure(flags: ImGuiInputFlags; repeat_delay: PSingle; repeat_rate: PSingle); cdecl;
  igTeleportMousePos: procedure(pos: ImVec2); cdecl;
  igSetActiveIdUsingAllKeyboardKeys: procedure(); cdecl;
  igIsActiveIdUsingNavDir: function(dir: ImGuiDir): Boolean; cdecl;
  igGetKeyOwner: function(key: ImGuiKey): ImGuiID; cdecl;
  igSetKeyOwner: procedure(key: ImGuiKey; owner_id: ImGuiID; flags: ImGuiInputFlags); cdecl;
  igSetKeyOwnersForKeyChord: procedure(key: ImGuiKeyChord; owner_id: ImGuiID; flags: ImGuiInputFlags); cdecl;
  igSetItemKeyOwner_InputFlags: procedure(key: ImGuiKey; flags: ImGuiInputFlags); cdecl;
  igTestKeyOwner: function(key: ImGuiKey; owner_id: ImGuiID): Boolean; cdecl;
  igGetKeyOwnerData: function(ctx: PImGuiContext; key: ImGuiKey): PImGuiKeyOwnerData; cdecl;
  igIsKeyDown_ID: function(key: ImGuiKey; owner_id: ImGuiID): Boolean; cdecl;
  igIsKeyPressed_InputFlags: function(key: ImGuiKey; flags: ImGuiInputFlags; owner_id: ImGuiID): Boolean; cdecl;
  igIsKeyReleased_ID: function(key: ImGuiKey; owner_id: ImGuiID): Boolean; cdecl;
  igIsKeyChordPressed_InputFlags: function(key_chord: ImGuiKeyChord; flags: ImGuiInputFlags; owner_id: ImGuiID): Boolean; cdecl;
  igIsMouseDown_ID: function(button: ImGuiMouseButton; owner_id: ImGuiID): Boolean; cdecl;
  igIsMouseClicked_InputFlags: function(button: ImGuiMouseButton; flags: ImGuiInputFlags; owner_id: ImGuiID): Boolean; cdecl;
  igIsMouseReleased_ID: function(button: ImGuiMouseButton; owner_id: ImGuiID): Boolean; cdecl;
  igIsMouseDoubleClicked_ID: function(button: ImGuiMouseButton; owner_id: ImGuiID): Boolean; cdecl;
  igShortcut_ID: function(key_chord: ImGuiKeyChord; flags: ImGuiInputFlags; owner_id: ImGuiID): Boolean; cdecl;
  igSetShortcutRouting: function(key_chord: ImGuiKeyChord; flags: ImGuiInputFlags; owner_id: ImGuiID): Boolean; cdecl;
  igTestShortcutRouting: function(key_chord: ImGuiKeyChord; owner_id: ImGuiID): Boolean; cdecl;
  igGetShortcutRoutingData: function(key_chord: ImGuiKeyChord): PImGuiKeyRoutingData; cdecl;
  igDockContextInitialize: procedure(ctx: PImGuiContext); cdecl;
  igDockContextShutdown: procedure(ctx: PImGuiContext); cdecl;
  igDockContextClearNodes: procedure(ctx: PImGuiContext; root_id: ImGuiID; clear_settings_refs: Boolean); cdecl;
  igDockContextRebuildNodes: procedure(ctx: PImGuiContext); cdecl;
  igDockContextNewFrameUpdateUndocking: procedure(ctx: PImGuiContext); cdecl;
  igDockContextNewFrameUpdateDocking: procedure(ctx: PImGuiContext); cdecl;
  igDockContextEndFrame: procedure(ctx: PImGuiContext); cdecl;
  igDockContextGenNodeID: function(ctx: PImGuiContext): ImGuiID; cdecl;
  igDockContextQueueDock: procedure(ctx: PImGuiContext; target: PImGuiWindow; target_node: PImGuiDockNode; payload: PImGuiWindow; split_dir: ImGuiDir; split_ratio: Single; split_outer: Boolean); cdecl;
  igDockContextQueueUndockWindow: procedure(ctx: PImGuiContext; window: PImGuiWindow); cdecl;
  igDockContextQueueUndockNode: procedure(ctx: PImGuiContext; node: PImGuiDockNode); cdecl;
  igDockContextProcessUndockWindow: procedure(ctx: PImGuiContext; window: PImGuiWindow; clear_persistent_docking_ref: Boolean); cdecl;
  igDockContextProcessUndockNode: procedure(ctx: PImGuiContext; node: PImGuiDockNode); cdecl;
  igDockContextCalcDropPosForDocking: function(target: PImGuiWindow; target_node: PImGuiDockNode; payload_window: PImGuiWindow; payload_node: PImGuiDockNode; split_dir: ImGuiDir; split_outer: Boolean; out_pos: PImVec2): Boolean; cdecl;
  igDockContextFindNodeByID: function(ctx: PImGuiContext; id: ImGuiID): PImGuiDockNode; cdecl;
  igDockNodeWindowMenuHandler_Default: procedure(ctx: PImGuiContext; node: PImGuiDockNode; tab_bar: PImGuiTabBar); cdecl;
  igDockNodeBeginAmendTabBar: function(node: PImGuiDockNode): Boolean; cdecl;
  igDockNodeEndAmendTabBar: procedure(); cdecl;
  igDockNodeGetRootNode: function(node: PImGuiDockNode): PImGuiDockNode; cdecl;
  igDockNodeIsInHierarchyOf: function(node: PImGuiDockNode; parent: PImGuiDockNode): Boolean; cdecl;
  igDockNodeGetDepth: function(const node: PImGuiDockNode): Integer; cdecl;
  igDockNodeGetWindowMenuButtonId: function(const node: PImGuiDockNode): ImGuiID; cdecl;
  igGetWindowDockNode: function(): PImGuiDockNode; cdecl;
  igGetWindowAlwaysWantOwnTabBar: function(window: PImGuiWindow): Boolean; cdecl;
  igBeginDocked: procedure(window: PImGuiWindow; p_open: PBoolean); cdecl;
  igBeginDockableDragDropSource: procedure(window: PImGuiWindow); cdecl;
  igBeginDockableDragDropTarget: procedure(window: PImGuiWindow); cdecl;
  igSetWindowDock: procedure(window: PImGuiWindow; dock_id: ImGuiID; cond: ImGuiCond); cdecl;
  igDockBuilderDockWindow: procedure(const window_name: PUTF8Char; node_id: ImGuiID); cdecl;
  igDockBuilderGetNode: function(node_id: ImGuiID): PImGuiDockNode; cdecl;
  igDockBuilderGetCentralNode: function(node_id: ImGuiID): PImGuiDockNode; cdecl;
  igDockBuilderAddNode: function(node_id: ImGuiID; flags: ImGuiDockNodeFlags): ImGuiID; cdecl;
  igDockBuilderRemoveNode: procedure(node_id: ImGuiID); cdecl;
  igDockBuilderRemoveNodeDockedWindows: procedure(node_id: ImGuiID; clear_settings_refs: Boolean); cdecl;
  igDockBuilderRemoveNodeChildNodes: procedure(node_id: ImGuiID); cdecl;
  igDockBuilderSetNodePos: procedure(node_id: ImGuiID; pos: ImVec2); cdecl;
  igDockBuilderSetNodeSize: procedure(node_id: ImGuiID; size: ImVec2); cdecl;
  igDockBuilderSplitNode: function(node_id: ImGuiID; split_dir: ImGuiDir; size_ratio_for_node_at_dir: Single; out_id_at_dir: PImGuiID; out_id_at_opposite_dir: PImGuiID): ImGuiID; cdecl;
  igDockBuilderCopyDockSpace: procedure(src_dockspace_id: ImGuiID; dst_dockspace_id: ImGuiID; in_window_remap_pairs: PImVector_const_charPtr); cdecl;
  igDockBuilderCopyNode: procedure(src_node_id: ImGuiID; dst_node_id: ImGuiID; out_node_remap_pairs: PImVector_ImGuiID); cdecl;
  igDockBuilderCopyWindowSettings: procedure(const src_name: PUTF8Char; const dst_name: PUTF8Char); cdecl;
  igDockBuilderFinish: procedure(node_id: ImGuiID); cdecl;
  igPushFocusScope: procedure(id: ImGuiID); cdecl;
  igPopFocusScope: procedure(); cdecl;
  igGetCurrentFocusScope: function(): ImGuiID; cdecl;
  igIsDragDropActive: function(): Boolean; cdecl;
  igBeginDragDropTargetCustom: function(bb: ImRect; id: ImGuiID): Boolean; cdecl;
  igClearDragDrop: procedure(); cdecl;
  igIsDragDropPayloadBeingAccepted: function(): Boolean; cdecl;
  igRenderDragDropTargetRect: procedure(bb: ImRect; item_clip_rect: ImRect); cdecl;
  igGetTypingSelectRequest: function(flags: ImGuiTypingSelectFlags): PImGuiTypingSelectRequest; cdecl;
  igTypingSelectFindMatch: function(req: PImGuiTypingSelectRequest; items_count: Integer; get_item_name_func: igTypingSelectFindMatch_get_item_name_func; user_data: Pointer; nav_item_idx: Integer): Integer; cdecl;
  igTypingSelectFindNextSingleCharMatch: function(req: PImGuiTypingSelectRequest; items_count: Integer; get_item_name_func: igTypingSelectFindNextSingleCharMatch_get_item_name_func; user_data: Pointer; nav_item_idx: Integer): Integer; cdecl;
  igTypingSelectFindBestLeadingMatch: function(req: PImGuiTypingSelectRequest; items_count: Integer; get_item_name_func: igTypingSelectFindBestLeadingMatch_get_item_name_func; user_data: Pointer): Integer; cdecl;
  igBeginBoxSelect: function(scope_rect: ImRect; window: PImGuiWindow; box_select_id: ImGuiID; ms_flags: ImGuiMultiSelectFlags): Boolean; cdecl;
  igEndBoxSelect: procedure(scope_rect: ImRect; ms_flags: ImGuiMultiSelectFlags); cdecl;
  igMultiSelectItemHeader: procedure(id: ImGuiID; p_selected: PBoolean; p_button_flags: PImGuiButtonFlags); cdecl;
  igMultiSelectItemFooter: procedure(id: ImGuiID; p_selected: PBoolean; p_pressed: PBoolean); cdecl;
  igMultiSelectAddSetAll: procedure(ms: PImGuiMultiSelectTempData; selected: Boolean); cdecl;
  igMultiSelectAddSetRange: procedure(ms: PImGuiMultiSelectTempData; selected: Boolean; range_dir: Integer; first_item: ImGuiSelectionUserData; last_item: ImGuiSelectionUserData); cdecl;
  igGetBoxSelectState: function(id: ImGuiID): PImGuiBoxSelectState; cdecl;
  igGetMultiSelectState: function(id: ImGuiID): PImGuiMultiSelectState; cdecl;
  igSetWindowClipRectBeforeSetChannel: procedure(window: PImGuiWindow; clip_rect: ImRect); cdecl;
  igBeginColumns: procedure(const str_id: PUTF8Char; count: Integer; flags: ImGuiOldColumnFlags); cdecl;
  igEndColumns: procedure(); cdecl;
  igPushColumnClipRect: procedure(column_index: Integer); cdecl;
  igPushColumnsBackground: procedure(); cdecl;
  igPopColumnsBackground: procedure(); cdecl;
  igGetColumnsID: function(const str_id: PUTF8Char; count: Integer): ImGuiID; cdecl;
  igFindOrCreateColumns: function(window: PImGuiWindow; id: ImGuiID): PImGuiOldColumns; cdecl;
  igGetColumnOffsetFromNorm: function(const columns: PImGuiOldColumns; offset_norm: Single): Single; cdecl;
  igGetColumnNormFromOffset: function(const columns: PImGuiOldColumns; offset: Single): Single; cdecl;
  igTableOpenContextMenu: procedure(column_n: Integer); cdecl;
  igTableSetColumnWidth: procedure(column_n: Integer; width: Single); cdecl;
  igTableSetColumnSortDirection: procedure(column_n: Integer; sort_direction: ImGuiSortDirection; append_to_sort_specs: Boolean); cdecl;
  igTableGetHoveredRow: function(): Integer; cdecl;
  igTableGetHeaderRowHeight: function(): Single; cdecl;
  igTableGetHeaderAngledMaxLabelWidth: function(): Single; cdecl;
  igTablePushBackgroundChannel: procedure(); cdecl;
  igTablePopBackgroundChannel: procedure(); cdecl;
  igTableAngledHeadersRowEx: procedure(row_id: ImGuiID; angle: Single; max_label_width: Single; const data: PImGuiTableHeaderData; data_count: Integer); cdecl;
  igGetCurrentTable: function(): PImGuiTable; cdecl;
  igTableFindByID: function(id: ImGuiID): PImGuiTable; cdecl;
  igBeginTableEx: function(const name: PUTF8Char; id: ImGuiID; columns_count: Integer; flags: ImGuiTableFlags; outer_size: ImVec2; inner_width: Single): Boolean; cdecl;
  igTableBeginInitMemory: procedure(table: PImGuiTable; columns_count: Integer); cdecl;
  igTableBeginApplyRequests: procedure(table: PImGuiTable); cdecl;
  igTableSetupDrawChannels: procedure(table: PImGuiTable); cdecl;
  igTableUpdateLayout: procedure(table: PImGuiTable); cdecl;
  igTableUpdateBorders: procedure(table: PImGuiTable); cdecl;
  igTableUpdateColumnsWeightFromWidth: procedure(table: PImGuiTable); cdecl;
  igTableDrawBorders: procedure(table: PImGuiTable); cdecl;
  igTableDrawDefaultContextMenu: procedure(table: PImGuiTable; flags_for_section_to_display: ImGuiTableFlags); cdecl;
  igTableBeginContextMenuPopup: function(table: PImGuiTable): Boolean; cdecl;
  igTableMergeDrawChannels: procedure(table: PImGuiTable); cdecl;
  igTableGetInstanceData: function(table: PImGuiTable; instance_no: Integer): PImGuiTableInstanceData; cdecl;
  igTableGetInstanceID: function(table: PImGuiTable; instance_no: Integer): ImGuiID; cdecl;
  igTableSortSpecsSanitize: procedure(table: PImGuiTable); cdecl;
  igTableSortSpecsBuild: procedure(table: PImGuiTable); cdecl;
  igTableGetColumnNextSortDirection: function(column: PImGuiTableColumn): ImGuiSortDirection; cdecl;
  igTableFixColumnSortDirection: procedure(table: PImGuiTable; column: PImGuiTableColumn); cdecl;
  igTableGetColumnWidthAuto: function(table: PImGuiTable; column: PImGuiTableColumn): Single; cdecl;
  igTableBeginRow: procedure(table: PImGuiTable); cdecl;
  igTableEndRow: procedure(table: PImGuiTable); cdecl;
  igTableBeginCell: procedure(table: PImGuiTable; column_n: Integer); cdecl;
  igTableEndCell: procedure(table: PImGuiTable); cdecl;
  igTableGetCellBgRect: procedure(pOut: PImRect; const table: PImGuiTable; column_n: Integer); cdecl;
  igTableGetColumnName_TablePtr: function(const table: PImGuiTable; column_n: Integer): PUTF8Char; cdecl;
  igTableGetColumnResizeID: function(table: PImGuiTable; column_n: Integer; instance_no: Integer): ImGuiID; cdecl;
  igTableCalcMaxColumnWidth: function(const table: PImGuiTable; column_n: Integer): Single; cdecl;
  igTableSetColumnWidthAutoSingle: procedure(table: PImGuiTable; column_n: Integer); cdecl;
  igTableSetColumnWidthAutoAll: procedure(table: PImGuiTable); cdecl;
  igTableRemove: procedure(table: PImGuiTable); cdecl;
  igTableGcCompactTransientBuffers_TablePtr: procedure(table: PImGuiTable); cdecl;
  igTableGcCompactTransientBuffers_TableTempDataPtr: procedure(table: PImGuiTableTempData); cdecl;
  igTableGcCompactSettings: procedure(); cdecl;
  igTableLoadSettings: procedure(table: PImGuiTable); cdecl;
  igTableSaveSettings: procedure(table: PImGuiTable); cdecl;
  igTableResetSettings: procedure(table: PImGuiTable); cdecl;
  igTableGetBoundSettings: function(table: PImGuiTable): PImGuiTableSettings; cdecl;
  igTableSettingsAddSettingsHandler: procedure(); cdecl;
  igTableSettingsCreate: function(id: ImGuiID; columns_count: Integer): PImGuiTableSettings; cdecl;
  igTableSettingsFindByID: function(id: ImGuiID): PImGuiTableSettings; cdecl;
  igGetCurrentTabBar: function(): PImGuiTabBar; cdecl;
  igBeginTabBarEx: function(tab_bar: PImGuiTabBar; bb: ImRect; flags: ImGuiTabBarFlags): Boolean; cdecl;
  igTabBarFindTabByID: function(tab_bar: PImGuiTabBar; tab_id: ImGuiID): PImGuiTabItem; cdecl;
  igTabBarFindTabByOrder: function(tab_bar: PImGuiTabBar; order: Integer): PImGuiTabItem; cdecl;
  igTabBarFindMostRecentlySelectedTabForActiveWindow: function(tab_bar: PImGuiTabBar): PImGuiTabItem; cdecl;
  igTabBarGetCurrentTab: function(tab_bar: PImGuiTabBar): PImGuiTabItem; cdecl;
  igTabBarGetTabOrder: function(tab_bar: PImGuiTabBar; tab: PImGuiTabItem): Integer; cdecl;
  igTabBarGetTabName: function(tab_bar: PImGuiTabBar; tab: PImGuiTabItem): PUTF8Char; cdecl;
  igTabBarAddTab: procedure(tab_bar: PImGuiTabBar; tab_flags: ImGuiTabItemFlags; window: PImGuiWindow); cdecl;
  igTabBarRemoveTab: procedure(tab_bar: PImGuiTabBar; tab_id: ImGuiID); cdecl;
  igTabBarCloseTab: procedure(tab_bar: PImGuiTabBar; tab: PImGuiTabItem); cdecl;
  igTabBarQueueFocus_TabItemPtr: procedure(tab_bar: PImGuiTabBar; tab: PImGuiTabItem); cdecl;
  igTabBarQueueFocus_Str: procedure(tab_bar: PImGuiTabBar; const tab_name: PUTF8Char); cdecl;
  igTabBarQueueReorder: procedure(tab_bar: PImGuiTabBar; tab: PImGuiTabItem; offset: Integer); cdecl;
  igTabBarQueueReorderFromMousePos: procedure(tab_bar: PImGuiTabBar; tab: PImGuiTabItem; mouse_pos: ImVec2); cdecl;
  igTabBarProcessReorder: function(tab_bar: PImGuiTabBar): Boolean; cdecl;
  igTabItemEx: function(tab_bar: PImGuiTabBar; const &label: PUTF8Char; p_open: PBoolean; flags: ImGuiTabItemFlags; docked_window: PImGuiWindow): Boolean; cdecl;
  igTabItemSpacing: procedure(const str_id: PUTF8Char; flags: ImGuiTabItemFlags; width: Single); cdecl;
  igTabItemCalcSize_Str: procedure(pOut: PImVec2; const &label: PUTF8Char; has_close_button_or_unsaved_marker: Boolean); cdecl;
  igTabItemCalcSize_WindowPtr: procedure(pOut: PImVec2; window: PImGuiWindow); cdecl;
  igTabItemBackground: procedure(draw_list: PImDrawList; bb: ImRect; flags: ImGuiTabItemFlags; col: ImU32); cdecl;
  igTabItemLabelAndCloseButton: procedure(draw_list: PImDrawList; bb: ImRect; flags: ImGuiTabItemFlags; frame_padding: ImVec2; const &label: PUTF8Char; tab_id: ImGuiID; close_button_id: ImGuiID; is_contents_visible: Boolean; out_just_closed: PBoolean; out_text_clipped: PBoolean); cdecl;
  igRenderText: procedure(pos: ImVec2; const text: PUTF8Char; const text_end: PUTF8Char; hide_text_after_hash: Boolean); cdecl;
  igRenderTextWrapped: procedure(pos: ImVec2; const text: PUTF8Char; const text_end: PUTF8Char; wrap_width: Single); cdecl;
  igRenderTextClipped: procedure(pos_min: ImVec2; pos_max: ImVec2; const text: PUTF8Char; const text_end: PUTF8Char; const text_size_if_known: PImVec2; align: ImVec2; const clip_rect: PImRect); cdecl;
  igRenderTextClippedEx: procedure(draw_list: PImDrawList; pos_min: ImVec2; pos_max: ImVec2; const text: PUTF8Char; const text_end: PUTF8Char; const text_size_if_known: PImVec2; align: ImVec2; const clip_rect: PImRect); cdecl;
  igRenderTextEllipsis: procedure(draw_list: PImDrawList; pos_min: ImVec2; pos_max: ImVec2; clip_max_x: Single; ellipsis_max_x: Single; const text: PUTF8Char; const text_end: PUTF8Char; const text_size_if_known: PImVec2); cdecl;
  igRenderFrame: procedure(p_min: ImVec2; p_max: ImVec2; fill_col: ImU32; borders: Boolean; rounding: Single); cdecl;
  igRenderFrameBorder: procedure(p_min: ImVec2; p_max: ImVec2; rounding: Single); cdecl;
  igRenderColorRectWithAlphaCheckerboard: procedure(draw_list: PImDrawList; p_min: ImVec2; p_max: ImVec2; fill_col: ImU32; grid_step: Single; grid_off: ImVec2; rounding: Single; flags: ImDrawFlags); cdecl;
  igRenderNavCursor: procedure(bb: ImRect; id: ImGuiID; flags: ImGuiNavRenderCursorFlags); cdecl;
  igFindRenderedTextEnd: function(const text: PUTF8Char; const text_end: PUTF8Char): PUTF8Char; cdecl;
  igRenderMouseCursor: procedure(pos: ImVec2; scale: Single; mouse_cursor: ImGuiMouseCursor; col_fill: ImU32; col_border: ImU32; col_shadow: ImU32); cdecl;
  igRenderArrow: procedure(draw_list: PImDrawList; pos: ImVec2; col: ImU32; dir: ImGuiDir; scale: Single); cdecl;
  igRenderBullet: procedure(draw_list: PImDrawList; pos: ImVec2; col: ImU32); cdecl;
  igRenderCheckMark: procedure(draw_list: PImDrawList; pos: ImVec2; col: ImU32; sz: Single); cdecl;
  igRenderArrowPointingAt: procedure(draw_list: PImDrawList; pos: ImVec2; half_sz: ImVec2; direction: ImGuiDir; col: ImU32); cdecl;
  igRenderArrowDockMenu: procedure(draw_list: PImDrawList; p_min: ImVec2; sz: Single; col: ImU32); cdecl;
  igRenderRectFilledRangeH: procedure(draw_list: PImDrawList; rect: ImRect; col: ImU32; x_start_norm: Single; x_end_norm: Single; rounding: Single); cdecl;
  igRenderRectFilledWithHole: procedure(draw_list: PImDrawList; outer: ImRect; inner: ImRect; col: ImU32; rounding: Single); cdecl;
  igCalcRoundingFlagsForRectInRect: function(r_in: ImRect; r_outer: ImRect; threshold: Single): ImDrawFlags; cdecl;
  igTextEx: procedure(const text: PUTF8Char; const text_end: PUTF8Char; flags: ImGuiTextFlags); cdecl;
  igButtonEx: function(const &label: PUTF8Char; size_arg: ImVec2; flags: ImGuiButtonFlags): Boolean; cdecl;
  igArrowButtonEx: function(const str_id: PUTF8Char; dir: ImGuiDir; size_arg: ImVec2; flags: ImGuiButtonFlags): Boolean; cdecl;
  igImageButtonEx: function(id: ImGuiID; user_texture_id: ImTextureID; image_size: ImVec2; uv0: ImVec2; uv1: ImVec2; bg_col: ImVec4; tint_col: ImVec4; flags: ImGuiButtonFlags): Boolean; cdecl;
  igSeparatorEx: procedure(flags: ImGuiSeparatorFlags; thickness: Single); cdecl;
  igSeparatorTextEx: procedure(id: ImGuiID; const &label: PUTF8Char; const label_end: PUTF8Char; extra_width: Single); cdecl;
  igCheckboxFlags_S64Ptr: function(const &label: PUTF8Char; flags: PImS64; flags_value: ImS64): Boolean; cdecl;
  igCheckboxFlags_U64Ptr: function(const &label: PUTF8Char; flags: PImU64; flags_value: ImU64): Boolean; cdecl;
  igCloseButton: function(id: ImGuiID; pos: ImVec2): Boolean; cdecl;
  igCollapseButton: function(id: ImGuiID; pos: ImVec2; dock_node: PImGuiDockNode): Boolean; cdecl;
  igScrollbar: procedure(axis: ImGuiAxis); cdecl;
  igScrollbarEx: function(bb: ImRect; id: ImGuiID; axis: ImGuiAxis; p_scroll_v: PImS64; avail_v: ImS64; contents_v: ImS64; draw_rounding_flags: ImDrawFlags): Boolean; cdecl;
  igGetWindowScrollbarRect: procedure(pOut: PImRect; window: PImGuiWindow; axis: ImGuiAxis); cdecl;
  igGetWindowScrollbarID: function(window: PImGuiWindow; axis: ImGuiAxis): ImGuiID; cdecl;
  igGetWindowResizeCornerID: function(window: PImGuiWindow; n: Integer): ImGuiID; cdecl;
  igGetWindowResizeBorderID: function(window: PImGuiWindow; dir: ImGuiDir): ImGuiID; cdecl;
  igButtonBehavior: function(bb: ImRect; id: ImGuiID; out_hovered: PBoolean; out_held: PBoolean; flags: ImGuiButtonFlags): Boolean; cdecl;
  igDragBehavior: function(id: ImGuiID; data_type: ImGuiDataType; p_v: Pointer; v_speed: Single; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags): Boolean; cdecl;
  igSliderBehavior: function(bb: ImRect; id: ImGuiID; data_type: ImGuiDataType; p_v: Pointer; const p_min: Pointer; const p_max: Pointer; const format: PUTF8Char; flags: ImGuiSliderFlags; out_grab_bb: PImRect): Boolean; cdecl;
  igSplitterBehavior: function(bb: ImRect; id: ImGuiID; axis: ImGuiAxis; size1: PSingle; size2: PSingle; min_size1: Single; min_size2: Single; hover_extend: Single; hover_visibility_delay: Single; bg_col: ImU32): Boolean; cdecl;
  igTreeNodeBehavior: function(id: ImGuiID; flags: ImGuiTreeNodeFlags; const &label: PUTF8Char; const label_end: PUTF8Char): Boolean; cdecl;
  igTreePushOverrideID: procedure(id: ImGuiID); cdecl;
  igTreeNodeGetOpen: function(storage_id: ImGuiID): Boolean; cdecl;
  igTreeNodeSetOpen: procedure(storage_id: ImGuiID; open: Boolean); cdecl;
  igTreeNodeUpdateNextOpen: function(storage_id: ImGuiID; flags: ImGuiTreeNodeFlags): Boolean; cdecl;
  igDataTypeGetInfo: function(data_type: ImGuiDataType): PImGuiDataTypeInfo; cdecl;
  igDataTypeFormatString: function(buf: PUTF8Char; buf_size: Integer; data_type: ImGuiDataType; const p_data: Pointer; const format: PUTF8Char): Integer; cdecl;
  igDataTypeApplyOp: procedure(data_type: ImGuiDataType; op: Integer; output: Pointer; const arg_1: Pointer; const arg_2: Pointer); cdecl;
  igDataTypeApplyFromText: function(const buf: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; const format: PUTF8Char; p_data_when_empty: Pointer): Boolean; cdecl;
  igDataTypeCompare: function(data_type: ImGuiDataType; const arg_1: Pointer; const arg_2: Pointer): Integer; cdecl;
  igDataTypeClamp: function(data_type: ImGuiDataType; p_data: Pointer; const p_min: Pointer; const p_max: Pointer): Boolean; cdecl;
  igDataTypeIsZero: function(data_type: ImGuiDataType; const p_data: Pointer): Boolean; cdecl;
  igInputTextEx: function(const &label: PUTF8Char; const hint: PUTF8Char; buf: PUTF8Char; buf_size: Integer; size_arg: ImVec2; flags: ImGuiInputTextFlags; callback: ImGuiInputTextCallback; user_data: Pointer): Boolean; cdecl;
  igInputTextDeactivateHook: procedure(id: ImGuiID); cdecl;
  igTempInputText: function(bb: ImRect; id: ImGuiID; const &label: PUTF8Char; buf: PUTF8Char; buf_size: Integer; flags: ImGuiInputTextFlags): Boolean; cdecl;
  igTempInputScalar: function(bb: ImRect; id: ImGuiID; const &label: PUTF8Char; data_type: ImGuiDataType; p_data: Pointer; const format: PUTF8Char; const p_clamp_min: Pointer; const p_clamp_max: Pointer): Boolean; cdecl;
  igTempInputIsActive: function(id: ImGuiID): Boolean; cdecl;
  igGetInputTextState: function(id: ImGuiID): PImGuiInputTextState; cdecl;
  igSetNextItemRefVal: procedure(data_type: ImGuiDataType; p_data: Pointer); cdecl;
  igColorTooltip: procedure(const text: PUTF8Char; const col: PSingle; flags: ImGuiColorEditFlags); cdecl;
  igColorEditOptionsPopup: procedure(const col: PSingle; flags: ImGuiColorEditFlags); cdecl;
  igColorPickerOptionsPopup: procedure(const ref_col: PSingle; flags: ImGuiColorEditFlags); cdecl;
  igPlotEx: function(plot_type: ImGuiPlotType; const &label: PUTF8Char; values_getter: igPlotEx_values_getter; data: Pointer; values_count: Integer; values_offset: Integer; const overlay_text: PUTF8Char; scale_min: Single; scale_max: Single; size_arg: ImVec2): Integer; cdecl;
  igShadeVertsLinearColorGradientKeepAlpha: procedure(draw_list: PImDrawList; vert_start_idx: Integer; vert_end_idx: Integer; gradient_p0: ImVec2; gradient_p1: ImVec2; col0: ImU32; col1: ImU32); cdecl;
  igShadeVertsLinearUV: procedure(draw_list: PImDrawList; vert_start_idx: Integer; vert_end_idx: Integer; a: ImVec2; b: ImVec2; uv_a: ImVec2; uv_b: ImVec2; clamp: Boolean); cdecl;
  igShadeVertsTransformPos: procedure(draw_list: PImDrawList; vert_start_idx: Integer; vert_end_idx: Integer; pivot_in: ImVec2; cos_a: Single; sin_a: Single; pivot_out: ImVec2); cdecl;
  igGcCompactTransientMiscBuffers: procedure(); cdecl;
  igGcCompactTransientWindowBuffers: procedure(window: PImGuiWindow); cdecl;
  igGcAwakeTransientWindowBuffers: procedure(window: PImGuiWindow); cdecl;
  igErrorLog: function(const msg: PUTF8Char): Boolean; cdecl;
  igErrorRecoveryStoreState: procedure(state_out: PImGuiErrorRecoveryState); cdecl;
  igErrorRecoveryTryToRecoverState: procedure(const state_in: PImGuiErrorRecoveryState); cdecl;
  igErrorRecoveryTryToRecoverWindowState: procedure(const state_in: PImGuiErrorRecoveryState); cdecl;
  igErrorCheckUsingSetCursorPosToExtendParentBoundaries: procedure(); cdecl;
  igErrorCheckEndFrameFinalizeErrorTooltip: procedure(); cdecl;
  igBeginErrorTooltip: function(): Boolean; cdecl;
  igEndErrorTooltip: procedure(); cdecl;
  igDebugAllocHook: procedure(info: PImGuiDebugAllocInfo; frame_count: Integer; ptr: Pointer; size: NativeUInt); cdecl;
  igDebugDrawCursorPos: procedure(col: ImU32); cdecl;
  igDebugDrawLineExtents: procedure(col: ImU32); cdecl;
  igDebugDrawItemRect: procedure(col: ImU32); cdecl;
  igDebugTextUnformattedWithLocateItem: procedure(const line_begin: PUTF8Char; const line_end: PUTF8Char); cdecl;
  igDebugLocateItem: procedure(target_id: ImGuiID); cdecl;
  igDebugLocateItemOnHover: procedure(target_id: ImGuiID); cdecl;
  igDebugLocateItemResolveWithLastItem: procedure(); cdecl;
  igDebugBreakClearData: procedure(); cdecl;
  igDebugBreakButton: function(const &label: PUTF8Char; const description_of_location: PUTF8Char): Boolean; cdecl;
  igDebugBreakButtonTooltip: procedure(keyboard_only: Boolean; const description_of_location: PUTF8Char); cdecl;
  igShowFontAtlas: procedure(atlas: PImFontAtlas); cdecl;
  igDebugHookIdInfo: procedure(id: ImGuiID; data_type: ImGuiDataType; const data_id: Pointer; const data_id_end: Pointer); cdecl;
  igDebugNodeColumns: procedure(columns: PImGuiOldColumns); cdecl;
  igDebugNodeDockNode: procedure(node: PImGuiDockNode; const &label: PUTF8Char); cdecl;
  igDebugNodeDrawList: procedure(window: PImGuiWindow; viewport: PImGuiViewportP; const draw_list: PImDrawList; const &label: PUTF8Char); cdecl;
  igDebugNodeDrawCmdShowMeshAndBoundingBox: procedure(out_draw_list: PImDrawList; const draw_list: PImDrawList; const draw_cmd: PImDrawCmd; show_mesh: Boolean; show_aabb: Boolean); cdecl;
  igDebugNodeFont: procedure(font: PImFont); cdecl;
  igDebugNodeFontGlyph: procedure(font: PImFont; const glyph: PImFontGlyph); cdecl;
  igDebugNodeStorage: procedure(storage: PImGuiStorage; const &label: PUTF8Char); cdecl;
  igDebugNodeTabBar: procedure(tab_bar: PImGuiTabBar; const &label: PUTF8Char); cdecl;
  igDebugNodeTable: procedure(table: PImGuiTable); cdecl;
  igDebugNodeTableSettings: procedure(settings: PImGuiTableSettings); cdecl;
  igDebugNodeInputTextState: procedure(state: PImGuiInputTextState); cdecl;
  igDebugNodeTypingSelectState: procedure(state: PImGuiTypingSelectState); cdecl;
  igDebugNodeMultiSelectState: procedure(state: PImGuiMultiSelectState); cdecl;
  igDebugNodeWindow: procedure(window: PImGuiWindow; const &label: PUTF8Char); cdecl;
  igDebugNodeWindowSettings: procedure(settings: PImGuiWindowSettings); cdecl;
  igDebugNodeWindowsList: procedure(windows: PImVector_ImGuiWindowPtr; const &label: PUTF8Char); cdecl;
  igDebugNodeWindowsListByBeginStackParent: procedure(windows: PPImGuiWindow; windows_size: Integer; parent_in_begin_stack: PImGuiWindow); cdecl;
  igDebugNodeViewport: procedure(viewport: PImGuiViewportP); cdecl;
  igDebugNodePlatformMonitor: procedure(monitor: PImGuiPlatformMonitor; const &label: PUTF8Char; idx: Integer); cdecl;
  igDebugRenderKeyboardPreview: procedure(draw_list: PImDrawList); cdecl;
  igDebugRenderViewportThumbnail: procedure(draw_list: PImDrawList; viewport: PImGuiViewportP; bb: ImRect); cdecl;
  igImFontAtlasGetBuilderForStbTruetype: function(): PImFontBuilderIO; cdecl;
  igImFontAtlasUpdateConfigDataPointers: procedure(atlas: PImFontAtlas); cdecl;
  igImFontAtlasBuildInit: procedure(atlas: PImFontAtlas); cdecl;
  igImFontAtlasBuildSetupFont: procedure(atlas: PImFontAtlas; font: PImFont; font_config: PImFontConfig; ascent: Single; descent: Single); cdecl;
  igImFontAtlasBuildPackCustomRects: procedure(atlas: PImFontAtlas; stbrp_context_opaque: Pointer); cdecl;
  igImFontAtlasBuildFinish: procedure(atlas: PImFontAtlas); cdecl;
  igImFontAtlasBuildRender8bppRectFromString: procedure(atlas: PImFontAtlas; x: Integer; y: Integer; w: Integer; h: Integer; const in_str: PUTF8Char; in_marker_char: UTF8Char; in_marker_pixel_value: Byte); cdecl;
  igImFontAtlasBuildRender32bppRectFromString: procedure(atlas: PImFontAtlas; x: Integer; y: Integer; w: Integer; h: Integer; const in_str: PUTF8Char; in_marker_char: UTF8Char; in_marker_pixel_value: Cardinal); cdecl;
  igImFontAtlasBuildMultiplyCalcLookupTable: procedure(out_table: PByte; in_multiply_factor: Single); cdecl;
  igImFontAtlasBuildMultiplyRectAlpha8: procedure(table: PByte; pixels: PByte; x: Integer; y: Integer; w: Integer; h: Integer; stride: Integer); cdecl;
  igImFontAtlasBuildGetOversampleFactors: procedure(const cfg: PImFontConfig; out_oversample_h: PInteger; out_oversample_v: PInteger); cdecl;
  igLogText: procedure(const fmt: PUTF8Char) varargs; cdecl;
  ImGuiTextBuffer_appendf: procedure(self: PImGuiTextBuffer; const fmt: PUTF8Char) varargs; cdecl;
  igGET_FLT_MAX: function(): Single; cdecl;
  igGET_FLT_MIN: function(): Single; cdecl;
  ImVector_ImWchar_create: function(): PImVector_ImWchar; cdecl;
  ImVector_ImWchar_destroy: procedure(self: PImVector_ImWchar); cdecl;
  ImVector_ImWchar_Init: procedure(p: PImVector_ImWchar); cdecl;
  ImVector_ImWchar_UnInit: procedure(p: PImVector_ImWchar); cdecl;
  ImGuiPlatformIO_Set_Platform_GetWindowPos: procedure(platform_io: PImGuiPlatformIO; user_callback: ImGuiPlatformIO_Set_Platform_GetWindowPos_user_callback); cdecl;
  ImGuiPlatformIO_Set_Platform_GetWindowSize: procedure(platform_io: PImGuiPlatformIO; user_callback: ImGuiPlatformIO_Set_Platform_GetWindowSize_user_callback); cdecl;
  ImGui_ImplGlfw_InitForOpenGL: function(window: PGLFWwindow; install_callbacks: Boolean): Boolean; cdecl;
  ImGui_ImplGlfw_InitForVulkan: function(window: PGLFWwindow; install_callbacks: Boolean): Boolean; cdecl;
  ImGui_ImplGlfw_InitForOther: function(window: PGLFWwindow; install_callbacks: Boolean): Boolean; cdecl;
  ImGui_ImplGlfw_Shutdown: procedure(); cdecl;
  ImGui_ImplGlfw_NewFrame: procedure(); cdecl;
  ImGui_ImplGlfw_InstallCallbacks: procedure(window: PGLFWwindow); cdecl;
  ImGui_ImplGlfw_RestoreCallbacks: procedure(window: PGLFWwindow); cdecl;
  ImGui_ImplGlfw_SetCallbacksChainForAllWindows: procedure(chain_for_all_windows: Boolean); cdecl;
  ImGui_ImplGlfw_WindowFocusCallback: procedure(window: PGLFWwindow; focused: Integer); cdecl;
  ImGui_ImplGlfw_CursorEnterCallback: procedure(window: PGLFWwindow; entered: Integer); cdecl;
  ImGui_ImplGlfw_CursorPosCallback: procedure(window: PGLFWwindow; x: Double; y: Double); cdecl;
  ImGui_ImplGlfw_MouseButtonCallback: procedure(window: PGLFWwindow; button: Integer; action: Integer; mods: Integer); cdecl;
  ImGui_ImplGlfw_ScrollCallback: procedure(window: PGLFWwindow; xoffset: Double; yoffset: Double); cdecl;
  ImGui_ImplGlfw_KeyCallback: procedure(window: PGLFWwindow; key: Integer; scancode: Integer; action: Integer; mods: Integer); cdecl;
  ImGui_ImplGlfw_CharCallback: procedure(window: PGLFWwindow; c: Cardinal); cdecl;
  ImGui_ImplGlfw_MonitorCallback: procedure(monitor: PGLFWmonitor; event: Integer); cdecl;
  ImGui_ImplGlfw_Sleep: procedure(milliseconds: Integer); cdecl;
  ImGui_ImplOpenGL2_Init: function(): Boolean; cdecl;
  ImGui_ImplOpenGL2_Shutdown: procedure(); cdecl;
  ImGui_ImplOpenGL2_NewFrame: procedure(); cdecl;
  ImGui_ImplOpenGL2_RenderDrawData: procedure(draw_data: PImDrawData; virtual_width: Single; virtual_height: Single); cdecl;
  ImGui_ImplOpenGL2_CreateFontsTexture: function(): Boolean; cdecl;
  ImGui_ImplOpenGL2_DestroyFontsTexture: procedure(); cdecl;
  ImGui_ImplOpenGL2_CreateDeviceObjects: function(): Boolean; cdecl;
  ImGui_ImplOpenGL2_DestroyDeviceObjects: procedure(); cdecl;

procedure GetExports(const aDLLHandle: THandle);

{$ENDREGION}

{$REGION ' Pyro.Common '}
const
  PyDONT_CARE = GLFW_DONT_CARE;

type
  { TPyHAlign }
  TPyHAlign = (haLeft, haCenter, haRight);

  { TPyVAlign }
  TPyVAlign = (vaTop, vaCenter, vaBottom);

  { TPyCallback }
  TPyCallback<T> = record
    Handler: T;
    UserData: Pointer;
  end;

type
  { TPyVirtualBuffer }
  TPyVirtualBuffer = class(TCustomMemoryStream)
  protected
    FHandle: THandle;
    FName: string;
    procedure Clear();
  public
    constructor Create(aSize: Cardinal);
    destructor Destroy(); override;
    function Write(const aBuffer; aCount: Longint): Longint; override;
    function Write(const aBuffer: TBytes; aOffset, aCount: Longint): Longint; override;
    procedure SaveToFile(aFilename: string);
    property Name: string read FName;
    function  Eob(): Boolean;
    function  ReadString(): string;
    class function LoadFromFile(const aFilename: string): TPyVirtualBuffer;
  end;

  { TPyRingBuffer }
  TPyRingBuffer<T> = class
  private type
    PType = ^T;
  private
    FBuffer: array of T;
    FReadIndex, FWriteIndex, FCapacity: Integer;
  public
    constructor Create(ACapacity: Integer);
    function Write(const AData: array of T; ACount: Integer): Integer;
    function Read(var AData: array of T; ACount: Integer): Integer;
    function DirectReadPointer(ACount: Integer): Pointer;
    function AvailableBytes(): Integer;
    procedure Clear();
  end;

  { TPyVirtualRingBuffer }
  TPyVirtualRingBuffer<T> = class
  private type
    PType = ^T;
  private
    FBuffer: TPyVirtualBuffer;
    FReadIndex, FWriteIndex, FCapacity: Integer;
    function GetArrayValue(AIndex: Integer): T;
    procedure SetArrayValue(AIndex: Integer; AValue: T);
  public
    constructor Create(ACapacity: Integer);
    destructor Destroy; override;
    function Write(const AData: array of T; ACount: Integer): Integer;
    function Read(var AData: array of T; ACount: Integer): Integer;
    function DirectReadPointer(ACount: Integer): Pointer;
    function AvailableBytes(): Integer;
    procedure Clear();
  end;

  { TPyTimer }
  PPyTimer = ^TPyTimer;
  TPyTimer = record
  private
    FLastTime: Double;
    FInterval: Double;
    FSpeed: Double;
  public
    class operator Initialize (out ADest: TPyTimer);
    procedure InitMS(const AValue: Double);
    procedure InitFPS(const AValue: Double);
    function Check(): Boolean;
    procedure Reset();
    function  Speed(): Double;
  end;

  { TBaseObject }
  TPyBaseObject = class(TObject)
  public
    constructor Create(); virtual;
    destructor Destroy(); override;
  end;

  { TAsyncProc }
  TPyAsyncProc = reference to procedure;

  { TAsyncThread }
  TPyAsyncThread = class(TThread)
  protected
    FTask: TPyAsyncProc;
    FWait: TPyAsyncProc;
    FFinished: Boolean;
  public
    property TaskProc: TPyAsyncProc read FTask write FTask;
    property WaitProc: TPyAsyncProc read FWait write FWait;
    property Finished: Boolean read FFinished;
    constructor Create(); virtual;
    destructor Destroy(); override;
    procedure Execute(); override;
  end;

  { TAsync }
  TPyAsync = class(TPyBaseObject)
  protected type
    TBusyData = record
      Name: string;
      Thread: Pointer;
      Flag: Boolean;
      Terminate: Boolean;
    end;
  protected
    FQueue: TList<TPyAsyncThread>;
    FBusy: TDictionary<string, TBusyData>;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    procedure Clear();
    procedure Process();
    procedure Exec(const AName: string; const ABackgroundTask: TPyAsyncProc; const AWaitForgroundTask: TPyAsyncProc);
    function  Busy(const AName: string): Boolean;
    procedure SetTerminate(const AName: string; const ATerminate: Boolean);
    function  ShouldTerminate(const AName: string): Boolean;
    procedure TerminateAll();
    procedure WaitForAllToTerminate();
    procedure Suspend();
    procedure Resume();
    procedure Enter();
    procedure Leave();
  end;

{$ENDREGION}

{$REGION ' Pyro.Utils '}
type

  { PyUtils }
  PyUtils = class
  private const
    CTempStaticBufferSize = 4096;
  private class var
    FCriticalSection: TCriticalSection;
    Marshaller: TMarshaller;
    TempStaticBuffer: array[0..CTempStaticBufferSize - 1] of Byte;
    FAsync: TPyAsync;
  private
    class constructor Create();
    class destructor Destroy();
  public
    class procedure UnitInit(); static;
    class procedure FreeNilObject(const [ref] AObject: TObject); static;
    class function  UnitToScalarValue(const aValue, aMaxValue: Double): Double; static;
    class function  SampleTimeToPosition(SampleRate: Integer; TimeInSeconds: Double; Channels: Integer; SampleSizeInBits: Integer): Int64; static;
    class function  FloatToSmallInt(Value: Single): SmallInt; static;
    class procedure ClearKeyboardBuffer(); static;
    class function  WasRunFromConsole() : Boolean; static;
    class function  IsStartedFromDelphiIDE: Boolean; static;
    class function  GetTempStaticBuffer(): PByte; static;
    class function  GetTempStaticBufferSize(): Integer; static;
    class procedure EnterCriticalSection(); static;
    class procedure LeaveCriticalSection(); static;
    class function  EnableVirtualTerminalProcessing(): DWORD; static;
    class function  HasConsoleOutput: Boolean; static;
    class function  IsValidWin64PE(const AFilePath: string): Boolean; static;
    class function  AddResFromMemory(const aModuleFile: string; const aName: string; aData: Pointer; aSize: Cardinal): Boolean; static;
    class function  ResourceExists(aInstance: THandle; const aResName: string): Boolean; static;
    class function  RemoveBOM(const AString: string): string; overload; static;
    class function  RemoveBOM(const ABytes: TBytes): TBytes; overload; static;
    class function  AsUTF8(const AText: string; const AArgs: array of const; const AUseArgs: Boolean=True; const ARemoveBOM: Boolean=False): Pointer; static;
    class procedure UpdateIconResource(const AExeFilePath, AIconFilePath: string); static;
    class procedure UpdateVersionInfoResource(const PEFilePath: string; const AMajor, AMinor, APatch: Word; const AProductName, ADescription, AFilename, ACompanyName, ACopyright: string); static;
    class function  HasEnoughDiskSpace(const APath: string; ARequiredSpace: Int64): Boolean; static;
    class function  RemoveDuplicates(const aText: string): string; static;
    class procedure ProcessMessages(); static;
    class procedure Wait(const AMilliseconds: Double); static;
    class function  HudTextItem(const AKey: string; const AValue: string; const APaddingWidth: Cardinal=20; const ASeperator: string='-'): string; static;
    class procedure AsyncProcess(); static;
    class procedure AsyncClear(); static;
    class procedure AsyncRun(const AName: string; const ABackgroundTask: TPyAsyncProc; const AWaitForgroundTask: TPyAsyncProc); static;
    class function  AsyncIsBusy(const AName: string): Boolean; static;
    class procedure AsyncSetTerminate(const AName: string; const ATerminate: Boolean); static;
    class function  AsyncShouldTerminate(const AName: string): Boolean; static;
    class procedure AsyncTerminateAll(); static;
    class procedure AsyncWaitForAllToTerminate(); static;
    class procedure AsyncSuspend(); static;
    class procedure AsyncResume(); static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Error '}
type

  { PyError }
  PyError = class
  private class var
    FError: string;
  private
    class constructor Create();
    class destructor Destroy();
  public
    class procedure UnitInit();
    class procedure SetError(const AText: string; const AArgs: array of const); static;
    class function  GetError(): string; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Math '}
const
  PyRADTODEG = 180.0 / PI;
  PyDEGTORAD = PI / 180.0;
  PyEPSILON  = 0.00001;
  PyNAN      =  0.0 / 0.0;
  PyKILOBYTE = 1024;                     // 1 KB = 1024 bytes
  PyMEGABYTE = 1024 * 1024;              // 1 MB = 1024 * 1024 bytes
  PyGIGABYTE = 1024 * 1024 * 1024;       // 1 GB = 1024 * 1024 * 1024 bytes

type
  { TPyVector }
  PPyVector = ^TPyVector;
  TPyVector = record
    x,y,z,w: Single;
  end;

  { TPyPoint }
  PPyPoint = ^TPyPoint;
  TPyPoint = record
    x,y: Single;
  end;

  { TPySize }
  PPySize = ^TPySize;
  TPySize = record
    w,h: Single;
  end;

  { TPyRect }
  PPyRect = ^TPyRect;
  TPyRect = record
    pos: TPyPoint;
    size: TPySize;
  end;

  { TPyExtent }
  PPyExtent = ^TPyExtent;
  TPyExtent = record
    min: TPyPoint;
    max: TPyPoint;
  end;

  { TPyOBB }
  PPyOBB = ^TPyOBB;
  TPyOBB = record
    Center: TPyPoint;
    Extents: TPyPoint;
    Rotation: Single;
  end;


  { TPyLineIntersection }
  TPyLineIntersection = (liNone, liTrue, liParallel);

  { TPyEaseType }
  TPyEaseType = (etLinearTween, etInQuad, etOutQuad, etInOutQuad, etInCubic,
    etOutCubic, etInOutCubic, etInQuart, etOutQuart, etInOutQuart, etInQuint,
    etOutQuint, etInOutQuint, etInSine, etOutSine, etInOutSine, etInExpo,
    etOutExpo, etInOutExpo, etInCircle, etOutCircle, etInOutCircle);


  { PyMath }
  PyMath = class
  private class var
    FCosTable: array [0..360] of Single;
    FSinTable: array [0..360] of Single;
  private
    class constructor Create();
    class destructor Destroy();

  public
    class procedure UnitInit(); static;
    class function Point(const X, Y: Single): TPyPoint; static;
    class function Vector(const X, Y: Single): TPyVector; static;
    class function Size(const W, H: Single): TPySize; static;
    class function Rect(const X, Y, W, H: Single): TPyRect; static;
    class function Extent(const AMinX, AMinY, AMaxX, AMaxY: Single): TPyExtent; static;

    class procedure AssignVector(var A: TPyVector; const B: TPyVector); overload; static;
    class procedure ClearVector(var A: TPyVector); static;
    class procedure AddVector(var A: TPyVector; const B: TPyVector); static;
    class procedure SubVector(var A: TPyVector; const B: TPyVector); static;
    class procedure MulVector(var A: TPyVector; const B: TPyVector); static;
    class procedure DivideVector(var A: TPyVector; const B: TPyVector); overload; static;
    class procedure DivideVictor(var A: TPyVector; const AValue: Single); overload; static;
    class function  VectorMagnitude(const A: TPyVector): Single; static;
    class function  VectorMagnitudeTruncate(const A: TPyVector; const AMaxMagnitude: Single): TPyVector; static;
    class function  VectorDistance(const A, B: TPyVector): Single; static;
    class procedure NormalizeVector(var A: TPyVector); static;
    class function  VectorAngle(const A, B: TPyVector): Single; static;
    class procedure ThrustVector(var A: TPyVector; const AAngle, ASpeed: Single); static;
    class function  VectorMagnitudeSquared(const A: TPyVector): Single; static;
    class function  VectorDotProduct(const A, B: TPyVector): Single; static;
    class procedure ScaleVectory(var A: TPyVector; const AValue: Single); static;
    class function  ProjectVector(const A, B: TPyVector): TPyVector; static;
    class procedure NegateVector(var A: TPyVector); static;

    class function  UnitToScalarValue(const AValue, AMaxValue: Double): Double; static;

    class function AngleCos(const AAngle: Cardinal): Single; static;
    class function AngleSin(const AAngle: Cardinal): Single; static;

    class function  RandomRange(const AMin, AMax: Integer): Integer; static;
    class function  RandomRangef(const AMin, AMax: Single): Single; static;
    class function  RandomBool(): Boolean; static;
    class function  GetRandomSeed(): Integer; static;
    class procedure SetRandomSeed(const AVaLue: Integer); static;
    class function  ClipVaLuef(var AVaLue: Single; const AMin, AMax: Single; const AWrap: Boolean): Single; static;
    class function  ClipVaLue(var AVaLue: Integer; const aMin, AMax: Integer; const AWrap: Boolean): Integer; static;
    class function  SameSign(const AVaLue1, AVaLue2: Integer): Boolean; static;
    class function  SameSignf(const AVaLue1, AVaLue2: Single): Boolean; static;
    class function  SameVaLue(const AA, AB: Double; const AEpsilon: Double = 0): Boolean; static;
    class function  SameVaLuef(const AA, AB: Single; const AEpsilon: Single = 0): Boolean; static;
    class function  AngleDiff(const ASrcAngle, ADestAngle: Single): Single; static;
    class procedure AngleRotatePos(const AAngle: Single; var AX, AY: Single); static;
    class procedure SmoothMove(var AVaLue: Single; const AAmount, AMax, ADrag: Single); static;
    class function  Lerp(const AFrom, ATo, ATime: Double): Double; static;
    class function  PointInRectangle(APoint: TPyVector; ARect: TPyRect): Boolean; static;
    class function  PointInCircle(APoint, ACenter: TPyVector; ARadius: Single): Boolean; static;
    class function  PointInTriangle(APoint, AP1, AP2, AP3: TPyVector): Boolean; static;
    class function  CirclesOverlap(ACenter1: TPyVector; ARadius1: Single; ACenter2: TPyVector; ARadius2: Single): Boolean; static;
    class function  CircleInRectangle(ACenter: TPyVector; ARadius: Single; ARect: TPyRect): Boolean; static;
    class function  RectanglesOverlap(ARect1: TPyRect; ARect2: TPyRect): Boolean; static;
    class function  RectangleIntersection(ARect1, ARect2: TPyRect): TPyRect; static;
    class function  LineIntersection(AX1, AY1, AX2, AY2, AX3, AY3, AX4, AY4: Integer; var AX: Integer; var AY: Integer): TPyLineIntersection; static;
    class function  RadiusOverlap(ARadius1, AX1, AY1, ARadius2, AX2, AY2, AShrinkFactor: Single): Boolean; static;
    class function  EaseValue(ACurrentTime: Double; AStartValue: Double; AChangeInValue: Double; ADuration: Double; AEaseType: TPyEaseType): Double; static;
    class function  EasePosition(AStartPos: Double; AEndPos: Double; ACurrentPos: Double; AEaseType: TPyEaseType): Double; static;
    class function  OBBIntersect(const AObbA, AObbB: TPyOBB): Boolean; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Console '}
const
  PyLF   = #10;
  PyCR   = #13;
  PyCRLF = PyLF+PyCR;
  PyESC  = #27;

  PyVK_ESC = 27;

  // Cursor Movement
  PyCSICursorPos = PyESC + '[%d;%dH';         // Set cursor position
  PyCSICursorUp = PyESC + '[%dA';             // Move cursor up
  PyCSICursorDown = PyESC + '[%dB';           // Move cursor down
  PyCSICursorForward = PyESC + '[%dC';        // Move cursor forward
  PyCSICursorBack = PyESC + '[%dD';           // Move cursor backward
  PyCSISaveCursorPos = PyESC + '[s';          // Save cursor position
  PyCSIRestoreCursorPos = PyESC + '[u';       // Restore cursor position

  // Cursor Visibility
  PyCSIShowCursor = PyESC + '[?25h';          // Show cursor
  PyCSIHideCursor = PyESC + '[?25l';          // Hide cursor
  PyCSIBlinkCursor = PyESC + '[?12h';         // Enable cursor blinking
  PyCSISteadyCursor = PyESC + '[?12l';        // Disable cursor blinking

  // Screen Manipulation
  PyCSIClearScreen = PyESC + '[2J';           // Clear screen
  PyCSIClearLine = PyESC + '[2K';             // Clear line
  PyCSIScrollUp = PyESC + '[%dS';             // Scroll up by n lines
  PyCSIScrollDown = PyESC + '[%dT';           // Scroll down by n lines

  // Text Formatting
  PyCSIBold = PyESC + '[1m';                  // Bold text
  PyCSIUnderline = PyESC + '[4m';             // Underline text
  PyCSIResetFormat = PyESC + '[0m';           // Reset text formatting
  PyCSIResetBackground = #27'[49m';         // Reset background text formatting
  PyCSIResetForeground = #27'[39m';         // Reset forground text formatting
  PyCSIInvertColors = PyESC + '[7m';          // Invert foreground/background
  PyCSINormalColors = PyESC + '[27m';         // Normal colors

  PyCSIDim = PyESC + '[2m';
  PyCSIItalic = PyESC + '[3m';
  PyCSIBlink = PyESC + '[5m';
  PyCSIFramed = PyESC + '[51m';
  PyCSIEncircled = PyESC + '[52m';

  // Text Modification
  PyCSIInsertChar = PyESC + '[%d@';           // Insert n spaces at cursor position
  PyCSIDeleteChar = PyESC + '[%dP';           // Delete n characters at cursor position
  PyCSIEraseChar = PyESC + '[%dX';            // Erase n characters at cursor position

  // Colors (Foreground and Background)
  PyCSIFGBlack = PyESC + '[30m';
  PyCSIFGRed = PyESC + '[31m';
  PyCSIFGGreen = PyESC + '[32m';
  PyCSIFGYellow = PyESC + '[33m';
  PyCSIFGBlue = PyESC + '[34m';
  PyCSIFGMagenta = PyESC + '[35m';
  PyCSIFGCyan = PyESC + '[36m';
  PyCSIFGWhite = PyESC + '[37m';

  PyCSIBGBlack = PyESC + '[40m';
  PyCSIBGRed = PyESC + '[41m';
  PyCSIBGGreen = PyESC + '[42m';
  CPySIBGYellow = PyESC + '[43m';
  PyCSIBGBlue = PyESC + '[44m';
  PyCSIBGMagenta = PyESC + '[45m';
  PyCSIBGCyan = PyESC + '[46m';
  PyCSIBGWhite = PyESC + '[47m';

  PyCSIFGBrightBlack = PyESC + '[90m';
  PyCSIFGBrightRed = PyESC + '[91m';
  PyCSIFGBrightGreen = PyESC + '[92m';
  PyCSIFGBrightYellow = PyESC + '[93m';
  PyCSIFGBrightBlue = PyESC + '[94m';
  PyCSIFGBrightMagenta = PyESC + '[95m';
  PyCSIFGBrightCyan = PyESC + '[96m';
  PyCSIFGBrightWhite = PyESC + '[97m';

  PyCSIBGBrightBlack = PyESC + '[100m';
  PyCSIBGBrightRed = PyESC + '[101m';
  PyCSIBGBrightGreen = PyESC + '[102m';
  PyCSIBGBrightYellow = PyESC + '[103m';
  PyCSIBGBrightBlue = PyESC + '[104m';
  PyCSIBGBrightMagenta = PyESC + '[105m';
  PyCSIBGBrightCyan = PyESC + '[106m';
  PyCSIBGBrightWhite = PyESC + '[107m';

  PyCSIFGRGB = PyESC + '[38;2;%d;%d;%dm';        // Foreground RGB
  PyCSIBGRGB = PyESC + '[48;2;%d;%d;%dm';        // Backg

type
  { TPyCharSet }
  TPyCharSet = set of AnsiChar;

  { PyConsole }
  PyConsole = class
  private class var
    FInputCodePage: Cardinal;
    FOutputCodePage: Cardinal;
    FTeletypeDelay: Integer;
    FKeyState: array [0..1, 0..255] of Boolean;
  private
    class constructor Create();
    class destructor Destroy();
  public
    class procedure UnitInit();
    class procedure Print(const AMsg: string); overload; static;
    class procedure PrintLn(const AMsg: string); overload; static;

    class procedure Print(const AMsg: string; const AArgs: array of const); overload; static;
    class procedure PrintLn(const AMsg: string; const AArgs: array of const); overload; static;

    class procedure Print(); overload; static;
    class procedure PrintLn(); overload; static;

    class procedure GetCursorPos(X, Y: PInteger); static;
    class procedure SetCursorPos(const X, Y: Integer); static;
    class procedure SetCursorVisible(const AVisible: Boolean); static;
    class procedure HideCursor(); static;
    class procedure ShowCursor(); static;
    class procedure SaveCursorPos(); static;
    class procedure RestoreCursorPos(); static;
    class procedure MoveCursorUp(const ALines: Integer); static;
    class procedure MoveCursorDown(const ALines: Integer); static;
    class procedure MoveCursorForward(const ACols: Integer); static;
    class procedure MoveCursorBack(const ACols: Integer); static;

    class procedure ClearScreen(); static;
    class procedure ClearLine(); static;
    class procedure ClearLineFromCursor(const AColor: string); static;

    class procedure SetBoldText(); static;
    class procedure ResetTextFormat(); static;
    class procedure SetForegroundColor(const AColor: string); static;
    class procedure SetBackgroundColor(const AColor: string); static;
    class procedure SetForegroundRGB(const ARed, AGreen, ABlue: Byte); static;
    class procedure SetBackgroundRGB(const ARed, AGreen, ABlue: Byte); static;

    class procedure GetSize(AWidth: PInteger; AHeight: PInteger); static;

    class procedure SetTitle(const ATitle: string); static;
    class function  GetTitle(): string; static;

    class function  HasOutput(): Boolean; static;
    class function  WasRunFrom(): Boolean; static;
    class procedure WaitForAnyKey(); static;
    class function  AnyKeyPressed(): Boolean; static;

    class procedure ClearKeyStates(); static;
    class procedure ClearKeyboardBuffer(); static;

    class function  IsKeyPressed(AKey: Byte): Boolean; static;
    class function  WasKeyReleased(AKey: Byte): Boolean; static;
    class function  WasKeyPressed(AKey: Byte): Boolean; static;

    class function  ReadKey(): WideChar; static;
    class function  ReadLnX(const AAllowedChars: TPyCharSet; AMaxLength: Integer; const AColor: string=PyCSIFGWhite): string; static;

    class procedure Pause(const AForcePause: Boolean=False; AColor: string=PyCSIFGWhite; const AMsg: string=''); static;

    class function  WrapTextEx(const ALine: string; AMaxCol: Integer; const ABreakChars: TPyCharSet=[' ', '-', ',', ':', #9]): string; static;
    class procedure Teletype(const AText: string; const AColor: string=PyCSIFGWhite; const AMargin: Integer=10; const AMinDelay: Integer=0; const AMaxDelay: Integer=3; const ABreakKey: Byte=VK_ESCAPE); static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Lua '}
type
  TPyLuaType = (
    ltNone = -1,
    ltNil = 0,
    ltBoolean = 1,
    ltLightUserData = 2,
    ltNumber = 3,
    ltString = 4,
    ltTable = 5,
    ltFunction = 6,
    ltUserData = 7,
    ltThread = 8
  );

  TPyLuaTable = (LuaTable);

  TPyLuaValueType = (
    vtInteger,
    vtDouble,
    vtString,
    vtTable,
    vtPointer,
    vtBoolean
  );

  TPyLuaValue = record
    AsType: TPyLuaValueType;

    class operator Implicit(const AValue: Integer): TPyLuaValue;
    class operator Implicit(const AValue: Double): TPyLuaValue;
    class operator Implicit(const AValue: System.PChar): TPyLuaValue;
    class operator Implicit(const AValue: TPyLuaTable): TPyLuaValue;
    class operator Implicit(const AValue: Pointer): TPyLuaValue;
    class operator Implicit(const AValue: Boolean): TPyLuaValue;
    class operator Implicit(const AValue: TPyLuaValue): Integer;
    class operator Implicit(const AValue: TPyLuaValue): Double;
    class operator Implicit(const AValue: TPyLuaValue): System.PChar;
    class operator Implicit(const AValue: TPyLuaValue): Pointer;
    class operator Implicit(const AValue: TPyLuaValue): Boolean;

    case Integer of
      0: (AsInteger: Integer);
      1: (AsNumber: Double);
      2: (AsString: System.PChar);
      3: (AsTable: TPyLuaTable);
      4: (AsPointer: Pointer);
      5: (AsBoolean: Boolean);
  end;

  TPyLuaResetCallback = procedure(const AUserData: Pointer);

  IPyLua = interface;
  IPyLuaContext = interface
    ['{6AEC306C-45BC-4C65-A0E1-044739DED1EB}']
    function ArgCount(): Integer;
    function PushCount(): Integer;
    procedure ClearStack();
    procedure PopStack(const ACount: Integer);
    function GetStackType(const AIndex: Integer): TPyLuaType;
    function GetValue(const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue;
    procedure PushValue(const AValue: TPyLuaValue);
    procedure SetTableFieldValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer);
    function GetTableFieldValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue;
    procedure SetTableIndexValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer; const AKey: Integer);
    function GetTableIndexValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer; const AKey: Integer): TPyLuaValue;
    function Lua(): IPyLua;
  end;

  TPyLuaFunction = procedure(const ALua: IPyLuaContext) of object;

  IPyLua = interface
    ['{671FAB20-00F2-4C81-96A6-6F675A37D00B}']
    function GetBeforeResetCallback(): TPyLuaResetCallback;
    procedure SetBeforeResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
    function GetAfterResetCallback(): TPyLuaResetCallback;
    procedure SetAfterResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
    procedure Reset();
    procedure AddSearchPath(const APath: string);
    procedure Print(const AText: string; const AArgs: array of const);
    procedure PrintLn(const AText: string; const AArgs: array of const);
    procedure LoadStream(const AStream: TStream; const ASize: NativeUInt = 0; const AAutoRun: Boolean = True);
    function LoadFile(const AFilename: string; const AAutoRun: Boolean = True): Boolean;
    procedure LoadString(const AData: string; const AAutoRun: Boolean = True);
    procedure LoadBuffer(const AData: Pointer; const ASize: NativeUInt; const AAutoRun: Boolean = True);
    procedure Run();
    function RoutineExist(const AName: string): Boolean;
    function Call(const AName: string; const AParams: array of TPyLuaValue): TPyLuaValue; overload;
    function PrepCall(const AName: string): Boolean;
    function Call(const AParamCount: Integer): TPyLuaValue; overload;
    function VariableExist(const AName: string): Boolean;
    procedure SetVariable(const AName: string; const AValue: TPyLuaValue);
    function GetVariable(const AName: string; const AType: TPyLuaValueType): TPyLuaValue;
    procedure RegisterRoutine(const AName: string; const AData: Pointer; const ACode: Pointer); overload;
    procedure RegisterRoutine(const AName: string; const ARoutine: TPyLuaFunction); overload;
    procedure RegisterRoutines(const AClass: TClass); overload;
    procedure RegisterRoutines(const AObject: TObject); overload;
    procedure RegisterRoutines(const ATables: string; const AClass: TClass; const ATableName: string = ''); overload;
    procedure RegisterRoutines(const ATables: string; const AObject: TObject; const ATableName: string = ''); overload;
    procedure UpdateArgs(const AStartIndex: Integer);
    procedure SetGCStepSize(const AStep: Integer);
    function GetGCStepSize(): Integer;
    function GetGCMemoryUsed(): Integer;
    procedure CollectGarbage();
    procedure CompileToStream(const AFilename: string; const AStream: TStream; const ACleanOutput: Boolean);
    function PayloadExist(): Boolean;
    function RunPayload(): Boolean;
    function SavePayloadExe(const AFilename: string): Boolean;
    function StorePayload(const ASourceFilename, AEXEFilename: string): Boolean;
    function UpdatePayloadIcon(const AEXEFilename, AIconFilename: string): Boolean;
    function UpdatePayloadVersionInfo(const AEXEFilename: string; const AMajor, AMinor, APatch: Word; const AProductName, ADescription, AFilename, ACompanyName, ACopyright: string): Boolean;
  end;

  TPyLua = class;

  TPyLuaContext = class;

  EPyLuaException = class(Exception);

  TPyLuaContext = class(TNoRefCountObject, IPyLuaContext)
  protected
    FLua: TPyLua;
    FPushCount: Integer;
    FPushFlag: Boolean;
    procedure Setup();
    procedure Check();
    procedure IncStackPushCount();
    procedure Cleanup();
    function PushTableForSet(const AName: array of string; const AIndex: Integer; var AStackIndex: Integer; var AFieldNameIndex: Integer): Boolean;
    function PushTableForGet(const AName: array of string; const AIndex: Integer; var AStackIndex: Integer; var AFieldNameIndex: Integer): Boolean;
  public
    constructor Create(const ALua: TPyLua);
    destructor Destroy(); override;
    function ArgCount(): Integer;
    function PushCount(): Integer;
    procedure ClearStack();
    procedure PopStack(const ACount: Integer);
    function GetStackType(const AIndex: Integer): TPyLuaType;
    function GetValue(const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue; overload;
    procedure PushValue(const AValue: TPyLuaValue); overload;
    procedure SetTableFieldValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer);
    function GetTableFieldValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue;
    procedure SetTableIndexValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer; const AKey: Integer);
    function GetTableIndexValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer; const AKey: Integer): TPyLuaValue;
    function Lua(): IPyLua;
  end;

  TPyLua = class(TNoRefCountObject, IPyLua)
  protected type
    TCallback<T> = record
      Handler: T;
      UserData: Pointer;
    end;
  protected
    FState: Pointer;
    FContext: TPyLuaContext;
    FGCStep: Integer;
    FOnBeforeReset: TCallback<TPyLuaResetCallback>;
    FOnAfterReset: TCallback<TPyLuaResetCallback>;
    function Open(): Boolean;
    procedure Close();
    procedure CheckLuaError(const AError: Integer);
    function PushGlobalTableForSet(const AName: array of string; var AIndex: Integer): Boolean;
    function PushGlobalTableForGet(const AName: array of string; var AIndex: Integer): Boolean;
    procedure PushTValue(const AValue: System.RTTI.TValue);
    function CallFunction(const AParams: array of TValue): TValue;
    procedure SaveByteCode(const AStream: TStream);
    procedure LoadByteCode(const AStream: TStream; const AName: string; const AAutoRun: Boolean = True);
    procedure Bundle(const AInFilename: string; const AOutFilename: string);
    procedure PushLuaValue(const AValue: TPyLuaValue);
    function GetLuaValue(const AIndex: Integer): TPyLuaValue;
    function DoCall(const AParams: array of TPyLuaValue): TPyLuaValue; overload;
    function DoCall(const AParamCount: Integer): TPyLuaValue; overload;
    procedure CleanStack();
    procedure OnBeforeReset();
    procedure OnAfterReset();
    property State: Pointer read FState;
    property Context: TPyLuaContext read FContext;
  public
    constructor Create(); virtual;
    destructor Destroy(); override;
    function GetBeforeResetCallback(): TPyLuaResetCallback;
    procedure SetBeforeResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
    function GetAfterResetCallback(): TPyLuaResetCallback;
    procedure SetAfterResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
    procedure Reset();
    procedure AddSearchPath(const APath: string);
    procedure Print(const AText: string; const AArgs: array of const);
    procedure PrintLn(const AText: string; const AArgs: array of const);
    procedure LoadStream(const AStream: TStream; const ASize: NativeUInt = 0; const AAutoRun: Boolean = True);
    function LoadFile(const AFilename: string; const AAutoRun: Boolean = True): Boolean;
    procedure LoadString(const AData: string; const AAutoRun: Boolean = True);
    procedure LoadBuffer(const AData: Pointer; const ASize: NativeUInt; const AAutoRun: Boolean = True);
    function Call(const AName: string; const AParams: array of TPyLuaValue): TPyLuaValue; overload;
    function PrepCall(const AName: string): Boolean;
    function Call(const AParamCount: Integer): TPyLuaValue; overload;
    procedure Run();
    function RoutineExist(const AName: string): Boolean;
    function VariableExist(const AName: string): Boolean;
    procedure SetVariable(const AName: string; const AValue: TPyLuaValue);
    function GetVariable(const AName: string; const AType: TPyLuaValueType): TPyLuaValue;
    procedure RegisterRoutine(const AName: string; const AData: Pointer; const ACode: Pointer); overload;
    procedure RegisterRoutine(const AName: string; const ARoutine: TPyLuaFunction); overload;
    procedure RegisterRoutines(const AClass: TClass); overload;
    procedure RegisterRoutines(const AObject: TObject); overload;
    procedure RegisterRoutines(const ATables: string; const AClass: TClass; const ATableName: string = ''); overload;
    procedure RegisterRoutines(const ATables: string; const AObject: TObject; const ATableName: string = ''); overload;
    procedure UpdateArgs(const AStartIndex: Integer);
    procedure SetGCStepSize(const AStep: Integer);
    function GetGCStepSize(): Integer;
    function GetGCMemoryUsed(): Integer;
    procedure CollectGarbage();
    procedure CompileToStream(const AFilename: string; const AStream: TStream; const ACleanOutput: Boolean);
    function PayloadExist(): Boolean;
    function RunPayload(): Boolean;
    function SavePayloadExe(const AFilename: string): Boolean;
    function StorePayload(const ASourceFilename, AEXEFilename: string): Boolean;
    function UpdatePayloadIcon(const AEXEFilename, AIconFilename: string): Boolean;
    function UpdatePayloadVersionInfo(const AEXEFilename: string; const AMajor, AMinor, APatch: Word; const AProductName, ADescription, AFilename, ACompanyName, ACopyright: string): Boolean;
  end;

{$ENDREGION}

{$REGION ' Pyro.Color '}
type
  { TPyColor }
  PPyColor = ^TPyColor;
  TPyColor = record
    r,g,b,a: Single;
    function  FromByte(const r, g, b, a: Byte): TPyColor;
    function  FromFloat(const r, g, b, a: Single): TPyColor;
    function  Fade(const ATo: TPyColor; const APos: Single): TPyColor;
    function  IsEqual(const AColor: TPyColor): Boolean;
  end;

const
  PyALICEBLUE           : TPyColor = (r:$F0/$FF; g:$F8/$FF; b:$FF/$FF; a:$FF/$FF);
  PyANTIQUEWHITE        : TPyColor = (r:$FA/$FF; g:$EB/$FF; b:$D7/$FF; a:$FF/$FF);
  PyAQUA                : TPyColor = (r:$00/$FF; g:$FF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyAQUAMARINE          : TPyColor = (r:$7F/$FF; g:$FF/$FF; b:$D4/$FF; a:$FF/$FF);
  PyAZURE               : TPyColor = (r:$F0/$FF; g:$FF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyBEIGE               : TPyColor = (r:$F5/$FF; g:$F5/$FF; b:$DC/$FF; a:$FF/$FF);
  PyBISQUE              : TPyColor = (r:$FF/$FF; g:$E4/$FF; b:$C4/$FF; a:$FF/$FF);
  PyBLACK               : TPyColor = (r:$00/$FF; g:$00/$FF; b:$00/$FF; a:$FF/$FF);
  PyBLANCHEDALMOND      : TPyColor = (r:$FF/$FF; g:$EB/$FF; b:$CD/$FF; a:$FF/$FF);
  PyBLUE                : TPyColor = (r:$00/$FF; g:$00/$FF; b:$FF/$FF; a:$FF/$FF);
  PyBLUEVIOLET          : TPyColor = (r:$8A/$FF; g:$2B/$FF; b:$E2/$FF; a:$FF/$FF);
  PyBROWN               : TPyColor = (r:$A5/$FF; g:$2A/$FF; b:$2A/$FF; a:$FF/$FF);
  PyBURLYWOOD           : TPyColor = (r:$DE/$FF; g:$B8/$FF; b:$87/$FF; a:$FF/$FF);
  PyCADETBLUE           : TPyColor = (r:$5F/$FF; g:$9E/$FF; b:$A0/$FF; a:$FF/$FF);
  PyCHARTREUSE          : TPyColor = (r:$7F/$FF; g:$FF/$FF; b:$00/$FF; a:$FF/$FF);
  PyCHOCOLATE           : TPyColor = (r:$D2/$FF; g:$69/$FF; b:$1E/$FF; a:$FF/$FF);
  PyCORAL               : TPyColor = (r:$FF/$FF; g:$7F/$FF; b:$50/$FF; a:$FF/$FF);
  PyCORNFLOWERBLUE      : TPyColor = (r:$64/$FF; g:$95/$FF; b:$ED/$FF; a:$FF/$FF);
  PyCORNSILK            : TPyColor = (r:$FF/$FF; g:$F8/$FF; b:$DC/$FF; a:$FF/$FF);
  PyCRIMSON             : TPyColor = (r:$DC/$FF; g:$14/$FF; b:$3C/$FF; a:$FF/$FF);
  PyCYAN                : TPyColor = (r:$00/$FF; g:$FF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyDARKBLUE            : TPyColor = (r:$00/$FF; g:$00/$FF; b:$8B/$FF; a:$FF/$FF);
  PyDARKCYAN            : TPyColor = (r:$00/$FF; g:$8B/$FF; b:$8B/$FF; a:$FF/$FF);
  PyDARKGOLDENROD       : TPyColor = (r:$B8/$FF; g:$86/$FF; b:$0B/$FF; a:$FF/$FF);
  PyDARKGRAY            : TPyColor = (r:$A9/$FF; g:$A9/$FF; b:$A9/$FF; a:$FF/$FF);
  PyDARKGREEN           : TPyColor = (r:$00/$FF; g:$64/$FF; b:$00/$FF; a:$FF/$FF);
  PyDARKGREY            : TPyColor = (r:$A9/$FF; g:$A9/$FF; b:$A9/$FF; a:$FF/$FF);
  PyDARKKHAKI           : TPyColor = (r:$BD/$FF; g:$B7/$FF; b:$6B/$FF; a:$FF/$FF);
  PyDARKMAGENTA         : TPyColor = (r:$8B/$FF; g:$00/$FF; b:$8B/$FF; a:$FF/$FF);
  PyDARKOLIVEGREEN      : TPyColor = (r:$55/$FF; g:$6B/$FF; b:$2F/$FF; a:$FF/$FF);
  PyDARKORANGE          : TPyColor = (r:$FF/$FF; g:$8C/$FF; b:$00/$FF; a:$FF/$FF);
  PyDARKORCHID          : TPyColor = (r:$99/$FF; g:$32/$FF; b:$CC/$FF; a:$FF/$FF);
  PyDARKRED             : TPyColor = (r:$8B/$FF; g:$00/$FF; b:$00/$FF; a:$FF/$FF);
  PyDARKSALMON          : TPyColor = (r:$E9/$FF; g:$96/$FF; b:$7A/$FF; a:$FF/$FF);
  PyDARKSEAGREEN        : TPyColor = (r:$8F/$FF; g:$BC/$FF; b:$8F/$FF; a:$FF/$FF);
  PyDARKSLATEBLUE       : TPyColor = (r:$48/$FF; g:$3D/$FF; b:$8B/$FF; a:$FF/$FF);
  PyDARKSLATEGRAY       : TPyColor = (r:$2F/$FF; g:$4F/$FF; b:$4F/$FF; a:$FF/$FF);
  PyDARKSLATEGREY       : TPyColor = (r:$2F/$FF; g:$4F/$FF; b:$4F/$FF; a:$FF/$FF);
  PyDARKTURQUOISE       : TPyColor = (r:$00/$FF; g:$CE/$FF; b:$D1/$FF; a:$FF/$FF);
  PyDARKVIOLET          : TPyColor = (r:$94/$FF; g:$00/$FF; b:$D3/$FF; a:$FF/$FF);
  PyDEEPPINK            : TPyColor = (r:$FF/$FF; g:$14/$FF; b:$93/$FF; a:$FF/$FF);
  PyDEEPSKYBLUE         : TPyColor = (r:$00/$FF; g:$BF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyDIMGRAY             : TPyColor = (r:$69/$FF; g:$69/$FF; b:$69/$FF; a:$FF/$FF);
  PyDIMGREY             : TPyColor = (r:$69/$FF; g:$69/$FF; b:$69/$FF; a:$FF/$FF);
  PyDODGERBLUE          : TPyColor = (r:$1E/$FF; g:$90/$FF; b:$FF/$FF; a:$FF/$FF);
  PyFIREBRICK           : TPyColor = (r:$B2/$FF; g:$22/$FF; b:$22/$FF; a:$FF/$FF);
  PyFLORALWHITE         : TPyColor = (r:$FF/$FF; g:$FA/$FF; b:$F0/$FF; a:$FF/$FF);
  PyFORESTGREEN         : TPyColor = (r:$22/$FF; g:$8B/$FF; b:$22/$FF; a:$FF/$FF);
  PyFUCHSIA             : TPyColor = (r:$FF/$FF; g:$00/$FF; b:$FF/$FF; a:$FF/$FF);
  PyGAINSBORO           : TPyColor = (r:$DC/$FF; g:$DC/$FF; b:$DC/$FF; a:$FF/$FF);
  PyGHOSTWHITE          : TPyColor = (r:$F8/$FF; g:$F8/$FF; b:$FF/$FF; a:$FF/$FF);
  PyGOLD                : TPyColor = (r:$FF/$FF; g:$D7/$FF; b:$00/$FF; a:$FF/$FF);
  PyGOLDENROD           : TPyColor = (r:$DA/$FF; g:$A5/$FF; b:$20/$FF; a:$FF/$FF);
  PyGRAY                : TPyColor = (r:$80/$FF; g:$80/$FF; b:$80/$FF; a:$FF/$FF);
  PyGREEN               : TPyColor = (r:$00/$FF; g:$80/$FF; b:$00/$FF; a:$FF/$FF);
  PyGREENYELLOW         : TPyColor = (r:$AD/$FF; g:$FF/$FF; b:$2F/$FF; a:$FF/$FF);
  PyGREY                : TPyColor = (r:$80/$FF; g:$80/$FF; b:$80/$FF; a:$FF/$FF);
  PyHONEYDEW            : TPyColor = (r:$F0/$FF; g:$FF/$FF; b:$F0/$FF; a:$FF/$FF);
  PyHOTPINK             : TPyColor = (r:$FF/$FF; g:$69/$FF; b:$B4/$FF; a:$FF/$FF);
  PyINDIANRED           : TPyColor = (r:$CD/$FF; g:$5C/$FF; b:$5C/$FF; a:$FF/$FF);
  PyINDIGO              : TPyColor = (r:$4B/$FF; g:$00/$FF; b:$82/$FF; a:$FF/$FF);
  PyIVORY               : TPyColor = (r:$FF/$FF; g:$FF/$FF; b:$F0/$FF; a:$FF/$FF);
  PyKHAKI               : TPyColor = (r:$F0/$FF; g:$E6/$FF; b:$8C/$FF; a:$FF/$FF);
  PyLAVENDER            : TPyColor = (r:$E6/$FF; g:$E6/$FF; b:$FA/$FF; a:$FF/$FF);
  PyLAVENDERBLUSH       : TPyColor = (r:$FF/$FF; g:$F0/$FF; b:$F5/$FF; a:$FF/$FF);
  PyLAWNGREEN           : TPyColor = (r:$7C/$FF; g:$FC/$FF; b:$00/$FF; a:$FF/$FF);
  PyLEMONCHIFFON        : TPyColor = (r:$FF/$FF; g:$FA/$FF; b:$CD/$FF; a:$FF/$FF);
  PyLIGHTBLUE           : TPyColor = (r:$AD/$FF; g:$D8/$FF; b:$E6/$FF; a:$FF/$FF);
  PyLIGHTCORAL          : TPyColor = (r:$F0/$FF; g:$80/$FF; b:$80/$FF; a:$FF/$FF);
  PyLIGHTCYAN           : TPyColor = (r:$E0/$FF; g:$FF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyLIGHTGOLDENRODYELLOW: TPyColor = (r:$FA/$FF; g:$FA/$FF; b:$D2/$FF; a:$FF/$FF);
  PyLIGHTGRAY           : TPyColor = (r:$D3/$FF; g:$D3/$FF; b:$D3/$FF; a:$FF/$FF);
  PyLIGHTGREEN          : TPyColor = (r:$90/$FF; g:$EE/$FF; b:$90/$FF; a:$FF/$FF);
  PyLIGHTGREY           : TPyColor = (r:$D3/$FF; g:$D3/$FF; b:$D3/$FF; a:$FF/$FF);
  PyLIGHTPINK           : TPyColor = (r:$FF/$FF; g:$B6/$FF; b:$C1/$FF; a:$FF/$FF);
  PyLIGHTSALMON         : TPyColor = (r:$FF/$FF; g:$A0/$FF; b:$7A/$FF; a:$FF/$FF);
  PyLIGHTSEAGREEN       : TPyColor = (r:$20/$FF; g:$B2/$FF; b:$AA/$FF; a:$FF/$FF);
  PyLIGHTSKYBLUE        : TPyColor = (r:$87/$FF; g:$CE/$FF; b:$FA/$FF; a:$FF/$FF);
  PyLIGHTSLATEGRAY      : TPyColor = (r:$77/$FF; g:$88/$FF; b:$99/$FF; a:$FF/$FF);
  PyLIGHTSLATEGREY      : TPyColor = (r:$77/$FF; g:$88/$FF; b:$99/$FF; a:$FF/$FF);
  PyLIGHTSTEELBLUE      : TPyColor = (r:$B0/$FF; g:$C4/$FF; b:$DE/$FF; a:$FF/$FF);
  PyLIGHTYELLOW         : TPyColor = (r:$FF/$FF; g:$FF/$FF; b:$E0/$FF; a:$FF/$FF);
  PyLIME                : TPyColor = (r:$00/$FF; g:$FF/$FF; b:$00/$FF; a:$FF/$FF);
  PyLIMEGREEN           : TPyColor = (r:$32/$FF; g:$CD/$FF; b:$32/$FF; a:$FF/$FF);
  PyLINEN               : TPyColor = (r:$FA/$FF; g:$F0/$FF; b:$E6/$FF; a:$FF/$FF);
  PyMAGENTA             : TPyColor = (r:$FF/$FF; g:$00/$FF; b:$FF/$FF; a:$FF/$FF);
  PyMAROON              : TPyColor = (r:$80/$FF; g:$00/$FF; b:$00/$FF; a:$FF/$FF);
  PyMEDIUMAQUAMARINE    : TPyColor = (r:$66/$FF; g:$CD/$FF; b:$AA/$FF; a:$FF/$FF);
  PyMEDIUMBLUE          : TPyColor = (r:$00/$FF; g:$00/$FF; b:$CD/$FF; a:$FF/$FF);
  PyMEDIUMORCHID        : TPyColor = (r:$BA/$FF; g:$55/$FF; b:$D3/$FF; a:$FF/$FF);
  PyMEDIUMPURPLE        : TPyColor = (r:$93/$FF; g:$70/$FF; b:$DB/$FF; a:$FF/$FF);
  PyMEDIUMSEAGREEN      : TPyColor = (r:$3C/$FF; g:$B3/$FF; b:$71/$FF; a:$FF/$FF);
  PyMEDIUMSLATEBLUE     : TPyColor = (r:$7B/$FF; g:$68/$FF; b:$EE/$FF; a:$FF/$FF);
  PyMEDIUMSPRINGGREEN   : TPyColor = (r:$00/$FF; g:$FA/$FF; b:$9A/$FF; a:$FF/$FF);
  PyMEDIUMTURQUOISE     : TPyColor = (r:$48/$FF; g:$D1/$FF; b:$CC/$FF; a:$FF/$FF);
  PyMEDIUMVIOLETRED     : TPyColor = (r:$C7/$FF; g:$15/$FF; b:$85/$FF; a:$FF/$FF);
  PyMIDNIGHTBLUE        : TPyColor = (r:$19/$FF; g:$19/$FF; b:$70/$FF; a:$FF/$FF);
  PyMINTCREAM           : TPyColor = (r:$F5/$FF; g:$FF/$FF; b:$FA/$FF; a:$FF/$FF);
  PyMISTYROSE           : TPyColor = (r:$FF/$FF; g:$E4/$FF; b:$E1/$FF; a:$FF/$FF);
  PyMOCCASIN            : TPyColor = (r:$FF/$FF; g:$E4/$FF; b:$B5/$FF; a:$FF/$FF);
  PyNAVAJOWHITE         : TPyColor = (r:$FF/$FF; g:$DE/$FF; b:$AD/$FF; a:$FF/$FF);
  PyNAVY                : TPyColor = (r:$00/$FF; g:$00/$FF; b:$80/$FF; a:$FF/$FF);
  PyOLDLACE             : TPyColor = (r:$FD/$FF; g:$F5/$FF; b:$E6/$FF; a:$FF/$FF);
  PyOLIVE               : TPyColor = (r:$80/$FF; g:$80/$FF; b:$00/$FF; a:$FF/$FF);
  PyOLIVEDRAB           : TPyColor = (r:$6B/$FF; g:$8E/$FF; b:$23/$FF; a:$FF/$FF);
  PyORANGE              : TPyColor = (r:$FF/$FF; g:$A5/$FF; b:$00/$FF; a:$FF/$FF);
  PyORANGERED           : TPyColor = (r:$FF/$FF; g:$45/$FF; b:$00/$FF; a:$FF/$FF);
  PyORCHID              : TPyColor = (r:$DA/$FF; g:$70/$FF; b:$D6/$FF; a:$FF/$FF);
  PyPALEGOLDENROD       : TPyColor = (r:$EE/$FF; g:$E8/$FF; b:$AA/$FF; a:$FF/$FF);
  PyPALEGREEN           : TPyColor = (r:$98/$FF; g:$FB/$FF; b:$98/$FF; a:$FF/$FF);
  PyPALETURQUOISE       : TPyColor = (r:$AF/$FF; g:$EE/$FF; b:$EE/$FF; a:$FF/$FF);
  PyPALEVIOLETRED       : TPyColor = (r:$DB/$FF; g:$70/$FF; b:$93/$FF; a:$FF/$FF);
  PyPAPAYAWHIP          : TPyColor = (r:$FF/$FF; g:$EF/$FF; b:$D5/$FF; a:$FF/$FF);
  PyPEACHPUFF           : TPyColor = (r:$FF/$FF; g:$DA/$FF; b:$B9/$FF; a:$FF/$FF);
  PyPERU                : TPyColor = (r:$CD/$FF; g:$85/$FF; b:$3F/$FF; a:$FF/$FF);
  PyPINK                : TPyColor = (r:$FF/$FF; g:$C0/$FF; b:$CB/$FF; a:$FF/$FF);
  PyPLUM                : TPyColor = (r:$DD/$FF; g:$A0/$FF; b:$DD/$FF; a:$FF/$FF);
  PyPOWDERBLUE          : TPyColor = (r:$B0/$FF; g:$E0/$FF; b:$E6/$FF; a:$FF/$FF);
  PyPURPLE              : TPyColor = (r:$80/$FF; g:$00/$FF; b:$80/$FF; a:$FF/$FF);
  PyREBECCAPURPLE       : TPyColor = (r:$66/$FF; g:$33/$FF; b:$99/$FF; a:$FF/$FF);
  PyRED                 : TPyColor = (r:$FF/$FF; g:$00/$FF; b:$00/$FF; a:$FF/$FF);
  PyROSYBROWN           : TPyColor = (r:$BC/$FF; g:$8F/$FF; b:$8F/$FF; a:$FF/$FF);
  PyROYALBLUE           : TPyColor = (r:$41/$FF; g:$69/$FF; b:$E1/$FF; a:$FF/$FF);
  PySADDLEBROWN         : TPyColor = (r:$8B/$FF; g:$45/$FF; b:$13/$FF; a:$FF/$FF);
  PySALMON              : TPyColor = (r:$FA/$FF; g:$80/$FF; b:$72/$FF; a:$FF/$FF);
  PySANDYBROWN          : TPyColor = (r:$F4/$FF; g:$A4/$FF; b:$60/$FF; a:$FF/$FF);
  PySEAGREEN            : TPyColor = (r:$2E/$FF; g:$8B/$FF; b:$57/$FF; a:$FF/$FF);
  PySEASHELL            : TPyColor = (r:$FF/$FF; g:$F5/$FF; b:$EE/$FF; a:$FF/$FF);
  PySIENNA              : TPyColor = (r:$A0/$FF; g:$52/$FF; b:$2D/$FF; a:$FF/$FF);
  PySILVER              : TPyColor = (r:$C0/$FF; g:$C0/$FF; b:$C0/$FF; a:$FF/$FF);
  PySKYBLUE             : TPyColor = (r:$87/$FF; g:$CE/$FF; b:$EB/$FF; a:$FF/$FF);
  PySLATEBLUE           : TPyColor = (r:$6A/$FF; g:$5A/$FF; b:$CD/$FF; a:$FF/$FF);
  PySLATEGRAY           : TPyColor = (r:$70/$FF; g:$80/$FF; b:$90/$FF; a:$FF/$FF);
  PySLATEGREY           : TPyColor = (r:$70/$FF; g:$80/$FF; b:$90/$FF; a:$FF/$FF);
  PySNOW                : TPyColor = (r:$FF/$FF; g:$FA/$FF; b:$FA/$FF; a:$FF/$FF);
  PySPRINGGREEN         : TPyColor = (r:$00/$FF; g:$FF/$FF; b:$7F/$FF; a:$FF/$FF);
  PySTEELBLUE           : TPyColor = (r:$46/$FF; g:$82/$FF; b:$B4/$FF; a:$FF/$FF);
  PyTAN                 : TPyColor = (r:$D2/$FF; g:$B4/$FF; b:$8C/$FF; a:$FF/$FF);
  PyTEAL                : TPyColor = (r:$00/$FF; g:$80/$FF; b:$80/$FF; a:$FF/$FF);
  PyTHISTLE             : TPyColor = (r:$D8/$FF; g:$BF/$FF; b:$D8/$FF; a:$FF/$FF);
  PyTOMATO              : TPyColor = (r:$FF/$FF; g:$63/$FF; b:$47/$FF; a:$FF/$FF);
  PyTURQUOISE           : TPyColor = (r:$40/$FF; g:$E0/$FF; b:$D0/$FF; a:$FF/$FF);
  PyVIOLET              : TPyColor = (r:$EE/$FF; g:$82/$FF; b:$EE/$FF; a:$FF/$FF);
  PyWHEAT               : TPyColor = (r:$F5/$FF; g:$DE/$FF; b:$B3/$FF; a:$FF/$FF);
  PyWHITE               : TPyColor = (r:$FF/$FF; g:$FF/$FF; b:$FF/$FF; a:$FF/$FF);
  PyWHITESMOKE          : TPyColor = (r:$F5/$FF; g:$F5/$FF; b:$F5/$FF; a:$FF/$FF);
  PyYELLOW              : TPyColor = (r:$FF/$FF; g:$FF/$FF; b:$00/$FF; a:$FF/$FF);
  PyYELLOWGREEN         : TPyColor = (r:$9A/$FF; g:$CD/$FF; b:$32/$FF; a:$FF/$FF);
  PyBLANK               : TPyColor = (r:$00;     g:$00;     b:$00;     a:$00);
  PyWHITE2              : TPyColor = (r:$F5/$FF; g:$F5/$FF; b:$F5/$FF; a:$FF/$FF);
  PyRED22               : TPyColor = (r:$7E/$FF; g:$32/$FF; b:$3F/$FF; a:255/$FF);
  PyCOLORKEY            : TPyColor = (r:$FF/$FF; g:$00;     b:$FF/$FF; a:$FF/$FF);
  PyOVERLAY1            : TPyColor = (r:$00/$FF; g:$20/$FF; b:$29/$FF; a:$B4/$FF);
  PyOVERLAY2            : TPyColor = (r:$01/$FF; g:$1B/$FF; b:$01/$FF; a:255/$FF);
  PyDIMWHITE            : TPyColor = (r:$10/$FF; g:$10/$FF; b:$10/$FF; a:$10/$FF);
  PyDARKSLATEBROWN      : TPyColor = (r:30/255; g:31/255; b:30/255; a:1/255);

{$ENDREGION}

{$REGION ' Pyro.Window '}
const
  PyKEY_UNKNOWN = -1;
  PyKEY_SPACE = 32;
  PyKEY_APOSTROPHE = 39;
  PyKEY_COMMA = 44;
  PyKEY_MINUS = 45;
  PyKEY_PERIOD = 46;
  PyKEY_SLASH = 47;
  PyKEY_0 = 48;
  PyKEY_1 = 49;
  PyKEY_2 = 50;
  PyKEY_3 = 51;
  PyKEY_4 = 52;
  PyKEY_5 = 53;
  PyKEY_6 = 54;
  PyKEY_7 = 55;
  PyKEY_8 = 56;
  PyKEY_9 = 57;
  PyKEY_SEMICOLON = 59;
  PyKEY_EQUAL = 61;
  PyKEY_A = 65;
  PyKEY_B = 66;
  PyKEY_C = 67;
  PyKEY_D = 68;
  PyKEY_E = 69;
  PyKEY_F = 70;
  PyKEY_G = 71;
  PyKEY_H = 72;
  PyKEY_I = 73;
  PyKEY_J = 74;
  PyKEY_K = 75;
  PyKEY_L = 76;
  PyKEY_M = 77;
  PyKEY_N = 78;
  PyKEY_O = 79;
  PyKEY_P = 80;
  PyKEY_Q = 81;
  PyKEY_R = 82;
  PyKEY_S = 83;
  PyKEY_T = 84;
  PyKEY_U = 85;
  PyKEY_V = 86;
  PyKEY_W = 87;
  PyKEY_X = 88;
  PyKEY_Y = 89;
  PyKEY_Z = 90;
  PyKEY_LEFT_BRACKET = 91;
  PyKEY_BACKSLASH = 92;
  PyKEY_RIGHT_BRACKET = 93;
  PyKEY_GRAVE_ACCENT = 96;
  PyKEY_WORLD_1 = 161;
  PyKEY_WORLD_2 = 162;
  PyKEY_ESCAPE = 256;
  PyKEY_ENTER = 257;
  PyKEY_TAB = 258;
  PyKEY_BACKSPACE = 259;
  PyKEY_INSERT = 260;
  PyKEY_DELETE = 261;
  PyKEY_RIGHT = 262;
  PyKEY_LEFT = 263;
  PyKEY_DOWN = 264;
  PyKEY_UP = 265;
  PyKEY_PAGE_UP = 266;
  PyKEY_PAGE_DOWN = 267;
  PyKEY_HOME = 268;
  PyKEY_END = 269;
  PyKEY_CAPS_LOCK = 280;
  PyKEY_SCROLL_LOCK = 281;
  PyKEY_NUM_LOCK = 282;
  PyKEY_PRINT_SCREEN = 283;
  PyKEY_PAUSE = 284;
  PyKEY_F1 = 290;
  PyKEY_F2 = 291;
  PyKEY_F3 = 292;
  PyKEY_F4 = 293;
  PyKEY_F5 = 294;
  PyKEY_F6 = 295;
  PyKEY_F7 = 296;
  PyKEY_F8 = 297;
  PyKEY_F9 = 298;
  PyKEY_F10 = 299;
  PyKEY_F11 = 300;
  PyKEY_F12 = 301;
  PyKEY_F13 = 302;
  PyKEY_F14 = 303;
  PyKEY_F15 = 304;
  PyKEY_F16 = 305;
  PyKEY_F17 = 306;
  PyKEY_F18 = 307;
  PyKEY_F19 = 308;
  PyKEY_F20 = 309;
  PyKEY_F21 = 310;
  PyKEY_F22 = 311;
  PyKEY_F23 = 312;
  PyKEY_F24 = 313;
  PyKEY_F25 = 314;
  PyKEY_KP_0 = 320;
  PyKEY_KP_1 = 321;
  PyKEY_KP_2 = 322;
  PyKEY_KP_3 = 323;
  PyKEY_KP_4 = 324;
  PyKEY_KP_5 = 325;
  PyKEY_KP_6 = 326;
  PyKEY_KP_7 = 327;
  PyKEY_KP_8 = 328;
  PyKEY_KP_9 = 329;
  PyKEY_KP_DECIMAL = 330;
  PyKEY_KP_DIVIDE = 331;
  PyKEY_KP_MULTIPLY = 332;
  PyKEY_KP_SUBTRACT = 333;
  PyKEY_KP_ADD = 334;
  PyKEY_KP_ENTER = 335;
  PyKEY_KP_EQUAL = 336;
  PyKEY_LEFT_SHIFT = 340;
  PyKEY_LEFT_CONTROL = 341;
  PyKEY_LEFT_ALT = 342;
  PyKEY_LEFT_SUPER = 343;
  PyKEY_RIGHT_SHIFT = 344;
  PyKEY_RIGHT_CONTROL = 345;
  PyKEY_RIGHT_ALT = 346;
  PyKEY_RIGHT_SUPER = 347;
  PyKEY_MENU = 348;
  PyKEY_LAST = PyKEY_MENU;

const
  PyMOUSE_BUTTON_1 = 0;
  PyMOUSE_BUTTON_2 = 1;
  PyMOUSE_BUTTON_3 = 2;
  PyMOUSE_BUTTON_4 = 3;
  PyMOUSE_BUTTON_5 = 4;
  PyMOUSE_BUTTON_6 = 5;
  PyMOUSE_BUTTON_7 = 6;
  PyMOUSE_BUTTON_8 = 7;
  PyMOUSE_BUTTON_LAST = 7;
  PyMOUSE_BUTTON_LEFT = 0;
  PyMOUSE_BUTTON_RIGHT = 1;
  PyMOUSE_BUTTON_MIDDLE = 2;

const
  PyGAMEPAD_1 = 0;
  PyGAMEPAD_2 = 1;
  PyGAMEPAD_3 = 2;
  PyGAMEPAD_4 = 3;
  PyGAMEPAD_5 = 4;
  PyGAMEPAD_6 = 5;
  PyGAMEPAD_7 = 6;
  PyGAMEPAD_8 = 7;
  PyGAMEPAD_9 = 8;
  PyGAMEPAD_10 = 9;
  PyGAMEPAD_11 = 10;
  PyGAMEPAD_12 = 11;
  PyGAMEPAD_13 = 12;
  PyGAMEPAD_14 = 13;
  PyGAMEPAD_15 = 14;
  PyGAMEPAD_16 = 15;
  PyGAMEPAD_LAST = PyGAMEPAD_16;

const
  PyGAMEPAD_BUTTON_A = 0;
  PyGAMEPAD_BUTTON_B = 1;
  PyGAMEPAD_BUTTON_X = 2;
  PyGAMEPAD_BUTTON_Y = 3;
  PyGAMEPAD_BUTTON_LEFT_BUMPER = 4;
  PyGAMEPAD_BUTTON_RIGHT_BUMPER = 5;
  PyGAMEPAD_BUTTON_BACK = 6;
  PyGAMEPAD_BUTTON_START = 7;
  PyGAMEPAD_BUTTON_GUIDE = 8;
  PyGAMEPAD_BUTTON_LEFT_THUMB = 9;
  PyGAMEPAD_BUTTON_RIGHT_THUMB = 10;
  PyGAMEPAD_BUTTON_DPAD_UP = 11;
  PyGAMEPAD_BUTTON_DPAD_RIGHT = 12;
  PyGAMEPAD_BUTTON_DPAD_DOWN = 13;
  PyGAMEPAD_BUTTON_DPAD_LEFT = 14;
  PyGAMEPAD_BUTTON_LAST = PyGAMEPAD_BUTTON_DPAD_LEFT;
  PyGAMEPAD_BUTTON_CROSS = PyGAMEPAD_BUTTON_A;
  PyGAMEPAD_BUTTON_CIRCLE = PyGAMEPAD_BUTTON_B;
  PyGAMEPAD_BUTTON_SQUARE = PyGAMEPAD_BUTTON_X;
  PyAMEPAD_BUTTON_TRIANGLE = PyGAMEPAD_BUTTON_Y;

const
  PyGAMEPAD_AXIS_LEFT_X = 0;
  PyGAMEPAD_AXIS_LEFT_Y = 1;
  PyGAMEPAD_AXIS_RIGHT_X = 2;
  PyGAMEPAD_AXIS_RIGHT_Y = 3;
  PyGAMEPAD_AXIS_LEFT_TRIGGER = 4;
  PyGAMEPAD_AXIS_RIGHT_TRIGGER = 5;
  PyGAMEPAD_AXIS_LAST = PyGAMEPAD_AXIS_RIGHT_TRIGGER;

const
  PyDEFAULT_WINDOW_WIDTH  = 1920 div 2;
  PyDEFAULT_WINDOW_HEIGHT = 1080 div 2;

  PyDEFAULT_FPS = 60;

type
  { TInputState }
  TPyInputState = (isPressed, isWasPressed, isWasReleased);

  { TWindow }
  TPyWindow = class(TPyBaseObject)
  protected type
    TTiming = record
      LastTime: Double;
      TargetTime: Double;
      CurrentTime: Double;
      ElapsedTime: Double;
      RemainingTime: Double;
      LastFPSTime: Double;
      Endtime: double;
      FrameCount: Cardinal;
      Framerate: Cardinal;
      TargetFrameRate: Cardinal;
      DeltaTime: Double;
    end;
  protected
    FParent: HWND;
    FHandle: PGLFWwindow;
    FVirtualSize: TPySize;
    FMaxTextureSize: Integer;
    FIsFullscreen: Boolean;
    FWindowedPosX, FWindowedPosY: Integer;
    FWindowedWidth, FWindowedHeight: Integer;
    FViewport: TPyRect;
    FKeyState: array [0..0, PyKEY_SPACE..PyKEY_LAST] of Boolean;
    FMouseButtonState: array [0..0, PyMOUSE_BUTTON_1..PyMOUSE_BUTTON_MIDDLE] of Boolean;
    FGamepadButtonState: array[0..0, PyGAMEPAD_BUTTON_A..PyGAMEPAD_BUTTON_LAST] of Boolean;
    FTiming: TTiming;
    FMouseWheel: TPyVector;
    procedure SetDefaultIcon();
    procedure StartTiming();
    procedure StopTiming();
  public
    property Handle: PGLFWwindow read FHandle;

    constructor Create(); override;
    destructor Destroy(); override;

    function  Open(const ATitle: string; const AVirtualWidth: Cardinal=PyDEFAULT_WINDOW_WIDTH; const AVirtualHeight: Cardinal=PyDEFAULT_WINDOW_HEIGHT; const AParent: NativeUInt=0): Boolean;
    procedure Close();

    function  GetTitle(): string;
    procedure SetTitle(const ATitle: string);

    procedure SetSizeLimits(const AMinWidth, AMinHeight, AMaxWidth, AMaxHeight: Integer);
    procedure Resize(const AWidth, AHeight: Cardinal);
    procedure ToggleFullscreen();
    function  IsFullscreen(): Boolean;

    function  HasFocus(): Boolean;

    function  GetVirtualSize(): TPySize;
    function  GetSize(): TPySize;
    function  GetScale(): TPySize;
    function  GetMaxTextureSize: Integer;

    function  GetViewport(): TPyRect;

    procedure Center();

    function  ShouldClose(): Boolean;
    procedure SetShouldClose(const AClose: Boolean);

    procedure StartFrame();
    procedure EndFrame();

    procedure StartDrawing();
    procedure ResetDrawing();
    procedure EndDrawing();

    procedure Clear(const AColor: TPyColor);

    procedure DrawLine(const X1, Y1, X2, Y2: Single; const AColor: TPyColor; const AThickness: Single);
    procedure DrawRect(const X, Y, AWidth, AHeight, AThickness: Single; const AColor: TPyColor; const AAngle: Single);
    procedure DrawFilledRect(const X, Y, AWidth, AHeight: Single; const AColor: TPyColor; const AAngle: Single);
    procedure DrawCircle(const X, Y, ARadius, AThickness: Single; const AColor: TPyColor);
    procedure DrawFilledCircle(const X, Y, ARadius: Single; const AColor: TPyColor);
    procedure DrawTriangle(const X1, Y1, X2, Y2, X3, Y3, AThickness: Single; const AColor: TPyColor);
    procedure DrawFilledTriangle(const X1, Y1, X2, Y2, X3, Y3: Single; const AColor: TPyColor);
    procedure DrawPolygon(const APoints: array of TPoint; const AThickness: Single; const AColor: TPyColor);
    procedure DrawFilledPolygon(const APoints: array of TPoint; const AColor: TPyColor);
    procedure DrawPolyline(const APoints: array of TPoint; const AThickness: Single; const AColor: TPyColor);

    procedure ClearInput();
    function  GetKey(const AKey: Integer; const AState: TPyInputState): Boolean;
    function  GetMouseButton(const AButton: Byte; const AState: TPyInputState): Boolean;
    procedure GetMousePos(const X, Y: System.PSingle); overload;
    function  GetMousePos(): TPyPoint; overload;
    procedure SetMousePos(const X, Y: Single);
    function  GetMouseWheel(): TPyVector;

    function  GamepadPresent(const AGamepad: Byte): Boolean;
    function  GetGamepadName(const AGamepad: Byte): string;
    function  GetGamepadButton(const AGamepad, AButton: Byte; const AState: TPyInputState): Boolean;
    function  GetGamepadAxisValue(const AGamepad, AAxis: Byte): Single;

    function  VirtualToScreen(const X, Y: Single): TPyPoint;
    function  ScreenToVirtual(const X, Y: Single): TPyPoint;

    procedure SetTargetFrameRate(const ATargetFrameRate: UInt32=PyDEFAULT_FPS);
    function  GetTargetFrameRate(): UInt32;
    function  GetTargetTime(): Double;
    procedure ResetTiming();
    function  GetFrameRate(): UInt32;
    function  GetDeltaTime(): Double;

    class function  Init(const ATitle: string; const AVirtualWidth: Cardinal=PyDEFAULT_WINDOW_WIDTH; const AVirtualHeight: Cardinal=PyDEFAULT_WINDOW_HEIGHT; const AParent: NativeUInt=0): TPyWindow; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.IO '}
type
  { TIOSeek }
  TPyIOSeek = (iosStart, iosCurrent, iosEnd);

  { TPyIO }
  TPyIO = class(TPyBaseObject)
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  IsOpen(): Boolean; virtual;
    procedure Close(); virtual;
    function  Size(): Int64; virtual;
    function  Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64; virtual;
    function  Read(const AData: Pointer; const ASize: Int64): Int64; virtual;
    function  Write(const AData: Pointer; const ASize: Int64): Int64; virtual;
    function  Pos(): Int64; virtual;
    function  Eos(): Boolean; virtual;
  end;

{$ENDREGION}

{$REGION ' Pyro.MemoryIO '}
type
  { TPyMemoryIO }
  TPyMemoryIO = class(TPyIO)
  protected
    FHandle: TMemoryStream;
  public
    function  IsOpen(): Boolean; override;
    procedure Close(); override;
    function  Size(): Int64; override;
    function  Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64; override;
    function  Read(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Write(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Pos(): Int64; override;
    function  Eos(): Boolean; override;
    function  Open(const AData: Pointer; ASize: Int64): Boolean;
  end;

{$ENDREGION}

{$REGION ' Pyro.FileIO '}
type
  { TIOMode }
  TPyIOMode = (iomRead, iomWrite);

  { TPyFileIO }
  TPyFileIO = class(TPyIO)
  protected
    FHandle: TFileStream;
    FMode: TPyIOMode;
  public
    function  IsOpen(): Boolean; override;
    procedure Close(); override;
    function  Size(): Int64; override;
    function  Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64; override;
    function  Read(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Write(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Pos(): Int64; override;
    function  Eos(): Boolean; override;
    function  Open(const AFilename: string; const AMode: TPyIOMode): Boolean;
  end;

{$ENDREGION}

{$REGION ' Pyro.ZipFileIO '}
const
  { CDefaultZipFilePassword }
  PyDEFAULT_ZIPFILE_PASSWORD = 'N^TpjE5/*czG,<ns>$}w;?x_uBm9[JSr{(+FRv7ZW@C-gd3D!PRUgWE4P2/wpm9-dt^Y?e)Az+xsMb@jH"!X`B3ar(yq=nZ_~85<';

type
  { TPyZipFileIOBuildProgressCallback }
  TPyZipFileIOBuildProgressCallback = procedure(const AFilename: string; const AProgress: Integer; const ANewFile: Boolean; const AUserData: Pointer);

  { TPyZipFileIO }
  TPyZipFileIO = class(TPyIO)
  protected
    FHandle: unzFile;
    FPassword: AnsiString;
    FFilename: AnsiString;
  public
    function  IsOpen(): Boolean; override;
    procedure Close(); override;
    function  Size(): Int64; override;
    function  Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64; override;
    function  Read(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Write(const AData: Pointer; const ASize: Int64): Int64; override;
    function  Pos(): Int64; override;
    function  Eos(): Boolean; override;
    function Open(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean;
    class function Init(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyZipFileIO; static;
    class function Load(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TMemoryStream; static;
    class function Build(const AZipFilename, ADirectoryName: string; const AHandler: TPyZipFileIOBuildProgressCallback=nil; const AUserData: Pointer=nil; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Texture '}
type
  { TTextureBlend }
  TPyTextureBlend = (tbNone, tbAlpha, tbAdditiveAlpha);

  { TPyTexture }
  TPyTexture = class(TPyBaseObject)
  private type
    PRGBA = ^TRGBA;
    TRGBA = packed record
      R, G, B, A: Byte;
    end;
  private
    FHandle: Cardinal;
    FChannels: Integer;
    FSize: TPySize;
    FPivot: TPyPoint;
    FAnchor: TPyPoint;
    FBlend: TPyTextureBlend;
    FPos: TPyPoint;
    FScale: Single;
    FColor: TPyColor;
    FAngle: Single;
    FHFlip: Boolean;
    FVFlip: Boolean;
    FRegion: TPyRect;
    FLock: PByte;
    procedure ConvertMaskToAlpha(Data: Pointer; Width, Height: Integer; MaskColor: TPyColor);
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  Alloc(const AWidth, AHeight: Integer): Boolean;
    procedure Fill(const AColor: TPyColor);
    function  Load(const ARGBData: Pointer; const AWidth, AHeight: Integer): Boolean; overload;
    function  Load(const AIO: TPyIO; const AOwnIO: Boolean=True; const AColorKey: PPyColor=nil): Boolean; overload;
    function  LoadFromFile(const AFilename: string; const AColorKey: PPyColor=nil): Boolean;
    function  LoadFromZipFile(const AZipFilename, AFilename: string; const AColorKey: PPyColor=nil; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean;
    function  IsLoaded(): Boolean;
    procedure Unload();
    function  GetHandle(): Cardinal;
    function  GetChannels(): Integer;
    function  GetSize():TPySize;
    function  GetPivot(): TPyPoint;
    procedure SetPivot( const APoint: TPyPoint); overload;
    procedure SetPivot(const X, Y: Single); overload;
    function  Anchor(): TPyPoint;
    procedure SetAnchor(const APoint: TPyPoint); overload;
    procedure SetAnchor(const X, Y: Single); overload;
    function  GetBlend(): TPyTextureBlend;
    procedure SetBlend(const AValue: TPyTextureBlend);
    function  GetPos(): TPyPoint;
    procedure SetPos(const APos: TPyPoint); overload;
    procedure SetPos(const X, Y: Single); overload;
    function  GetScale(): Single;
    procedure SetScale(const AScale: Single);
    function  GetColor(): TPyColor;
    procedure SetColor(const AColor: TPyColor); overload;
    procedure SetColor(const ARed, AGreen, ABlue, AAlpha: Single); overload;
    function  GetAngle(): Single;
    procedure SetAngle(const AAngle: Single);
    function  GetHFlip(): Boolean;
    procedure SetHFlip(const AFlip: Boolean);
    function  GetVFlip(): Boolean;
    procedure SetVFlip(const AFlip: Boolean);
    function  GetRegion(): TPyRect;
    procedure SetRegion(const ARegion: TPyRect); overload;
    procedure SetRegion(const X, Y, AWidth, AHeight: Single); overload;
    procedure ResetRegion();
    procedure Draw(const AWindow: TPyWindow);
    procedure DrawTiled(const AWindow: TPyWindow; const ADeltaX, ADeltaY: Single);
    function  Save(const AFilename: string): Boolean;
    function  Lock(): Boolean;
    procedure Unlock();
    function  GetPixel(const X, Y: Single): TPyColor;
    procedure SetPixel(const X, Y: Single; const AColor: TPyColor); overload;
    procedure SetPixel(const X, Y: Single; const ARed, AGreen, ABlue, AAlpha: Byte); overload;
    function  CollideAABB(const ATexture: TPyTexture): Boolean;
    function  CollideOBB(const ATexture: TPyTexture): Boolean;
    class function Init(const AZipFilename, AFilename: string; const AColorKey: PPyColor=nil; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyTexture; static;
    class function Spine(const AIO: TPyIO; const AOwnIO: Boolean=True): GLuint;
    class procedure Delete(const ATexture: GLuint);

  end;

{$ENDREGION}

{$REGION ' Pyro.Font '}
type
  { TPyFont }
  TPyFont = class(TPyBaseObject)
  protected const
    DEFAULT_GLYPHS = ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~™©';
  protected type
    PFontGlyph = ^TFontGlyph;
    TFontGlyph = record
      SrcRect: TPyRect;
      DstRect: TPyRect;
      XAdvance: Single;
    end;
  protected
    FAtlasSize: Integer;
    FAtlas: TPyTexture;
    FBaseLine: Single;
    FGlyph: TDictionary<Integer, TFontGlyph>;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  Load(const AWindow: TPyWindow; const ASize: Cardinal; const AGlyphs: string=''): Boolean; overload;
    function  Load(const AWindow: TPyWindow; const AIO: TPyIO; const ASize: Cardinal; const AGlyphs: string=''; const AOwnIO: Boolean=True): Boolean; overload;
    function  LoadFromFile(const AWindow: TPyWindow; const AFilename: string; const ASize: Cardinal; const AGlyphs: string=''): Boolean;
    function  LoadFromZipFile(const AWindow: TPyWindow; const AZipFilename, AFilename: string; const ASize: Cardinal; const AGlyphs: string=''; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean;
    procedure Unload();
    procedure DrawText(const AWindow: TPyWindow; const X, Y: Single; const AColor: TPyColor; AHAlign: TPyHAlign; const AText: string); overload;
    procedure DrawText(const AWindow: TPyWindow; const X: Single; var Y: Single; const aLineSpace: Single; const aColor: TPyColor; AHAlign: TPyHAlign; const AText: string); overload;
    procedure DrawText(const AWindow: TPyWindow; const X, Y: Single; const AColor: TPyColor; AHAlign: TPyHAlign; const AText: string; const AArgs: array of const); overload;
    procedure DrawText(const AWindow: TPyWindow; const X: Single; var Y: Single; const aLineSpace: Single; const aColor: TPyColor; AHAlign: TPyHAlign; const AText: string; const AArgs: array of const); overload;
    function  TextLength(const AText: string): Single; overload;
    function  TextLength(const AText: string; const AArgs: array of const): Single; overload;
    function  TextHeight(): Single;
    function  SaveTexture(const AFilename: string): Boolean;

    class function Init(const AWindow: TPyWindow; const ASize: Cardinal; const AGlyphs: string=''): TPyFont; overload; static;
    class function Init(const AWindow: TPyWindow; const AZipFilename, AFilename: string; const ASize: Cardinal; const AGlyphs: string=''; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyFont; overload; static;

  end;

{$ENDREGION}

{$REGION ' Pyro.Sprite '}
type
  { TPySprite }
  TPySprite = class(TPyBaseObject)
  protected type
    PImageRegion = ^TImageRegion;
    TImageRegion = record
      Rect: TPyRect;
      Page: Integer;
    end;
    PGroup = ^TGroup;
    TGroup = record
      Image: array of TImageRegion;
      Count: Integer;
    end;
  protected
    FTextures: array of TPyTexture;
    FGroups: array of TGroup;
    FPageCount: Integer;
    FGroupCount: Integer;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    procedure Clear();
    function LoadPageFromFile(const AFilename: string; AColorKey: PPyColor): Integer;
    function LoadPageFromZipFile(const AZipFilename, AFilename: string; AColorKey: PPyColor; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Integer;
    function AddGroup(): Integer;
    function GetGroupCount(): Integer;
    function AddImageFromRect(const APage, AGroup: Integer; const ARect: TPyRect; const AXOffset: Integer=0; const AYOffset: Integer=0): Integer;
    function AddImageFromGrid(const APage, AGroup, AGridX, AGridY, AGridWidth, AGridHeight: Integer; const AXOffset: Integer=0; const AYOffset: Integer=0): Integer;
    function AddImages(const APage, AGroup, AColCount, ARowCount, AImageWidth, AImageHeight: Integer; const AXOffset: Integer=0; const AYOffset: Integer=0): Boolean;
    function GetImageCount(const AGroup: Integer): Integer;
    function GetImageWidth(const ANum, AGroup: Integer): Single;
    function GetImageHeight(const ANum, AGroup: Integer): Single;
    function GetImageTexture(const ANum, AGroup: Integer): TPyTexture;
    function GetImageRegion(const ANum, AGroup: Integer): TPyRect;
  end;

{$ENDREGION}

{$REGION ' Pyro.Entity '}
type
  { TPyEntityOverlap }
  TPyEntityOverlap = (eoAABB, eoOBB);

  { TPyEntity }
  TPyEntity = class(TPyBaseObject)
  protected
    FSprite: TPySprite;
    FGroup: Integer;
    FFrame: Integer;
    FFrameSpeed: Single;
    FPos: TPyVector;
    FDir: TPyVector;
    FScale: Single;
    FAngle: Single;
    FAngleOffset : Single;
    FColor: TPyColor;
    FHFlip: Boolean;
    FVFlip: Boolean;
    FLoopFrame: Boolean;
    FWidth: Single;
    FHeight: Single;
    FRadius: Single;
    FFirstFrame: Integer;
    FLastFrame: Integer;
    FShrinkFactor: Single;
    FPivot: TPyPoint;
    FAnchor: TPyPoint;
    FBlend: TPyTextureBlend;
    FFrameTimer: TPyTimer;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  Init(const ASprite: TPySprite; const AGroup: Integer): Boolean;
    function  GetPivot(): TPyPoint;
    procedure SetPivot(const APoint: TPyPoint); overload;
    procedure SetPivot(const X, Y: Single); overload;
    function  GetAnchor(): TPyPoint;
    procedure SetAnchor(const APoint: TPyPoint); overload;
    procedure SetAnchor(const X, Y: Single); overload;
    procedure SetFrameRange(const aFirst, aLast: Integer);
    function  NextFrame(): Boolean;
    function  PrevFrame(): Boolean;
    function  GetFrame(): Integer;
    procedure SetFrame(const AFrame: Integer);
    function  GetFrameSpeed(): Single;
    procedure SetFrameSpeed(const AFrameSpeed: Single);
    function  GetFirstFrame(): Integer;
    function  GetLastFrame(): Integer;
    procedure SetPosAbs(const X, Y: Single);
    procedure SetPosRel(const X, Y: Single);
    function  GetPos(): TPyVector;
    function  GetDir(): TPyVector;
    procedure SetScaleAbs(const AScale: Single);
    procedure SetScaleRel(const AScale: Single);
    function  GetAngle(): Single;
    function  GetAngleOffset(): Single;
    procedure SetAngleOffset(const AAngle: Single);
    procedure RotateAbs(const AAngle: Single);
    procedure RotateRel(const AAngle: Single);
    function  RotateToAngle(const AAngle, ASpeed: Single): Boolean;
    function  RotateToPos(const X, Y, ASpeed: Single): Boolean;
    function  RotateToPosAt(const aSrcX, aSrcY, ADestX, ADestY, ASpeed: Single): Boolean;
    procedure Thrust(const ASpeed: Single);
    procedure ThrustAngle(const AAngle, ASpeed: Single);
    function  ThrustToPos(const aThrustSpeed, ARotSpeed, ADestX, ADestY, ASlowdownDist, AStopDist, AStopSpeed, AStopSpeedEpsilon: Single): Boolean;
    function  IsVisible(const AWindow: TPyWindow): Boolean;
    function  IsFullyVisible(const AWindow: TPyWindow): Boolean;
    function  Collide(const X, Y, aRadius, aShrinkFactor: Single): Boolean; overload;
    function  Collide(const AEntity: TPyEntity; const AOverlap: TPyEntityOverlap=eoAABB): Boolean; overload;
    procedure Render(const AWindow: TPyWindow);
    procedure RenderAt(const AWindow: TPyWindow; const X, Y: Single);
    function  GetSprite(): TPySprite;
    function  GetGroup(): Integer;
    function  GetScale(): Single;
    function  GetColor(): TPyColor;
    procedure SetColor(const AColor: TPyColor);
    function  GetBlend(): TPyTextureBlend;
    procedure SetBlend(const AValue: TPyTextureBlend);
    function  GetHFlip(): Boolean;
    procedure SetHFlip(const AFlip: Boolean);
    function  GetVFlip: Boolean;
    procedure SetVFlip(const AFlip: Boolean);
    function  GetLoopFrame(): Boolean;
    procedure SetLoopFrame(const aLoop: Boolean);
    function  GetWidth(): Single;
    function  GetHeight(): Single;
    function  GetRadius(): Single;
  end;

{$ENDREGION}

{$REGION ' Pyro.Audio '}
const
  PyAUDIO_ERROR           = -1;
  PyAUDIO_MUSIC_COUNT     = 256;
  PyAUDIO_SOUND_COUNT     = 256;
  PyAUDIO_CHANNEL_COUNT   = 16;
  PyAUDIO_CHANNEL_DYNAMIC = -2;

type
  { TPyMaVFS }
  PPyMaVFS = ^TPyMaVFS;
  TPyMaVFS = record
  private
    Callbacks: ma_vfs_callbacks;
    IO: TPyIO;
  public
    constructor Create(const AIO: TPyIO);
  end;

  PyAudio = class
  protected type
    TMusic = record
      Handle: ma_sound;
      Loaded: Boolean;
      Volume: Single;
      Pan: Single;
    end;
    TSound = record
      Handle: ma_sound;
      InUse: Boolean;
    end;
    TChannel = record
      Handle: ma_sound;
      Reserved: Boolean;
      InUse: Boolean;
      Volume: Single;
    end;
  protected class var
    FVFS: TPyMaVFS;
    FEngineConfig: ma_engine_config;
    FEngine: ma_engine;
    FOpened: Boolean;
    FPaused: Boolean;
    FMusic: TMusic;
    snd1,snd2,snd3: ma_sound;
    FSound: array[0..PyAUDIO_SOUND_COUNT-1] of TSound;
    FChannel: array[0..PyAUDIO_CHANNEL_COUNT-1] of TChannel;
    class function FindFreeSoundSlot(): Integer; static;
    class function FindFreeChannelSlot(): Integer; static;
    class function ValidChannel(const AChannel: Integer): Boolean; static;
    class procedure InitData(); static;
    class constructor Create();
    class destructor Destroy();

  public
    class procedure UnitInit(); static;
    class procedure Update(); static;
    class function  Open(): Boolean; static;
    class function  IsOpen(): Boolean; static;
    class procedure Close(); static;
    class function  IsPaused(): Boolean; static;
    class procedure SetPause(const APause: Boolean); static;
    class function  PlayMusic(const AIO: TPyIO; const AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single=0.0): Boolean; static;
    class function  PlayMusicFromFile(const AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single=0.0): Boolean; static;
    class function  PlayMusicFromZipFile(const AZipFilename, AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single=0.0; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean; static;
    class procedure UnloadMusic(); static;
    class function  IsMusicLooping(): Boolean; static;
    class procedure SetMusicLooping(const ALoop: Boolean); static;
    class function  MusicVolume(): Single; static;
    class procedure SetMusicVolume(const AVolume: Single); static;
    class function  MusicPan(): Single; static;
    class procedure SetMusicPan(const APan: Single); static;
    class function  LoadSound(const AIO: TPyIO; const AFilename: string): Integer; static;
    class function  LoadSoundFromFile(const AFilename: string): Integer; static;
    class function  LoadSoundFromZipFile(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Integer; static;
    class procedure UnloadSound(var ASound: Integer); static;
    class procedure UnloadAllSounds(); static;
    class function  PlaySound(const ASound, AChannel: Integer; const AVolume: Single; const ALoop: Boolean): Integer; static;
    class procedure ReserveChannel(const AChannel: Integer; const aReserve: Boolean); static;
    class procedure StopChannel(const AChannel: Integer); static;
    class procedure SetChannelVolume(const AChannel: Integer; const AVolume: Single); static;
    class function  GetChannelVolume(const AChannel: Integer): Single; static;
    class procedure SetChannelPosition(const AChannel: Integer; const X, Y: Single); static;
    class procedure SetChannelLoop(const AChannel: Integer; const ALoop: Boolean); static;
    class function  GetchannelLoop(const AChannel: Integer): Boolean; static;
    class function  GetChannelPlaying(const AChannel: Integer): Boolean; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Video '}
type
  { TPyVideoStatus }
  TPyVideoStatus = (vsStopped, vsPlaying);

  { TPyVideoStatusEvent }
  TPyVideoStatusEvent = procedure(const ASender: Pointer; const AStatus: TPyVideoStatus; const AFilename: string);

  { PyVideo }
  PyVideo = class
  private const
    BUFFERSIZE = 1024;
    CSampleSize = 2304;
    CSampleRate = 44100;
  private class var
    FIO: TPyIO;
    FStatus: TPyVideoStatus;
    FStatusFlag: Boolean;
    FStaticPlmBuffer: array[0..BUFFERSIZE] of byte;
    FRingBuffer: TPyVirtualRingBuffer<Single>;
    FDeviceConfig: ma_device_config;
    FDevice: ma_device;
    FPLM: Pplm_t;
    FVolume: Single;
    FLoop: Boolean;
    FRGBABuffer: array of uint8;
    FTexture: TPyTexture;
    FCallback: TPyCallback<TPyVideoStatusEvent>;
    FFilename: string;
    class procedure OnStatusEvent(); static;
    class constructor Create();
    class destructor Destroy();
  public
    class procedure UnitInit; static;
    class function  GetStatusEvent(): TPyVideoStatusEvent; static;
    class procedure SetStatusEvent(const ASender: Pointer; const AHandler: TPyVideoStatusEvent); static;
    class function  Play(const AIO: TPyIO; const AFilename: string; const AVolume: Single; const ALoop: Boolean): Boolean; static;
    class function  PlayFromZipFile(const AZipFilename, AFilename: string; const AVolume: Single; const ALoop: Boolean; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): Boolean; static;
    class procedure Stop(); static;
    class function  Update(const AWindow: TPyWindow): Boolean; static;
    class procedure Draw(const AWindow: TPyWindow; const X, Y, AScale: Single); static;
    class function  Status(): TPyVideoStatus; static;
    class function  Volume(): Single; static;
    class procedure SetVolume(const AVolume: Single); static;
    class function  IsLooping(): Boolean; static;
    class procedure SetLooping(const ALoop: Boolean); static;
    class function  GetTexture(): TPyTexture; static;
  end;

{$ENDREGION}

{$REGION ' Pyro.Camera '}
type
  { TPyCamera }
  TPyCamera = class(TPyBaseObject)
  private
    FX, FY: Single;
    FRotation: Single;
    FScale: Single;
    FWindow: TPyWindow;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  GetX(): Single;
    procedure SetX(const AValue: Single);
    function  GetY(): Single;
    procedure SetY(const AValue: Single);
    function  GetRotation(): Single;
    procedure SetRotation(const AValue: Single);
    function  GetScale(): Single;
    procedure SetScale(const AValue: Single);
    procedure Move(const X, Y: Single);
    procedure Zoom(const AScale: Single);
    procedure Rotate(const ARotation: Single);
    procedure Use(const AWindow: TPyWindow);
    procedure Reset();
  end;

{$ENDREGION}

{$REGION ' Pyro.LocalDb '}
type
  { TPyLocalDb }
  TPyLocalDb = class(TPyBaseObject)
  protected
    FDatabase: string;
    FResponseText: string;
    FLastError: string;
    FSQL: TStringList;
    FPrepairedSQL: string;
    FJSON: TJSONObject;
    FDataset: TJSONArray;
    FMacros: TDictionary<string, string>;
    FParams: TDictionary<string, string>;
    FHandle: PSQLite3;
    FStmt: Psqlite3_stmt;
    procedure SetMacroValue(const AName, AValue: string);
    procedure SetParamValue(const AName, AValue: string);
    procedure Prepair;
    function  ExecuteSQLInternal(const ASQL: string): Boolean;
  public
    property Handle: PSQLite3 read FHandle;
    constructor Create(); override;
    destructor Destroy(); override;
    function  IsOpen(): Boolean;
    function  Open(const AFilename: string): Boolean;
    procedure Close();
    procedure ClearSQLText();
    procedure AddSQLText(const AText: string);
    function  GetSQLText(): string;
    procedure SetSQLText(const AText: string);
    function  GetPrepairedSQL(): string;
    procedure ClearMacros();
    function  GetMacro(const AName: string): string;
    procedure SetMacro(const AName, AValue: string);
    procedure ClearParams();
    function  GetParam(const AName: string): string;
    procedure SetParam(const AName, AValue: string);
    function  RecordCount(): Integer;
    function  GetField(const AIndex: Cardinal; const AName: string): string;
    function  Execute(): Boolean;
    function  ExecuteSQL(const ASQL: string): Boolean;
    function  GetLastError(): string;
    function  GetResponseText(): string;
  end;

{$ENDREGION}

{$REGION ' Pyro.RemoteDb '}
type
  { TPyRemoteDb }
  TPyRemoteDb = class(TPyBaseObject)
  protected const
    cURL = '/?apikey=%s&keyspace=%s&query=%s';
  protected
    FUrl: string;
    FApiKey: string;
    FDatabase: string;
    FResponseText: string;
    FLastError: string;
    FHttp: THTTPClient;
    FSQL: TStringList;
    FPrepairedSQL: string;
    FJSON: TJSONObject;
    FDataset: TJSONArray;
    FMacros: TDictionary<string, string>;
    FParams: TDictionary<string, string>;
    procedure SetMacroValue(const AName, AValue: string);
    procedure SetParamValue(const AName, AValue: string);
    procedure Prepair();
    function  GetQueryURL(const ASQL: string): string;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    procedure Setup(const AURL, AApiKey, ADatabase: string);
    procedure ClearSQLText();
    procedure AddSQLText(const AText: string; const AArgs: array of const);
    function  GetSQLText(): string;
    procedure SetSQLText(const AText: string);
    function  GetPrepairedSQL(): string;
    procedure ClearMacros();
    function  GetMacro(const AName: string): string;
    procedure SetMacro(const AName, AValue: string);
    procedure ClearParams();
    function  GetParam(const AName: string): string;
    procedure SetParam(const AName, AValue: string);
    function  RecordCount(): Integer;
    function  GetField(const AIndex: Cardinal; const AName: string): string;
    function  Execute(): Boolean;
    function  ExecuteSQL(const ASQL: string): Boolean;
    function  GetLastError(): string;
    function  GetResponseText(): string;
  end;

{$ENDREGION}

{$REGION ' Pyro.ConfigFile '}
type
  { TPyConfigFile }
  TPyConfigFile = class(TPyBaseObject)
  private
    FHandle: TIniFile;
    FFilename: string;
    FSection: TStringList;
  public
    constructor Create(); override;
    destructor Destroy(); override;
    function  Open(const AFilename: string=''): Boolean;
    procedure Close();
    function  Opened(): Boolean;
    procedure Update();
    function  RemoveSection(const AName: string): Boolean;
    procedure SetValue(const ASection, AKey, AValue: string);  overload;
    procedure SetValue(const ASection, AKey: string; AValue: Integer); overload;
    procedure SetValue(const ASection, AKey: string; AValue: Boolean); overload;
    procedure SetValue(const ASection, AKey: string; AValue: Pointer; AValueSize: Cardinal); overload;
    function  GetValue(const ASection, AKey, ADefaultValue: string): string; overload;
    function  GetValue(const ASection, AKey: string; ADefaultValue: Integer): Integer; overload;
    function  GetValue(const ASection, AKey: string; ADefaultValue: Boolean): Boolean; overload;
    procedure GetValue(const ASection, AKey: string; AValue: Pointer; AValueSize: Cardinal); overload;
    function  RemoveKey(const ASection, AKey: string): Boolean;
    function  GetSectionValues(const ASection: string): Integer;
    function  GetSectionValue(const AIndex: Integer; const ADefaultValue: string): string; overload;
    function  GetSectionValue(const AIndex, ADefaultValue: Integer): Integer; overload;
    function  GetSectionValue(const AIndex: Integer; const ADefaultValue: Boolean): Boolean; overload;
  end;

{$ENDREGION}

{$REGION ' Pyro '}
const
  PYRO_VERSION_MAJOR = '0';
  PYRO_VERSION_MINOR = '1';
  PYRO_VERSION_PATCH = '0';
  PYRO_VERSION       = PYRO_VERSION_MAJOR + '.' + PYRO_VERSION_MINOR + '.' + PYRO_VERSION_PATCH;

{$ENDREGION}

implementation

{$REGION ' Pyro.OpenGL '}
type
  TLoadProc = function(proc: PAnsiChar): Pointer;

function hasExt(const extname: string): Boolean;
var
  extensions: PChar;
  loc, terminator: Pchar;
{$IFDEF HAS_GL_NUM_EXTENSIONS}
  num_extensions, i: integer;
  ext: pchar;
{$ENDIF}
begin
  result := false;
{$IFDEF HAS_GL_NUM_EXTENSIONS}
  if glVersionMajor >= 3 then begin
      glGetIntegerv(GL_NUM_EXTENSIONS, @num_extensions);
      for i := 0 to num_extensions - 1 do begin
          ext := PChar( glGetStringi(GL_EXTENSIONS, i) );
          if strcomp(ext, PChar(extname)) = 0 then
              exit(true);
      end;
      exit;
  end;
{$ENDIF}
  extensions := PChar( glGetString(GL_EXTENSIONS) );
  while true do begin
      loc := strpos(extensions, PChar(extname));
      if loc = nil then
          exit;
      terminator := loc + length(extname);
      if (loc = extensions) or (loc[-1] = ' ') then
          if (terminator[0] = ' ') or (terminator[0] = #0) then
              exit(true);
      extensions := terminator;
  end;
end;

procedure load_GL_VERSION_1_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_0 then exit;
  glCullFace := load('glCullFace');
  glFrontFace := load('glFrontFace');
  glHint := load('glHint');
  glLineWidth := load('glLineWidth');
  glPointSize := load('glPointSize');
  glPolygonMode := load('glPolygonMode');
  glScissor := load('glScissor');
  glTexParameterf := load('glTexParameterf');
  glTexParameterfv := load('glTexParameterfv');
  glTexParameteri := load('glTexParameteri');
  glTexParameteriv := load('glTexParameteriv');
  glTexImage1D := load('glTexImage1D');
  glTexImage2D := load('glTexImage2D');
  glDrawBuffer := load('glDrawBuffer');
  glClear := load('glClear');
  glClearColor := load('glClearColor');
  glClearStencil := load('glClearStencil');
  glClearDepth := load('glClearDepth');
  glStencilMask := load('glStencilMask');
  glColorMask := load('glColorMask');
  glDepthMask := load('glDepthMask');
  glDisable := load('glDisable');
  glEnable := load('glEnable');
  glFinish := load('glFinish');
  glFlush := load('glFlush');
  glBlendFunc := load('glBlendFunc');
  glLogicOp := load('glLogicOp');
  glStencilFunc := load('glStencilFunc');
  glStencilOp := load('glStencilOp');
  glDepthFunc := load('glDepthFunc');
  glPixelStoref := load('glPixelStoref');
  glPixelStorei := load('glPixelStorei');
  glReadBuffer := load('glReadBuffer');
  glReadPixels := load('glReadPixels');
  glGetBooleanv := load('glGetBooleanv');
  glGetDoublev := load('glGetDoublev');
  glGetError := load('glGetError');
  glGetFloatv := load('glGetFloatv');
  glGetIntegerv := load('glGetIntegerv');
  glGetString := load('glGetString');
  glGetTexImage := load('glGetTexImage');
  glGetTexParameterfv := load('glGetTexParameterfv');
  glGetTexParameteriv := load('glGetTexParameteriv');
  glGetTexLevelParameterfv := load('glGetTexLevelParameterfv');
  glGetTexLevelParameteriv := load('glGetTexLevelParameteriv');
  glIsEnabled := load('glIsEnabled');
  glDepthRange := load('glDepthRange');
  glViewport := load('glViewport');
  glNewList := load('glNewList');
  glEndList := load('glEndList');
  glCallList := load('glCallList');
  glCallLists := load('glCallLists');
  glDeleteLists := load('glDeleteLists');
  glGenLists := load('glGenLists');
  glListBase := load('glListBase');
  glBegin := load('glBegin');
  glBitmap := load('glBitmap');
  glColor3b := load('glColor3b');
  glColor3bv := load('glColor3bv');
  glColor3d := load('glColor3d');
  glColor3dv := load('glColor3dv');
  glColor3f := load('glColor3f');
  glColor3fv := load('glColor3fv');
  glColor3i := load('glColor3i');
  glColor3iv := load('glColor3iv');
  glColor3s := load('glColor3s');
  glColor3sv := load('glColor3sv');
  glColor3ub := load('glColor3ub');
  glColor3ubv := load('glColor3ubv');
  glColor3ui := load('glColor3ui');
  glColor3uiv := load('glColor3uiv');
  glColor3us := load('glColor3us');
  glColor3usv := load('glColor3usv');
  glColor4b := load('glColor4b');
  glColor4bv := load('glColor4bv');
  glColor4d := load('glColor4d');
  glColor4dv := load('glColor4dv');
  glColor4f := load('glColor4f');
  glColor4fv := load('glColor4fv');
  glColor4i := load('glColor4i');
  glColor4iv := load('glColor4iv');
  glColor4s := load('glColor4s');
  glColor4sv := load('glColor4sv');
  glColor4ub := load('glColor4ub');
  glColor4ubv := load('glColor4ubv');
  glColor4ui := load('glColor4ui');
  glColor4uiv := load('glColor4uiv');
  glColor4us := load('glColor4us');
  glColor4usv := load('glColor4usv');
  glEdgeFlag := load('glEdgeFlag');
  glEdgeFlagv := load('glEdgeFlagv');
  glEnd := load('glEnd');
  glIndexd := load('glIndexd');
  glIndexdv := load('glIndexdv');
  glIndexf := load('glIndexf');
  glIndexfv := load('glIndexfv');
  glIndexi := load('glIndexi');
  glIndexiv := load('glIndexiv');
  glIndexs := load('glIndexs');
  glIndexsv := load('glIndexsv');
  glNormal3b := load('glNormal3b');
  glNormal3bv := load('glNormal3bv');
  glNormal3d := load('glNormal3d');
  glNormal3dv := load('glNormal3dv');
  glNormal3f := load('glNormal3f');
  glNormal3fv := load('glNormal3fv');
  glNormal3i := load('glNormal3i');
  glNormal3iv := load('glNormal3iv');
  glNormal3s := load('glNormal3s');
  glNormal3sv := load('glNormal3sv');
  glRasterPos2d := load('glRasterPos2d');
  glRasterPos2dv := load('glRasterPos2dv');
  glRasterPos2f := load('glRasterPos2f');
  glRasterPos2fv := load('glRasterPos2fv');
  glRasterPos2i := load('glRasterPos2i');
  glRasterPos2iv := load('glRasterPos2iv');
  glRasterPos2s := load('glRasterPos2s');
  glRasterPos2sv := load('glRasterPos2sv');
  glRasterPos3d := load('glRasterPos3d');
  glRasterPos3dv := load('glRasterPos3dv');
  glRasterPos3f := load('glRasterPos3f');
  glRasterPos3fv := load('glRasterPos3fv');
  glRasterPos3i := load('glRasterPos3i');
  glRasterPos3iv := load('glRasterPos3iv');
  glRasterPos3s := load('glRasterPos3s');
  glRasterPos3sv := load('glRasterPos3sv');
  glRasterPos4d := load('glRasterPos4d');
  glRasterPos4dv := load('glRasterPos4dv');
  glRasterPos4f := load('glRasterPos4f');
  glRasterPos4fv := load('glRasterPos4fv');
  glRasterPos4i := load('glRasterPos4i');
  glRasterPos4iv := load('glRasterPos4iv');
  glRasterPos4s := load('glRasterPos4s');
  glRasterPos4sv := load('glRasterPos4sv');
  glRectd := load('glRectd');
  glRectdv := load('glRectdv');
  glRectf := load('glRectf');
  glRectfv := load('glRectfv');
  glRecti := load('glRecti');
  glRectiv := load('glRectiv');
  glRects := load('glRects');
  glRectsv := load('glRectsv');
  glTexCoord1d := load('glTexCoord1d');
  glTexCoord1dv := load('glTexCoord1dv');
  glTexCoord1f := load('glTexCoord1f');
  glTexCoord1fv := load('glTexCoord1fv');
  glTexCoord1i := load('glTexCoord1i');
  glTexCoord1iv := load('glTexCoord1iv');
  glTexCoord1s := load('glTexCoord1s');
  glTexCoord1sv := load('glTexCoord1sv');
  glTexCoord2d := load('glTexCoord2d');
  glTexCoord2dv := load('glTexCoord2dv');
  glTexCoord2f := load('glTexCoord2f');
  glTexCoord2fv := load('glTexCoord2fv');
  glTexCoord2i := load('glTexCoord2i');
  glTexCoord2iv := load('glTexCoord2iv');
  glTexCoord2s := load('glTexCoord2s');
  glTexCoord2sv := load('glTexCoord2sv');
  glTexCoord3d := load('glTexCoord3d');
  glTexCoord3dv := load('glTexCoord3dv');
  glTexCoord3f := load('glTexCoord3f');
  glTexCoord3fv := load('glTexCoord3fv');
  glTexCoord3i := load('glTexCoord3i');
  glTexCoord3iv := load('glTexCoord3iv');
  glTexCoord3s := load('glTexCoord3s');
  glTexCoord3sv := load('glTexCoord3sv');
  glTexCoord4d := load('glTexCoord4d');
  glTexCoord4dv := load('glTexCoord4dv');
  glTexCoord4f := load('glTexCoord4f');
  glTexCoord4fv := load('glTexCoord4fv');
  glTexCoord4i := load('glTexCoord4i');
  glTexCoord4iv := load('glTexCoord4iv');
  glTexCoord4s := load('glTexCoord4s');
  glTexCoord4sv := load('glTexCoord4sv');
  glVertex2d := load('glVertex2d');
  glVertex2dv := load('glVertex2dv');
  glVertex2f := load('glVertex2f');
  glVertex2fv := load('glVertex2fv');
  glVertex2i := load('glVertex2i');
  glVertex2iv := load('glVertex2iv');
  glVertex2s := load('glVertex2s');
  glVertex2sv := load('glVertex2sv');
  glVertex3d := load('glVertex3d');
  glVertex3dv := load('glVertex3dv');
  glVertex3f := load('glVertex3f');
  glVertex3fv := load('glVertex3fv');
  glVertex3i := load('glVertex3i');
  glVertex3iv := load('glVertex3iv');
  glVertex3s := load('glVertex3s');
  glVertex3sv := load('glVertex3sv');
  glVertex4d := load('glVertex4d');
  glVertex4dv := load('glVertex4dv');
  glVertex4f := load('glVertex4f');
  glVertex4fv := load('glVertex4fv');
  glVertex4i := load('glVertex4i');
  glVertex4iv := load('glVertex4iv');
  glVertex4s := load('glVertex4s');
  glVertex4sv := load('glVertex4sv');
  glClipPlane := load('glClipPlane');
  glColorMaterial := load('glColorMaterial');
  glFogf := load('glFogf');
  glFogfv := load('glFogfv');
  glFogi := load('glFogi');
  glFogiv := load('glFogiv');
  glLightf := load('glLightf');
  glLightfv := load('glLightfv');
  glLighti := load('glLighti');
  glLightiv := load('glLightiv');
  glLightModelf := load('glLightModelf');
  glLightModelfv := load('glLightModelfv');
  glLightModeli := load('glLightModeli');
  glLightModeliv := load('glLightModeliv');
  glLineStipple := load('glLineStipple');
  glMaterialf := load('glMaterialf');
  glMaterialfv := load('glMaterialfv');
  glMateriali := load('glMateriali');
  glMaterialiv := load('glMaterialiv');
  glPolygonStipple := load('glPolygonStipple');
  glShadeModel := load('glShadeModel');
  glTexEnvf := load('glTexEnvf');
  glTexEnvfv := load('glTexEnvfv');
  glTexEnvi := load('glTexEnvi');
  glTexEnviv := load('glTexEnviv');
  glTexGend := load('glTexGend');
  glTexGendv := load('glTexGendv');
  glTexGenf := load('glTexGenf');
  glTexGenfv := load('glTexGenfv');
  glTexGeni := load('glTexGeni');
  glTexGeniv := load('glTexGeniv');
  glFeedbackBuffer := load('glFeedbackBuffer');
  glSelectBuffer := load('glSelectBuffer');
  glRenderMode := load('glRenderMode');
  glInitNames := load('glInitNames');
  glLoadName := load('glLoadName');
  glPassThrough := load('glPassThrough');
  glPopName := load('glPopName');
  glPushName := load('glPushName');
  glClearAccum := load('glClearAccum');
  glClearIndex := load('glClearIndex');
  glIndexMask := load('glIndexMask');
  glAccum := load('glAccum');
  glPopAttrib := load('glPopAttrib');
  glPushAttrib := load('glPushAttrib');
  glMap1d := load('glMap1d');
  glMap1f := load('glMap1f');
  glMap2d := load('glMap2d');
  glMap2f := load('glMap2f');
  glMapGrid1d := load('glMapGrid1d');
  glMapGrid1f := load('glMapGrid1f');
  glMapGrid2d := load('glMapGrid2d');
  glMapGrid2f := load('glMapGrid2f');
  glEvalCoord1d := load('glEvalCoord1d');
  glEvalCoord1dv := load('glEvalCoord1dv');
  glEvalCoord1f := load('glEvalCoord1f');
  glEvalCoord1fv := load('glEvalCoord1fv');
  glEvalCoord2d := load('glEvalCoord2d');
  glEvalCoord2dv := load('glEvalCoord2dv');
  glEvalCoord2f := load('glEvalCoord2f');
  glEvalCoord2fv := load('glEvalCoord2fv');
  glEvalMesh1 := load('glEvalMesh1');
  glEvalPoint1 := load('glEvalPoint1');
  glEvalMesh2 := load('glEvalMesh2');
  glEvalPoint2 := load('glEvalPoint2');
  glAlphaFunc := load('glAlphaFunc');
  glPixelZoom := load('glPixelZoom');
  glPixelTransferf := load('glPixelTransferf');
  glPixelTransferi := load('glPixelTransferi');
  glPixelMapfv := load('glPixelMapfv');
  glPixelMapuiv := load('glPixelMapuiv');
  glPixelMapusv := load('glPixelMapusv');
  glCopyPixels := load('glCopyPixels');
  glDrawPixels := load('glDrawPixels');
  glGetClipPlane := load('glGetClipPlane');
  glGetLightfv := load('glGetLightfv');
  glGetLightiv := load('glGetLightiv');
  glGetMapdv := load('glGetMapdv');
  glGetMapfv := load('glGetMapfv');
  glGetMapiv := load('glGetMapiv');
  glGetMaterialfv := load('glGetMaterialfv');
  glGetMaterialiv := load('glGetMaterialiv');
  glGetPixelMapfv := load('glGetPixelMapfv');
  glGetPixelMapuiv := load('glGetPixelMapuiv');
  glGetPixelMapusv := load('glGetPixelMapusv');
  glGetPolygonStipple := load('glGetPolygonStipple');
  glGetTexEnvfv := load('glGetTexEnvfv');
  glGetTexEnviv := load('glGetTexEnviv');
  glGetTexGendv := load('glGetTexGendv');
  glGetTexGenfv := load('glGetTexGenfv');
  glGetTexGeniv := load('glGetTexGeniv');
  glIsList := load('glIsList');
  glFrustum := load('glFrustum');
  glLoadIdentity := load('glLoadIdentity');
  glLoadMatrixf := load('glLoadMatrixf');
  glLoadMatrixd := load('glLoadMatrixd');
  glMatrixMode := load('glMatrixMode');
  glMultMatrixf := load('glMultMatrixf');
  glMultMatrixd := load('glMultMatrixd');
  glOrtho := load('glOrtho');
  glPopMatrix := load('glPopMatrix');
  glPushMatrix := load('glPushMatrix');
  glRotated := load('glRotated');
  glRotatef := load('glRotatef');
  glScaled := load('glScaled');
  glScalef := load('glScalef');
  glTranslated := load('glTranslated');
  glTranslatef := load('glTranslatef');
end;

procedure load_GL_VERSION_1_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_1 then exit;
  glDrawArrays := load('glDrawArrays');
  glDrawElements := load('glDrawElements');
  glGetPointerv := load('glGetPointerv');
  glPolygonOffset := load('glPolygonOffset');
  glCopyTexImage1D := load('glCopyTexImage1D');
  glCopyTexImage2D := load('glCopyTexImage2D');
  glCopyTexSubImage1D := load('glCopyTexSubImage1D');
  glCopyTexSubImage2D := load('glCopyTexSubImage2D');
  glTexSubImage1D := load('glTexSubImage1D');
  glTexSubImage2D := load('glTexSubImage2D');
  glBindTexture := load('glBindTexture');
  glDeleteTextures := load('glDeleteTextures');
  glGenTextures := load('glGenTextures');
  glIsTexture := load('glIsTexture');
  glArrayElement := load('glArrayElement');
  glColorPointer := load('glColorPointer');
  glDisableClientState := load('glDisableClientState');
  glEdgeFlagPointer := load('glEdgeFlagPointer');
  glEnableClientState := load('glEnableClientState');
  glIndexPointer := load('glIndexPointer');
  glInterleavedArrays := load('glInterleavedArrays');
  glNormalPointer := load('glNormalPointer');
  glTexCoordPointer := load('glTexCoordPointer');
  glVertexPointer := load('glVertexPointer');
  glAreTexturesResident := load('glAreTexturesResident');
  glPrioritizeTextures := load('glPrioritizeTextures');
  glIndexub := load('glIndexub');
  glIndexubv := load('glIndexubv');
  glPopClientAttrib := load('glPopClientAttrib');
  glPushClientAttrib := load('glPushClientAttrib');
end;

procedure load_GL_VERSION_1_2(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_2 then exit;
  glDrawRangeElements := load('glDrawRangeElements');
  glTexImage3D := load('glTexImage3D');
  glTexSubImage3D := load('glTexSubImage3D');
  glCopyTexSubImage3D := load('glCopyTexSubImage3D');
end;

procedure load_GL_VERSION_1_3(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_3 then exit;
  glActiveTexture := load('glActiveTexture');
  glSampleCoverage := load('glSampleCoverage');
  glCompressedTexImage3D := load('glCompressedTexImage3D');
  glCompressedTexImage2D := load('glCompressedTexImage2D');
  glCompressedTexImage1D := load('glCompressedTexImage1D');
  glCompressedTexSubImage3D := load('glCompressedTexSubImage3D');
  glCompressedTexSubImage2D := load('glCompressedTexSubImage2D');
  glCompressedTexSubImage1D := load('glCompressedTexSubImage1D');
  glGetCompressedTexImage := load('glGetCompressedTexImage');
  glClientActiveTexture := load('glClientActiveTexture');
  glMultiTexCoord1d := load('glMultiTexCoord1d');
  glMultiTexCoord1dv := load('glMultiTexCoord1dv');
  glMultiTexCoord1f := load('glMultiTexCoord1f');
  glMultiTexCoord1fv := load('glMultiTexCoord1fv');
  glMultiTexCoord1i := load('glMultiTexCoord1i');
  glMultiTexCoord1iv := load('glMultiTexCoord1iv');
  glMultiTexCoord1s := load('glMultiTexCoord1s');
  glMultiTexCoord1sv := load('glMultiTexCoord1sv');
  glMultiTexCoord2d := load('glMultiTexCoord2d');
  glMultiTexCoord2dv := load('glMultiTexCoord2dv');
  glMultiTexCoord2f := load('glMultiTexCoord2f');
  glMultiTexCoord2fv := load('glMultiTexCoord2fv');
  glMultiTexCoord2i := load('glMultiTexCoord2i');
  glMultiTexCoord2iv := load('glMultiTexCoord2iv');
  glMultiTexCoord2s := load('glMultiTexCoord2s');
  glMultiTexCoord2sv := load('glMultiTexCoord2sv');
  glMultiTexCoord3d := load('glMultiTexCoord3d');
  glMultiTexCoord3dv := load('glMultiTexCoord3dv');
  glMultiTexCoord3f := load('glMultiTexCoord3f');
  glMultiTexCoord3fv := load('glMultiTexCoord3fv');
  glMultiTexCoord3i := load('glMultiTexCoord3i');
  glMultiTexCoord3iv := load('glMultiTexCoord3iv');
  glMultiTexCoord3s := load('glMultiTexCoord3s');
  glMultiTexCoord3sv := load('glMultiTexCoord3sv');
  glMultiTexCoord4d := load('glMultiTexCoord4d');
  glMultiTexCoord4dv := load('glMultiTexCoord4dv');
  glMultiTexCoord4f := load('glMultiTexCoord4f');
  glMultiTexCoord4fv := load('glMultiTexCoord4fv');
  glMultiTexCoord4i := load('glMultiTexCoord4i');
  glMultiTexCoord4iv := load('glMultiTexCoord4iv');
  glMultiTexCoord4s := load('glMultiTexCoord4s');
  glMultiTexCoord4sv := load('glMultiTexCoord4sv');
  glLoadTransposeMatrixf := load('glLoadTransposeMatrixf');
  glLoadTransposeMatrixd := load('glLoadTransposeMatrixd');
  glMultTransposeMatrixf := load('glMultTransposeMatrixf');
  glMultTransposeMatrixd := load('glMultTransposeMatrixd');
end;

procedure load_GL_VERSION_1_4(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_4 then exit;
  glBlendFuncSeparate := load('glBlendFuncSeparate');
  glMultiDrawArrays := load('glMultiDrawArrays');
  glMultiDrawElements := load('glMultiDrawElements');
  glPointParameterf := load('glPointParameterf');
  glPointParameterfv := load('glPointParameterfv');
  glPointParameteri := load('glPointParameteri');
  glPointParameteriv := load('glPointParameteriv');
  glFogCoordf := load('glFogCoordf');
  glFogCoordfv := load('glFogCoordfv');
  glFogCoordd := load('glFogCoordd');
  glFogCoorddv := load('glFogCoorddv');
  glFogCoordPointer := load('glFogCoordPointer');
  glSecondaryColor3b := load('glSecondaryColor3b');
  glSecondaryColor3bv := load('glSecondaryColor3bv');
  glSecondaryColor3d := load('glSecondaryColor3d');
  glSecondaryColor3dv := load('glSecondaryColor3dv');
  glSecondaryColor3f := load('glSecondaryColor3f');
  glSecondaryColor3fv := load('glSecondaryColor3fv');
  glSecondaryColor3i := load('glSecondaryColor3i');
  glSecondaryColor3iv := load('glSecondaryColor3iv');
  glSecondaryColor3s := load('glSecondaryColor3s');
  glSecondaryColor3sv := load('glSecondaryColor3sv');
  glSecondaryColor3ub := load('glSecondaryColor3ub');
  glSecondaryColor3ubv := load('glSecondaryColor3ubv');
  glSecondaryColor3ui := load('glSecondaryColor3ui');
  glSecondaryColor3uiv := load('glSecondaryColor3uiv');
  glSecondaryColor3us := load('glSecondaryColor3us');
  glSecondaryColor3usv := load('glSecondaryColor3usv');
  glSecondaryColorPointer := load('glSecondaryColorPointer');
  glWindowPos2d := load('glWindowPos2d');
  glWindowPos2dv := load('glWindowPos2dv');
  glWindowPos2f := load('glWindowPos2f');
  glWindowPos2fv := load('glWindowPos2fv');
  glWindowPos2i := load('glWindowPos2i');
  glWindowPos2iv := load('glWindowPos2iv');
  glWindowPos2s := load('glWindowPos2s');
  glWindowPos2sv := load('glWindowPos2sv');
  glWindowPos3d := load('glWindowPos3d');
  glWindowPos3dv := load('glWindowPos3dv');
  glWindowPos3f := load('glWindowPos3f');
  glWindowPos3fv := load('glWindowPos3fv');
  glWindowPos3i := load('glWindowPos3i');
  glWindowPos3iv := load('glWindowPos3iv');
  glWindowPos3s := load('glWindowPos3s');
  glWindowPos3sv := load('glWindowPos3sv');
  glBlendColor := load('glBlendColor');
  glBlendEquation := load('glBlendEquation');
end;

procedure load_GL_VERSION_1_5(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_5 then exit;
  glGenQueries := load('glGenQueries');
  glDeleteQueries := load('glDeleteQueries');
  glIsQuery := load('glIsQuery');
  glBeginQuery := load('glBeginQuery');
  glEndQuery := load('glEndQuery');
  glGetQueryiv := load('glGetQueryiv');
  glGetQueryObjectiv := load('glGetQueryObjectiv');
  glGetQueryObjectuiv := load('glGetQueryObjectuiv');
  glBindBuffer := load('glBindBuffer');
  glDeleteBuffers := load('glDeleteBuffers');
  glGenBuffers := load('glGenBuffers');
  glIsBuffer := load('glIsBuffer');
  glBufferData := load('glBufferData');
  glBufferSubData := load('glBufferSubData');
  glGetBufferSubData := load('glGetBufferSubData');
  glMapBuffer := load('glMapBuffer');
  glUnmapBuffer := load('glUnmapBuffer');
  glGetBufferParameteriv := load('glGetBufferParameteriv');
  glGetBufferPointerv := load('glGetBufferPointerv');
end;

procedure load_GL_VERSION_2_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_2_0 then exit;
  glBlendEquationSeparate := load('glBlendEquationSeparate');
  glDrawBuffers := load('glDrawBuffers');
  glStencilOpSeparate := load('glStencilOpSeparate');
  glStencilFuncSeparate := load('glStencilFuncSeparate');
  glStencilMaskSeparate := load('glStencilMaskSeparate');
  glAttachShader := load('glAttachShader');
  glBindAttribLocation := load('glBindAttribLocation');
  glCompileShader := load('glCompileShader');
  glCreateProgram := load('glCreateProgram');
  glCreateShader := load('glCreateShader');
  glDeleteProgram := load('glDeleteProgram');
  glDeleteShader := load('glDeleteShader');
  glDetachShader := load('glDetachShader');
  glDisableVertexAttribArray := load('glDisableVertexAttribArray');
  glEnableVertexAttribArray := load('glEnableVertexAttribArray');
  glGetActiveAttrib := load('glGetActiveAttrib');
  glGetActiveUniform := load('glGetActiveUniform');
  glGetAttachedShaders := load('glGetAttachedShaders');
  glGetAttribLocation := load('glGetAttribLocation');
  glGetProgramiv := load('glGetProgramiv');
  glGetProgramInfoLog := load('glGetProgramInfoLog');
  glGetShaderiv := load('glGetShaderiv');
  glGetShaderInfoLog := load('glGetShaderInfoLog');
  glGetShaderSource := load('glGetShaderSource');
  glGetUniformLocation := load('glGetUniformLocation');
  glGetUniformfv := load('glGetUniformfv');
  glGetUniformiv := load('glGetUniformiv');
  glGetVertexAttribdv := load('glGetVertexAttribdv');
  glGetVertexAttribfv := load('glGetVertexAttribfv');
  glGetVertexAttribiv := load('glGetVertexAttribiv');
  glGetVertexAttribPointerv := load('glGetVertexAttribPointerv');
  glIsProgram := load('glIsProgram');
  glIsShader := load('glIsShader');
  glLinkProgram := load('glLinkProgram');
  glShaderSource := load('glShaderSource');
  glUseProgram := load('glUseProgram');
  glUniform1f := load('glUniform1f');
  glUniform2f := load('glUniform2f');
  glUniform3f := load('glUniform3f');
  glUniform4f := load('glUniform4f');
  glUniform1i := load('glUniform1i');
  glUniform2i := load('glUniform2i');
  glUniform3i := load('glUniform3i');
  glUniform4i := load('glUniform4i');
  glUniform1fv := load('glUniform1fv');
  glUniform2fv := load('glUniform2fv');
  glUniform3fv := load('glUniform3fv');
  glUniform4fv := load('glUniform4fv');
  glUniform1iv := load('glUniform1iv');
  glUniform2iv := load('glUniform2iv');
  glUniform3iv := load('glUniform3iv');
  glUniform4iv := load('glUniform4iv');
  glUniformMatrix2fv := load('glUniformMatrix2fv');
  glUniformMatrix3fv := load('glUniformMatrix3fv');
  glUniformMatrix4fv := load('glUniformMatrix4fv');
  glValidateProgram := load('glValidateProgram');
  glVertexAttrib1d := load('glVertexAttrib1d');
  glVertexAttrib1dv := load('glVertexAttrib1dv');
  glVertexAttrib1f := load('glVertexAttrib1f');
  glVertexAttrib1fv := load('glVertexAttrib1fv');
  glVertexAttrib1s := load('glVertexAttrib1s');
  glVertexAttrib1sv := load('glVertexAttrib1sv');
  glVertexAttrib2d := load('glVertexAttrib2d');
  glVertexAttrib2dv := load('glVertexAttrib2dv');
  glVertexAttrib2f := load('glVertexAttrib2f');
  glVertexAttrib2fv := load('glVertexAttrib2fv');
  glVertexAttrib2s := load('glVertexAttrib2s');
  glVertexAttrib2sv := load('glVertexAttrib2sv');
  glVertexAttrib3d := load('glVertexAttrib3d');
  glVertexAttrib3dv := load('glVertexAttrib3dv');
  glVertexAttrib3f := load('glVertexAttrib3f');
  glVertexAttrib3fv := load('glVertexAttrib3fv');
  glVertexAttrib3s := load('glVertexAttrib3s');
  glVertexAttrib3sv := load('glVertexAttrib3sv');
  glVertexAttrib4Nbv := load('glVertexAttrib4Nbv');
  glVertexAttrib4Niv := load('glVertexAttrib4Niv');
  glVertexAttrib4Nsv := load('glVertexAttrib4Nsv');
  glVertexAttrib4Nub := load('glVertexAttrib4Nub');
  glVertexAttrib4Nubv := load('glVertexAttrib4Nubv');
  glVertexAttrib4Nuiv := load('glVertexAttrib4Nuiv');
  glVertexAttrib4Nusv := load('glVertexAttrib4Nusv');
  glVertexAttrib4bv := load('glVertexAttrib4bv');
  glVertexAttrib4d := load('glVertexAttrib4d');
  glVertexAttrib4dv := load('glVertexAttrib4dv');
  glVertexAttrib4f := load('glVertexAttrib4f');
  glVertexAttrib4fv := load('glVertexAttrib4fv');
  glVertexAttrib4iv := load('glVertexAttrib4iv');
  glVertexAttrib4s := load('glVertexAttrib4s');
  glVertexAttrib4sv := load('glVertexAttrib4sv');
  glVertexAttrib4ubv := load('glVertexAttrib4ubv');
  glVertexAttrib4uiv := load('glVertexAttrib4uiv');
  glVertexAttrib4usv := load('glVertexAttrib4usv');
  glVertexAttribPointer := load('glVertexAttribPointer');
end;

procedure load_GL_VERSION_2_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_2_1 then exit;
  glUniformMatrix2x3fv := load('glUniformMatrix2x3fv');
  glUniformMatrix3x2fv := load('glUniformMatrix3x2fv');
  glUniformMatrix2x4fv := load('glUniformMatrix2x4fv');
  glUniformMatrix4x2fv := load('glUniformMatrix4x2fv');
  glUniformMatrix3x4fv := load('glUniformMatrix3x4fv');
  glUniformMatrix4x3fv := load('glUniformMatrix4x3fv');
end;

procedure findExtensionsGL();
begin
end;

procedure findCoreGL(glVersion: string);
const
  prefixes: array[0..2] of string = ('OpenGL ES-CM ', 'OpenGL ES-CL ', 'OpenGL ES ');
var
  version, p: string;
  major, minor: integer;
begin
  version := glVersion;
  for p in prefixes do
    if string(LeftStr(AnsiString(version), length(p))) = p then begin
      version := StringReplace(version, p, '', [rfReplaceAll]);
      break;
    end;

  major := ord(version[1]) - ord('0');
  minor := ord(version[3]) - ord('0');

  glVersionMajor := major;
  glVersionMinor := minor;

  GLAD_GL_VERSION_1_0 := ((major = 1) and (minor >= 0)) or (major > 1);
  GLAD_GL_VERSION_1_1 := ((major = 1) and (minor >= 1)) or (major > 1);
  GLAD_GL_VERSION_1_2 := ((major = 1) and (minor >= 2)) or (major > 1);
  GLAD_GL_VERSION_1_3 := ((major = 1) and (minor >= 3)) or (major > 1);
  GLAD_GL_VERSION_1_4 := ((major = 1) and (minor >= 4)) or (major > 1);
  GLAD_GL_VERSION_1_5 := ((major = 1) and (minor >= 5)) or (major > 1);
  GLAD_GL_VERSION_2_0 := ((major = 2) and (minor >= 0)) or (major > 2);
  GLAD_GL_VERSION_2_1 := ((major = 2) and (minor >= 1)) or (major > 2);
end;

function gladLoadGL(load: TLoadProc): boolean;
var
  glVersion: PAnsiChar;
begin
  glGetString := load('glGetString');
  if not Assigned(glGetString) then exit(false);
  glVersion := PAnsiChar( glGetString(GL_VERSION) );
  if glVersion = nil then exit(false);

  findCoreGL(string(glVersion));
  load_GL_VERSION_1_0(load);
  load_GL_VERSION_1_1(load);
  load_GL_VERSION_1_2(load);
  load_GL_VERSION_1_3(load);
  load_GL_VERSION_1_4(load);
  load_GL_VERSION_1_5(load);
  load_GL_VERSION_2_0(load);
  load_GL_VERSION_2_1(load);

  findExtensionsGL();

  result := (glVersionMajor <> 0) or (glVersionMinor <> 0);
end;

function loadGLProc(proc: PAnsiChar): Pointer; cdecl;
begin
  Result := Pointer(glfwGetProcAddress(proc));
end;

function LoadOpenGL(): Boolean;
var
  LVersion: Integer;
begin
  Result := False;
  if glfwGetCurrentContext() = nil then Exit;
  LVersion := initGL();
  if LVersion = 0 then Exit;
  Result := gladLoadGL(@loadGLProc);
end;

{$ENDREGION}

{$REGION ' Pyro.CLibs '}
procedure GetExports(const aDLLHandle: THandle);
begin
  if aDllHandle = 0 then Exit;
  _spClippingAttachment_dispose := GetProcAddress(aDLLHandle, '_spClippingAttachment_dispose');
  c2AABBtoAABB := GetProcAddress(aDLLHandle, 'c2AABBtoAABB');
  c2AABBtoAABBManifold := GetProcAddress(aDLLHandle, 'c2AABBtoAABBManifold');
  c2AABBtoCapsule := GetProcAddress(aDLLHandle, 'c2AABBtoCapsule');
  c2AABBtoCapsuleManifold := GetProcAddress(aDLLHandle, 'c2AABBtoCapsuleManifold');
  c2AABBtoPoly := GetProcAddress(aDLLHandle, 'c2AABBtoPoly');
  c2AABBtoPolyManifold := GetProcAddress(aDLLHandle, 'c2AABBtoPolyManifold');
  c2CapsuletoCapsule := GetProcAddress(aDLLHandle, 'c2CapsuletoCapsule');
  c2CapsuletoCapsuleManifold := GetProcAddress(aDLLHandle, 'c2CapsuletoCapsuleManifold');
  c2CapsuletoPoly := GetProcAddress(aDLLHandle, 'c2CapsuletoPoly');
  c2CapsuletoPolyManifold := GetProcAddress(aDLLHandle, 'c2CapsuletoPolyManifold');
  c2CastRay := GetProcAddress(aDLLHandle, 'c2CastRay');
  c2CircletoAABB := GetProcAddress(aDLLHandle, 'c2CircletoAABB');
  c2CircletoAABBManifold := GetProcAddress(aDLLHandle, 'c2CircletoAABBManifold');
  c2CircletoCapsule := GetProcAddress(aDLLHandle, 'c2CircletoCapsule');
  c2CircletoCapsuleManifold := GetProcAddress(aDLLHandle, 'c2CircletoCapsuleManifold');
  c2CircletoCircle := GetProcAddress(aDLLHandle, 'c2CircletoCircle');
  c2CircletoCircleManifold := GetProcAddress(aDLLHandle, 'c2CircletoCircleManifold');
  c2CircletoPoly := GetProcAddress(aDLLHandle, 'c2CircletoPoly');
  c2CircletoPolyManifold := GetProcAddress(aDLLHandle, 'c2CircletoPolyManifold');
  c2Collide := GetProcAddress(aDLLHandle, 'c2Collide');
  c2Collided := GetProcAddress(aDLLHandle, 'c2Collided');
  c2GJK := GetProcAddress(aDLLHandle, 'c2GJK');
  c2Hull := GetProcAddress(aDLLHandle, 'c2Hull');
  c2Inflate := GetProcAddress(aDLLHandle, 'c2Inflate');
  c2MakePoly := GetProcAddress(aDLLHandle, 'c2MakePoly');
  c2Norms := GetProcAddress(aDLLHandle, 'c2Norms');
  c2PolytoPoly := GetProcAddress(aDLLHandle, 'c2PolytoPoly');
  c2PolytoPolyManifold := GetProcAddress(aDLLHandle, 'c2PolytoPolyManifold');
  c2RaytoAABB := GetProcAddress(aDLLHandle, 'c2RaytoAABB');
  c2RaytoCapsule := GetProcAddress(aDLLHandle, 'c2RaytoCapsule');
  c2RaytoCircle := GetProcAddress(aDLLHandle, 'c2RaytoCircle');
  c2RaytoPoly := GetProcAddress(aDLLHandle, 'c2RaytoPoly');
  c2TOI := GetProcAddress(aDLLHandle, 'c2TOI');
  crc32 := GetProcAddress(aDLLHandle, 'crc32');
  glfwCreateCursor := GetProcAddress(aDLLHandle, 'glfwCreateCursor');
  glfwCreateStandardCursor := GetProcAddress(aDLLHandle, 'glfwCreateStandardCursor');
  glfwCreateWindow := GetProcAddress(aDLLHandle, 'glfwCreateWindow');
  glfwDefaultWindowHints := GetProcAddress(aDLLHandle, 'glfwDefaultWindowHints');
  glfwDestroyCursor := GetProcAddress(aDLLHandle, 'glfwDestroyCursor');
  glfwDestroyWindow := GetProcAddress(aDLLHandle, 'glfwDestroyWindow');
  glfwExtensionSupported := GetProcAddress(aDLLHandle, 'glfwExtensionSupported');
  glfwFocusWindow := GetProcAddress(aDLLHandle, 'glfwFocusWindow');
  glfwGetClipboardString := GetProcAddress(aDLLHandle, 'glfwGetClipboardString');
  glfwGetCurrentContext := GetProcAddress(aDLLHandle, 'glfwGetCurrentContext');
  glfwGetCursorPos := GetProcAddress(aDLLHandle, 'glfwGetCursorPos');
  glfwGetError := GetProcAddress(aDLLHandle, 'glfwGetError');
  glfwGetFramebufferSize := GetProcAddress(aDLLHandle, 'glfwGetFramebufferSize');
  glfwGetGamepadName := GetProcAddress(aDLLHandle, 'glfwGetGamepadName');
  glfwGetGamepadState := GetProcAddress(aDLLHandle, 'glfwGetGamepadState');
  glfwGetGammaRamp := GetProcAddress(aDLLHandle, 'glfwGetGammaRamp');
  glfwGetInputMode := GetProcAddress(aDLLHandle, 'glfwGetInputMode');
  glfwGetJoystickAxes := GetProcAddress(aDLLHandle, 'glfwGetJoystickAxes');
  glfwGetJoystickButtons := GetProcAddress(aDLLHandle, 'glfwGetJoystickButtons');
  glfwGetJoystickGUID := GetProcAddress(aDLLHandle, 'glfwGetJoystickGUID');
  glfwGetJoystickHats := GetProcAddress(aDLLHandle, 'glfwGetJoystickHats');
  glfwGetJoystickName := GetProcAddress(aDLLHandle, 'glfwGetJoystickName');
  glfwGetJoystickUserPointer := GetProcAddress(aDLLHandle, 'glfwGetJoystickUserPointer');
  glfwGetKey := GetProcAddress(aDLLHandle, 'glfwGetKey');
  glfwGetKeyName := GetProcAddress(aDLLHandle, 'glfwGetKeyName');
  glfwGetKeyScancode := GetProcAddress(aDLLHandle, 'glfwGetKeyScancode');
  glfwGetMonitorContentScale := GetProcAddress(aDLLHandle, 'glfwGetMonitorContentScale');
  glfwGetMonitorName := GetProcAddress(aDLLHandle, 'glfwGetMonitorName');
  glfwGetMonitorPhysicalSize := GetProcAddress(aDLLHandle, 'glfwGetMonitorPhysicalSize');
  glfwGetMonitorPos := GetProcAddress(aDLLHandle, 'glfwGetMonitorPos');
  glfwGetMonitors := GetProcAddress(aDLLHandle, 'glfwGetMonitors');
  glfwGetMonitorUserPointer := GetProcAddress(aDLLHandle, 'glfwGetMonitorUserPointer');
  glfwGetMonitorWorkarea := GetProcAddress(aDLLHandle, 'glfwGetMonitorWorkarea');
  glfwGetMouseButton := GetProcAddress(aDLLHandle, 'glfwGetMouseButton');
  glfwGetPlatform := GetProcAddress(aDLLHandle, 'glfwGetPlatform');
  glfwGetPrimaryMonitor := GetProcAddress(aDLLHandle, 'glfwGetPrimaryMonitor');
  glfwGetProcAddress := GetProcAddress(aDLLHandle, 'glfwGetProcAddress');
  glfwGetRequiredInstanceExtensions := GetProcAddress(aDLLHandle, 'glfwGetRequiredInstanceExtensions');
  glfwGetTime := GetProcAddress(aDLLHandle, 'glfwGetTime');
  glfwGetTimerFrequency := GetProcAddress(aDLLHandle, 'glfwGetTimerFrequency');
  glfwGetTimerValue := GetProcAddress(aDLLHandle, 'glfwGetTimerValue');
  glfwGetVersion := GetProcAddress(aDLLHandle, 'glfwGetVersion');
  glfwGetVersionString := GetProcAddress(aDLLHandle, 'glfwGetVersionString');
  glfwGetVideoMode := GetProcAddress(aDLLHandle, 'glfwGetVideoMode');
  glfwGetVideoModes := GetProcAddress(aDLLHandle, 'glfwGetVideoModes');
  glfwGetWin32Adapter := GetProcAddress(aDLLHandle, 'glfwGetWin32Adapter');
  glfwGetWin32Monitor := GetProcAddress(aDLLHandle, 'glfwGetWin32Monitor');
  glfwGetWin32Window := GetProcAddress(aDLLHandle, 'glfwGetWin32Window');
  glfwGetWindowAttrib := GetProcAddress(aDLLHandle, 'glfwGetWindowAttrib');
  glfwGetWindowContentScale := GetProcAddress(aDLLHandle, 'glfwGetWindowContentScale');
  glfwGetWindowFrameSize := GetProcAddress(aDLLHandle, 'glfwGetWindowFrameSize');
  glfwGetWindowMonitor := GetProcAddress(aDLLHandle, 'glfwGetWindowMonitor');
  glfwGetWindowOpacity := GetProcAddress(aDLLHandle, 'glfwGetWindowOpacity');
  glfwGetWindowPos := GetProcAddress(aDLLHandle, 'glfwGetWindowPos');
  glfwGetWindowSize := GetProcAddress(aDLLHandle, 'glfwGetWindowSize');
  glfwGetWindowTitle := GetProcAddress(aDLLHandle, 'glfwGetWindowTitle');
  glfwGetWindowUserPointer := GetProcAddress(aDLLHandle, 'glfwGetWindowUserPointer');
  glfwHideWindow := GetProcAddress(aDLLHandle, 'glfwHideWindow');
  glfwIconifyWindow := GetProcAddress(aDLLHandle, 'glfwIconifyWindow');
  glfwInit := GetProcAddress(aDLLHandle, 'glfwInit');
  glfwInitAllocator := GetProcAddress(aDLLHandle, 'glfwInitAllocator');
  glfwInitHint := GetProcAddress(aDLLHandle, 'glfwInitHint');
  glfwJoystickIsGamepad := GetProcAddress(aDLLHandle, 'glfwJoystickIsGamepad');
  glfwJoystickPresent := GetProcAddress(aDLLHandle, 'glfwJoystickPresent');
  glfwMakeContextCurrent := GetProcAddress(aDLLHandle, 'glfwMakeContextCurrent');
  glfwMaximizeWindow := GetProcAddress(aDLLHandle, 'glfwMaximizeWindow');
  glfwPlatformSupported := GetProcAddress(aDLLHandle, 'glfwPlatformSupported');
  glfwPollEvents := GetProcAddress(aDLLHandle, 'glfwPollEvents');
  glfwPostEmptyEvent := GetProcAddress(aDLLHandle, 'glfwPostEmptyEvent');
  glfwRawMouseMotionSupported := GetProcAddress(aDLLHandle, 'glfwRawMouseMotionSupported');
  glfwRequestWindowAttention := GetProcAddress(aDLLHandle, 'glfwRequestWindowAttention');
  glfwRestoreWindow := GetProcAddress(aDLLHandle, 'glfwRestoreWindow');
  glfwSetCharCallback := GetProcAddress(aDLLHandle, 'glfwSetCharCallback');
  glfwSetCharModsCallback := GetProcAddress(aDLLHandle, 'glfwSetCharModsCallback');
  glfwSetClipboardString := GetProcAddress(aDLLHandle, 'glfwSetClipboardString');
  glfwSetCursor := GetProcAddress(aDLLHandle, 'glfwSetCursor');
  glfwSetCursorEnterCallback := GetProcAddress(aDLLHandle, 'glfwSetCursorEnterCallback');
  glfwSetCursorPos := GetProcAddress(aDLLHandle, 'glfwSetCursorPos');
  glfwSetCursorPosCallback := GetProcAddress(aDLLHandle, 'glfwSetCursorPosCallback');
  glfwSetDropCallback := GetProcAddress(aDLLHandle, 'glfwSetDropCallback');
  glfwSetErrorCallback := GetProcAddress(aDLLHandle, 'glfwSetErrorCallback');
  glfwSetFramebufferSizeCallback := GetProcAddress(aDLLHandle, 'glfwSetFramebufferSizeCallback');
  glfwSetGamma := GetProcAddress(aDLLHandle, 'glfwSetGamma');
  glfwSetGammaRamp := GetProcAddress(aDLLHandle, 'glfwSetGammaRamp');
  glfwSetInputMode := GetProcAddress(aDLLHandle, 'glfwSetInputMode');
  glfwSetJoystickCallback := GetProcAddress(aDLLHandle, 'glfwSetJoystickCallback');
  glfwSetJoystickUserPointer := GetProcAddress(aDLLHandle, 'glfwSetJoystickUserPointer');
  glfwSetKeyCallback := GetProcAddress(aDLLHandle, 'glfwSetKeyCallback');
  glfwSetMonitorCallback := GetProcAddress(aDLLHandle, 'glfwSetMonitorCallback');
  glfwSetMonitorUserPointer := GetProcAddress(aDLLHandle, 'glfwSetMonitorUserPointer');
  glfwSetMouseButtonCallback := GetProcAddress(aDLLHandle, 'glfwSetMouseButtonCallback');
  glfwSetScrollCallback := GetProcAddress(aDLLHandle, 'glfwSetScrollCallback');
  glfwSetTime := GetProcAddress(aDLLHandle, 'glfwSetTime');
  glfwSetWindowAspectRatio := GetProcAddress(aDLLHandle, 'glfwSetWindowAspectRatio');
  glfwSetWindowAttrib := GetProcAddress(aDLLHandle, 'glfwSetWindowAttrib');
  glfwSetWindowCloseCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowCloseCallback');
  glfwSetWindowContentScaleCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowContentScaleCallback');
  glfwSetWindowFocusCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowFocusCallback');
  glfwSetWindowIcon := GetProcAddress(aDLLHandle, 'glfwSetWindowIcon');
  glfwSetWindowIconifyCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowIconifyCallback');
  glfwSetWindowMaximizeCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowMaximizeCallback');
  glfwSetWindowMonitor := GetProcAddress(aDLLHandle, 'glfwSetWindowMonitor');
  glfwSetWindowOpacity := GetProcAddress(aDLLHandle, 'glfwSetWindowOpacity');
  glfwSetWindowPos := GetProcAddress(aDLLHandle, 'glfwSetWindowPos');
  glfwSetWindowPosCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowPosCallback');
  glfwSetWindowRefreshCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowRefreshCallback');
  glfwSetWindowShouldClose := GetProcAddress(aDLLHandle, 'glfwSetWindowShouldClose');
  glfwSetWindowSize := GetProcAddress(aDLLHandle, 'glfwSetWindowSize');
  glfwSetWindowSizeCallback := GetProcAddress(aDLLHandle, 'glfwSetWindowSizeCallback');
  glfwSetWindowSizeLimits := GetProcAddress(aDLLHandle, 'glfwSetWindowSizeLimits');
  glfwSetWindowTitle := GetProcAddress(aDLLHandle, 'glfwSetWindowTitle');
  glfwSetWindowUserPointer := GetProcAddress(aDLLHandle, 'glfwSetWindowUserPointer');
  glfwShowWindow := GetProcAddress(aDLLHandle, 'glfwShowWindow');
  glfwSwapBuffers := GetProcAddress(aDLLHandle, 'glfwSwapBuffers');
  glfwSwapInterval := GetProcAddress(aDLLHandle, 'glfwSwapInterval');
  glfwTerminate := GetProcAddress(aDLLHandle, 'glfwTerminate');
  glfwUpdateGamepadMappings := GetProcAddress(aDLLHandle, 'glfwUpdateGamepadMappings');
  glfwVulkanSupported := GetProcAddress(aDLLHandle, 'glfwVulkanSupported');
  glfwWaitEvents := GetProcAddress(aDLLHandle, 'glfwWaitEvents');
  glfwWaitEventsTimeout := GetProcAddress(aDLLHandle, 'glfwWaitEventsTimeout');
  glfwWindowHint := GetProcAddress(aDLLHandle, 'glfwWindowHint');
  glfwWindowHintString := GetProcAddress(aDLLHandle, 'glfwWindowHintString');
  glfwWindowShouldClose := GetProcAddress(aDLLHandle, 'glfwWindowShouldClose');
  igAcceptDragDropPayload := GetProcAddress(aDLLHandle, 'igAcceptDragDropPayload');
  igActivateItemByID := GetProcAddress(aDLLHandle, 'igActivateItemByID');
  igAddContextHook := GetProcAddress(aDLLHandle, 'igAddContextHook');
  igAddDrawListToDrawDataEx := GetProcAddress(aDLLHandle, 'igAddDrawListToDrawDataEx');
  igAddSettingsHandler := GetProcAddress(aDLLHandle, 'igAddSettingsHandler');
  igAlignTextToFramePadding := GetProcAddress(aDLLHandle, 'igAlignTextToFramePadding');
  igArrowButton := GetProcAddress(aDLLHandle, 'igArrowButton');
  igArrowButtonEx := GetProcAddress(aDLLHandle, 'igArrowButtonEx');
  igBegin := GetProcAddress(aDLLHandle, 'igBegin');
  igBeginBoxSelect := GetProcAddress(aDLLHandle, 'igBeginBoxSelect');
  igBeginChild_ID := GetProcAddress(aDLLHandle, 'igBeginChild_ID');
  igBeginChild_Str := GetProcAddress(aDLLHandle, 'igBeginChild_Str');
  igBeginChildEx := GetProcAddress(aDLLHandle, 'igBeginChildEx');
  igBeginColumns := GetProcAddress(aDLLHandle, 'igBeginColumns');
  igBeginCombo := GetProcAddress(aDLLHandle, 'igBeginCombo');
  igBeginComboPopup := GetProcAddress(aDLLHandle, 'igBeginComboPopup');
  igBeginComboPreview := GetProcAddress(aDLLHandle, 'igBeginComboPreview');
  igBeginDisabled := GetProcAddress(aDLLHandle, 'igBeginDisabled');
  igBeginDisabledOverrideReenable := GetProcAddress(aDLLHandle, 'igBeginDisabledOverrideReenable');
  igBeginDockableDragDropSource := GetProcAddress(aDLLHandle, 'igBeginDockableDragDropSource');
  igBeginDockableDragDropTarget := GetProcAddress(aDLLHandle, 'igBeginDockableDragDropTarget');
  igBeginDocked := GetProcAddress(aDLLHandle, 'igBeginDocked');
  igBeginDragDropSource := GetProcAddress(aDLLHandle, 'igBeginDragDropSource');
  igBeginDragDropTarget := GetProcAddress(aDLLHandle, 'igBeginDragDropTarget');
  igBeginDragDropTargetCustom := GetProcAddress(aDLLHandle, 'igBeginDragDropTargetCustom');
  igBeginErrorTooltip := GetProcAddress(aDLLHandle, 'igBeginErrorTooltip');
  igBeginGroup := GetProcAddress(aDLLHandle, 'igBeginGroup');
  igBeginItemTooltip := GetProcAddress(aDLLHandle, 'igBeginItemTooltip');
  igBeginListBox := GetProcAddress(aDLLHandle, 'igBeginListBox');
  igBeginMainMenuBar := GetProcAddress(aDLLHandle, 'igBeginMainMenuBar');
  igBeginMenu := GetProcAddress(aDLLHandle, 'igBeginMenu');
  igBeginMenuBar := GetProcAddress(aDLLHandle, 'igBeginMenuBar');
  igBeginMenuEx := GetProcAddress(aDLLHandle, 'igBeginMenuEx');
  igBeginMultiSelect := GetProcAddress(aDLLHandle, 'igBeginMultiSelect');
  igBeginPopup := GetProcAddress(aDLLHandle, 'igBeginPopup');
  igBeginPopupContextItem := GetProcAddress(aDLLHandle, 'igBeginPopupContextItem');
  igBeginPopupContextVoid := GetProcAddress(aDLLHandle, 'igBeginPopupContextVoid');
  igBeginPopupContextWindow := GetProcAddress(aDLLHandle, 'igBeginPopupContextWindow');
  igBeginPopupEx := GetProcAddress(aDLLHandle, 'igBeginPopupEx');
  igBeginPopupModal := GetProcAddress(aDLLHandle, 'igBeginPopupModal');
  igBeginTabBar := GetProcAddress(aDLLHandle, 'igBeginTabBar');
  igBeginTabBarEx := GetProcAddress(aDLLHandle, 'igBeginTabBarEx');
  igBeginTabItem := GetProcAddress(aDLLHandle, 'igBeginTabItem');
  igBeginTable := GetProcAddress(aDLLHandle, 'igBeginTable');
  igBeginTableEx := GetProcAddress(aDLLHandle, 'igBeginTableEx');
  igBeginTooltip := GetProcAddress(aDLLHandle, 'igBeginTooltip');
  igBeginTooltipEx := GetProcAddress(aDLLHandle, 'igBeginTooltipEx');
  igBeginTooltipHidden := GetProcAddress(aDLLHandle, 'igBeginTooltipHidden');
  igBeginViewportSideBar := GetProcAddress(aDLLHandle, 'igBeginViewportSideBar');
  igBringWindowToDisplayBack := GetProcAddress(aDLLHandle, 'igBringWindowToDisplayBack');
  igBringWindowToDisplayBehind := GetProcAddress(aDLLHandle, 'igBringWindowToDisplayBehind');
  igBringWindowToDisplayFront := GetProcAddress(aDLLHandle, 'igBringWindowToDisplayFront');
  igBringWindowToFocusFront := GetProcAddress(aDLLHandle, 'igBringWindowToFocusFront');
  igBullet := GetProcAddress(aDLLHandle, 'igBullet');
  igBulletText := GetProcAddress(aDLLHandle, 'igBulletText');
  igBulletTextV := GetProcAddress(aDLLHandle, 'igBulletTextV');
  igButton := GetProcAddress(aDLLHandle, 'igButton');
  igButtonBehavior := GetProcAddress(aDLLHandle, 'igButtonBehavior');
  igButtonEx := GetProcAddress(aDLLHandle, 'igButtonEx');
  igCalcItemSize := GetProcAddress(aDLLHandle, 'igCalcItemSize');
  igCalcItemWidth := GetProcAddress(aDLLHandle, 'igCalcItemWidth');
  igCalcRoundingFlagsForRectInRect := GetProcAddress(aDLLHandle, 'igCalcRoundingFlagsForRectInRect');
  igCalcTextSize := GetProcAddress(aDLLHandle, 'igCalcTextSize');
  igCalcTypematicRepeatAmount := GetProcAddress(aDLLHandle, 'igCalcTypematicRepeatAmount');
  igCalcWindowNextAutoFitSize := GetProcAddress(aDLLHandle, 'igCalcWindowNextAutoFitSize');
  igCalcWrapWidthForPos := GetProcAddress(aDLLHandle, 'igCalcWrapWidthForPos');
  igCallContextHooks := GetProcAddress(aDLLHandle, 'igCallContextHooks');
  igCheckbox := GetProcAddress(aDLLHandle, 'igCheckbox');
  igCheckboxFlags_IntPtr := GetProcAddress(aDLLHandle, 'igCheckboxFlags_IntPtr');
  igCheckboxFlags_S64Ptr := GetProcAddress(aDLLHandle, 'igCheckboxFlags_S64Ptr');
  igCheckboxFlags_U64Ptr := GetProcAddress(aDLLHandle, 'igCheckboxFlags_U64Ptr');
  igCheckboxFlags_UintPtr := GetProcAddress(aDLLHandle, 'igCheckboxFlags_UintPtr');
  igClearActiveID := GetProcAddress(aDLLHandle, 'igClearActiveID');
  igClearDragDrop := GetProcAddress(aDLLHandle, 'igClearDragDrop');
  igClearIniSettings := GetProcAddress(aDLLHandle, 'igClearIniSettings');
  igClearWindowSettings := GetProcAddress(aDLLHandle, 'igClearWindowSettings');
  igCloseButton := GetProcAddress(aDLLHandle, 'igCloseButton');
  igCloseCurrentPopup := GetProcAddress(aDLLHandle, 'igCloseCurrentPopup');
  igClosePopupsExceptModals := GetProcAddress(aDLLHandle, 'igClosePopupsExceptModals');
  igClosePopupsOverWindow := GetProcAddress(aDLLHandle, 'igClosePopupsOverWindow');
  igClosePopupToLevel := GetProcAddress(aDLLHandle, 'igClosePopupToLevel');
  igCollapseButton := GetProcAddress(aDLLHandle, 'igCollapseButton');
  igCollapsingHeader_BoolPtr := GetProcAddress(aDLLHandle, 'igCollapsingHeader_BoolPtr');
  igCollapsingHeader_TreeNodeFlags := GetProcAddress(aDLLHandle, 'igCollapsingHeader_TreeNodeFlags');
  igColorButton := GetProcAddress(aDLLHandle, 'igColorButton');
  igColorConvertFloat4ToU32 := GetProcAddress(aDLLHandle, 'igColorConvertFloat4ToU32');
  igColorConvertHSVtoRGB := GetProcAddress(aDLLHandle, 'igColorConvertHSVtoRGB');
  igColorConvertRGBtoHSV := GetProcAddress(aDLLHandle, 'igColorConvertRGBtoHSV');
  igColorConvertU32ToFloat4 := GetProcAddress(aDLLHandle, 'igColorConvertU32ToFloat4');
  igColorEdit3 := GetProcAddress(aDLLHandle, 'igColorEdit3');
  igColorEdit4 := GetProcAddress(aDLLHandle, 'igColorEdit4');
  igColorEditOptionsPopup := GetProcAddress(aDLLHandle, 'igColorEditOptionsPopup');
  igColorPicker3 := GetProcAddress(aDLLHandle, 'igColorPicker3');
  igColorPicker4 := GetProcAddress(aDLLHandle, 'igColorPicker4');
  igColorPickerOptionsPopup := GetProcAddress(aDLLHandle, 'igColorPickerOptionsPopup');
  igColorTooltip := GetProcAddress(aDLLHandle, 'igColorTooltip');
  igColumns := GetProcAddress(aDLLHandle, 'igColumns');
  igCombo_FnStrPtr := GetProcAddress(aDLLHandle, 'igCombo_FnStrPtr');
  igCombo_Str := GetProcAddress(aDLLHandle, 'igCombo_Str');
  igCombo_Str_arr := GetProcAddress(aDLLHandle, 'igCombo_Str_arr');
  igConvertSingleModFlagToKey := GetProcAddress(aDLLHandle, 'igConvertSingleModFlagToKey');
  igCreateContext := GetProcAddress(aDLLHandle, 'igCreateContext');
  igCreateNewWindowSettings := GetProcAddress(aDLLHandle, 'igCreateNewWindowSettings');
  igDataTypeApplyFromText := GetProcAddress(aDLLHandle, 'igDataTypeApplyFromText');
  igDataTypeApplyOp := GetProcAddress(aDLLHandle, 'igDataTypeApplyOp');
  igDataTypeClamp := GetProcAddress(aDLLHandle, 'igDataTypeClamp');
  igDataTypeCompare := GetProcAddress(aDLLHandle, 'igDataTypeCompare');
  igDataTypeFormatString := GetProcAddress(aDLLHandle, 'igDataTypeFormatString');
  igDataTypeGetInfo := GetProcAddress(aDLLHandle, 'igDataTypeGetInfo');
  igDataTypeIsZero := GetProcAddress(aDLLHandle, 'igDataTypeIsZero');
  igDebugAllocHook := GetProcAddress(aDLLHandle, 'igDebugAllocHook');
  igDebugBreakButton := GetProcAddress(aDLLHandle, 'igDebugBreakButton');
  igDebugBreakButtonTooltip := GetProcAddress(aDLLHandle, 'igDebugBreakButtonTooltip');
  igDebugBreakClearData := GetProcAddress(aDLLHandle, 'igDebugBreakClearData');
  igDebugCheckVersionAndDataLayout := GetProcAddress(aDLLHandle, 'igDebugCheckVersionAndDataLayout');
  igDebugDrawCursorPos := GetProcAddress(aDLLHandle, 'igDebugDrawCursorPos');
  igDebugDrawItemRect := GetProcAddress(aDLLHandle, 'igDebugDrawItemRect');
  igDebugDrawLineExtents := GetProcAddress(aDLLHandle, 'igDebugDrawLineExtents');
  igDebugFlashStyleColor := GetProcAddress(aDLLHandle, 'igDebugFlashStyleColor');
  igDebugHookIdInfo := GetProcAddress(aDLLHandle, 'igDebugHookIdInfo');
  igDebugLocateItem := GetProcAddress(aDLLHandle, 'igDebugLocateItem');
  igDebugLocateItemOnHover := GetProcAddress(aDLLHandle, 'igDebugLocateItemOnHover');
  igDebugLocateItemResolveWithLastItem := GetProcAddress(aDLLHandle, 'igDebugLocateItemResolveWithLastItem');
  igDebugLog := GetProcAddress(aDLLHandle, 'igDebugLog');
  igDebugLogV := GetProcAddress(aDLLHandle, 'igDebugLogV');
  igDebugNodeColumns := GetProcAddress(aDLLHandle, 'igDebugNodeColumns');
  igDebugNodeDockNode := GetProcAddress(aDLLHandle, 'igDebugNodeDockNode');
  igDebugNodeDrawCmdShowMeshAndBoundingBox := GetProcAddress(aDLLHandle, 'igDebugNodeDrawCmdShowMeshAndBoundingBox');
  igDebugNodeDrawList := GetProcAddress(aDLLHandle, 'igDebugNodeDrawList');
  igDebugNodeFont := GetProcAddress(aDLLHandle, 'igDebugNodeFont');
  igDebugNodeFontGlyph := GetProcAddress(aDLLHandle, 'igDebugNodeFontGlyph');
  igDebugNodeInputTextState := GetProcAddress(aDLLHandle, 'igDebugNodeInputTextState');
  igDebugNodeMultiSelectState := GetProcAddress(aDLLHandle, 'igDebugNodeMultiSelectState');
  igDebugNodePlatformMonitor := GetProcAddress(aDLLHandle, 'igDebugNodePlatformMonitor');
  igDebugNodeStorage := GetProcAddress(aDLLHandle, 'igDebugNodeStorage');
  igDebugNodeTabBar := GetProcAddress(aDLLHandle, 'igDebugNodeTabBar');
  igDebugNodeTable := GetProcAddress(aDLLHandle, 'igDebugNodeTable');
  igDebugNodeTableSettings := GetProcAddress(aDLLHandle, 'igDebugNodeTableSettings');
  igDebugNodeTypingSelectState := GetProcAddress(aDLLHandle, 'igDebugNodeTypingSelectState');
  igDebugNodeViewport := GetProcAddress(aDLLHandle, 'igDebugNodeViewport');
  igDebugNodeWindow := GetProcAddress(aDLLHandle, 'igDebugNodeWindow');
  igDebugNodeWindowSettings := GetProcAddress(aDLLHandle, 'igDebugNodeWindowSettings');
  igDebugNodeWindowsList := GetProcAddress(aDLLHandle, 'igDebugNodeWindowsList');
  igDebugNodeWindowsListByBeginStackParent := GetProcAddress(aDLLHandle, 'igDebugNodeWindowsListByBeginStackParent');
  igDebugRenderKeyboardPreview := GetProcAddress(aDLLHandle, 'igDebugRenderKeyboardPreview');
  igDebugRenderViewportThumbnail := GetProcAddress(aDLLHandle, 'igDebugRenderViewportThumbnail');
  igDebugStartItemPicker := GetProcAddress(aDLLHandle, 'igDebugStartItemPicker');
  igDebugTextEncoding := GetProcAddress(aDLLHandle, 'igDebugTextEncoding');
  igDebugTextUnformattedWithLocateItem := GetProcAddress(aDLLHandle, 'igDebugTextUnformattedWithLocateItem');
  igDestroyContext := GetProcAddress(aDLLHandle, 'igDestroyContext');
  igDestroyPlatformWindow := GetProcAddress(aDLLHandle, 'igDestroyPlatformWindow');
  igDestroyPlatformWindows := GetProcAddress(aDLLHandle, 'igDestroyPlatformWindows');
  igDockBuilderAddNode := GetProcAddress(aDLLHandle, 'igDockBuilderAddNode');
  igDockBuilderCopyDockSpace := GetProcAddress(aDLLHandle, 'igDockBuilderCopyDockSpace');
  igDockBuilderCopyNode := GetProcAddress(aDLLHandle, 'igDockBuilderCopyNode');
  igDockBuilderCopyWindowSettings := GetProcAddress(aDLLHandle, 'igDockBuilderCopyWindowSettings');
  igDockBuilderDockWindow := GetProcAddress(aDLLHandle, 'igDockBuilderDockWindow');
  igDockBuilderFinish := GetProcAddress(aDLLHandle, 'igDockBuilderFinish');
  igDockBuilderGetCentralNode := GetProcAddress(aDLLHandle, 'igDockBuilderGetCentralNode');
  igDockBuilderGetNode := GetProcAddress(aDLLHandle, 'igDockBuilderGetNode');
  igDockBuilderRemoveNode := GetProcAddress(aDLLHandle, 'igDockBuilderRemoveNode');
  igDockBuilderRemoveNodeChildNodes := GetProcAddress(aDLLHandle, 'igDockBuilderRemoveNodeChildNodes');
  igDockBuilderRemoveNodeDockedWindows := GetProcAddress(aDLLHandle, 'igDockBuilderRemoveNodeDockedWindows');
  igDockBuilderSetNodePos := GetProcAddress(aDLLHandle, 'igDockBuilderSetNodePos');
  igDockBuilderSetNodeSize := GetProcAddress(aDLLHandle, 'igDockBuilderSetNodeSize');
  igDockBuilderSplitNode := GetProcAddress(aDLLHandle, 'igDockBuilderSplitNode');
  igDockContextCalcDropPosForDocking := GetProcAddress(aDLLHandle, 'igDockContextCalcDropPosForDocking');
  igDockContextClearNodes := GetProcAddress(aDLLHandle, 'igDockContextClearNodes');
  igDockContextEndFrame := GetProcAddress(aDLLHandle, 'igDockContextEndFrame');
  igDockContextFindNodeByID := GetProcAddress(aDLLHandle, 'igDockContextFindNodeByID');
  igDockContextGenNodeID := GetProcAddress(aDLLHandle, 'igDockContextGenNodeID');
  igDockContextInitialize := GetProcAddress(aDLLHandle, 'igDockContextInitialize');
  igDockContextNewFrameUpdateDocking := GetProcAddress(aDLLHandle, 'igDockContextNewFrameUpdateDocking');
  igDockContextNewFrameUpdateUndocking := GetProcAddress(aDLLHandle, 'igDockContextNewFrameUpdateUndocking');
  igDockContextProcessUndockNode := GetProcAddress(aDLLHandle, 'igDockContextProcessUndockNode');
  igDockContextProcessUndockWindow := GetProcAddress(aDLLHandle, 'igDockContextProcessUndockWindow');
  igDockContextQueueDock := GetProcAddress(aDLLHandle, 'igDockContextQueueDock');
  igDockContextQueueUndockNode := GetProcAddress(aDLLHandle, 'igDockContextQueueUndockNode');
  igDockContextQueueUndockWindow := GetProcAddress(aDLLHandle, 'igDockContextQueueUndockWindow');
  igDockContextRebuildNodes := GetProcAddress(aDLLHandle, 'igDockContextRebuildNodes');
  igDockContextShutdown := GetProcAddress(aDLLHandle, 'igDockContextShutdown');
  igDockNodeBeginAmendTabBar := GetProcAddress(aDLLHandle, 'igDockNodeBeginAmendTabBar');
  igDockNodeEndAmendTabBar := GetProcAddress(aDLLHandle, 'igDockNodeEndAmendTabBar');
  igDockNodeGetDepth := GetProcAddress(aDLLHandle, 'igDockNodeGetDepth');
  igDockNodeGetRootNode := GetProcAddress(aDLLHandle, 'igDockNodeGetRootNode');
  igDockNodeGetWindowMenuButtonId := GetProcAddress(aDLLHandle, 'igDockNodeGetWindowMenuButtonId');
  igDockNodeIsInHierarchyOf := GetProcAddress(aDLLHandle, 'igDockNodeIsInHierarchyOf');
  igDockNodeWindowMenuHandler_Default := GetProcAddress(aDLLHandle, 'igDockNodeWindowMenuHandler_Default');
  igDockSpace := GetProcAddress(aDLLHandle, 'igDockSpace');
  igDockSpaceOverViewport := GetProcAddress(aDLLHandle, 'igDockSpaceOverViewport');
  igDragBehavior := GetProcAddress(aDLLHandle, 'igDragBehavior');
  igDragFloat := GetProcAddress(aDLLHandle, 'igDragFloat');
  igDragFloat2 := GetProcAddress(aDLLHandle, 'igDragFloat2');
  igDragFloat3 := GetProcAddress(aDLLHandle, 'igDragFloat3');
  igDragFloat4 := GetProcAddress(aDLLHandle, 'igDragFloat4');
  igDragFloatRange2 := GetProcAddress(aDLLHandle, 'igDragFloatRange2');
  igDragInt := GetProcAddress(aDLLHandle, 'igDragInt');
  igDragInt2 := GetProcAddress(aDLLHandle, 'igDragInt2');
  igDragInt3 := GetProcAddress(aDLLHandle, 'igDragInt3');
  igDragInt4 := GetProcAddress(aDLLHandle, 'igDragInt4');
  igDragIntRange2 := GetProcAddress(aDLLHandle, 'igDragIntRange2');
  igDragScalar := GetProcAddress(aDLLHandle, 'igDragScalar');
  igDragScalarN := GetProcAddress(aDLLHandle, 'igDragScalarN');
  igDummy := GetProcAddress(aDLLHandle, 'igDummy');
  igEnd := GetProcAddress(aDLLHandle, 'igEnd');
  igEndBoxSelect := GetProcAddress(aDLLHandle, 'igEndBoxSelect');
  igEndChild := GetProcAddress(aDLLHandle, 'igEndChild');
  igEndColumns := GetProcAddress(aDLLHandle, 'igEndColumns');
  igEndCombo := GetProcAddress(aDLLHandle, 'igEndCombo');
  igEndComboPreview := GetProcAddress(aDLLHandle, 'igEndComboPreview');
  igEndDisabled := GetProcAddress(aDLLHandle, 'igEndDisabled');
  igEndDisabledOverrideReenable := GetProcAddress(aDLLHandle, 'igEndDisabledOverrideReenable');
  igEndDragDropSource := GetProcAddress(aDLLHandle, 'igEndDragDropSource');
  igEndDragDropTarget := GetProcAddress(aDLLHandle, 'igEndDragDropTarget');
  igEndErrorTooltip := GetProcAddress(aDLLHandle, 'igEndErrorTooltip');
  igEndFrame := GetProcAddress(aDLLHandle, 'igEndFrame');
  igEndGroup := GetProcAddress(aDLLHandle, 'igEndGroup');
  igEndListBox := GetProcAddress(aDLLHandle, 'igEndListBox');
  igEndMainMenuBar := GetProcAddress(aDLLHandle, 'igEndMainMenuBar');
  igEndMenu := GetProcAddress(aDLLHandle, 'igEndMenu');
  igEndMenuBar := GetProcAddress(aDLLHandle, 'igEndMenuBar');
  igEndMultiSelect := GetProcAddress(aDLLHandle, 'igEndMultiSelect');
  igEndPopup := GetProcAddress(aDLLHandle, 'igEndPopup');
  igEndTabBar := GetProcAddress(aDLLHandle, 'igEndTabBar');
  igEndTabItem := GetProcAddress(aDLLHandle, 'igEndTabItem');
  igEndTable := GetProcAddress(aDLLHandle, 'igEndTable');
  igEndTooltip := GetProcAddress(aDLLHandle, 'igEndTooltip');
  igErrorCheckEndFrameFinalizeErrorTooltip := GetProcAddress(aDLLHandle, 'igErrorCheckEndFrameFinalizeErrorTooltip');
  igErrorCheckUsingSetCursorPosToExtendParentBoundaries := GetProcAddress(aDLLHandle, 'igErrorCheckUsingSetCursorPosToExtendParentBoundaries');
  igErrorLog := GetProcAddress(aDLLHandle, 'igErrorLog');
  igErrorRecoveryStoreState := GetProcAddress(aDLLHandle, 'igErrorRecoveryStoreState');
  igErrorRecoveryTryToRecoverState := GetProcAddress(aDLLHandle, 'igErrorRecoveryTryToRecoverState');
  igErrorRecoveryTryToRecoverWindowState := GetProcAddress(aDLLHandle, 'igErrorRecoveryTryToRecoverWindowState');
  igFindBestWindowPosForPopup := GetProcAddress(aDLLHandle, 'igFindBestWindowPosForPopup');
  igFindBestWindowPosForPopupEx := GetProcAddress(aDLLHandle, 'igFindBestWindowPosForPopupEx');
  igFindBlockingModal := GetProcAddress(aDLLHandle, 'igFindBlockingModal');
  igFindBottomMostVisibleWindowWithinBeginStack := GetProcAddress(aDLLHandle, 'igFindBottomMostVisibleWindowWithinBeginStack');
  igFindHoveredViewportFromPlatformWindowStack := GetProcAddress(aDLLHandle, 'igFindHoveredViewportFromPlatformWindowStack');
  igFindHoveredWindowEx := GetProcAddress(aDLLHandle, 'igFindHoveredWindowEx');
  igFindOrCreateColumns := GetProcAddress(aDLLHandle, 'igFindOrCreateColumns');
  igFindRenderedTextEnd := GetProcAddress(aDLLHandle, 'igFindRenderedTextEnd');
  igFindSettingsHandler := GetProcAddress(aDLLHandle, 'igFindSettingsHandler');
  igFindViewportByID := GetProcAddress(aDLLHandle, 'igFindViewportByID');
  igFindViewportByPlatformHandle := GetProcAddress(aDLLHandle, 'igFindViewportByPlatformHandle');
  igFindWindowByID := GetProcAddress(aDLLHandle, 'igFindWindowByID');
  igFindWindowByName := GetProcAddress(aDLLHandle, 'igFindWindowByName');
  igFindWindowDisplayIndex := GetProcAddress(aDLLHandle, 'igFindWindowDisplayIndex');
  igFindWindowSettingsByID := GetProcAddress(aDLLHandle, 'igFindWindowSettingsByID');
  igFindWindowSettingsByWindow := GetProcAddress(aDLLHandle, 'igFindWindowSettingsByWindow');
  igFixupKeyChord := GetProcAddress(aDLLHandle, 'igFixupKeyChord');
  igFocusItem := GetProcAddress(aDLLHandle, 'igFocusItem');
  igFocusTopMostWindowUnderOne := GetProcAddress(aDLLHandle, 'igFocusTopMostWindowUnderOne');
  igFocusWindow := GetProcAddress(aDLLHandle, 'igFocusWindow');
  igGcAwakeTransientWindowBuffers := GetProcAddress(aDLLHandle, 'igGcAwakeTransientWindowBuffers');
  igGcCompactTransientMiscBuffers := GetProcAddress(aDLLHandle, 'igGcCompactTransientMiscBuffers');
  igGcCompactTransientWindowBuffers := GetProcAddress(aDLLHandle, 'igGcCompactTransientWindowBuffers');
  igGET_FLT_MAX := GetProcAddress(aDLLHandle, 'igGET_FLT_MAX');
  igGET_FLT_MIN := GetProcAddress(aDLLHandle, 'igGET_FLT_MIN');
  igGetActiveID := GetProcAddress(aDLLHandle, 'igGetActiveID');
  igGetAllocatorFunctions := GetProcAddress(aDLLHandle, 'igGetAllocatorFunctions');
  igGetBackgroundDrawList := GetProcAddress(aDLLHandle, 'igGetBackgroundDrawList');
  igGetBoxSelectState := GetProcAddress(aDLLHandle, 'igGetBoxSelectState');
  igGetClipboardText := GetProcAddress(aDLLHandle, 'igGetClipboardText');
  igGetColorU32_Col := GetProcAddress(aDLLHandle, 'igGetColorU32_Col');
  igGetColorU32_U32 := GetProcAddress(aDLLHandle, 'igGetColorU32_U32');
  igGetColorU32_Vec4 := GetProcAddress(aDLLHandle, 'igGetColorU32_Vec4');
  igGetColumnIndex := GetProcAddress(aDLLHandle, 'igGetColumnIndex');
  igGetColumnNormFromOffset := GetProcAddress(aDLLHandle, 'igGetColumnNormFromOffset');
  igGetColumnOffset := GetProcAddress(aDLLHandle, 'igGetColumnOffset');
  igGetColumnOffsetFromNorm := GetProcAddress(aDLLHandle, 'igGetColumnOffsetFromNorm');
  igGetColumnsCount := GetProcAddress(aDLLHandle, 'igGetColumnsCount');
  igGetColumnsID := GetProcAddress(aDLLHandle, 'igGetColumnsID');
  igGetColumnWidth := GetProcAddress(aDLLHandle, 'igGetColumnWidth');
  igGetContentRegionAvail := GetProcAddress(aDLLHandle, 'igGetContentRegionAvail');
  igGetCurrentContext := GetProcAddress(aDLLHandle, 'igGetCurrentContext');
  igGetCurrentFocusScope := GetProcAddress(aDLLHandle, 'igGetCurrentFocusScope');
  igGetCurrentTabBar := GetProcAddress(aDLLHandle, 'igGetCurrentTabBar');
  igGetCurrentTable := GetProcAddress(aDLLHandle, 'igGetCurrentTable');
  igGetCurrentWindow := GetProcAddress(aDLLHandle, 'igGetCurrentWindow');
  igGetCurrentWindowRead := GetProcAddress(aDLLHandle, 'igGetCurrentWindowRead');
  igGetCursorPos := GetProcAddress(aDLLHandle, 'igGetCursorPos');
  igGetCursorPosX := GetProcAddress(aDLLHandle, 'igGetCursorPosX');
  igGetCursorPosY := GetProcAddress(aDLLHandle, 'igGetCursorPosY');
  igGetCursorScreenPos := GetProcAddress(aDLLHandle, 'igGetCursorScreenPos');
  igGetCursorStartPos := GetProcAddress(aDLLHandle, 'igGetCursorStartPos');
  igGetDefaultFont := GetProcAddress(aDLLHandle, 'igGetDefaultFont');
  igGetDragDropPayload := GetProcAddress(aDLLHandle, 'igGetDragDropPayload');
  igGetDrawData := GetProcAddress(aDLLHandle, 'igGetDrawData');
  igGetDrawListSharedData := GetProcAddress(aDLLHandle, 'igGetDrawListSharedData');
  igGetFocusID := GetProcAddress(aDLLHandle, 'igGetFocusID');
  igGetFont := GetProcAddress(aDLLHandle, 'igGetFont');
  igGetFontSize := GetProcAddress(aDLLHandle, 'igGetFontSize');
  igGetFontTexUvWhitePixel := GetProcAddress(aDLLHandle, 'igGetFontTexUvWhitePixel');
  igGetForegroundDrawList_ViewportPtr := GetProcAddress(aDLLHandle, 'igGetForegroundDrawList_ViewportPtr');
  igGetForegroundDrawList_WindowPtr := GetProcAddress(aDLLHandle, 'igGetForegroundDrawList_WindowPtr');
  igGetFrameCount := GetProcAddress(aDLLHandle, 'igGetFrameCount');
  igGetFrameHeight := GetProcAddress(aDLLHandle, 'igGetFrameHeight');
  igGetFrameHeightWithSpacing := GetProcAddress(aDLLHandle, 'igGetFrameHeightWithSpacing');
  igGetHoveredID := GetProcAddress(aDLLHandle, 'igGetHoveredID');
  igGetID_Int := GetProcAddress(aDLLHandle, 'igGetID_Int');
  igGetID_Ptr := GetProcAddress(aDLLHandle, 'igGetID_Ptr');
  igGetID_Str := GetProcAddress(aDLLHandle, 'igGetID_Str');
  igGetID_StrStr := GetProcAddress(aDLLHandle, 'igGetID_StrStr');
  igGetIDWithSeed_Int := GetProcAddress(aDLLHandle, 'igGetIDWithSeed_Int');
  igGetIDWithSeed_Str := GetProcAddress(aDLLHandle, 'igGetIDWithSeed_Str');
  igGetInputTextState := GetProcAddress(aDLLHandle, 'igGetInputTextState');
  igGetIO := GetProcAddress(aDLLHandle, 'igGetIO');
  igGetIOEx := GetProcAddress(aDLLHandle, 'igGetIOEx');
  igGetItemFlags := GetProcAddress(aDLLHandle, 'igGetItemFlags');
  igGetItemID := GetProcAddress(aDLLHandle, 'igGetItemID');
  igGetItemRectMax := GetProcAddress(aDLLHandle, 'igGetItemRectMax');
  igGetItemRectMin := GetProcAddress(aDLLHandle, 'igGetItemRectMin');
  igGetItemRectSize := GetProcAddress(aDLLHandle, 'igGetItemRectSize');
  igGetItemStatusFlags := GetProcAddress(aDLLHandle, 'igGetItemStatusFlags');
  igGetKeyChordName := GetProcAddress(aDLLHandle, 'igGetKeyChordName');
  igGetKeyData_ContextPtr := GetProcAddress(aDLLHandle, 'igGetKeyData_ContextPtr');
  igGetKeyData_Key := GetProcAddress(aDLLHandle, 'igGetKeyData_Key');
  igGetKeyMagnitude2d := GetProcAddress(aDLLHandle, 'igGetKeyMagnitude2d');
  igGetKeyName := GetProcAddress(aDLLHandle, 'igGetKeyName');
  igGetKeyOwner := GetProcAddress(aDLLHandle, 'igGetKeyOwner');
  igGetKeyOwnerData := GetProcAddress(aDLLHandle, 'igGetKeyOwnerData');
  igGetKeyPressedAmount := GetProcAddress(aDLLHandle, 'igGetKeyPressedAmount');
  igGetMainViewport := GetProcAddress(aDLLHandle, 'igGetMainViewport');
  igGetMouseClickedCount := GetProcAddress(aDLLHandle, 'igGetMouseClickedCount');
  igGetMouseCursor := GetProcAddress(aDLLHandle, 'igGetMouseCursor');
  igGetMouseDragDelta := GetProcAddress(aDLLHandle, 'igGetMouseDragDelta');
  igGetMousePos := GetProcAddress(aDLLHandle, 'igGetMousePos');
  igGetMousePosOnOpeningCurrentPopup := GetProcAddress(aDLLHandle, 'igGetMousePosOnOpeningCurrentPopup');
  igGetMultiSelectState := GetProcAddress(aDLLHandle, 'igGetMultiSelectState');
  igGetNavTweakPressedAmount := GetProcAddress(aDLLHandle, 'igGetNavTweakPressedAmount');
  igGetPlatformIO := GetProcAddress(aDLLHandle, 'igGetPlatformIO');
  igGetPlatformIOEx := GetProcAddress(aDLLHandle, 'igGetPlatformIOEx');
  igGetPopupAllowedExtentRect := GetProcAddress(aDLLHandle, 'igGetPopupAllowedExtentRect');
  igGetScrollMaxX := GetProcAddress(aDLLHandle, 'igGetScrollMaxX');
  igGetScrollMaxY := GetProcAddress(aDLLHandle, 'igGetScrollMaxY');
  igGetScrollX := GetProcAddress(aDLLHandle, 'igGetScrollX');
  igGetScrollY := GetProcAddress(aDLLHandle, 'igGetScrollY');
  igGetShortcutRoutingData := GetProcAddress(aDLLHandle, 'igGetShortcutRoutingData');
  igGetStateStorage := GetProcAddress(aDLLHandle, 'igGetStateStorage');
  igGetStyle := GetProcAddress(aDLLHandle, 'igGetStyle');
  igGetStyleColorName := GetProcAddress(aDLLHandle, 'igGetStyleColorName');
  igGetStyleColorVec4 := GetProcAddress(aDLLHandle, 'igGetStyleColorVec4');
  igGetStyleVarInfo := GetProcAddress(aDLLHandle, 'igGetStyleVarInfo');
  igGetTextLineHeight := GetProcAddress(aDLLHandle, 'igGetTextLineHeight');
  igGetTextLineHeightWithSpacing := GetProcAddress(aDLLHandle, 'igGetTextLineHeightWithSpacing');
  igGetTime := GetProcAddress(aDLLHandle, 'igGetTime');
  igGetTopMostAndVisiblePopupModal := GetProcAddress(aDLLHandle, 'igGetTopMostAndVisiblePopupModal');
  igGetTopMostPopupModal := GetProcAddress(aDLLHandle, 'igGetTopMostPopupModal');
  igGetTreeNodeToLabelSpacing := GetProcAddress(aDLLHandle, 'igGetTreeNodeToLabelSpacing');
  igGetTypematicRepeatRate := GetProcAddress(aDLLHandle, 'igGetTypematicRepeatRate');
  igGetTypingSelectRequest := GetProcAddress(aDLLHandle, 'igGetTypingSelectRequest');
  igGetVersion := GetProcAddress(aDLLHandle, 'igGetVersion');
  igGetViewportPlatformMonitor := GetProcAddress(aDLLHandle, 'igGetViewportPlatformMonitor');
  igGetWindowAlwaysWantOwnTabBar := GetProcAddress(aDLLHandle, 'igGetWindowAlwaysWantOwnTabBar');
  igGetWindowDockID := GetProcAddress(aDLLHandle, 'igGetWindowDockID');
  igGetWindowDockNode := GetProcAddress(aDLLHandle, 'igGetWindowDockNode');
  igGetWindowDpiScale := GetProcAddress(aDLLHandle, 'igGetWindowDpiScale');
  igGetWindowDrawList := GetProcAddress(aDLLHandle, 'igGetWindowDrawList');
  igGetWindowHeight := GetProcAddress(aDLLHandle, 'igGetWindowHeight');
  igGetWindowPos := GetProcAddress(aDLLHandle, 'igGetWindowPos');
  igGetWindowResizeBorderID := GetProcAddress(aDLLHandle, 'igGetWindowResizeBorderID');
  igGetWindowResizeCornerID := GetProcAddress(aDLLHandle, 'igGetWindowResizeCornerID');
  igGetWindowScrollbarID := GetProcAddress(aDLLHandle, 'igGetWindowScrollbarID');
  igGetWindowScrollbarRect := GetProcAddress(aDLLHandle, 'igGetWindowScrollbarRect');
  igGetWindowSize := GetProcAddress(aDLLHandle, 'igGetWindowSize');
  igGetWindowViewport := GetProcAddress(aDLLHandle, 'igGetWindowViewport');
  igGetWindowWidth := GetProcAddress(aDLLHandle, 'igGetWindowWidth');
  igImAbs_double := GetProcAddress(aDLLHandle, 'igImAbs_double');
  igImAbs_Float := GetProcAddress(aDLLHandle, 'igImAbs_Float');
  igImAbs_Int := GetProcAddress(aDLLHandle, 'igImAbs_Int');
  igImage := GetProcAddress(aDLLHandle, 'igImage');
  igImageButton := GetProcAddress(aDLLHandle, 'igImageButton');
  igImageButtonEx := GetProcAddress(aDLLHandle, 'igImageButtonEx');
  igImAlphaBlendColors := GetProcAddress(aDLLHandle, 'igImAlphaBlendColors');
  igImBezierCubicCalc := GetProcAddress(aDLLHandle, 'igImBezierCubicCalc');
  igImBezierCubicClosestPoint := GetProcAddress(aDLLHandle, 'igImBezierCubicClosestPoint');
  igImBezierCubicClosestPointCasteljau := GetProcAddress(aDLLHandle, 'igImBezierCubicClosestPointCasteljau');
  igImBezierQuadraticCalc := GetProcAddress(aDLLHandle, 'igImBezierQuadraticCalc');
  igImBitArrayClearAllBits := GetProcAddress(aDLLHandle, 'igImBitArrayClearAllBits');
  igImBitArrayClearBit := GetProcAddress(aDLLHandle, 'igImBitArrayClearBit');
  igImBitArrayGetStorageSizeInBytes := GetProcAddress(aDLLHandle, 'igImBitArrayGetStorageSizeInBytes');
  igImBitArraySetBit := GetProcAddress(aDLLHandle, 'igImBitArraySetBit');
  igImBitArraySetBitRange := GetProcAddress(aDLLHandle, 'igImBitArraySetBitRange');
  igImBitArrayTestBit := GetProcAddress(aDLLHandle, 'igImBitArrayTestBit');
  igImCharIsBlankA := GetProcAddress(aDLLHandle, 'igImCharIsBlankA');
  igImCharIsBlankW := GetProcAddress(aDLLHandle, 'igImCharIsBlankW');
  igImCharIsXdigitA := GetProcAddress(aDLLHandle, 'igImCharIsXdigitA');
  igImClamp := GetProcAddress(aDLLHandle, 'igImClamp');
  igImDot := GetProcAddress(aDLLHandle, 'igImDot');
  igImExponentialMovingAverage := GetProcAddress(aDLLHandle, 'igImExponentialMovingAverage');
  igImFileClose := GetProcAddress(aDLLHandle, 'igImFileClose');
  igImFileGetSize := GetProcAddress(aDLLHandle, 'igImFileGetSize');
  igImFileLoadToMemory := GetProcAddress(aDLLHandle, 'igImFileLoadToMemory');
  igImFileOpen := GetProcAddress(aDLLHandle, 'igImFileOpen');
  igImFileRead := GetProcAddress(aDLLHandle, 'igImFileRead');
  igImFileWrite := GetProcAddress(aDLLHandle, 'igImFileWrite');
  igImFloor_Float := GetProcAddress(aDLLHandle, 'igImFloor_Float');
  igImFloor_Vec2 := GetProcAddress(aDLLHandle, 'igImFloor_Vec2');
  igImFontAtlasBuildFinish := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildFinish');
  igImFontAtlasBuildGetOversampleFactors := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildGetOversampleFactors');
  igImFontAtlasBuildInit := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildInit');
  igImFontAtlasBuildMultiplyCalcLookupTable := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildMultiplyCalcLookupTable');
  igImFontAtlasBuildMultiplyRectAlpha8 := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildMultiplyRectAlpha8');
  igImFontAtlasBuildPackCustomRects := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildPackCustomRects');
  igImFontAtlasBuildRender32bppRectFromString := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildRender32bppRectFromString');
  igImFontAtlasBuildRender8bppRectFromString := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildRender8bppRectFromString');
  igImFontAtlasBuildSetupFont := GetProcAddress(aDLLHandle, 'igImFontAtlasBuildSetupFont');
  igImFontAtlasGetBuilderForStbTruetype := GetProcAddress(aDLLHandle, 'igImFontAtlasGetBuilderForStbTruetype');
  igImFontAtlasUpdateConfigDataPointers := GetProcAddress(aDLLHandle, 'igImFontAtlasUpdateConfigDataPointers');
  igImFormatString := GetProcAddress(aDLLHandle, 'igImFormatString');
  igImFormatStringToTempBuffer := GetProcAddress(aDLLHandle, 'igImFormatStringToTempBuffer');
  igImFormatStringToTempBufferV := GetProcAddress(aDLLHandle, 'igImFormatStringToTempBufferV');
  igImFormatStringV := GetProcAddress(aDLLHandle, 'igImFormatStringV');
  igImHashData := GetProcAddress(aDLLHandle, 'igImHashData');
  igImHashStr := GetProcAddress(aDLLHandle, 'igImHashStr');
  igImInvLength := GetProcAddress(aDLLHandle, 'igImInvLength');
  igImIsFloatAboveGuaranteedIntegerPrecision := GetProcAddress(aDLLHandle, 'igImIsFloatAboveGuaranteedIntegerPrecision');
  igImIsPowerOfTwo_Int := GetProcAddress(aDLLHandle, 'igImIsPowerOfTwo_Int');
  igImIsPowerOfTwo_U64 := GetProcAddress(aDLLHandle, 'igImIsPowerOfTwo_U64');
  igImLengthSqr_Vec2 := GetProcAddress(aDLLHandle, 'igImLengthSqr_Vec2');
  igImLengthSqr_Vec4 := GetProcAddress(aDLLHandle, 'igImLengthSqr_Vec4');
  igImLerp_Vec2Float := GetProcAddress(aDLLHandle, 'igImLerp_Vec2Float');
  igImLerp_Vec2Vec2 := GetProcAddress(aDLLHandle, 'igImLerp_Vec2Vec2');
  igImLerp_Vec4 := GetProcAddress(aDLLHandle, 'igImLerp_Vec4');
  igImLinearRemapClamp := GetProcAddress(aDLLHandle, 'igImLinearRemapClamp');
  igImLinearSweep := GetProcAddress(aDLLHandle, 'igImLinearSweep');
  igImLineClosestPoint := GetProcAddress(aDLLHandle, 'igImLineClosestPoint');
  igImLog_double := GetProcAddress(aDLLHandle, 'igImLog_double');
  igImLog_Float := GetProcAddress(aDLLHandle, 'igImLog_Float');
  igImLowerBound := GetProcAddress(aDLLHandle, 'igImLowerBound');
  igImMax := GetProcAddress(aDLLHandle, 'igImMax');
  igImMin := GetProcAddress(aDLLHandle, 'igImMin');
  igImModPositive := GetProcAddress(aDLLHandle, 'igImModPositive');
  igImMul := GetProcAddress(aDLLHandle, 'igImMul');
  igImParseFormatFindEnd := GetProcAddress(aDLLHandle, 'igImParseFormatFindEnd');
  igImParseFormatFindStart := GetProcAddress(aDLLHandle, 'igImParseFormatFindStart');
  igImParseFormatPrecision := GetProcAddress(aDLLHandle, 'igImParseFormatPrecision');
  igImParseFormatSanitizeForPrinting := GetProcAddress(aDLLHandle, 'igImParseFormatSanitizeForPrinting');
  igImParseFormatSanitizeForScanning := GetProcAddress(aDLLHandle, 'igImParseFormatSanitizeForScanning');
  igImParseFormatTrimDecorations := GetProcAddress(aDLLHandle, 'igImParseFormatTrimDecorations');
  igImPow_double := GetProcAddress(aDLLHandle, 'igImPow_double');
  igImPow_Float := GetProcAddress(aDLLHandle, 'igImPow_Float');
  igImQsort := GetProcAddress(aDLLHandle, 'igImQsort');
  igImRotate := GetProcAddress(aDLLHandle, 'igImRotate');
  igImRsqrt_double := GetProcAddress(aDLLHandle, 'igImRsqrt_double');
  igImRsqrt_Float := GetProcAddress(aDLLHandle, 'igImRsqrt_Float');
  igImSaturate := GetProcAddress(aDLLHandle, 'igImSaturate');
  igImSign_double := GetProcAddress(aDLLHandle, 'igImSign_double');
  igImSign_Float := GetProcAddress(aDLLHandle, 'igImSign_Float');
  igImStrbol := GetProcAddress(aDLLHandle, 'igImStrbol');
  igImStrchrRange := GetProcAddress(aDLLHandle, 'igImStrchrRange');
  igImStrdup := GetProcAddress(aDLLHandle, 'igImStrdup');
  igImStrdupcpy := GetProcAddress(aDLLHandle, 'igImStrdupcpy');
  igImStreolRange := GetProcAddress(aDLLHandle, 'igImStreolRange');
  igImStricmp := GetProcAddress(aDLLHandle, 'igImStricmp');
  igImStristr := GetProcAddress(aDLLHandle, 'igImStristr');
  igImStrlenW := GetProcAddress(aDLLHandle, 'igImStrlenW');
  igImStrncpy := GetProcAddress(aDLLHandle, 'igImStrncpy');
  igImStrnicmp := GetProcAddress(aDLLHandle, 'igImStrnicmp');
  igImStrSkipBlank := GetProcAddress(aDLLHandle, 'igImStrSkipBlank');
  igImStrTrimBlanks := GetProcAddress(aDLLHandle, 'igImStrTrimBlanks');
  igImTextCharFromUtf8 := GetProcAddress(aDLLHandle, 'igImTextCharFromUtf8');
  igImTextCharToUtf8 := GetProcAddress(aDLLHandle, 'igImTextCharToUtf8');
  igImTextCountCharsFromUtf8 := GetProcAddress(aDLLHandle, 'igImTextCountCharsFromUtf8');
  igImTextCountLines := GetProcAddress(aDLLHandle, 'igImTextCountLines');
  igImTextCountUtf8BytesFromChar := GetProcAddress(aDLLHandle, 'igImTextCountUtf8BytesFromChar');
  igImTextCountUtf8BytesFromStr := GetProcAddress(aDLLHandle, 'igImTextCountUtf8BytesFromStr');
  igImTextFindPreviousUtf8Codepoint := GetProcAddress(aDLLHandle, 'igImTextFindPreviousUtf8Codepoint');
  igImTextStrFromUtf8 := GetProcAddress(aDLLHandle, 'igImTextStrFromUtf8');
  igImTextStrToUtf8 := GetProcAddress(aDLLHandle, 'igImTextStrToUtf8');
  igImToUpper := GetProcAddress(aDLLHandle, 'igImToUpper');
  igImTriangleArea := GetProcAddress(aDLLHandle, 'igImTriangleArea');
  igImTriangleBarycentricCoords := GetProcAddress(aDLLHandle, 'igImTriangleBarycentricCoords');
  igImTriangleClosestPoint := GetProcAddress(aDLLHandle, 'igImTriangleClosestPoint');
  igImTriangleContainsPoint := GetProcAddress(aDLLHandle, 'igImTriangleContainsPoint');
  igImTriangleIsClockwise := GetProcAddress(aDLLHandle, 'igImTriangleIsClockwise');
  igImTrunc_Float := GetProcAddress(aDLLHandle, 'igImTrunc_Float');
  igImTrunc_Vec2 := GetProcAddress(aDLLHandle, 'igImTrunc_Vec2');
  igImUpperPowerOfTwo := GetProcAddress(aDLLHandle, 'igImUpperPowerOfTwo');
  igIndent := GetProcAddress(aDLLHandle, 'igIndent');
  igInitialize := GetProcAddress(aDLLHandle, 'igInitialize');
  igInputDouble := GetProcAddress(aDLLHandle, 'igInputDouble');
  igInputFloat := GetProcAddress(aDLLHandle, 'igInputFloat');
  igInputFloat2 := GetProcAddress(aDLLHandle, 'igInputFloat2');
  igInputFloat3 := GetProcAddress(aDLLHandle, 'igInputFloat3');
  igInputFloat4 := GetProcAddress(aDLLHandle, 'igInputFloat4');
  igInputInt := GetProcAddress(aDLLHandle, 'igInputInt');
  igInputInt2 := GetProcAddress(aDLLHandle, 'igInputInt2');
  igInputInt3 := GetProcAddress(aDLLHandle, 'igInputInt3');
  igInputInt4 := GetProcAddress(aDLLHandle, 'igInputInt4');
  igInputScalar := GetProcAddress(aDLLHandle, 'igInputScalar');
  igInputScalarN := GetProcAddress(aDLLHandle, 'igInputScalarN');
  igInputText := GetProcAddress(aDLLHandle, 'igInputText');
  igInputTextDeactivateHook := GetProcAddress(aDLLHandle, 'igInputTextDeactivateHook');
  igInputTextEx := GetProcAddress(aDLLHandle, 'igInputTextEx');
  igInputTextMultiline := GetProcAddress(aDLLHandle, 'igInputTextMultiline');
  igInputTextWithHint := GetProcAddress(aDLLHandle, 'igInputTextWithHint');
  igInvisibleButton := GetProcAddress(aDLLHandle, 'igInvisibleButton');
  igIsActiveIdUsingNavDir := GetProcAddress(aDLLHandle, 'igIsActiveIdUsingNavDir');
  igIsAliasKey := GetProcAddress(aDLLHandle, 'igIsAliasKey');
  igIsAnyItemActive := GetProcAddress(aDLLHandle, 'igIsAnyItemActive');
  igIsAnyItemFocused := GetProcAddress(aDLLHandle, 'igIsAnyItemFocused');
  igIsAnyItemHovered := GetProcAddress(aDLLHandle, 'igIsAnyItemHovered');
  igIsAnyMouseDown := GetProcAddress(aDLLHandle, 'igIsAnyMouseDown');
  igIsClippedEx := GetProcAddress(aDLLHandle, 'igIsClippedEx');
  igIsDragDropActive := GetProcAddress(aDLLHandle, 'igIsDragDropActive');
  igIsDragDropPayloadBeingAccepted := GetProcAddress(aDLLHandle, 'igIsDragDropPayloadBeingAccepted');
  igIsGamepadKey := GetProcAddress(aDLLHandle, 'igIsGamepadKey');
  igIsItemActivated := GetProcAddress(aDLLHandle, 'igIsItemActivated');
  igIsItemActive := GetProcAddress(aDLLHandle, 'igIsItemActive');
  igIsItemClicked := GetProcAddress(aDLLHandle, 'igIsItemClicked');
  igIsItemDeactivated := GetProcAddress(aDLLHandle, 'igIsItemDeactivated');
  igIsItemDeactivatedAfterEdit := GetProcAddress(aDLLHandle, 'igIsItemDeactivatedAfterEdit');
  igIsItemEdited := GetProcAddress(aDLLHandle, 'igIsItemEdited');
  igIsItemFocused := GetProcAddress(aDLLHandle, 'igIsItemFocused');
  igIsItemHovered := GetProcAddress(aDLLHandle, 'igIsItemHovered');
  igIsItemToggledOpen := GetProcAddress(aDLLHandle, 'igIsItemToggledOpen');
  igIsItemToggledSelection := GetProcAddress(aDLLHandle, 'igIsItemToggledSelection');
  igIsItemVisible := GetProcAddress(aDLLHandle, 'igIsItemVisible');
  igIsKeyboardKey := GetProcAddress(aDLLHandle, 'igIsKeyboardKey');
  igIsKeyChordPressed_InputFlags := GetProcAddress(aDLLHandle, 'igIsKeyChordPressed_InputFlags');
  igIsKeyChordPressed_Nil := GetProcAddress(aDLLHandle, 'igIsKeyChordPressed_Nil');
  igIsKeyDown_ID := GetProcAddress(aDLLHandle, 'igIsKeyDown_ID');
  igIsKeyDown_Nil := GetProcAddress(aDLLHandle, 'igIsKeyDown_Nil');
  igIsKeyPressed_Bool := GetProcAddress(aDLLHandle, 'igIsKeyPressed_Bool');
  igIsKeyPressed_InputFlags := GetProcAddress(aDLLHandle, 'igIsKeyPressed_InputFlags');
  igIsKeyReleased_ID := GetProcAddress(aDLLHandle, 'igIsKeyReleased_ID');
  igIsKeyReleased_Nil := GetProcAddress(aDLLHandle, 'igIsKeyReleased_Nil');
  igIsLegacyKey := GetProcAddress(aDLLHandle, 'igIsLegacyKey');
  igIsLRModKey := GetProcAddress(aDLLHandle, 'igIsLRModKey');
  igIsMouseClicked_Bool := GetProcAddress(aDLLHandle, 'igIsMouseClicked_Bool');
  igIsMouseClicked_InputFlags := GetProcAddress(aDLLHandle, 'igIsMouseClicked_InputFlags');
  igIsMouseDoubleClicked_ID := GetProcAddress(aDLLHandle, 'igIsMouseDoubleClicked_ID');
  igIsMouseDoubleClicked_Nil := GetProcAddress(aDLLHandle, 'igIsMouseDoubleClicked_Nil');
  igIsMouseDown_ID := GetProcAddress(aDLLHandle, 'igIsMouseDown_ID');
  igIsMouseDown_Nil := GetProcAddress(aDLLHandle, 'igIsMouseDown_Nil');
  igIsMouseDragging := GetProcAddress(aDLLHandle, 'igIsMouseDragging');
  igIsMouseDragPastThreshold := GetProcAddress(aDLLHandle, 'igIsMouseDragPastThreshold');
  igIsMouseHoveringRect := GetProcAddress(aDLLHandle, 'igIsMouseHoveringRect');
  igIsMouseKey := GetProcAddress(aDLLHandle, 'igIsMouseKey');
  igIsMousePosValid := GetProcAddress(aDLLHandle, 'igIsMousePosValid');
  igIsMouseReleased_ID := GetProcAddress(aDLLHandle, 'igIsMouseReleased_ID');
  igIsMouseReleased_Nil := GetProcAddress(aDLLHandle, 'igIsMouseReleased_Nil');
  igIsMouseReleasedWithDelay := GetProcAddress(aDLLHandle, 'igIsMouseReleasedWithDelay');
  igIsNamedKey := GetProcAddress(aDLLHandle, 'igIsNamedKey');
  igIsNamedKeyOrMod := GetProcAddress(aDLLHandle, 'igIsNamedKeyOrMod');
  igIsPopupOpen_ID := GetProcAddress(aDLLHandle, 'igIsPopupOpen_ID');
  igIsPopupOpen_Str := GetProcAddress(aDLLHandle, 'igIsPopupOpen_Str');
  igIsRectVisible_Nil := GetProcAddress(aDLLHandle, 'igIsRectVisible_Nil');
  igIsRectVisible_Vec2 := GetProcAddress(aDLLHandle, 'igIsRectVisible_Vec2');
  igIsWindowAbove := GetProcAddress(aDLLHandle, 'igIsWindowAbove');
  igIsWindowAppearing := GetProcAddress(aDLLHandle, 'igIsWindowAppearing');
  igIsWindowChildOf := GetProcAddress(aDLLHandle, 'igIsWindowChildOf');
  igIsWindowCollapsed := GetProcAddress(aDLLHandle, 'igIsWindowCollapsed');
  igIsWindowContentHoverable := GetProcAddress(aDLLHandle, 'igIsWindowContentHoverable');
  igIsWindowDocked := GetProcAddress(aDLLHandle, 'igIsWindowDocked');
  igIsWindowFocused := GetProcAddress(aDLLHandle, 'igIsWindowFocused');
  igIsWindowHovered := GetProcAddress(aDLLHandle, 'igIsWindowHovered');
  igIsWindowNavFocusable := GetProcAddress(aDLLHandle, 'igIsWindowNavFocusable');
  igIsWindowWithinBeginStackOf := GetProcAddress(aDLLHandle, 'igIsWindowWithinBeginStackOf');
  igItemAdd := GetProcAddress(aDLLHandle, 'igItemAdd');
  igItemHoverable := GetProcAddress(aDLLHandle, 'igItemHoverable');
  igItemSize_Rect := GetProcAddress(aDLLHandle, 'igItemSize_Rect');
  igItemSize_Vec2 := GetProcAddress(aDLLHandle, 'igItemSize_Vec2');
  igKeepAliveID := GetProcAddress(aDLLHandle, 'igKeepAliveID');
  igLabelText := GetProcAddress(aDLLHandle, 'igLabelText');
  igLabelTextV := GetProcAddress(aDLLHandle, 'igLabelTextV');
  igListBox_FnStrPtr := GetProcAddress(aDLLHandle, 'igListBox_FnStrPtr');
  igListBox_Str_arr := GetProcAddress(aDLLHandle, 'igListBox_Str_arr');
  igLoadIniSettingsFromDisk := GetProcAddress(aDLLHandle, 'igLoadIniSettingsFromDisk');
  igLoadIniSettingsFromMemory := GetProcAddress(aDLLHandle, 'igLoadIniSettingsFromMemory');
  igLocalizeGetMsg := GetProcAddress(aDLLHandle, 'igLocalizeGetMsg');
  igLocalizeRegisterEntries := GetProcAddress(aDLLHandle, 'igLocalizeRegisterEntries');
  igLogBegin := GetProcAddress(aDLLHandle, 'igLogBegin');
  igLogButtons := GetProcAddress(aDLLHandle, 'igLogButtons');
  igLogFinish := GetProcAddress(aDLLHandle, 'igLogFinish');
  igLogRenderedText := GetProcAddress(aDLLHandle, 'igLogRenderedText');
  igLogSetNextTextDecoration := GetProcAddress(aDLLHandle, 'igLogSetNextTextDecoration');
  igLogText := GetProcAddress(aDLLHandle, 'igLogText');
  igLogTextV := GetProcAddress(aDLLHandle, 'igLogTextV');
  igLogToBuffer := GetProcAddress(aDLLHandle, 'igLogToBuffer');
  igLogToClipboard := GetProcAddress(aDLLHandle, 'igLogToClipboard');
  igLogToFile := GetProcAddress(aDLLHandle, 'igLogToFile');
  igLogToTTY := GetProcAddress(aDLLHandle, 'igLogToTTY');
  igMarkIniSettingsDirty_Nil := GetProcAddress(aDLLHandle, 'igMarkIniSettingsDirty_Nil');
  igMarkIniSettingsDirty_WindowPtr := GetProcAddress(aDLLHandle, 'igMarkIniSettingsDirty_WindowPtr');
  igMarkItemEdited := GetProcAddress(aDLLHandle, 'igMarkItemEdited');
  igMemAlloc := GetProcAddress(aDLLHandle, 'igMemAlloc');
  igMemFree := GetProcAddress(aDLLHandle, 'igMemFree');
  igMenuItem_Bool := GetProcAddress(aDLLHandle, 'igMenuItem_Bool');
  igMenuItem_BoolPtr := GetProcAddress(aDLLHandle, 'igMenuItem_BoolPtr');
  igMenuItemEx := GetProcAddress(aDLLHandle, 'igMenuItemEx');
  igMouseButtonToKey := GetProcAddress(aDLLHandle, 'igMouseButtonToKey');
  igMultiSelectAddSetAll := GetProcAddress(aDLLHandle, 'igMultiSelectAddSetAll');
  igMultiSelectAddSetRange := GetProcAddress(aDLLHandle, 'igMultiSelectAddSetRange');
  igMultiSelectItemFooter := GetProcAddress(aDLLHandle, 'igMultiSelectItemFooter');
  igMultiSelectItemHeader := GetProcAddress(aDLLHandle, 'igMultiSelectItemHeader');
  igNavClearPreferredPosForAxis := GetProcAddress(aDLLHandle, 'igNavClearPreferredPosForAxis');
  igNavHighlightActivated := GetProcAddress(aDLLHandle, 'igNavHighlightActivated');
  igNavInitRequestApplyResult := GetProcAddress(aDLLHandle, 'igNavInitRequestApplyResult');
  igNavInitWindow := GetProcAddress(aDLLHandle, 'igNavInitWindow');
  igNavMoveRequestApplyResult := GetProcAddress(aDLLHandle, 'igNavMoveRequestApplyResult');
  igNavMoveRequestButNoResultYet := GetProcAddress(aDLLHandle, 'igNavMoveRequestButNoResultYet');
  igNavMoveRequestCancel := GetProcAddress(aDLLHandle, 'igNavMoveRequestCancel');
  igNavMoveRequestForward := GetProcAddress(aDLLHandle, 'igNavMoveRequestForward');
  igNavMoveRequestResolveWithLastItem := GetProcAddress(aDLLHandle, 'igNavMoveRequestResolveWithLastItem');
  igNavMoveRequestResolveWithPastTreeNode := GetProcAddress(aDLLHandle, 'igNavMoveRequestResolveWithPastTreeNode');
  igNavMoveRequestSubmit := GetProcAddress(aDLLHandle, 'igNavMoveRequestSubmit');
  igNavMoveRequestTryWrapping := GetProcAddress(aDLLHandle, 'igNavMoveRequestTryWrapping');
  igNavUpdateCurrentWindowIsScrollPushableX := GetProcAddress(aDLLHandle, 'igNavUpdateCurrentWindowIsScrollPushableX');
  igNewFrame := GetProcAddress(aDLLHandle, 'igNewFrame');
  igNewLine := GetProcAddress(aDLLHandle, 'igNewLine');
  igNextColumn := GetProcAddress(aDLLHandle, 'igNextColumn');
  igOpenPopup_ID := GetProcAddress(aDLLHandle, 'igOpenPopup_ID');
  igOpenPopup_Str := GetProcAddress(aDLLHandle, 'igOpenPopup_Str');
  igOpenPopupEx := GetProcAddress(aDLLHandle, 'igOpenPopupEx');
  igOpenPopupOnItemClick := GetProcAddress(aDLLHandle, 'igOpenPopupOnItemClick');
  igPlotEx := GetProcAddress(aDLLHandle, 'igPlotEx');
  igPlotHistogram_FloatPtr := GetProcAddress(aDLLHandle, 'igPlotHistogram_FloatPtr');
  igPlotHistogram_FnFloatPtr := GetProcAddress(aDLLHandle, 'igPlotHistogram_FnFloatPtr');
  igPlotLines_FloatPtr := GetProcAddress(aDLLHandle, 'igPlotLines_FloatPtr');
  igPlotLines_FnFloatPtr := GetProcAddress(aDLLHandle, 'igPlotLines_FnFloatPtr');
  igPopClipRect := GetProcAddress(aDLLHandle, 'igPopClipRect');
  igPopColumnsBackground := GetProcAddress(aDLLHandle, 'igPopColumnsBackground');
  igPopFocusScope := GetProcAddress(aDLLHandle, 'igPopFocusScope');
  igPopFont := GetProcAddress(aDLLHandle, 'igPopFont');
  igPopID := GetProcAddress(aDLLHandle, 'igPopID');
  igPopItemFlag := GetProcAddress(aDLLHandle, 'igPopItemFlag');
  igPopItemWidth := GetProcAddress(aDLLHandle, 'igPopItemWidth');
  igPopStyleColor := GetProcAddress(aDLLHandle, 'igPopStyleColor');
  igPopStyleVar := GetProcAddress(aDLLHandle, 'igPopStyleVar');
  igPopTextWrapPos := GetProcAddress(aDLLHandle, 'igPopTextWrapPos');
  igProgressBar := GetProcAddress(aDLLHandle, 'igProgressBar');
  igPushClipRect := GetProcAddress(aDLLHandle, 'igPushClipRect');
  igPushColumnClipRect := GetProcAddress(aDLLHandle, 'igPushColumnClipRect');
  igPushColumnsBackground := GetProcAddress(aDLLHandle, 'igPushColumnsBackground');
  igPushFocusScope := GetProcAddress(aDLLHandle, 'igPushFocusScope');
  igPushFont := GetProcAddress(aDLLHandle, 'igPushFont');
  igPushID_Int := GetProcAddress(aDLLHandle, 'igPushID_Int');
  igPushID_Ptr := GetProcAddress(aDLLHandle, 'igPushID_Ptr');
  igPushID_Str := GetProcAddress(aDLLHandle, 'igPushID_Str');
  igPushID_StrStr := GetProcAddress(aDLLHandle, 'igPushID_StrStr');
  igPushItemFlag := GetProcAddress(aDLLHandle, 'igPushItemFlag');
  igPushItemWidth := GetProcAddress(aDLLHandle, 'igPushItemWidth');
  igPushMultiItemsWidths := GetProcAddress(aDLLHandle, 'igPushMultiItemsWidths');
  igPushOverrideID := GetProcAddress(aDLLHandle, 'igPushOverrideID');
  igPushPasswordFont := GetProcAddress(aDLLHandle, 'igPushPasswordFont');
  igPushStyleColor_U32 := GetProcAddress(aDLLHandle, 'igPushStyleColor_U32');
  igPushStyleColor_Vec4 := GetProcAddress(aDLLHandle, 'igPushStyleColor_Vec4');
  igPushStyleVar_Float := GetProcAddress(aDLLHandle, 'igPushStyleVar_Float');
  igPushStyleVar_Vec2 := GetProcAddress(aDLLHandle, 'igPushStyleVar_Vec2');
  igPushStyleVarX := GetProcAddress(aDLLHandle, 'igPushStyleVarX');
  igPushStyleVarY := GetProcAddress(aDLLHandle, 'igPushStyleVarY');
  igPushTextWrapPos := GetProcAddress(aDLLHandle, 'igPushTextWrapPos');
  igRadioButton_Bool := GetProcAddress(aDLLHandle, 'igRadioButton_Bool');
  igRadioButton_IntPtr := GetProcAddress(aDLLHandle, 'igRadioButton_IntPtr');
  igRemoveContextHook := GetProcAddress(aDLLHandle, 'igRemoveContextHook');
  igRemoveSettingsHandler := GetProcAddress(aDLLHandle, 'igRemoveSettingsHandler');
  igRender := GetProcAddress(aDLLHandle, 'igRender');
  igRenderArrow := GetProcAddress(aDLLHandle, 'igRenderArrow');
  igRenderArrowDockMenu := GetProcAddress(aDLLHandle, 'igRenderArrowDockMenu');
  igRenderArrowPointingAt := GetProcAddress(aDLLHandle, 'igRenderArrowPointingAt');
  igRenderBullet := GetProcAddress(aDLLHandle, 'igRenderBullet');
  igRenderCheckMark := GetProcAddress(aDLLHandle, 'igRenderCheckMark');
  igRenderColorRectWithAlphaCheckerboard := GetProcAddress(aDLLHandle, 'igRenderColorRectWithAlphaCheckerboard');
  igRenderDragDropTargetRect := GetProcAddress(aDLLHandle, 'igRenderDragDropTargetRect');
  igRenderFrame := GetProcAddress(aDLLHandle, 'igRenderFrame');
  igRenderFrameBorder := GetProcAddress(aDLLHandle, 'igRenderFrameBorder');
  igRenderMouseCursor := GetProcAddress(aDLLHandle, 'igRenderMouseCursor');
  igRenderNavCursor := GetProcAddress(aDLLHandle, 'igRenderNavCursor');
  igRenderPlatformWindowsDefault := GetProcAddress(aDLLHandle, 'igRenderPlatformWindowsDefault');
  igRenderRectFilledRangeH := GetProcAddress(aDLLHandle, 'igRenderRectFilledRangeH');
  igRenderRectFilledWithHole := GetProcAddress(aDLLHandle, 'igRenderRectFilledWithHole');
  igRenderText := GetProcAddress(aDLLHandle, 'igRenderText');
  igRenderTextClipped := GetProcAddress(aDLLHandle, 'igRenderTextClipped');
  igRenderTextClippedEx := GetProcAddress(aDLLHandle, 'igRenderTextClippedEx');
  igRenderTextEllipsis := GetProcAddress(aDLLHandle, 'igRenderTextEllipsis');
  igRenderTextWrapped := GetProcAddress(aDLLHandle, 'igRenderTextWrapped');
  igResetMouseDragDelta := GetProcAddress(aDLLHandle, 'igResetMouseDragDelta');
  igSameLine := GetProcAddress(aDLLHandle, 'igSameLine');
  igSaveIniSettingsToDisk := GetProcAddress(aDLLHandle, 'igSaveIniSettingsToDisk');
  igSaveIniSettingsToMemory := GetProcAddress(aDLLHandle, 'igSaveIniSettingsToMemory');
  igScaleWindowsInViewport := GetProcAddress(aDLLHandle, 'igScaleWindowsInViewport');
  igScrollbar := GetProcAddress(aDLLHandle, 'igScrollbar');
  igScrollbarEx := GetProcAddress(aDLLHandle, 'igScrollbarEx');
  igScrollToBringRectIntoView := GetProcAddress(aDLLHandle, 'igScrollToBringRectIntoView');
  igScrollToItem := GetProcAddress(aDLLHandle, 'igScrollToItem');
  igScrollToRect := GetProcAddress(aDLLHandle, 'igScrollToRect');
  igScrollToRectEx := GetProcAddress(aDLLHandle, 'igScrollToRectEx');
  igSelectable_Bool := GetProcAddress(aDLLHandle, 'igSelectable_Bool');
  igSelectable_BoolPtr := GetProcAddress(aDLLHandle, 'igSelectable_BoolPtr');
  igSeparator := GetProcAddress(aDLLHandle, 'igSeparator');
  igSeparatorEx := GetProcAddress(aDLLHandle, 'igSeparatorEx');
  igSeparatorText := GetProcAddress(aDLLHandle, 'igSeparatorText');
  igSeparatorTextEx := GetProcAddress(aDLLHandle, 'igSeparatorTextEx');
  igSetActiveID := GetProcAddress(aDLLHandle, 'igSetActiveID');
  igSetActiveIdUsingAllKeyboardKeys := GetProcAddress(aDLLHandle, 'igSetActiveIdUsingAllKeyboardKeys');
  igSetAllocatorFunctions := GetProcAddress(aDLLHandle, 'igSetAllocatorFunctions');
  igSetClipboardText := GetProcAddress(aDLLHandle, 'igSetClipboardText');
  igSetColorEditOptions := GetProcAddress(aDLLHandle, 'igSetColorEditOptions');
  igSetColumnOffset := GetProcAddress(aDLLHandle, 'igSetColumnOffset');
  igSetColumnWidth := GetProcAddress(aDLLHandle, 'igSetColumnWidth');
  igSetCurrentContext := GetProcAddress(aDLLHandle, 'igSetCurrentContext');
  igSetCurrentFont := GetProcAddress(aDLLHandle, 'igSetCurrentFont');
  igSetCurrentViewport := GetProcAddress(aDLLHandle, 'igSetCurrentViewport');
  igSetCursorPos := GetProcAddress(aDLLHandle, 'igSetCursorPos');
  igSetCursorPosX := GetProcAddress(aDLLHandle, 'igSetCursorPosX');
  igSetCursorPosY := GetProcAddress(aDLLHandle, 'igSetCursorPosY');
  igSetCursorScreenPos := GetProcAddress(aDLLHandle, 'igSetCursorScreenPos');
  igSetDragDropPayload := GetProcAddress(aDLLHandle, 'igSetDragDropPayload');
  igSetFocusID := GetProcAddress(aDLLHandle, 'igSetFocusID');
  igSetHoveredID := GetProcAddress(aDLLHandle, 'igSetHoveredID');
  igSetItemDefaultFocus := GetProcAddress(aDLLHandle, 'igSetItemDefaultFocus');
  igSetItemKeyOwner_InputFlags := GetProcAddress(aDLLHandle, 'igSetItemKeyOwner_InputFlags');
  igSetItemKeyOwner_Nil := GetProcAddress(aDLLHandle, 'igSetItemKeyOwner_Nil');
  igSetItemTooltip := GetProcAddress(aDLLHandle, 'igSetItemTooltip');
  igSetItemTooltipV := GetProcAddress(aDLLHandle, 'igSetItemTooltipV');
  igSetKeyboardFocusHere := GetProcAddress(aDLLHandle, 'igSetKeyboardFocusHere');
  igSetKeyOwner := GetProcAddress(aDLLHandle, 'igSetKeyOwner');
  igSetKeyOwnersForKeyChord := GetProcAddress(aDLLHandle, 'igSetKeyOwnersForKeyChord');
  igSetLastItemData := GetProcAddress(aDLLHandle, 'igSetLastItemData');
  igSetMouseCursor := GetProcAddress(aDLLHandle, 'igSetMouseCursor');
  igSetNavCursorVisible := GetProcAddress(aDLLHandle, 'igSetNavCursorVisible');
  igSetNavCursorVisibleAfterMove := GetProcAddress(aDLLHandle, 'igSetNavCursorVisibleAfterMove');
  igSetNavFocusScope := GetProcAddress(aDLLHandle, 'igSetNavFocusScope');
  igSetNavID := GetProcAddress(aDLLHandle, 'igSetNavID');
  igSetNavWindow := GetProcAddress(aDLLHandle, 'igSetNavWindow');
  igSetNextFrameWantCaptureKeyboard := GetProcAddress(aDLLHandle, 'igSetNextFrameWantCaptureKeyboard');
  igSetNextFrameWantCaptureMouse := GetProcAddress(aDLLHandle, 'igSetNextFrameWantCaptureMouse');
  igSetNextItemAllowOverlap := GetProcAddress(aDLLHandle, 'igSetNextItemAllowOverlap');
  igSetNextItemOpen := GetProcAddress(aDLLHandle, 'igSetNextItemOpen');
  igSetNextItemRefVal := GetProcAddress(aDLLHandle, 'igSetNextItemRefVal');
  igSetNextItemSelectionUserData := GetProcAddress(aDLLHandle, 'igSetNextItemSelectionUserData');
  igSetNextItemShortcut := GetProcAddress(aDLLHandle, 'igSetNextItemShortcut');
  igSetNextItemStorageID := GetProcAddress(aDLLHandle, 'igSetNextItemStorageID');
  igSetNextItemWidth := GetProcAddress(aDLLHandle, 'igSetNextItemWidth');
  igSetNextWindowBgAlpha := GetProcAddress(aDLLHandle, 'igSetNextWindowBgAlpha');
  igSetNextWindowClass := GetProcAddress(aDLLHandle, 'igSetNextWindowClass');
  igSetNextWindowCollapsed := GetProcAddress(aDLLHandle, 'igSetNextWindowCollapsed');
  igSetNextWindowContentSize := GetProcAddress(aDLLHandle, 'igSetNextWindowContentSize');
  igSetNextWindowDockID := GetProcAddress(aDLLHandle, 'igSetNextWindowDockID');
  igSetNextWindowFocus := GetProcAddress(aDLLHandle, 'igSetNextWindowFocus');
  igSetNextWindowPos := GetProcAddress(aDLLHandle, 'igSetNextWindowPos');
  igSetNextWindowRefreshPolicy := GetProcAddress(aDLLHandle, 'igSetNextWindowRefreshPolicy');
  igSetNextWindowScroll := GetProcAddress(aDLLHandle, 'igSetNextWindowScroll');
  igSetNextWindowSize := GetProcAddress(aDLLHandle, 'igSetNextWindowSize');
  igSetNextWindowSizeConstraints := GetProcAddress(aDLLHandle, 'igSetNextWindowSizeConstraints');
  igSetNextWindowViewport := GetProcAddress(aDLLHandle, 'igSetNextWindowViewport');
  igSetScrollFromPosX_Float := GetProcAddress(aDLLHandle, 'igSetScrollFromPosX_Float');
  igSetScrollFromPosX_WindowPtr := GetProcAddress(aDLLHandle, 'igSetScrollFromPosX_WindowPtr');
  igSetScrollFromPosY_Float := GetProcAddress(aDLLHandle, 'igSetScrollFromPosY_Float');
  igSetScrollFromPosY_WindowPtr := GetProcAddress(aDLLHandle, 'igSetScrollFromPosY_WindowPtr');
  igSetScrollHereX := GetProcAddress(aDLLHandle, 'igSetScrollHereX');
  igSetScrollHereY := GetProcAddress(aDLLHandle, 'igSetScrollHereY');
  igSetScrollX_Float := GetProcAddress(aDLLHandle, 'igSetScrollX_Float');
  igSetScrollX_WindowPtr := GetProcAddress(aDLLHandle, 'igSetScrollX_WindowPtr');
  igSetScrollY_Float := GetProcAddress(aDLLHandle, 'igSetScrollY_Float');
  igSetScrollY_WindowPtr := GetProcAddress(aDLLHandle, 'igSetScrollY_WindowPtr');
  igSetShortcutRouting := GetProcAddress(aDLLHandle, 'igSetShortcutRouting');
  igSetStateStorage := GetProcAddress(aDLLHandle, 'igSetStateStorage');
  igSetTabItemClosed := GetProcAddress(aDLLHandle, 'igSetTabItemClosed');
  igSetTooltip := GetProcAddress(aDLLHandle, 'igSetTooltip');
  igSetTooltipV := GetProcAddress(aDLLHandle, 'igSetTooltipV');
  igSetWindowClipRectBeforeSetChannel := GetProcAddress(aDLLHandle, 'igSetWindowClipRectBeforeSetChannel');
  igSetWindowCollapsed_Bool := GetProcAddress(aDLLHandle, 'igSetWindowCollapsed_Bool');
  igSetWindowCollapsed_Str := GetProcAddress(aDLLHandle, 'igSetWindowCollapsed_Str');
  igSetWindowCollapsed_WindowPtr := GetProcAddress(aDLLHandle, 'igSetWindowCollapsed_WindowPtr');
  igSetWindowDock := GetProcAddress(aDLLHandle, 'igSetWindowDock');
  igSetWindowFocus_Nil := GetProcAddress(aDLLHandle, 'igSetWindowFocus_Nil');
  igSetWindowFocus_Str := GetProcAddress(aDLLHandle, 'igSetWindowFocus_Str');
  igSetWindowFontScale := GetProcAddress(aDLLHandle, 'igSetWindowFontScale');
  igSetWindowHiddenAndSkipItemsForCurrentFrame := GetProcAddress(aDLLHandle, 'igSetWindowHiddenAndSkipItemsForCurrentFrame');
  igSetWindowHitTestHole := GetProcAddress(aDLLHandle, 'igSetWindowHitTestHole');
  igSetWindowParentWindowForFocusRoute := GetProcAddress(aDLLHandle, 'igSetWindowParentWindowForFocusRoute');
  igSetWindowPos_Str := GetProcAddress(aDLLHandle, 'igSetWindowPos_Str');
  igSetWindowPos_Vec2 := GetProcAddress(aDLLHandle, 'igSetWindowPos_Vec2');
  igSetWindowPos_WindowPtr := GetProcAddress(aDLLHandle, 'igSetWindowPos_WindowPtr');
  igSetWindowSize_Str := GetProcAddress(aDLLHandle, 'igSetWindowSize_Str');
  igSetWindowSize_Vec2 := GetProcAddress(aDLLHandle, 'igSetWindowSize_Vec2');
  igSetWindowSize_WindowPtr := GetProcAddress(aDLLHandle, 'igSetWindowSize_WindowPtr');
  igSetWindowViewport := GetProcAddress(aDLLHandle, 'igSetWindowViewport');
  igShadeVertsLinearColorGradientKeepAlpha := GetProcAddress(aDLLHandle, 'igShadeVertsLinearColorGradientKeepAlpha');
  igShadeVertsLinearUV := GetProcAddress(aDLLHandle, 'igShadeVertsLinearUV');
  igShadeVertsTransformPos := GetProcAddress(aDLLHandle, 'igShadeVertsTransformPos');
  igShortcut_ID := GetProcAddress(aDLLHandle, 'igShortcut_ID');
  igShortcut_Nil := GetProcAddress(aDLLHandle, 'igShortcut_Nil');
  igShowAboutWindow := GetProcAddress(aDLLHandle, 'igShowAboutWindow');
  igShowDebugLogWindow := GetProcAddress(aDLLHandle, 'igShowDebugLogWindow');
  igShowDemoWindow := GetProcAddress(aDLLHandle, 'igShowDemoWindow');
  igShowFontAtlas := GetProcAddress(aDLLHandle, 'igShowFontAtlas');
  igShowFontSelector := GetProcAddress(aDLLHandle, 'igShowFontSelector');
  igShowIDStackToolWindow := GetProcAddress(aDLLHandle, 'igShowIDStackToolWindow');
  igShowMetricsWindow := GetProcAddress(aDLLHandle, 'igShowMetricsWindow');
  igShowStyleEditor := GetProcAddress(aDLLHandle, 'igShowStyleEditor');
  igShowStyleSelector := GetProcAddress(aDLLHandle, 'igShowStyleSelector');
  igShowUserGuide := GetProcAddress(aDLLHandle, 'igShowUserGuide');
  igShrinkWidths := GetProcAddress(aDLLHandle, 'igShrinkWidths');
  igShutdown := GetProcAddress(aDLLHandle, 'igShutdown');
  igSliderAngle := GetProcAddress(aDLLHandle, 'igSliderAngle');
  igSliderBehavior := GetProcAddress(aDLLHandle, 'igSliderBehavior');
  igSliderFloat := GetProcAddress(aDLLHandle, 'igSliderFloat');
  igSliderFloat2 := GetProcAddress(aDLLHandle, 'igSliderFloat2');
  igSliderFloat3 := GetProcAddress(aDLLHandle, 'igSliderFloat3');
  igSliderFloat4 := GetProcAddress(aDLLHandle, 'igSliderFloat4');
  igSliderInt := GetProcAddress(aDLLHandle, 'igSliderInt');
  igSliderInt2 := GetProcAddress(aDLLHandle, 'igSliderInt2');
  igSliderInt3 := GetProcAddress(aDLLHandle, 'igSliderInt3');
  igSliderInt4 := GetProcAddress(aDLLHandle, 'igSliderInt4');
  igSliderScalar := GetProcAddress(aDLLHandle, 'igSliderScalar');
  igSliderScalarN := GetProcAddress(aDLLHandle, 'igSliderScalarN');
  igSmallButton := GetProcAddress(aDLLHandle, 'igSmallButton');
  igSpacing := GetProcAddress(aDLLHandle, 'igSpacing');
  igSplitterBehavior := GetProcAddress(aDLLHandle, 'igSplitterBehavior');
  igStartMouseMovingWindow := GetProcAddress(aDLLHandle, 'igStartMouseMovingWindow');
  igStartMouseMovingWindowOrNode := GetProcAddress(aDLLHandle, 'igStartMouseMovingWindowOrNode');
  igStyleColorsClassic := GetProcAddress(aDLLHandle, 'igStyleColorsClassic');
  igStyleColorsDark := GetProcAddress(aDLLHandle, 'igStyleColorsDark');
  igStyleColorsLight := GetProcAddress(aDLLHandle, 'igStyleColorsLight');
  igTabBarAddTab := GetProcAddress(aDLLHandle, 'igTabBarAddTab');
  igTabBarCloseTab := GetProcAddress(aDLLHandle, 'igTabBarCloseTab');
  igTabBarFindMostRecentlySelectedTabForActiveWindow := GetProcAddress(aDLLHandle, 'igTabBarFindMostRecentlySelectedTabForActiveWindow');
  igTabBarFindTabByID := GetProcAddress(aDLLHandle, 'igTabBarFindTabByID');
  igTabBarFindTabByOrder := GetProcAddress(aDLLHandle, 'igTabBarFindTabByOrder');
  igTabBarGetCurrentTab := GetProcAddress(aDLLHandle, 'igTabBarGetCurrentTab');
  igTabBarGetTabName := GetProcAddress(aDLLHandle, 'igTabBarGetTabName');
  igTabBarGetTabOrder := GetProcAddress(aDLLHandle, 'igTabBarGetTabOrder');
  igTabBarProcessReorder := GetProcAddress(aDLLHandle, 'igTabBarProcessReorder');
  igTabBarQueueFocus_Str := GetProcAddress(aDLLHandle, 'igTabBarQueueFocus_Str');
  igTabBarQueueFocus_TabItemPtr := GetProcAddress(aDLLHandle, 'igTabBarQueueFocus_TabItemPtr');
  igTabBarQueueReorder := GetProcAddress(aDLLHandle, 'igTabBarQueueReorder');
  igTabBarQueueReorderFromMousePos := GetProcAddress(aDLLHandle, 'igTabBarQueueReorderFromMousePos');
  igTabBarRemoveTab := GetProcAddress(aDLLHandle, 'igTabBarRemoveTab');
  igTabItemBackground := GetProcAddress(aDLLHandle, 'igTabItemBackground');
  igTabItemButton := GetProcAddress(aDLLHandle, 'igTabItemButton');
  igTabItemCalcSize_Str := GetProcAddress(aDLLHandle, 'igTabItemCalcSize_Str');
  igTabItemCalcSize_WindowPtr := GetProcAddress(aDLLHandle, 'igTabItemCalcSize_WindowPtr');
  igTabItemEx := GetProcAddress(aDLLHandle, 'igTabItemEx');
  igTabItemLabelAndCloseButton := GetProcAddress(aDLLHandle, 'igTabItemLabelAndCloseButton');
  igTabItemSpacing := GetProcAddress(aDLLHandle, 'igTabItemSpacing');
  igTableAngledHeadersRow := GetProcAddress(aDLLHandle, 'igTableAngledHeadersRow');
  igTableAngledHeadersRowEx := GetProcAddress(aDLLHandle, 'igTableAngledHeadersRowEx');
  igTableBeginApplyRequests := GetProcAddress(aDLLHandle, 'igTableBeginApplyRequests');
  igTableBeginCell := GetProcAddress(aDLLHandle, 'igTableBeginCell');
  igTableBeginContextMenuPopup := GetProcAddress(aDLLHandle, 'igTableBeginContextMenuPopup');
  igTableBeginInitMemory := GetProcAddress(aDLLHandle, 'igTableBeginInitMemory');
  igTableBeginRow := GetProcAddress(aDLLHandle, 'igTableBeginRow');
  igTableCalcMaxColumnWidth := GetProcAddress(aDLLHandle, 'igTableCalcMaxColumnWidth');
  igTableDrawBorders := GetProcAddress(aDLLHandle, 'igTableDrawBorders');
  igTableDrawDefaultContextMenu := GetProcAddress(aDLLHandle, 'igTableDrawDefaultContextMenu');
  igTableEndCell := GetProcAddress(aDLLHandle, 'igTableEndCell');
  igTableEndRow := GetProcAddress(aDLLHandle, 'igTableEndRow');
  igTableFindByID := GetProcAddress(aDLLHandle, 'igTableFindByID');
  igTableFixColumnSortDirection := GetProcAddress(aDLLHandle, 'igTableFixColumnSortDirection');
  igTableGcCompactSettings := GetProcAddress(aDLLHandle, 'igTableGcCompactSettings');
  igTableGcCompactTransientBuffers_TablePtr := GetProcAddress(aDLLHandle, 'igTableGcCompactTransientBuffers_TablePtr');
  igTableGcCompactTransientBuffers_TableTempDataPtr := GetProcAddress(aDLLHandle, 'igTableGcCompactTransientBuffers_TableTempDataPtr');
  igTableGetBoundSettings := GetProcAddress(aDLLHandle, 'igTableGetBoundSettings');
  igTableGetCellBgRect := GetProcAddress(aDLLHandle, 'igTableGetCellBgRect');
  igTableGetColumnCount := GetProcAddress(aDLLHandle, 'igTableGetColumnCount');
  igTableGetColumnFlags := GetProcAddress(aDLLHandle, 'igTableGetColumnFlags');
  igTableGetColumnIndex := GetProcAddress(aDLLHandle, 'igTableGetColumnIndex');
  igTableGetColumnName_Int := GetProcAddress(aDLLHandle, 'igTableGetColumnName_Int');
  igTableGetColumnName_TablePtr := GetProcAddress(aDLLHandle, 'igTableGetColumnName_TablePtr');
  igTableGetColumnNextSortDirection := GetProcAddress(aDLLHandle, 'igTableGetColumnNextSortDirection');
  igTableGetColumnResizeID := GetProcAddress(aDLLHandle, 'igTableGetColumnResizeID');
  igTableGetColumnWidthAuto := GetProcAddress(aDLLHandle, 'igTableGetColumnWidthAuto');
  igTableGetHeaderAngledMaxLabelWidth := GetProcAddress(aDLLHandle, 'igTableGetHeaderAngledMaxLabelWidth');
  igTableGetHeaderRowHeight := GetProcAddress(aDLLHandle, 'igTableGetHeaderRowHeight');
  igTableGetHoveredColumn := GetProcAddress(aDLLHandle, 'igTableGetHoveredColumn');
  igTableGetHoveredRow := GetProcAddress(aDLLHandle, 'igTableGetHoveredRow');
  igTableGetInstanceData := GetProcAddress(aDLLHandle, 'igTableGetInstanceData');
  igTableGetInstanceID := GetProcAddress(aDLLHandle, 'igTableGetInstanceID');
  igTableGetRowIndex := GetProcAddress(aDLLHandle, 'igTableGetRowIndex');
  igTableGetSortSpecs := GetProcAddress(aDLLHandle, 'igTableGetSortSpecs');
  igTableHeader := GetProcAddress(aDLLHandle, 'igTableHeader');
  igTableHeadersRow := GetProcAddress(aDLLHandle, 'igTableHeadersRow');
  igTableLoadSettings := GetProcAddress(aDLLHandle, 'igTableLoadSettings');
  igTableMergeDrawChannels := GetProcAddress(aDLLHandle, 'igTableMergeDrawChannels');
  igTableNextColumn := GetProcAddress(aDLLHandle, 'igTableNextColumn');
  igTableNextRow := GetProcAddress(aDLLHandle, 'igTableNextRow');
  igTableOpenContextMenu := GetProcAddress(aDLLHandle, 'igTableOpenContextMenu');
  igTablePopBackgroundChannel := GetProcAddress(aDLLHandle, 'igTablePopBackgroundChannel');
  igTablePushBackgroundChannel := GetProcAddress(aDLLHandle, 'igTablePushBackgroundChannel');
  igTableRemove := GetProcAddress(aDLLHandle, 'igTableRemove');
  igTableResetSettings := GetProcAddress(aDLLHandle, 'igTableResetSettings');
  igTableSaveSettings := GetProcAddress(aDLLHandle, 'igTableSaveSettings');
  igTableSetBgColor := GetProcAddress(aDLLHandle, 'igTableSetBgColor');
  igTableSetColumnEnabled := GetProcAddress(aDLLHandle, 'igTableSetColumnEnabled');
  igTableSetColumnIndex := GetProcAddress(aDLLHandle, 'igTableSetColumnIndex');
  igTableSetColumnSortDirection := GetProcAddress(aDLLHandle, 'igTableSetColumnSortDirection');
  igTableSetColumnWidth := GetProcAddress(aDLLHandle, 'igTableSetColumnWidth');
  igTableSetColumnWidthAutoAll := GetProcAddress(aDLLHandle, 'igTableSetColumnWidthAutoAll');
  igTableSetColumnWidthAutoSingle := GetProcAddress(aDLLHandle, 'igTableSetColumnWidthAutoSingle');
  igTableSettingsAddSettingsHandler := GetProcAddress(aDLLHandle, 'igTableSettingsAddSettingsHandler');
  igTableSettingsCreate := GetProcAddress(aDLLHandle, 'igTableSettingsCreate');
  igTableSettingsFindByID := GetProcAddress(aDLLHandle, 'igTableSettingsFindByID');
  igTableSetupColumn := GetProcAddress(aDLLHandle, 'igTableSetupColumn');
  igTableSetupDrawChannels := GetProcAddress(aDLLHandle, 'igTableSetupDrawChannels');
  igTableSetupScrollFreeze := GetProcAddress(aDLLHandle, 'igTableSetupScrollFreeze');
  igTableSortSpecsBuild := GetProcAddress(aDLLHandle, 'igTableSortSpecsBuild');
  igTableSortSpecsSanitize := GetProcAddress(aDLLHandle, 'igTableSortSpecsSanitize');
  igTableUpdateBorders := GetProcAddress(aDLLHandle, 'igTableUpdateBorders');
  igTableUpdateColumnsWeightFromWidth := GetProcAddress(aDLLHandle, 'igTableUpdateColumnsWeightFromWidth');
  igTableUpdateLayout := GetProcAddress(aDLLHandle, 'igTableUpdateLayout');
  igTeleportMousePos := GetProcAddress(aDLLHandle, 'igTeleportMousePos');
  igTempInputIsActive := GetProcAddress(aDLLHandle, 'igTempInputIsActive');
  igTempInputScalar := GetProcAddress(aDLLHandle, 'igTempInputScalar');
  igTempInputText := GetProcAddress(aDLLHandle, 'igTempInputText');
  igTestKeyOwner := GetProcAddress(aDLLHandle, 'igTestKeyOwner');
  igTestShortcutRouting := GetProcAddress(aDLLHandle, 'igTestShortcutRouting');
  igText := GetProcAddress(aDLLHandle, 'igText');
  igTextColored := GetProcAddress(aDLLHandle, 'igTextColored');
  igTextColoredV := GetProcAddress(aDLLHandle, 'igTextColoredV');
  igTextDisabled := GetProcAddress(aDLLHandle, 'igTextDisabled');
  igTextDisabledV := GetProcAddress(aDLLHandle, 'igTextDisabledV');
  igTextEx := GetProcAddress(aDLLHandle, 'igTextEx');
  igTextLink := GetProcAddress(aDLLHandle, 'igTextLink');
  igTextLinkOpenURL := GetProcAddress(aDLLHandle, 'igTextLinkOpenURL');
  igTextUnformatted := GetProcAddress(aDLLHandle, 'igTextUnformatted');
  igTextV := GetProcAddress(aDLLHandle, 'igTextV');
  igTextWrapped := GetProcAddress(aDLLHandle, 'igTextWrapped');
  igTextWrappedV := GetProcAddress(aDLLHandle, 'igTextWrappedV');
  igTranslateWindowsInViewport := GetProcAddress(aDLLHandle, 'igTranslateWindowsInViewport');
  igTreeNode_Ptr := GetProcAddress(aDLLHandle, 'igTreeNode_Ptr');
  igTreeNode_Str := GetProcAddress(aDLLHandle, 'igTreeNode_Str');
  igTreeNode_StrStr := GetProcAddress(aDLLHandle, 'igTreeNode_StrStr');
  igTreeNodeBehavior := GetProcAddress(aDLLHandle, 'igTreeNodeBehavior');
  igTreeNodeEx_Ptr := GetProcAddress(aDLLHandle, 'igTreeNodeEx_Ptr');
  igTreeNodeEx_Str := GetProcAddress(aDLLHandle, 'igTreeNodeEx_Str');
  igTreeNodeEx_StrStr := GetProcAddress(aDLLHandle, 'igTreeNodeEx_StrStr');
  igTreeNodeExV_Ptr := GetProcAddress(aDLLHandle, 'igTreeNodeExV_Ptr');
  igTreeNodeExV_Str := GetProcAddress(aDLLHandle, 'igTreeNodeExV_Str');
  igTreeNodeGetOpen := GetProcAddress(aDLLHandle, 'igTreeNodeGetOpen');
  igTreeNodeSetOpen := GetProcAddress(aDLLHandle, 'igTreeNodeSetOpen');
  igTreeNodeUpdateNextOpen := GetProcAddress(aDLLHandle, 'igTreeNodeUpdateNextOpen');
  igTreeNodeV_Ptr := GetProcAddress(aDLLHandle, 'igTreeNodeV_Ptr');
  igTreeNodeV_Str := GetProcAddress(aDLLHandle, 'igTreeNodeV_Str');
  igTreePop := GetProcAddress(aDLLHandle, 'igTreePop');
  igTreePush_Ptr := GetProcAddress(aDLLHandle, 'igTreePush_Ptr');
  igTreePush_Str := GetProcAddress(aDLLHandle, 'igTreePush_Str');
  igTreePushOverrideID := GetProcAddress(aDLLHandle, 'igTreePushOverrideID');
  igTypingSelectFindBestLeadingMatch := GetProcAddress(aDLLHandle, 'igTypingSelectFindBestLeadingMatch');
  igTypingSelectFindMatch := GetProcAddress(aDLLHandle, 'igTypingSelectFindMatch');
  igTypingSelectFindNextSingleCharMatch := GetProcAddress(aDLLHandle, 'igTypingSelectFindNextSingleCharMatch');
  igUnindent := GetProcAddress(aDLLHandle, 'igUnindent');
  igUpdateHoveredWindowAndCaptureFlags := GetProcAddress(aDLLHandle, 'igUpdateHoveredWindowAndCaptureFlags');
  igUpdateInputEvents := GetProcAddress(aDLLHandle, 'igUpdateInputEvents');
  igUpdateMouseMovingWindowEndFrame := GetProcAddress(aDLLHandle, 'igUpdateMouseMovingWindowEndFrame');
  igUpdateMouseMovingWindowNewFrame := GetProcAddress(aDLLHandle, 'igUpdateMouseMovingWindowNewFrame');
  igUpdatePlatformWindows := GetProcAddress(aDLLHandle, 'igUpdatePlatformWindows');
  igUpdateWindowParentAndRootLinks := GetProcAddress(aDLLHandle, 'igUpdateWindowParentAndRootLinks');
  igUpdateWindowSkipRefresh := GetProcAddress(aDLLHandle, 'igUpdateWindowSkipRefresh');
  igValue_Bool := GetProcAddress(aDLLHandle, 'igValue_Bool');
  igValue_Float := GetProcAddress(aDLLHandle, 'igValue_Float');
  igValue_Int := GetProcAddress(aDLLHandle, 'igValue_Int');
  igValue_Uint := GetProcAddress(aDLLHandle, 'igValue_Uint');
  igVSliderFloat := GetProcAddress(aDLLHandle, 'igVSliderFloat');
  igVSliderInt := GetProcAddress(aDLLHandle, 'igVSliderInt');
  igVSliderScalar := GetProcAddress(aDLLHandle, 'igVSliderScalar');
  igWindowPosAbsToRel := GetProcAddress(aDLLHandle, 'igWindowPosAbsToRel');
  igWindowPosRelToAbs := GetProcAddress(aDLLHandle, 'igWindowPosRelToAbs');
  igWindowRectAbsToRel := GetProcAddress(aDLLHandle, 'igWindowRectAbsToRel');
  igWindowRectRelToAbs := GetProcAddress(aDLLHandle, 'igWindowRectRelToAbs');
  ImBitVector_Clear := GetProcAddress(aDLLHandle, 'ImBitVector_Clear');
  ImBitVector_ClearBit := GetProcAddress(aDLLHandle, 'ImBitVector_ClearBit');
  ImBitVector_Create := GetProcAddress(aDLLHandle, 'ImBitVector_Create');
  ImBitVector_SetBit := GetProcAddress(aDLLHandle, 'ImBitVector_SetBit');
  ImBitVector_TestBit := GetProcAddress(aDLLHandle, 'ImBitVector_TestBit');
  ImColor_destroy := GetProcAddress(aDLLHandle, 'ImColor_destroy');
  ImColor_HSV := GetProcAddress(aDLLHandle, 'ImColor_HSV');
  ImColor_ImColor_Float := GetProcAddress(aDLLHandle, 'ImColor_ImColor_Float');
  ImColor_ImColor_Int := GetProcAddress(aDLLHandle, 'ImColor_ImColor_Int');
  ImColor_ImColor_Nil := GetProcAddress(aDLLHandle, 'ImColor_ImColor_Nil');
  ImColor_ImColor_U32 := GetProcAddress(aDLLHandle, 'ImColor_ImColor_U32');
  ImColor_ImColor_Vec4 := GetProcAddress(aDLLHandle, 'ImColor_ImColor_Vec4');
  ImColor_SetHSV := GetProcAddress(aDLLHandle, 'ImColor_SetHSV');
  ImDrawCmd_destroy := GetProcAddress(aDLLHandle, 'ImDrawCmd_destroy');
  ImDrawCmd_GetTexID := GetProcAddress(aDLLHandle, 'ImDrawCmd_GetTexID');
  ImDrawCmd_ImDrawCmd := GetProcAddress(aDLLHandle, 'ImDrawCmd_ImDrawCmd');
  ImDrawData_AddDrawList := GetProcAddress(aDLLHandle, 'ImDrawData_AddDrawList');
  ImDrawData_Clear := GetProcAddress(aDLLHandle, 'ImDrawData_Clear');
  ImDrawData_DeIndexAllBuffers := GetProcAddress(aDLLHandle, 'ImDrawData_DeIndexAllBuffers');
  ImDrawData_destroy := GetProcAddress(aDLLHandle, 'ImDrawData_destroy');
  ImDrawData_ImDrawData := GetProcAddress(aDLLHandle, 'ImDrawData_ImDrawData');
  ImDrawData_ScaleClipRects := GetProcAddress(aDLLHandle, 'ImDrawData_ScaleClipRects');
  ImDrawDataBuilder_destroy := GetProcAddress(aDLLHandle, 'ImDrawDataBuilder_destroy');
  ImDrawDataBuilder_ImDrawDataBuilder := GetProcAddress(aDLLHandle, 'ImDrawDataBuilder_ImDrawDataBuilder');
  ImDrawList__CalcCircleAutoSegmentCount := GetProcAddress(aDLLHandle, 'ImDrawList__CalcCircleAutoSegmentCount');
  ImDrawList__ClearFreeMemory := GetProcAddress(aDLLHandle, 'ImDrawList__ClearFreeMemory');
  ImDrawList__OnChangedClipRect := GetProcAddress(aDLLHandle, 'ImDrawList__OnChangedClipRect');
  ImDrawList__OnChangedTextureID := GetProcAddress(aDLLHandle, 'ImDrawList__OnChangedTextureID');
  ImDrawList__OnChangedVtxOffset := GetProcAddress(aDLLHandle, 'ImDrawList__OnChangedVtxOffset');
  ImDrawList__PathArcToFastEx := GetProcAddress(aDLLHandle, 'ImDrawList__PathArcToFastEx');
  ImDrawList__PathArcToN := GetProcAddress(aDLLHandle, 'ImDrawList__PathArcToN');
  ImDrawList__PopUnusedDrawCmd := GetProcAddress(aDLLHandle, 'ImDrawList__PopUnusedDrawCmd');
  ImDrawList__ResetForNewFrame := GetProcAddress(aDLLHandle, 'ImDrawList__ResetForNewFrame');
  ImDrawList__SetTextureID := GetProcAddress(aDLLHandle, 'ImDrawList__SetTextureID');
  ImDrawList__TryMergeDrawCmds := GetProcAddress(aDLLHandle, 'ImDrawList__TryMergeDrawCmds');
  ImDrawList_AddBezierCubic := GetProcAddress(aDLLHandle, 'ImDrawList_AddBezierCubic');
  ImDrawList_AddBezierQuadratic := GetProcAddress(aDLLHandle, 'ImDrawList_AddBezierQuadratic');
  ImDrawList_AddCallback := GetProcAddress(aDLLHandle, 'ImDrawList_AddCallback');
  ImDrawList_AddCircle := GetProcAddress(aDLLHandle, 'ImDrawList_AddCircle');
  ImDrawList_AddCircleFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddCircleFilled');
  ImDrawList_AddConcavePolyFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddConcavePolyFilled');
  ImDrawList_AddConvexPolyFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddConvexPolyFilled');
  ImDrawList_AddDrawCmd := GetProcAddress(aDLLHandle, 'ImDrawList_AddDrawCmd');
  ImDrawList_AddEllipse := GetProcAddress(aDLLHandle, 'ImDrawList_AddEllipse');
  ImDrawList_AddEllipseFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddEllipseFilled');
  ImDrawList_AddImage := GetProcAddress(aDLLHandle, 'ImDrawList_AddImage');
  ImDrawList_AddImageQuad := GetProcAddress(aDLLHandle, 'ImDrawList_AddImageQuad');
  ImDrawList_AddImageRounded := GetProcAddress(aDLLHandle, 'ImDrawList_AddImageRounded');
  ImDrawList_AddLine := GetProcAddress(aDLLHandle, 'ImDrawList_AddLine');
  ImDrawList_AddNgon := GetProcAddress(aDLLHandle, 'ImDrawList_AddNgon');
  ImDrawList_AddNgonFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddNgonFilled');
  ImDrawList_AddPolyline := GetProcAddress(aDLLHandle, 'ImDrawList_AddPolyline');
  ImDrawList_AddQuad := GetProcAddress(aDLLHandle, 'ImDrawList_AddQuad');
  ImDrawList_AddQuadFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddQuadFilled');
  ImDrawList_AddRect := GetProcAddress(aDLLHandle, 'ImDrawList_AddRect');
  ImDrawList_AddRectFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddRectFilled');
  ImDrawList_AddRectFilledMultiColor := GetProcAddress(aDLLHandle, 'ImDrawList_AddRectFilledMultiColor');
  ImDrawList_AddText_FontPtr := GetProcAddress(aDLLHandle, 'ImDrawList_AddText_FontPtr');
  ImDrawList_AddText_Vec2 := GetProcAddress(aDLLHandle, 'ImDrawList_AddText_Vec2');
  ImDrawList_AddTriangle := GetProcAddress(aDLLHandle, 'ImDrawList_AddTriangle');
  ImDrawList_AddTriangleFilled := GetProcAddress(aDLLHandle, 'ImDrawList_AddTriangleFilled');
  ImDrawList_ChannelsMerge := GetProcAddress(aDLLHandle, 'ImDrawList_ChannelsMerge');
  ImDrawList_ChannelsSetCurrent := GetProcAddress(aDLLHandle, 'ImDrawList_ChannelsSetCurrent');
  ImDrawList_ChannelsSplit := GetProcAddress(aDLLHandle, 'ImDrawList_ChannelsSplit');
  ImDrawList_CloneOutput := GetProcAddress(aDLLHandle, 'ImDrawList_CloneOutput');
  ImDrawList_destroy := GetProcAddress(aDLLHandle, 'ImDrawList_destroy');
  ImDrawList_GetClipRectMax := GetProcAddress(aDLLHandle, 'ImDrawList_GetClipRectMax');
  ImDrawList_GetClipRectMin := GetProcAddress(aDLLHandle, 'ImDrawList_GetClipRectMin');
  ImDrawList_ImDrawList := GetProcAddress(aDLLHandle, 'ImDrawList_ImDrawList');
  ImDrawList_PathArcTo := GetProcAddress(aDLLHandle, 'ImDrawList_PathArcTo');
  ImDrawList_PathArcToFast := GetProcAddress(aDLLHandle, 'ImDrawList_PathArcToFast');
  ImDrawList_PathBezierCubicCurveTo := GetProcAddress(aDLLHandle, 'ImDrawList_PathBezierCubicCurveTo');
  ImDrawList_PathBezierQuadraticCurveTo := GetProcAddress(aDLLHandle, 'ImDrawList_PathBezierQuadraticCurveTo');
  ImDrawList_PathClear := GetProcAddress(aDLLHandle, 'ImDrawList_PathClear');
  ImDrawList_PathEllipticalArcTo := GetProcAddress(aDLLHandle, 'ImDrawList_PathEllipticalArcTo');
  ImDrawList_PathFillConcave := GetProcAddress(aDLLHandle, 'ImDrawList_PathFillConcave');
  ImDrawList_PathFillConvex := GetProcAddress(aDLLHandle, 'ImDrawList_PathFillConvex');
  ImDrawList_PathLineTo := GetProcAddress(aDLLHandle, 'ImDrawList_PathLineTo');
  ImDrawList_PathLineToMergeDuplicate := GetProcAddress(aDLLHandle, 'ImDrawList_PathLineToMergeDuplicate');
  ImDrawList_PathRect := GetProcAddress(aDLLHandle, 'ImDrawList_PathRect');
  ImDrawList_PathStroke := GetProcAddress(aDLLHandle, 'ImDrawList_PathStroke');
  ImDrawList_PopClipRect := GetProcAddress(aDLLHandle, 'ImDrawList_PopClipRect');
  ImDrawList_PopTextureID := GetProcAddress(aDLLHandle, 'ImDrawList_PopTextureID');
  ImDrawList_PrimQuadUV := GetProcAddress(aDLLHandle, 'ImDrawList_PrimQuadUV');
  ImDrawList_PrimRect := GetProcAddress(aDLLHandle, 'ImDrawList_PrimRect');
  ImDrawList_PrimRectUV := GetProcAddress(aDLLHandle, 'ImDrawList_PrimRectUV');
  ImDrawList_PrimReserve := GetProcAddress(aDLLHandle, 'ImDrawList_PrimReserve');
  ImDrawList_PrimUnreserve := GetProcAddress(aDLLHandle, 'ImDrawList_PrimUnreserve');
  ImDrawList_PrimVtx := GetProcAddress(aDLLHandle, 'ImDrawList_PrimVtx');
  ImDrawList_PrimWriteIdx := GetProcAddress(aDLLHandle, 'ImDrawList_PrimWriteIdx');
  ImDrawList_PrimWriteVtx := GetProcAddress(aDLLHandle, 'ImDrawList_PrimWriteVtx');
  ImDrawList_PushClipRect := GetProcAddress(aDLLHandle, 'ImDrawList_PushClipRect');
  ImDrawList_PushClipRectFullScreen := GetProcAddress(aDLLHandle, 'ImDrawList_PushClipRectFullScreen');
  ImDrawList_PushTextureID := GetProcAddress(aDLLHandle, 'ImDrawList_PushTextureID');
  ImDrawListSharedData_destroy := GetProcAddress(aDLLHandle, 'ImDrawListSharedData_destroy');
  ImDrawListSharedData_ImDrawListSharedData := GetProcAddress(aDLLHandle, 'ImDrawListSharedData_ImDrawListSharedData');
  ImDrawListSharedData_SetCircleTessellationMaxError := GetProcAddress(aDLLHandle, 'ImDrawListSharedData_SetCircleTessellationMaxError');
  ImDrawListSplitter_Clear := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_Clear');
  ImDrawListSplitter_ClearFreeMemory := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_ClearFreeMemory');
  ImDrawListSplitter_destroy := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_destroy');
  ImDrawListSplitter_ImDrawListSplitter := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_ImDrawListSplitter');
  ImDrawListSplitter_Merge := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_Merge');
  ImDrawListSplitter_SetCurrentChannel := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_SetCurrentChannel');
  ImDrawListSplitter_Split := GetProcAddress(aDLLHandle, 'ImDrawListSplitter_Split');
  ImFont_AddGlyph := GetProcAddress(aDLLHandle, 'ImFont_AddGlyph');
  ImFont_AddRemapChar := GetProcAddress(aDLLHandle, 'ImFont_AddRemapChar');
  ImFont_BuildLookupTable := GetProcAddress(aDLLHandle, 'ImFont_BuildLookupTable');
  ImFont_CalcTextSizeA := GetProcAddress(aDLLHandle, 'ImFont_CalcTextSizeA');
  ImFont_CalcWordWrapPositionA := GetProcAddress(aDLLHandle, 'ImFont_CalcWordWrapPositionA');
  ImFont_ClearOutputData := GetProcAddress(aDLLHandle, 'ImFont_ClearOutputData');
  ImFont_destroy := GetProcAddress(aDLLHandle, 'ImFont_destroy');
  ImFont_FindGlyph := GetProcAddress(aDLLHandle, 'ImFont_FindGlyph');
  ImFont_FindGlyphNoFallback := GetProcAddress(aDLLHandle, 'ImFont_FindGlyphNoFallback');
  ImFont_GetCharAdvance := GetProcAddress(aDLLHandle, 'ImFont_GetCharAdvance');
  ImFont_GetDebugName := GetProcAddress(aDLLHandle, 'ImFont_GetDebugName');
  ImFont_GrowIndex := GetProcAddress(aDLLHandle, 'ImFont_GrowIndex');
  ImFont_ImFont := GetProcAddress(aDLLHandle, 'ImFont_ImFont');
  ImFont_IsGlyphRangeUnused := GetProcAddress(aDLLHandle, 'ImFont_IsGlyphRangeUnused');
  ImFont_IsLoaded := GetProcAddress(aDLLHandle, 'ImFont_IsLoaded');
  ImFont_RenderChar := GetProcAddress(aDLLHandle, 'ImFont_RenderChar');
  ImFont_RenderText := GetProcAddress(aDLLHandle, 'ImFont_RenderText');
  ImFont_SetGlyphVisible := GetProcAddress(aDLLHandle, 'ImFont_SetGlyphVisible');
  ImFontAtlas_AddCustomRectFontGlyph := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddCustomRectFontGlyph');
  ImFontAtlas_AddCustomRectRegular := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddCustomRectRegular');
  ImFontAtlas_AddFont := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFont');
  ImFontAtlas_AddFontDefault := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFontDefault');
  ImFontAtlas_AddFontFromFileTTF := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFontFromFileTTF');
  ImFontAtlas_AddFontFromMemoryCompressedBase85TTF := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFontFromMemoryCompressedBase85TTF');
  ImFontAtlas_AddFontFromMemoryCompressedTTF := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFontFromMemoryCompressedTTF');
  ImFontAtlas_AddFontFromMemoryTTF := GetProcAddress(aDLLHandle, 'ImFontAtlas_AddFontFromMemoryTTF');
  ImFontAtlas_Build := GetProcAddress(aDLLHandle, 'ImFontAtlas_Build');
  ImFontAtlas_CalcCustomRectUV := GetProcAddress(aDLLHandle, 'ImFontAtlas_CalcCustomRectUV');
  ImFontAtlas_Clear := GetProcAddress(aDLLHandle, 'ImFontAtlas_Clear');
  ImFontAtlas_ClearFonts := GetProcAddress(aDLLHandle, 'ImFontAtlas_ClearFonts');
  ImFontAtlas_ClearInputData := GetProcAddress(aDLLHandle, 'ImFontAtlas_ClearInputData');
  ImFontAtlas_ClearTexData := GetProcAddress(aDLLHandle, 'ImFontAtlas_ClearTexData');
  ImFontAtlas_destroy := GetProcAddress(aDLLHandle, 'ImFontAtlas_destroy');
  ImFontAtlas_GetCustomRectByIndex := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetCustomRectByIndex');
  ImFontAtlas_GetGlyphRangesChineseFull := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesChineseFull');
  ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon');
  ImFontAtlas_GetGlyphRangesCyrillic := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesCyrillic');
  ImFontAtlas_GetGlyphRangesDefault := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesDefault');
  ImFontAtlas_GetGlyphRangesGreek := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesGreek');
  ImFontAtlas_GetGlyphRangesJapanese := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesJapanese');
  ImFontAtlas_GetGlyphRangesKorean := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesKorean');
  ImFontAtlas_GetGlyphRangesThai := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesThai');
  ImFontAtlas_GetGlyphRangesVietnamese := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetGlyphRangesVietnamese');
  ImFontAtlas_GetMouseCursorTexData := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetMouseCursorTexData');
  ImFontAtlas_GetTexDataAsAlpha8 := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetTexDataAsAlpha8');
  ImFontAtlas_GetTexDataAsRGBA32 := GetProcAddress(aDLLHandle, 'ImFontAtlas_GetTexDataAsRGBA32');
  ImFontAtlas_ImFontAtlas := GetProcAddress(aDLLHandle, 'ImFontAtlas_ImFontAtlas');
  ImFontAtlas_IsBuilt := GetProcAddress(aDLLHandle, 'ImFontAtlas_IsBuilt');
  ImFontAtlas_SetTexID := GetProcAddress(aDLLHandle, 'ImFontAtlas_SetTexID');
  ImFontAtlasCustomRect_destroy := GetProcAddress(aDLLHandle, 'ImFontAtlasCustomRect_destroy');
  ImFontAtlasCustomRect_ImFontAtlasCustomRect := GetProcAddress(aDLLHandle, 'ImFontAtlasCustomRect_ImFontAtlasCustomRect');
  ImFontAtlasCustomRect_IsPacked := GetProcAddress(aDLLHandle, 'ImFontAtlasCustomRect_IsPacked');
  ImFontConfig_destroy := GetProcAddress(aDLLHandle, 'ImFontConfig_destroy');
  ImFontConfig_ImFontConfig := GetProcAddress(aDLLHandle, 'ImFontConfig_ImFontConfig');
  ImFontGlyphRangesBuilder_AddChar := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_AddChar');
  ImFontGlyphRangesBuilder_AddRanges := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_AddRanges');
  ImFontGlyphRangesBuilder_AddText := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_AddText');
  ImFontGlyphRangesBuilder_BuildRanges := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_BuildRanges');
  ImFontGlyphRangesBuilder_Clear := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_Clear');
  ImFontGlyphRangesBuilder_destroy := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_destroy');
  ImFontGlyphRangesBuilder_GetBit := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_GetBit');
  ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder');
  ImFontGlyphRangesBuilder_SetBit := GetProcAddress(aDLLHandle, 'ImFontGlyphRangesBuilder_SetBit');
  ImGui_ImplGlfw_CharCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_CharCallback');
  ImGui_ImplGlfw_CursorEnterCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_CursorEnterCallback');
  ImGui_ImplGlfw_CursorPosCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_CursorPosCallback');
  ImGui_ImplGlfw_InitForOpenGL := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_InitForOpenGL');
  ImGui_ImplGlfw_InitForOther := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_InitForOther');
  ImGui_ImplGlfw_InitForVulkan := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_InitForVulkan');
  ImGui_ImplGlfw_InstallCallbacks := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_InstallCallbacks');
  ImGui_ImplGlfw_KeyCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_KeyCallback');
  ImGui_ImplGlfw_MonitorCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_MonitorCallback');
  ImGui_ImplGlfw_MouseButtonCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_MouseButtonCallback');
  ImGui_ImplGlfw_NewFrame := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_NewFrame');
  ImGui_ImplGlfw_RestoreCallbacks := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_RestoreCallbacks');
  ImGui_ImplGlfw_ScrollCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_ScrollCallback');
  ImGui_ImplGlfw_SetCallbacksChainForAllWindows := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_SetCallbacksChainForAllWindows');
  ImGui_ImplGlfw_Shutdown := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_Shutdown');
  ImGui_ImplGlfw_Sleep := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_Sleep');
  ImGui_ImplGlfw_WindowFocusCallback := GetProcAddress(aDLLHandle, 'ImGui_ImplGlfw_WindowFocusCallback');
  ImGui_ImplOpenGL2_CreateDeviceObjects := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_CreateDeviceObjects');
  ImGui_ImplOpenGL2_CreateFontsTexture := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_CreateFontsTexture');
  ImGui_ImplOpenGL2_DestroyDeviceObjects := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_DestroyDeviceObjects');
  ImGui_ImplOpenGL2_DestroyFontsTexture := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_DestroyFontsTexture');
  ImGui_ImplOpenGL2_Init := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_Init');
  ImGui_ImplOpenGL2_NewFrame := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_NewFrame');
  ImGui_ImplOpenGL2_RenderDrawData := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_RenderDrawData');
  ImGui_ImplOpenGL2_Shutdown := GetProcAddress(aDLLHandle, 'ImGui_ImplOpenGL2_Shutdown');
  ImGuiBoxSelectState_destroy := GetProcAddress(aDLLHandle, 'ImGuiBoxSelectState_destroy');
  ImGuiBoxSelectState_ImGuiBoxSelectState := GetProcAddress(aDLLHandle, 'ImGuiBoxSelectState_ImGuiBoxSelectState');
  ImGuiComboPreviewData_destroy := GetProcAddress(aDLLHandle, 'ImGuiComboPreviewData_destroy');
  ImGuiComboPreviewData_ImGuiComboPreviewData := GetProcAddress(aDLLHandle, 'ImGuiComboPreviewData_ImGuiComboPreviewData');
  ImGuiContext_destroy := GetProcAddress(aDLLHandle, 'ImGuiContext_destroy');
  ImGuiContext_ImGuiContext := GetProcAddress(aDLLHandle, 'ImGuiContext_ImGuiContext');
  ImGuiContextHook_destroy := GetProcAddress(aDLLHandle, 'ImGuiContextHook_destroy');
  ImGuiContextHook_ImGuiContextHook := GetProcAddress(aDLLHandle, 'ImGuiContextHook_ImGuiContextHook');
  ImGuiDataVarInfo_GetVarPtr := GetProcAddress(aDLLHandle, 'ImGuiDataVarInfo_GetVarPtr');
  ImGuiDebugAllocInfo_destroy := GetProcAddress(aDLLHandle, 'ImGuiDebugAllocInfo_destroy');
  ImGuiDebugAllocInfo_ImGuiDebugAllocInfo := GetProcAddress(aDLLHandle, 'ImGuiDebugAllocInfo_ImGuiDebugAllocInfo');
  ImGuiDockContext_destroy := GetProcAddress(aDLLHandle, 'ImGuiDockContext_destroy');
  ImGuiDockContext_ImGuiDockContext := GetProcAddress(aDLLHandle, 'ImGuiDockContext_ImGuiDockContext');
  ImGuiDockNode_destroy := GetProcAddress(aDLLHandle, 'ImGuiDockNode_destroy');
  ImGuiDockNode_ImGuiDockNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_ImGuiDockNode');
  ImGuiDockNode_IsCentralNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsCentralNode');
  ImGuiDockNode_IsDockSpace := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsDockSpace');
  ImGuiDockNode_IsEmpty := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsEmpty');
  ImGuiDockNode_IsFloatingNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsFloatingNode');
  ImGuiDockNode_IsHiddenTabBar := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsHiddenTabBar');
  ImGuiDockNode_IsLeafNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsLeafNode');
  ImGuiDockNode_IsNoTabBar := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsNoTabBar');
  ImGuiDockNode_IsRootNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsRootNode');
  ImGuiDockNode_IsSplitNode := GetProcAddress(aDLLHandle, 'ImGuiDockNode_IsSplitNode');
  ImGuiDockNode_Rect := GetProcAddress(aDLLHandle, 'ImGuiDockNode_Rect');
  ImGuiDockNode_SetLocalFlags := GetProcAddress(aDLLHandle, 'ImGuiDockNode_SetLocalFlags');
  ImGuiDockNode_UpdateMergedFlags := GetProcAddress(aDLLHandle, 'ImGuiDockNode_UpdateMergedFlags');
  ImGuiErrorRecoveryState_destroy := GetProcAddress(aDLLHandle, 'ImGuiErrorRecoveryState_destroy');
  ImGuiErrorRecoveryState_ImGuiErrorRecoveryState := GetProcAddress(aDLLHandle, 'ImGuiErrorRecoveryState_ImGuiErrorRecoveryState');
  ImGuiIDStackTool_destroy := GetProcAddress(aDLLHandle, 'ImGuiIDStackTool_destroy');
  ImGuiIDStackTool_ImGuiIDStackTool := GetProcAddress(aDLLHandle, 'ImGuiIDStackTool_ImGuiIDStackTool');
  ImGuiInputEvent_destroy := GetProcAddress(aDLLHandle, 'ImGuiInputEvent_destroy');
  ImGuiInputEvent_ImGuiInputEvent := GetProcAddress(aDLLHandle, 'ImGuiInputEvent_ImGuiInputEvent');
  ImGuiInputTextCallbackData_ClearSelection := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_ClearSelection');
  ImGuiInputTextCallbackData_DeleteChars := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_DeleteChars');
  ImGuiInputTextCallbackData_destroy := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_destroy');
  ImGuiInputTextCallbackData_HasSelection := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_HasSelection');
  ImGuiInputTextCallbackData_ImGuiInputTextCallbackData := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_ImGuiInputTextCallbackData');
  ImGuiInputTextCallbackData_InsertChars := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_InsertChars');
  ImGuiInputTextCallbackData_SelectAll := GetProcAddress(aDLLHandle, 'ImGuiInputTextCallbackData_SelectAll');
  ImGuiInputTextDeactivatedState_ClearFreeMemory := GetProcAddress(aDLLHandle, 'ImGuiInputTextDeactivatedState_ClearFreeMemory');
  ImGuiInputTextDeactivatedState_destroy := GetProcAddress(aDLLHandle, 'ImGuiInputTextDeactivatedState_destroy');
  ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState := GetProcAddress(aDLLHandle, 'ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState');
  ImGuiInputTextState_ClearFreeMemory := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ClearFreeMemory');
  ImGuiInputTextState_ClearSelection := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ClearSelection');
  ImGuiInputTextState_ClearText := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ClearText');
  ImGuiInputTextState_CursorAnimReset := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_CursorAnimReset');
  ImGuiInputTextState_CursorClamp := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_CursorClamp');
  ImGuiInputTextState_destroy := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_destroy');
  ImGuiInputTextState_GetCursorPos := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_GetCursorPos');
  ImGuiInputTextState_GetSelectionEnd := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_GetSelectionEnd');
  ImGuiInputTextState_GetSelectionStart := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_GetSelectionStart');
  ImGuiInputTextState_HasSelection := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_HasSelection');
  ImGuiInputTextState_ImGuiInputTextState := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ImGuiInputTextState');
  ImGuiInputTextState_OnCharPressed := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_OnCharPressed');
  ImGuiInputTextState_OnKeyPressed := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_OnKeyPressed');
  ImGuiInputTextState_ReloadUserBufAndKeepSelection := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ReloadUserBufAndKeepSelection');
  ImGuiInputTextState_ReloadUserBufAndMoveToEnd := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ReloadUserBufAndMoveToEnd');
  ImGuiInputTextState_ReloadUserBufAndSelectAll := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_ReloadUserBufAndSelectAll');
  ImGuiInputTextState_SelectAll := GetProcAddress(aDLLHandle, 'ImGuiInputTextState_SelectAll');
  ImGuiIO_AddFocusEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddFocusEvent');
  ImGuiIO_AddInputCharacter := GetProcAddress(aDLLHandle, 'ImGuiIO_AddInputCharacter');
  ImGuiIO_AddInputCharactersUTF8 := GetProcAddress(aDLLHandle, 'ImGuiIO_AddInputCharactersUTF8');
  ImGuiIO_AddInputCharacterUTF16 := GetProcAddress(aDLLHandle, 'ImGuiIO_AddInputCharacterUTF16');
  ImGuiIO_AddKeyAnalogEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddKeyAnalogEvent');
  ImGuiIO_AddKeyEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddKeyEvent');
  ImGuiIO_AddMouseButtonEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddMouseButtonEvent');
  ImGuiIO_AddMousePosEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddMousePosEvent');
  ImGuiIO_AddMouseSourceEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddMouseSourceEvent');
  ImGuiIO_AddMouseViewportEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddMouseViewportEvent');
  ImGuiIO_AddMouseWheelEvent := GetProcAddress(aDLLHandle, 'ImGuiIO_AddMouseWheelEvent');
  ImGuiIO_ClearEventsQueue := GetProcAddress(aDLLHandle, 'ImGuiIO_ClearEventsQueue');
  ImGuiIO_ClearInputKeys := GetProcAddress(aDLLHandle, 'ImGuiIO_ClearInputKeys');
  ImGuiIO_ClearInputMouse := GetProcAddress(aDLLHandle, 'ImGuiIO_ClearInputMouse');
  ImGuiIO_destroy := GetProcAddress(aDLLHandle, 'ImGuiIO_destroy');
  ImGuiIO_ImGuiIO := GetProcAddress(aDLLHandle, 'ImGuiIO_ImGuiIO');
  ImGuiIO_SetAppAcceptingEvents := GetProcAddress(aDLLHandle, 'ImGuiIO_SetAppAcceptingEvents');
  ImGuiIO_SetKeyEventNativeData := GetProcAddress(aDLLHandle, 'ImGuiIO_SetKeyEventNativeData');
  ImGuiKeyOwnerData_destroy := GetProcAddress(aDLLHandle, 'ImGuiKeyOwnerData_destroy');
  ImGuiKeyOwnerData_ImGuiKeyOwnerData := GetProcAddress(aDLLHandle, 'ImGuiKeyOwnerData_ImGuiKeyOwnerData');
  ImGuiKeyRoutingData_destroy := GetProcAddress(aDLLHandle, 'ImGuiKeyRoutingData_destroy');
  ImGuiKeyRoutingData_ImGuiKeyRoutingData := GetProcAddress(aDLLHandle, 'ImGuiKeyRoutingData_ImGuiKeyRoutingData');
  ImGuiKeyRoutingTable_Clear := GetProcAddress(aDLLHandle, 'ImGuiKeyRoutingTable_Clear');
  ImGuiKeyRoutingTable_destroy := GetProcAddress(aDLLHandle, 'ImGuiKeyRoutingTable_destroy');
  ImGuiKeyRoutingTable_ImGuiKeyRoutingTable := GetProcAddress(aDLLHandle, 'ImGuiKeyRoutingTable_ImGuiKeyRoutingTable');
  ImGuiLastItemData_destroy := GetProcAddress(aDLLHandle, 'ImGuiLastItemData_destroy');
  ImGuiLastItemData_ImGuiLastItemData := GetProcAddress(aDLLHandle, 'ImGuiLastItemData_ImGuiLastItemData');
  ImGuiListClipper_Begin := GetProcAddress(aDLLHandle, 'ImGuiListClipper_Begin');
  ImGuiListClipper_destroy := GetProcAddress(aDLLHandle, 'ImGuiListClipper_destroy');
  ImGuiListClipper_End := GetProcAddress(aDLLHandle, 'ImGuiListClipper_End');
  ImGuiListClipper_ImGuiListClipper := GetProcAddress(aDLLHandle, 'ImGuiListClipper_ImGuiListClipper');
  ImGuiListClipper_IncludeItemByIndex := GetProcAddress(aDLLHandle, 'ImGuiListClipper_IncludeItemByIndex');
  ImGuiListClipper_IncludeItemsByIndex := GetProcAddress(aDLLHandle, 'ImGuiListClipper_IncludeItemsByIndex');
  ImGuiListClipper_SeekCursorForItem := GetProcAddress(aDLLHandle, 'ImGuiListClipper_SeekCursorForItem');
  ImGuiListClipper_Step := GetProcAddress(aDLLHandle, 'ImGuiListClipper_Step');
  ImGuiListClipperData_destroy := GetProcAddress(aDLLHandle, 'ImGuiListClipperData_destroy');
  ImGuiListClipperData_ImGuiListClipperData := GetProcAddress(aDLLHandle, 'ImGuiListClipperData_ImGuiListClipperData');
  ImGuiListClipperData_Reset := GetProcAddress(aDLLHandle, 'ImGuiListClipperData_Reset');
  ImGuiListClipperRange_FromIndices := GetProcAddress(aDLLHandle, 'ImGuiListClipperRange_FromIndices');
  ImGuiListClipperRange_FromPositions := GetProcAddress(aDLLHandle, 'ImGuiListClipperRange_FromPositions');
  ImGuiMenuColumns_CalcNextTotalWidth := GetProcAddress(aDLLHandle, 'ImGuiMenuColumns_CalcNextTotalWidth');
  ImGuiMenuColumns_DeclColumns := GetProcAddress(aDLLHandle, 'ImGuiMenuColumns_DeclColumns');
  ImGuiMenuColumns_destroy := GetProcAddress(aDLLHandle, 'ImGuiMenuColumns_destroy');
  ImGuiMenuColumns_ImGuiMenuColumns := GetProcAddress(aDLLHandle, 'ImGuiMenuColumns_ImGuiMenuColumns');
  ImGuiMenuColumns_Update := GetProcAddress(aDLLHandle, 'ImGuiMenuColumns_Update');
  ImGuiMultiSelectState_destroy := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectState_destroy');
  ImGuiMultiSelectState_ImGuiMultiSelectState := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectState_ImGuiMultiSelectState');
  ImGuiMultiSelectTempData_Clear := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectTempData_Clear');
  ImGuiMultiSelectTempData_ClearIO := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectTempData_ClearIO');
  ImGuiMultiSelectTempData_destroy := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectTempData_destroy');
  ImGuiMultiSelectTempData_ImGuiMultiSelectTempData := GetProcAddress(aDLLHandle, 'ImGuiMultiSelectTempData_ImGuiMultiSelectTempData');
  ImGuiNavItemData_Clear := GetProcAddress(aDLLHandle, 'ImGuiNavItemData_Clear');
  ImGuiNavItemData_destroy := GetProcAddress(aDLLHandle, 'ImGuiNavItemData_destroy');
  ImGuiNavItemData_ImGuiNavItemData := GetProcAddress(aDLLHandle, 'ImGuiNavItemData_ImGuiNavItemData');
  ImGuiNextItemData_ClearFlags := GetProcAddress(aDLLHandle, 'ImGuiNextItemData_ClearFlags');
  ImGuiNextItemData_destroy := GetProcAddress(aDLLHandle, 'ImGuiNextItemData_destroy');
  ImGuiNextItemData_ImGuiNextItemData := GetProcAddress(aDLLHandle, 'ImGuiNextItemData_ImGuiNextItemData');
  ImGuiNextWindowData_ClearFlags := GetProcAddress(aDLLHandle, 'ImGuiNextWindowData_ClearFlags');
  ImGuiNextWindowData_destroy := GetProcAddress(aDLLHandle, 'ImGuiNextWindowData_destroy');
  ImGuiNextWindowData_ImGuiNextWindowData := GetProcAddress(aDLLHandle, 'ImGuiNextWindowData_ImGuiNextWindowData');
  ImGuiOldColumnData_destroy := GetProcAddress(aDLLHandle, 'ImGuiOldColumnData_destroy');
  ImGuiOldColumnData_ImGuiOldColumnData := GetProcAddress(aDLLHandle, 'ImGuiOldColumnData_ImGuiOldColumnData');
  ImGuiOldColumns_destroy := GetProcAddress(aDLLHandle, 'ImGuiOldColumns_destroy');
  ImGuiOldColumns_ImGuiOldColumns := GetProcAddress(aDLLHandle, 'ImGuiOldColumns_ImGuiOldColumns');
  ImGuiOnceUponAFrame_destroy := GetProcAddress(aDLLHandle, 'ImGuiOnceUponAFrame_destroy');
  ImGuiOnceUponAFrame_ImGuiOnceUponAFrame := GetProcAddress(aDLLHandle, 'ImGuiOnceUponAFrame_ImGuiOnceUponAFrame');
  ImGuiPayload_Clear := GetProcAddress(aDLLHandle, 'ImGuiPayload_Clear');
  ImGuiPayload_destroy := GetProcAddress(aDLLHandle, 'ImGuiPayload_destroy');
  ImGuiPayload_ImGuiPayload := GetProcAddress(aDLLHandle, 'ImGuiPayload_ImGuiPayload');
  ImGuiPayload_IsDataType := GetProcAddress(aDLLHandle, 'ImGuiPayload_IsDataType');
  ImGuiPayload_IsDelivery := GetProcAddress(aDLLHandle, 'ImGuiPayload_IsDelivery');
  ImGuiPayload_IsPreview := GetProcAddress(aDLLHandle, 'ImGuiPayload_IsPreview');
  ImGuiPlatformImeData_destroy := GetProcAddress(aDLLHandle, 'ImGuiPlatformImeData_destroy');
  ImGuiPlatformImeData_ImGuiPlatformImeData := GetProcAddress(aDLLHandle, 'ImGuiPlatformImeData_ImGuiPlatformImeData');
  ImGuiPlatformIO_destroy := GetProcAddress(aDLLHandle, 'ImGuiPlatformIO_destroy');
  ImGuiPlatformIO_ImGuiPlatformIO := GetProcAddress(aDLLHandle, 'ImGuiPlatformIO_ImGuiPlatformIO');
  ImGuiPlatformIO_Set_Platform_GetWindowPos := GetProcAddress(aDLLHandle, 'ImGuiPlatformIO_Set_Platform_GetWindowPos');
  ImGuiPlatformIO_Set_Platform_GetWindowSize := GetProcAddress(aDLLHandle, 'ImGuiPlatformIO_Set_Platform_GetWindowSize');
  ImGuiPlatformMonitor_destroy := GetProcAddress(aDLLHandle, 'ImGuiPlatformMonitor_destroy');
  ImGuiPlatformMonitor_ImGuiPlatformMonitor := GetProcAddress(aDLLHandle, 'ImGuiPlatformMonitor_ImGuiPlatformMonitor');
  ImGuiPopupData_destroy := GetProcAddress(aDLLHandle, 'ImGuiPopupData_destroy');
  ImGuiPopupData_ImGuiPopupData := GetProcAddress(aDLLHandle, 'ImGuiPopupData_ImGuiPopupData');
  ImGuiPtrOrIndex_destroy := GetProcAddress(aDLLHandle, 'ImGuiPtrOrIndex_destroy');
  ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int := GetProcAddress(aDLLHandle, 'ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int');
  ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr := GetProcAddress(aDLLHandle, 'ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr');
  ImGuiSelectionBasicStorage_ApplyRequests := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_ApplyRequests');
  ImGuiSelectionBasicStorage_Clear := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_Clear');
  ImGuiSelectionBasicStorage_Contains := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_Contains');
  ImGuiSelectionBasicStorage_destroy := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_destroy');
  ImGuiSelectionBasicStorage_GetNextSelectedItem := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_GetNextSelectedItem');
  ImGuiSelectionBasicStorage_GetStorageIdFromIndex := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_GetStorageIdFromIndex');
  ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage');
  ImGuiSelectionBasicStorage_SetItemSelected := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_SetItemSelected');
  ImGuiSelectionBasicStorage_Swap := GetProcAddress(aDLLHandle, 'ImGuiSelectionBasicStorage_Swap');
  ImGuiSelectionExternalStorage_ApplyRequests := GetProcAddress(aDLLHandle, 'ImGuiSelectionExternalStorage_ApplyRequests');
  ImGuiSelectionExternalStorage_destroy := GetProcAddress(aDLLHandle, 'ImGuiSelectionExternalStorage_destroy');
  ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage := GetProcAddress(aDLLHandle, 'ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage');
  ImGuiSettingsHandler_destroy := GetProcAddress(aDLLHandle, 'ImGuiSettingsHandler_destroy');
  ImGuiSettingsHandler_ImGuiSettingsHandler := GetProcAddress(aDLLHandle, 'ImGuiSettingsHandler_ImGuiSettingsHandler');
  ImGuiStackLevelInfo_destroy := GetProcAddress(aDLLHandle, 'ImGuiStackLevelInfo_destroy');
  ImGuiStackLevelInfo_ImGuiStackLevelInfo := GetProcAddress(aDLLHandle, 'ImGuiStackLevelInfo_ImGuiStackLevelInfo');
  ImGuiStorage_BuildSortByKey := GetProcAddress(aDLLHandle, 'ImGuiStorage_BuildSortByKey');
  ImGuiStorage_Clear := GetProcAddress(aDLLHandle, 'ImGuiStorage_Clear');
  ImGuiStorage_GetBool := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetBool');
  ImGuiStorage_GetBoolRef := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetBoolRef');
  ImGuiStorage_GetFloat := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetFloat');
  ImGuiStorage_GetFloatRef := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetFloatRef');
  ImGuiStorage_GetInt := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetInt');
  ImGuiStorage_GetIntRef := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetIntRef');
  ImGuiStorage_GetVoidPtr := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetVoidPtr');
  ImGuiStorage_GetVoidPtrRef := GetProcAddress(aDLLHandle, 'ImGuiStorage_GetVoidPtrRef');
  ImGuiStorage_SetAllInt := GetProcAddress(aDLLHandle, 'ImGuiStorage_SetAllInt');
  ImGuiStorage_SetBool := GetProcAddress(aDLLHandle, 'ImGuiStorage_SetBool');
  ImGuiStorage_SetFloat := GetProcAddress(aDLLHandle, 'ImGuiStorage_SetFloat');
  ImGuiStorage_SetInt := GetProcAddress(aDLLHandle, 'ImGuiStorage_SetInt');
  ImGuiStorage_SetVoidPtr := GetProcAddress(aDLLHandle, 'ImGuiStorage_SetVoidPtr');
  ImGuiStoragePair_destroy := GetProcAddress(aDLLHandle, 'ImGuiStoragePair_destroy');
  ImGuiStoragePair_ImGuiStoragePair_Float := GetProcAddress(aDLLHandle, 'ImGuiStoragePair_ImGuiStoragePair_Float');
  ImGuiStoragePair_ImGuiStoragePair_Int := GetProcAddress(aDLLHandle, 'ImGuiStoragePair_ImGuiStoragePair_Int');
  ImGuiStoragePair_ImGuiStoragePair_Ptr := GetProcAddress(aDLLHandle, 'ImGuiStoragePair_ImGuiStoragePair_Ptr');
  ImGuiStyle_destroy := GetProcAddress(aDLLHandle, 'ImGuiStyle_destroy');
  ImGuiStyle_ImGuiStyle := GetProcAddress(aDLLHandle, 'ImGuiStyle_ImGuiStyle');
  ImGuiStyle_ScaleAllSizes := GetProcAddress(aDLLHandle, 'ImGuiStyle_ScaleAllSizes');
  ImGuiStyleMod_destroy := GetProcAddress(aDLLHandle, 'ImGuiStyleMod_destroy');
  ImGuiStyleMod_ImGuiStyleMod_Float := GetProcAddress(aDLLHandle, 'ImGuiStyleMod_ImGuiStyleMod_Float');
  ImGuiStyleMod_ImGuiStyleMod_Int := GetProcAddress(aDLLHandle, 'ImGuiStyleMod_ImGuiStyleMod_Int');
  ImGuiStyleMod_ImGuiStyleMod_Vec2 := GetProcAddress(aDLLHandle, 'ImGuiStyleMod_ImGuiStyleMod_Vec2');
  ImGuiTabBar_destroy := GetProcAddress(aDLLHandle, 'ImGuiTabBar_destroy');
  ImGuiTabBar_ImGuiTabBar := GetProcAddress(aDLLHandle, 'ImGuiTabBar_ImGuiTabBar');
  ImGuiTabItem_destroy := GetProcAddress(aDLLHandle, 'ImGuiTabItem_destroy');
  ImGuiTabItem_ImGuiTabItem := GetProcAddress(aDLLHandle, 'ImGuiTabItem_ImGuiTabItem');
  ImGuiTable_destroy := GetProcAddress(aDLLHandle, 'ImGuiTable_destroy');
  ImGuiTable_ImGuiTable := GetProcAddress(aDLLHandle, 'ImGuiTable_ImGuiTable');
  ImGuiTableColumn_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableColumn_destroy');
  ImGuiTableColumn_ImGuiTableColumn := GetProcAddress(aDLLHandle, 'ImGuiTableColumn_ImGuiTableColumn');
  ImGuiTableColumnSettings_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableColumnSettings_destroy');
  ImGuiTableColumnSettings_ImGuiTableColumnSettings := GetProcAddress(aDLLHandle, 'ImGuiTableColumnSettings_ImGuiTableColumnSettings');
  ImGuiTableColumnSortSpecs_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableColumnSortSpecs_destroy');
  ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs := GetProcAddress(aDLLHandle, 'ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs');
  ImGuiTableInstanceData_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableInstanceData_destroy');
  ImGuiTableInstanceData_ImGuiTableInstanceData := GetProcAddress(aDLLHandle, 'ImGuiTableInstanceData_ImGuiTableInstanceData');
  ImGuiTableSettings_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableSettings_destroy');
  ImGuiTableSettings_GetColumnSettings := GetProcAddress(aDLLHandle, 'ImGuiTableSettings_GetColumnSettings');
  ImGuiTableSettings_ImGuiTableSettings := GetProcAddress(aDLLHandle, 'ImGuiTableSettings_ImGuiTableSettings');
  ImGuiTableSortSpecs_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableSortSpecs_destroy');
  ImGuiTableSortSpecs_ImGuiTableSortSpecs := GetProcAddress(aDLLHandle, 'ImGuiTableSortSpecs_ImGuiTableSortSpecs');
  ImGuiTableTempData_destroy := GetProcAddress(aDLLHandle, 'ImGuiTableTempData_destroy');
  ImGuiTableTempData_ImGuiTableTempData := GetProcAddress(aDLLHandle, 'ImGuiTableTempData_ImGuiTableTempData');
  ImGuiTextBuffer_append := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_append');
  ImGuiTextBuffer_appendf := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_appendf');
  ImGuiTextBuffer_appendfv := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_appendfv');
  ImGuiTextBuffer_begin := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_begin');
  ImGuiTextBuffer_c_str := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_c_str');
  ImGuiTextBuffer_clear := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_clear');
  ImGuiTextBuffer_destroy := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_destroy');
  ImGuiTextBuffer_empty := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_empty');
  ImGuiTextBuffer_end := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_end');
  ImGuiTextBuffer_ImGuiTextBuffer := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_ImGuiTextBuffer');
  ImGuiTextBuffer_reserve := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_reserve');
  ImGuiTextBuffer_size := GetProcAddress(aDLLHandle, 'ImGuiTextBuffer_size');
  ImGuiTextFilter_Build := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_Build');
  ImGuiTextFilter_Clear := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_Clear');
  ImGuiTextFilter_destroy := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_destroy');
  ImGuiTextFilter_Draw := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_Draw');
  ImGuiTextFilter_ImGuiTextFilter := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_ImGuiTextFilter');
  ImGuiTextFilter_IsActive := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_IsActive');
  ImGuiTextFilter_PassFilter := GetProcAddress(aDLLHandle, 'ImGuiTextFilter_PassFilter');
  ImGuiTextIndex_append := GetProcAddress(aDLLHandle, 'ImGuiTextIndex_append');
  ImGuiTextIndex_clear := GetProcAddress(aDLLHandle, 'ImGuiTextIndex_clear');
  ImGuiTextIndex_get_line_begin := GetProcAddress(aDLLHandle, 'ImGuiTextIndex_get_line_begin');
  ImGuiTextIndex_get_line_end := GetProcAddress(aDLLHandle, 'ImGuiTextIndex_get_line_end');
  ImGuiTextIndex_size := GetProcAddress(aDLLHandle, 'ImGuiTextIndex_size');
  ImGuiTextRange_destroy := GetProcAddress(aDLLHandle, 'ImGuiTextRange_destroy');
  ImGuiTextRange_empty := GetProcAddress(aDLLHandle, 'ImGuiTextRange_empty');
  ImGuiTextRange_ImGuiTextRange_Nil := GetProcAddress(aDLLHandle, 'ImGuiTextRange_ImGuiTextRange_Nil');
  ImGuiTextRange_ImGuiTextRange_Str := GetProcAddress(aDLLHandle, 'ImGuiTextRange_ImGuiTextRange_Str');
  ImGuiTextRange_split := GetProcAddress(aDLLHandle, 'ImGuiTextRange_split');
  ImGuiTypingSelectState_Clear := GetProcAddress(aDLLHandle, 'ImGuiTypingSelectState_Clear');
  ImGuiTypingSelectState_destroy := GetProcAddress(aDLLHandle, 'ImGuiTypingSelectState_destroy');
  ImGuiTypingSelectState_ImGuiTypingSelectState := GetProcAddress(aDLLHandle, 'ImGuiTypingSelectState_ImGuiTypingSelectState');
  ImGuiViewport_destroy := GetProcAddress(aDLLHandle, 'ImGuiViewport_destroy');
  ImGuiViewport_GetCenter := GetProcAddress(aDLLHandle, 'ImGuiViewport_GetCenter');
  ImGuiViewport_GetWorkCenter := GetProcAddress(aDLLHandle, 'ImGuiViewport_GetWorkCenter');
  ImGuiViewport_ImGuiViewport := GetProcAddress(aDLLHandle, 'ImGuiViewport_ImGuiViewport');
  ImGuiViewportP_CalcWorkRectPos := GetProcAddress(aDLLHandle, 'ImGuiViewportP_CalcWorkRectPos');
  ImGuiViewportP_CalcWorkRectSize := GetProcAddress(aDLLHandle, 'ImGuiViewportP_CalcWorkRectSize');
  ImGuiViewportP_ClearRequestFlags := GetProcAddress(aDLLHandle, 'ImGuiViewportP_ClearRequestFlags');
  ImGuiViewportP_destroy := GetProcAddress(aDLLHandle, 'ImGuiViewportP_destroy');
  ImGuiViewportP_GetBuildWorkRect := GetProcAddress(aDLLHandle, 'ImGuiViewportP_GetBuildWorkRect');
  ImGuiViewportP_GetMainRect := GetProcAddress(aDLLHandle, 'ImGuiViewportP_GetMainRect');
  ImGuiViewportP_GetWorkRect := GetProcAddress(aDLLHandle, 'ImGuiViewportP_GetWorkRect');
  ImGuiViewportP_ImGuiViewportP := GetProcAddress(aDLLHandle, 'ImGuiViewportP_ImGuiViewportP');
  ImGuiViewportP_UpdateWorkRect := GetProcAddress(aDLLHandle, 'ImGuiViewportP_UpdateWorkRect');
  ImGuiWindow_CalcFontSize := GetProcAddress(aDLLHandle, 'ImGuiWindow_CalcFontSize');
  ImGuiWindow_destroy := GetProcAddress(aDLLHandle, 'ImGuiWindow_destroy');
  ImGuiWindow_GetID_Int := GetProcAddress(aDLLHandle, 'ImGuiWindow_GetID_Int');
  ImGuiWindow_GetID_Ptr := GetProcAddress(aDLLHandle, 'ImGuiWindow_GetID_Ptr');
  ImGuiWindow_GetID_Str := GetProcAddress(aDLLHandle, 'ImGuiWindow_GetID_Str');
  ImGuiWindow_GetIDFromPos := GetProcAddress(aDLLHandle, 'ImGuiWindow_GetIDFromPos');
  ImGuiWindow_GetIDFromRectangle := GetProcAddress(aDLLHandle, 'ImGuiWindow_GetIDFromRectangle');
  ImGuiWindow_ImGuiWindow := GetProcAddress(aDLLHandle, 'ImGuiWindow_ImGuiWindow');
  ImGuiWindow_MenuBarRect := GetProcAddress(aDLLHandle, 'ImGuiWindow_MenuBarRect');
  ImGuiWindow_Rect := GetProcAddress(aDLLHandle, 'ImGuiWindow_Rect');
  ImGuiWindow_TitleBarRect := GetProcAddress(aDLLHandle, 'ImGuiWindow_TitleBarRect');
  ImGuiWindowClass_destroy := GetProcAddress(aDLLHandle, 'ImGuiWindowClass_destroy');
  ImGuiWindowClass_ImGuiWindowClass := GetProcAddress(aDLLHandle, 'ImGuiWindowClass_ImGuiWindowClass');
  ImGuiWindowSettings_destroy := GetProcAddress(aDLLHandle, 'ImGuiWindowSettings_destroy');
  ImGuiWindowSettings_GetName := GetProcAddress(aDLLHandle, 'ImGuiWindowSettings_GetName');
  ImGuiWindowSettings_ImGuiWindowSettings := GetProcAddress(aDLLHandle, 'ImGuiWindowSettings_ImGuiWindowSettings');
  ImRect_Add_Rect := GetProcAddress(aDLLHandle, 'ImRect_Add_Rect');
  ImRect_Add_Vec2 := GetProcAddress(aDLLHandle, 'ImRect_Add_Vec2');
  ImRect_ClipWith := GetProcAddress(aDLLHandle, 'ImRect_ClipWith');
  ImRect_ClipWithFull := GetProcAddress(aDLLHandle, 'ImRect_ClipWithFull');
  ImRect_Contains_Rect := GetProcAddress(aDLLHandle, 'ImRect_Contains_Rect');
  ImRect_Contains_Vec2 := GetProcAddress(aDLLHandle, 'ImRect_Contains_Vec2');
  ImRect_ContainsWithPad := GetProcAddress(aDLLHandle, 'ImRect_ContainsWithPad');
  ImRect_destroy := GetProcAddress(aDLLHandle, 'ImRect_destroy');
  ImRect_Expand_Float := GetProcAddress(aDLLHandle, 'ImRect_Expand_Float');
  ImRect_Expand_Vec2 := GetProcAddress(aDLLHandle, 'ImRect_Expand_Vec2');
  ImRect_Floor := GetProcAddress(aDLLHandle, 'ImRect_Floor');
  ImRect_GetArea := GetProcAddress(aDLLHandle, 'ImRect_GetArea');
  ImRect_GetBL := GetProcAddress(aDLLHandle, 'ImRect_GetBL');
  ImRect_GetBR := GetProcAddress(aDLLHandle, 'ImRect_GetBR');
  ImRect_GetCenter := GetProcAddress(aDLLHandle, 'ImRect_GetCenter');
  ImRect_GetHeight := GetProcAddress(aDLLHandle, 'ImRect_GetHeight');
  ImRect_GetSize := GetProcAddress(aDLLHandle, 'ImRect_GetSize');
  ImRect_GetTL := GetProcAddress(aDLLHandle, 'ImRect_GetTL');
  ImRect_GetTR := GetProcAddress(aDLLHandle, 'ImRect_GetTR');
  ImRect_GetWidth := GetProcAddress(aDLLHandle, 'ImRect_GetWidth');
  ImRect_ImRect_Float := GetProcAddress(aDLLHandle, 'ImRect_ImRect_Float');
  ImRect_ImRect_Nil := GetProcAddress(aDLLHandle, 'ImRect_ImRect_Nil');
  ImRect_ImRect_Vec2 := GetProcAddress(aDLLHandle, 'ImRect_ImRect_Vec2');
  ImRect_ImRect_Vec4 := GetProcAddress(aDLLHandle, 'ImRect_ImRect_Vec4');
  ImRect_IsInverted := GetProcAddress(aDLLHandle, 'ImRect_IsInverted');
  ImRect_Overlaps := GetProcAddress(aDLLHandle, 'ImRect_Overlaps');
  ImRect_ToVec4 := GetProcAddress(aDLLHandle, 'ImRect_ToVec4');
  ImRect_Translate := GetProcAddress(aDLLHandle, 'ImRect_Translate');
  ImRect_TranslateX := GetProcAddress(aDLLHandle, 'ImRect_TranslateX');
  ImRect_TranslateY := GetProcAddress(aDLLHandle, 'ImRect_TranslateY');
  ImVec1_destroy := GetProcAddress(aDLLHandle, 'ImVec1_destroy');
  ImVec1_ImVec1_Float := GetProcAddress(aDLLHandle, 'ImVec1_ImVec1_Float');
  ImVec1_ImVec1_Nil := GetProcAddress(aDLLHandle, 'ImVec1_ImVec1_Nil');
  ImVec2_destroy := GetProcAddress(aDLLHandle, 'ImVec2_destroy');
  ImVec2_ImVec2_Float := GetProcAddress(aDLLHandle, 'ImVec2_ImVec2_Float');
  ImVec2_ImVec2_Nil := GetProcAddress(aDLLHandle, 'ImVec2_ImVec2_Nil');
  ImVec2ih_destroy := GetProcAddress(aDLLHandle, 'ImVec2ih_destroy');
  ImVec2ih_ImVec2ih_Nil := GetProcAddress(aDLLHandle, 'ImVec2ih_ImVec2ih_Nil');
  ImVec2ih_ImVec2ih_short := GetProcAddress(aDLLHandle, 'ImVec2ih_ImVec2ih_short');
  ImVec2ih_ImVec2ih_Vec2 := GetProcAddress(aDLLHandle, 'ImVec2ih_ImVec2ih_Vec2');
  ImVec4_destroy := GetProcAddress(aDLLHandle, 'ImVec4_destroy');
  ImVec4_ImVec4_Float := GetProcAddress(aDLLHandle, 'ImVec4_ImVec4_Float');
  ImVec4_ImVec4_Nil := GetProcAddress(aDLLHandle, 'ImVec4_ImVec4_Nil');
  ImVector_ImWchar_create := GetProcAddress(aDLLHandle, 'ImVector_ImWchar_create');
  ImVector_ImWchar_destroy := GetProcAddress(aDLLHandle, 'ImVector_ImWchar_destroy');
  ImVector_ImWchar_Init := GetProcAddress(aDLLHandle, 'ImVector_ImWchar_Init');
  ImVector_ImWchar_UnInit := GetProcAddress(aDLLHandle, 'ImVector_ImWchar_UnInit');
  initGL := GetProcAddress(aDLLHandle, 'initGL');
  lua_atpanic := GetProcAddress(aDLLHandle, 'lua_atpanic');
  lua_call := GetProcAddress(aDLLHandle, 'lua_call');
  lua_checkstack := GetProcAddress(aDLLHandle, 'lua_checkstack');
  lua_close := GetProcAddress(aDLLHandle, 'lua_close');
  lua_concat := GetProcAddress(aDLLHandle, 'lua_concat');
  lua_copy := GetProcAddress(aDLLHandle, 'lua_copy');
  lua_cpcall := GetProcAddress(aDLLHandle, 'lua_cpcall');
  lua_createtable := GetProcAddress(aDLLHandle, 'lua_createtable');
  lua_dump := GetProcAddress(aDLLHandle, 'lua_dump');
  lua_equal := GetProcAddress(aDLLHandle, 'lua_equal');
  lua_error := GetProcAddress(aDLLHandle, 'lua_error');
  lua_gc := GetProcAddress(aDLLHandle, 'lua_gc');
  lua_getallocf := GetProcAddress(aDLLHandle, 'lua_getallocf');
  lua_getfenv := GetProcAddress(aDLLHandle, 'lua_getfenv');
  lua_getfield := GetProcAddress(aDLLHandle, 'lua_getfield');
  lua_gethook := GetProcAddress(aDLLHandle, 'lua_gethook');
  lua_gethookcount := GetProcAddress(aDLLHandle, 'lua_gethookcount');
  lua_gethookmask := GetProcAddress(aDLLHandle, 'lua_gethookmask');
  lua_getinfo := GetProcAddress(aDLLHandle, 'lua_getinfo');
  lua_getlocal := GetProcAddress(aDLLHandle, 'lua_getlocal');
  lua_getmetatable := GetProcAddress(aDLLHandle, 'lua_getmetatable');
  lua_getstack := GetProcAddress(aDLLHandle, 'lua_getstack');
  lua_gettable := GetProcAddress(aDLLHandle, 'lua_gettable');
  lua_gettop := GetProcAddress(aDLLHandle, 'lua_gettop');
  lua_getupvalue := GetProcAddress(aDLLHandle, 'lua_getupvalue');
  lua_insert := GetProcAddress(aDLLHandle, 'lua_insert');
  lua_iscfunction := GetProcAddress(aDLLHandle, 'lua_iscfunction');
  lua_isnumber := GetProcAddress(aDLLHandle, 'lua_isnumber');
  lua_isstring := GetProcAddress(aDLLHandle, 'lua_isstring');
  lua_isuserdata := GetProcAddress(aDLLHandle, 'lua_isuserdata');
  lua_isyieldable := GetProcAddress(aDLLHandle, 'lua_isyieldable');
  lua_lessthan := GetProcAddress(aDLLHandle, 'lua_lessthan');
  lua_load := GetProcAddress(aDLLHandle, 'lua_load');
  lua_loadx := GetProcAddress(aDLLHandle, 'lua_loadx');
  lua_newstate := GetProcAddress(aDLLHandle, 'lua_newstate');
  lua_newthread := GetProcAddress(aDLLHandle, 'lua_newthread');
  lua_newuserdata := GetProcAddress(aDLLHandle, 'lua_newuserdata');
  lua_next := GetProcAddress(aDLLHandle, 'lua_next');
  lua_objlen := GetProcAddress(aDLLHandle, 'lua_objlen');
  lua_pcall := GetProcAddress(aDLLHandle, 'lua_pcall');
  lua_pushboolean := GetProcAddress(aDLLHandle, 'lua_pushboolean');
  lua_pushcclosure := GetProcAddress(aDLLHandle, 'lua_pushcclosure');
  lua_pushfstring := GetProcAddress(aDLLHandle, 'lua_pushfstring');
  lua_pushinteger := GetProcAddress(aDLLHandle, 'lua_pushinteger');
  lua_pushlightuserdata := GetProcAddress(aDLLHandle, 'lua_pushlightuserdata');
  lua_pushlstring := GetProcAddress(aDLLHandle, 'lua_pushlstring');
  lua_pushnil := GetProcAddress(aDLLHandle, 'lua_pushnil');
  lua_pushnumber := GetProcAddress(aDLLHandle, 'lua_pushnumber');
  lua_pushstring := GetProcAddress(aDLLHandle, 'lua_pushstring');
  lua_pushthread := GetProcAddress(aDLLHandle, 'lua_pushthread');
  lua_pushvalue := GetProcAddress(aDLLHandle, 'lua_pushvalue');
  lua_pushvfstring := GetProcAddress(aDLLHandle, 'lua_pushvfstring');
  lua_rawequal := GetProcAddress(aDLLHandle, 'lua_rawequal');
  lua_rawget := GetProcAddress(aDLLHandle, 'lua_rawget');
  lua_rawgeti := GetProcAddress(aDLLHandle, 'lua_rawgeti');
  lua_rawset := GetProcAddress(aDLLHandle, 'lua_rawset');
  lua_rawseti := GetProcAddress(aDLLHandle, 'lua_rawseti');
  lua_remove := GetProcAddress(aDLLHandle, 'lua_remove');
  lua_replace := GetProcAddress(aDLLHandle, 'lua_replace');
  lua_resume := GetProcAddress(aDLLHandle, 'lua_resume');
  lua_setallocf := GetProcAddress(aDLLHandle, 'lua_setallocf');
  lua_setfenv := GetProcAddress(aDLLHandle, 'lua_setfenv');
  lua_setfield := GetProcAddress(aDLLHandle, 'lua_setfield');
  lua_sethook := GetProcAddress(aDLLHandle, 'lua_sethook');
  lua_setlocal := GetProcAddress(aDLLHandle, 'lua_setlocal');
  lua_setmetatable := GetProcAddress(aDLLHandle, 'lua_setmetatable');
  lua_settable := GetProcAddress(aDLLHandle, 'lua_settable');
  lua_settop := GetProcAddress(aDLLHandle, 'lua_settop');
  lua_setupvalue := GetProcAddress(aDLLHandle, 'lua_setupvalue');
  lua_status := GetProcAddress(aDLLHandle, 'lua_status');
  lua_toboolean := GetProcAddress(aDLLHandle, 'lua_toboolean');
  lua_tocfunction := GetProcAddress(aDLLHandle, 'lua_tocfunction');
  lua_tointeger := GetProcAddress(aDLLHandle, 'lua_tointeger');
  lua_tointegerx := GetProcAddress(aDLLHandle, 'lua_tointegerx');
  lua_tolstring := GetProcAddress(aDLLHandle, 'lua_tolstring');
  lua_tonumber := GetProcAddress(aDLLHandle, 'lua_tonumber');
  lua_tonumberx := GetProcAddress(aDLLHandle, 'lua_tonumberx');
  lua_topointer := GetProcAddress(aDLLHandle, 'lua_topointer');
  lua_tothread := GetProcAddress(aDLLHandle, 'lua_tothread');
  lua_touserdata := GetProcAddress(aDLLHandle, 'lua_touserdata');
  lua_type := GetProcAddress(aDLLHandle, 'lua_type');
  lua_typename := GetProcAddress(aDLLHandle, 'lua_typename');
  lua_upvalueid := GetProcAddress(aDLLHandle, 'lua_upvalueid');
  lua_upvaluejoin := GetProcAddress(aDLLHandle, 'lua_upvaluejoin');
  lua_version := GetProcAddress(aDLLHandle, 'lua_version');
  lua_xmove := GetProcAddress(aDLLHandle, 'lua_xmove');
  lua_yield := GetProcAddress(aDLLHandle, 'lua_yield');
  luaJIT_profile_dumpstack := GetProcAddress(aDLLHandle, 'luaJIT_profile_dumpstack');
  luaJIT_profile_start := GetProcAddress(aDLLHandle, 'luaJIT_profile_start');
  luaJIT_profile_stop := GetProcAddress(aDLLHandle, 'luaJIT_profile_stop');
  luaJIT_setmode := GetProcAddress(aDLLHandle, 'luaJIT_setmode');
  luaJIT_version_2_1_1736781742 := GetProcAddress(aDLLHandle, 'luaJIT_version_2_1_1736781742');
  luaL_addlstring := GetProcAddress(aDLLHandle, 'luaL_addlstring');
  luaL_addstring := GetProcAddress(aDLLHandle, 'luaL_addstring');
  luaL_addvalue := GetProcAddress(aDLLHandle, 'luaL_addvalue');
  luaL_argerror := GetProcAddress(aDLLHandle, 'luaL_argerror');
  luaL_buffinit := GetProcAddress(aDLLHandle, 'luaL_buffinit');
  luaL_callmeta := GetProcAddress(aDLLHandle, 'luaL_callmeta');
  luaL_checkany := GetProcAddress(aDLLHandle, 'luaL_checkany');
  luaL_checkinteger := GetProcAddress(aDLLHandle, 'luaL_checkinteger');
  luaL_checklstring := GetProcAddress(aDLLHandle, 'luaL_checklstring');
  luaL_checknumber := GetProcAddress(aDLLHandle, 'luaL_checknumber');
  luaL_checkoption := GetProcAddress(aDLLHandle, 'luaL_checkoption');
  luaL_checkstack := GetProcAddress(aDLLHandle, 'luaL_checkstack');
  luaL_checktype := GetProcAddress(aDLLHandle, 'luaL_checktype');
  luaL_checkudata := GetProcAddress(aDLLHandle, 'luaL_checkudata');
  luaL_error := GetProcAddress(aDLLHandle, 'luaL_error');
  luaL_execresult := GetProcAddress(aDLLHandle, 'luaL_execresult');
  luaL_fileresult := GetProcAddress(aDLLHandle, 'luaL_fileresult');
  luaL_findtable := GetProcAddress(aDLLHandle, 'luaL_findtable');
  luaL_getmetafield := GetProcAddress(aDLLHandle, 'luaL_getmetafield');
  luaL_gsub := GetProcAddress(aDLLHandle, 'luaL_gsub');
  luaL_loadbuffer := GetProcAddress(aDLLHandle, 'luaL_loadbuffer');
  luaL_loadbufferx := GetProcAddress(aDLLHandle, 'luaL_loadbufferx');
  luaL_loadfile := GetProcAddress(aDLLHandle, 'luaL_loadfile');
  luaL_loadfilex := GetProcAddress(aDLLHandle, 'luaL_loadfilex');
  luaL_loadstring := GetProcAddress(aDLLHandle, 'luaL_loadstring');
  luaL_newmetatable := GetProcAddress(aDLLHandle, 'luaL_newmetatable');
  luaL_newstate := GetProcAddress(aDLLHandle, 'luaL_newstate');
  luaL_openlib := GetProcAddress(aDLLHandle, 'luaL_openlib');
  luaL_openlibs := GetProcAddress(aDLLHandle, 'luaL_openlibs');
  luaL_optinteger := GetProcAddress(aDLLHandle, 'luaL_optinteger');
  luaL_optlstring := GetProcAddress(aDLLHandle, 'luaL_optlstring');
  luaL_optnumber := GetProcAddress(aDLLHandle, 'luaL_optnumber');
  luaL_prepbuffer := GetProcAddress(aDLLHandle, 'luaL_prepbuffer');
  luaL_pushmodule := GetProcAddress(aDLLHandle, 'luaL_pushmodule');
  luaL_pushresult := GetProcAddress(aDLLHandle, 'luaL_pushresult');
  luaL_ref := GetProcAddress(aDLLHandle, 'luaL_ref');
  luaL_register := GetProcAddress(aDLLHandle, 'luaL_register');
  luaL_setfuncs := GetProcAddress(aDLLHandle, 'luaL_setfuncs');
  luaL_setmetatable := GetProcAddress(aDLLHandle, 'luaL_setmetatable');
  luaL_testudata := GetProcAddress(aDLLHandle, 'luaL_testudata');
  luaL_traceback := GetProcAddress(aDLLHandle, 'luaL_traceback');
  luaL_typerror := GetProcAddress(aDLLHandle, 'luaL_typerror');
  luaL_unref := GetProcAddress(aDLLHandle, 'luaL_unref');
  luaL_where := GetProcAddress(aDLLHandle, 'luaL_where');
  luaopen_base := GetProcAddress(aDLLHandle, 'luaopen_base');
  luaopen_bit := GetProcAddress(aDLLHandle, 'luaopen_bit');
  luaopen_debug := GetProcAddress(aDLLHandle, 'luaopen_debug');
  luaopen_ffi := GetProcAddress(aDLLHandle, 'luaopen_ffi');
  luaopen_io := GetProcAddress(aDLLHandle, 'luaopen_io');
  luaopen_jit := GetProcAddress(aDLLHandle, 'luaopen_jit');
  luaopen_math := GetProcAddress(aDLLHandle, 'luaopen_math');
  luaopen_os := GetProcAddress(aDLLHandle, 'luaopen_os');
  luaopen_package := GetProcAddress(aDLLHandle, 'luaopen_package');
  luaopen_string := GetProcAddress(aDLLHandle, 'luaopen_string');
  luaopen_string_buffer := GetProcAddress(aDLLHandle, 'luaopen_string_buffer');
  luaopen_table := GetProcAddress(aDLLHandle, 'luaopen_table');
  ma_aligned_free := GetProcAddress(aDLLHandle, 'ma_aligned_free');
  ma_aligned_malloc := GetProcAddress(aDLLHandle, 'ma_aligned_malloc');
  ma_apply_volume_factor_f32 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_f32');
  ma_apply_volume_factor_pcm_frames := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames');
  ma_apply_volume_factor_pcm_frames_f32 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames_f32');
  ma_apply_volume_factor_pcm_frames_s16 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames_s16');
  ma_apply_volume_factor_pcm_frames_s24 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames_s24');
  ma_apply_volume_factor_pcm_frames_s32 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames_s32');
  ma_apply_volume_factor_pcm_frames_u8 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_pcm_frames_u8');
  ma_apply_volume_factor_s16 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_s16');
  ma_apply_volume_factor_s24 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_s24');
  ma_apply_volume_factor_s32 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_s32');
  ma_apply_volume_factor_u8 := GetProcAddress(aDLLHandle, 'ma_apply_volume_factor_u8');
  ma_async_notification_event_init := GetProcAddress(aDLLHandle, 'ma_async_notification_event_init');
  ma_async_notification_event_signal := GetProcAddress(aDLLHandle, 'ma_async_notification_event_signal');
  ma_async_notification_event_uninit := GetProcAddress(aDLLHandle, 'ma_async_notification_event_uninit');
  ma_async_notification_event_wait := GetProcAddress(aDLLHandle, 'ma_async_notification_event_wait');
  ma_async_notification_poll_init := GetProcAddress(aDLLHandle, 'ma_async_notification_poll_init');
  ma_async_notification_poll_is_signalled := GetProcAddress(aDLLHandle, 'ma_async_notification_poll_is_signalled');
  ma_async_notification_signal := GetProcAddress(aDLLHandle, 'ma_async_notification_signal');
  ma_audio_buffer_alloc_and_init := GetProcAddress(aDLLHandle, 'ma_audio_buffer_alloc_and_init');
  ma_audio_buffer_at_end := GetProcAddress(aDLLHandle, 'ma_audio_buffer_at_end');
  ma_audio_buffer_config_init := GetProcAddress(aDLLHandle, 'ma_audio_buffer_config_init');
  ma_audio_buffer_get_available_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_get_available_frames');
  ma_audio_buffer_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_get_cursor_in_pcm_frames');
  ma_audio_buffer_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_get_length_in_pcm_frames');
  ma_audio_buffer_init := GetProcAddress(aDLLHandle, 'ma_audio_buffer_init');
  ma_audio_buffer_init_copy := GetProcAddress(aDLLHandle, 'ma_audio_buffer_init_copy');
  ma_audio_buffer_map := GetProcAddress(aDLLHandle, 'ma_audio_buffer_map');
  ma_audio_buffer_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_read_pcm_frames');
  ma_audio_buffer_ref_at_end := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_at_end');
  ma_audio_buffer_ref_get_available_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_get_available_frames');
  ma_audio_buffer_ref_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_get_cursor_in_pcm_frames');
  ma_audio_buffer_ref_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_get_length_in_pcm_frames');
  ma_audio_buffer_ref_init := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_init');
  ma_audio_buffer_ref_map := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_map');
  ma_audio_buffer_ref_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_read_pcm_frames');
  ma_audio_buffer_ref_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_seek_to_pcm_frame');
  ma_audio_buffer_ref_set_data := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_set_data');
  ma_audio_buffer_ref_uninit := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_uninit');
  ma_audio_buffer_ref_unmap := GetProcAddress(aDLLHandle, 'ma_audio_buffer_ref_unmap');
  ma_audio_buffer_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_audio_buffer_seek_to_pcm_frame');
  ma_audio_buffer_uninit := GetProcAddress(aDLLHandle, 'ma_audio_buffer_uninit');
  ma_audio_buffer_uninit_and_free := GetProcAddress(aDLLHandle, 'ma_audio_buffer_uninit_and_free');
  ma_audio_buffer_unmap := GetProcAddress(aDLLHandle, 'ma_audio_buffer_unmap');
  ma_biquad_clear_cache := GetProcAddress(aDLLHandle, 'ma_biquad_clear_cache');
  ma_biquad_config_init := GetProcAddress(aDLLHandle, 'ma_biquad_config_init');
  ma_biquad_get_heap_size := GetProcAddress(aDLLHandle, 'ma_biquad_get_heap_size');
  ma_biquad_get_latency := GetProcAddress(aDLLHandle, 'ma_biquad_get_latency');
  ma_biquad_init := GetProcAddress(aDLLHandle, 'ma_biquad_init');
  ma_biquad_init_preallocated := GetProcAddress(aDLLHandle, 'ma_biquad_init_preallocated');
  ma_biquad_node_config_init := GetProcAddress(aDLLHandle, 'ma_biquad_node_config_init');
  ma_biquad_node_init := GetProcAddress(aDLLHandle, 'ma_biquad_node_init');
  ma_biquad_node_reinit := GetProcAddress(aDLLHandle, 'ma_biquad_node_reinit');
  ma_biquad_node_uninit := GetProcAddress(aDLLHandle, 'ma_biquad_node_uninit');
  ma_biquad_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_biquad_process_pcm_frames');
  ma_biquad_reinit := GetProcAddress(aDLLHandle, 'ma_biquad_reinit');
  ma_biquad_uninit := GetProcAddress(aDLLHandle, 'ma_biquad_uninit');
  ma_blend_f32 := GetProcAddress(aDLLHandle, 'ma_blend_f32');
  ma_bpf_config_init := GetProcAddress(aDLLHandle, 'ma_bpf_config_init');
  ma_bpf_get_heap_size := GetProcAddress(aDLLHandle, 'ma_bpf_get_heap_size');
  ma_bpf_get_latency := GetProcAddress(aDLLHandle, 'ma_bpf_get_latency');
  ma_bpf_init := GetProcAddress(aDLLHandle, 'ma_bpf_init');
  ma_bpf_init_preallocated := GetProcAddress(aDLLHandle, 'ma_bpf_init_preallocated');
  ma_bpf_node_config_init := GetProcAddress(aDLLHandle, 'ma_bpf_node_config_init');
  ma_bpf_node_init := GetProcAddress(aDLLHandle, 'ma_bpf_node_init');
  ma_bpf_node_reinit := GetProcAddress(aDLLHandle, 'ma_bpf_node_reinit');
  ma_bpf_node_uninit := GetProcAddress(aDLLHandle, 'ma_bpf_node_uninit');
  ma_bpf_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_bpf_process_pcm_frames');
  ma_bpf_reinit := GetProcAddress(aDLLHandle, 'ma_bpf_reinit');
  ma_bpf_uninit := GetProcAddress(aDLLHandle, 'ma_bpf_uninit');
  ma_bpf2_config_init := GetProcAddress(aDLLHandle, 'ma_bpf2_config_init');
  ma_bpf2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_bpf2_get_heap_size');
  ma_bpf2_get_latency := GetProcAddress(aDLLHandle, 'ma_bpf2_get_latency');
  ma_bpf2_init := GetProcAddress(aDLLHandle, 'ma_bpf2_init');
  ma_bpf2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_bpf2_init_preallocated');
  ma_bpf2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_bpf2_process_pcm_frames');
  ma_bpf2_reinit := GetProcAddress(aDLLHandle, 'ma_bpf2_reinit');
  ma_bpf2_uninit := GetProcAddress(aDLLHandle, 'ma_bpf2_uninit');
  ma_calculate_buffer_size_in_frames_from_descriptor := GetProcAddress(aDLLHandle, 'ma_calculate_buffer_size_in_frames_from_descriptor');
  ma_calculate_buffer_size_in_frames_from_milliseconds := GetProcAddress(aDLLHandle, 'ma_calculate_buffer_size_in_frames_from_milliseconds');
  ma_calculate_buffer_size_in_milliseconds_from_frames := GetProcAddress(aDLLHandle, 'ma_calculate_buffer_size_in_milliseconds_from_frames');
  ma_calloc := GetProcAddress(aDLLHandle, 'ma_calloc');
  ma_channel_converter_config_init := GetProcAddress(aDLLHandle, 'ma_channel_converter_config_init');
  ma_channel_converter_get_heap_size := GetProcAddress(aDLLHandle, 'ma_channel_converter_get_heap_size');
  ma_channel_converter_get_input_channel_map := GetProcAddress(aDLLHandle, 'ma_channel_converter_get_input_channel_map');
  ma_channel_converter_get_output_channel_map := GetProcAddress(aDLLHandle, 'ma_channel_converter_get_output_channel_map');
  ma_channel_converter_init := GetProcAddress(aDLLHandle, 'ma_channel_converter_init');
  ma_channel_converter_init_preallocated := GetProcAddress(aDLLHandle, 'ma_channel_converter_init_preallocated');
  ma_channel_converter_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_channel_converter_process_pcm_frames');
  ma_channel_converter_uninit := GetProcAddress(aDLLHandle, 'ma_channel_converter_uninit');
  ma_channel_map_contains_channel_position := GetProcAddress(aDLLHandle, 'ma_channel_map_contains_channel_position');
  ma_channel_map_copy := GetProcAddress(aDLLHandle, 'ma_channel_map_copy');
  ma_channel_map_copy_or_default := GetProcAddress(aDLLHandle, 'ma_channel_map_copy_or_default');
  ma_channel_map_find_channel_position := GetProcAddress(aDLLHandle, 'ma_channel_map_find_channel_position');
  ma_channel_map_get_channel := GetProcAddress(aDLLHandle, 'ma_channel_map_get_channel');
  ma_channel_map_init_blank := GetProcAddress(aDLLHandle, 'ma_channel_map_init_blank');
  ma_channel_map_init_standard := GetProcAddress(aDLLHandle, 'ma_channel_map_init_standard');
  ma_channel_map_is_blank := GetProcAddress(aDLLHandle, 'ma_channel_map_is_blank');
  ma_channel_map_is_equal := GetProcAddress(aDLLHandle, 'ma_channel_map_is_equal');
  ma_channel_map_is_valid := GetProcAddress(aDLLHandle, 'ma_channel_map_is_valid');
  ma_channel_map_to_string := GetProcAddress(aDLLHandle, 'ma_channel_map_to_string');
  ma_channel_position_to_string := GetProcAddress(aDLLHandle, 'ma_channel_position_to_string');
  ma_clip_pcm_frames := GetProcAddress(aDLLHandle, 'ma_clip_pcm_frames');
  ma_clip_samples_f32 := GetProcAddress(aDLLHandle, 'ma_clip_samples_f32');
  ma_clip_samples_s16 := GetProcAddress(aDLLHandle, 'ma_clip_samples_s16');
  ma_clip_samples_s24 := GetProcAddress(aDLLHandle, 'ma_clip_samples_s24');
  ma_clip_samples_s32 := GetProcAddress(aDLLHandle, 'ma_clip_samples_s32');
  ma_clip_samples_u8 := GetProcAddress(aDLLHandle, 'ma_clip_samples_u8');
  ma_context_config_init := GetProcAddress(aDLLHandle, 'ma_context_config_init');
  ma_context_enumerate_devices := GetProcAddress(aDLLHandle, 'ma_context_enumerate_devices');
  ma_context_get_device_info := GetProcAddress(aDLLHandle, 'ma_context_get_device_info');
  ma_context_get_devices := GetProcAddress(aDLLHandle, 'ma_context_get_devices');
  ma_context_get_log := GetProcAddress(aDLLHandle, 'ma_context_get_log');
  ma_context_init := GetProcAddress(aDLLHandle, 'ma_context_init');
  ma_context_is_loopback_supported := GetProcAddress(aDLLHandle, 'ma_context_is_loopback_supported');
  ma_context_sizeof := GetProcAddress(aDLLHandle, 'ma_context_sizeof');
  ma_context_uninit := GetProcAddress(aDLLHandle, 'ma_context_uninit');
  ma_convert_frames := GetProcAddress(aDLLHandle, 'ma_convert_frames');
  ma_convert_frames_ex := GetProcAddress(aDLLHandle, 'ma_convert_frames_ex');
  ma_convert_pcm_frames_format := GetProcAddress(aDLLHandle, 'ma_convert_pcm_frames_format');
  ma_copy_and_apply_volume_and_clip_pcm_frames := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_pcm_frames');
  ma_copy_and_apply_volume_and_clip_samples_f32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_samples_f32');
  ma_copy_and_apply_volume_and_clip_samples_s16 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_samples_s16');
  ma_copy_and_apply_volume_and_clip_samples_s24 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_samples_s24');
  ma_copy_and_apply_volume_and_clip_samples_s32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_samples_s32');
  ma_copy_and_apply_volume_and_clip_samples_u8 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_and_clip_samples_u8');
  ma_copy_and_apply_volume_factor_f32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_f32');
  ma_copy_and_apply_volume_factor_pcm_frames := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames');
  ma_copy_and_apply_volume_factor_pcm_frames_f32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames_f32');
  ma_copy_and_apply_volume_factor_pcm_frames_s16 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames_s16');
  ma_copy_and_apply_volume_factor_pcm_frames_s24 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames_s24');
  ma_copy_and_apply_volume_factor_pcm_frames_s32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames_s32');
  ma_copy_and_apply_volume_factor_pcm_frames_u8 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_pcm_frames_u8');
  ma_copy_and_apply_volume_factor_per_channel_f32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_per_channel_f32');
  ma_copy_and_apply_volume_factor_s16 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_s16');
  ma_copy_and_apply_volume_factor_s24 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_s24');
  ma_copy_and_apply_volume_factor_s32 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_s32');
  ma_copy_and_apply_volume_factor_u8 := GetProcAddress(aDLLHandle, 'ma_copy_and_apply_volume_factor_u8');
  ma_copy_pcm_frames := GetProcAddress(aDLLHandle, 'ma_copy_pcm_frames');
  ma_data_converter_config_init := GetProcAddress(aDLLHandle, 'ma_data_converter_config_init');
  ma_data_converter_config_init_default := GetProcAddress(aDLLHandle, 'ma_data_converter_config_init_default');
  ma_data_converter_get_expected_output_frame_count := GetProcAddress(aDLLHandle, 'ma_data_converter_get_expected_output_frame_count');
  ma_data_converter_get_heap_size := GetProcAddress(aDLLHandle, 'ma_data_converter_get_heap_size');
  ma_data_converter_get_input_channel_map := GetProcAddress(aDLLHandle, 'ma_data_converter_get_input_channel_map');
  ma_data_converter_get_input_latency := GetProcAddress(aDLLHandle, 'ma_data_converter_get_input_latency');
  ma_data_converter_get_output_channel_map := GetProcAddress(aDLLHandle, 'ma_data_converter_get_output_channel_map');
  ma_data_converter_get_output_latency := GetProcAddress(aDLLHandle, 'ma_data_converter_get_output_latency');
  ma_data_converter_get_required_input_frame_count := GetProcAddress(aDLLHandle, 'ma_data_converter_get_required_input_frame_count');
  ma_data_converter_init := GetProcAddress(aDLLHandle, 'ma_data_converter_init');
  ma_data_converter_init_preallocated := GetProcAddress(aDLLHandle, 'ma_data_converter_init_preallocated');
  ma_data_converter_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_converter_process_pcm_frames');
  ma_data_converter_reset := GetProcAddress(aDLLHandle, 'ma_data_converter_reset');
  ma_data_converter_set_rate := GetProcAddress(aDLLHandle, 'ma_data_converter_set_rate');
  ma_data_converter_set_rate_ratio := GetProcAddress(aDLLHandle, 'ma_data_converter_set_rate_ratio');
  ma_data_converter_uninit := GetProcAddress(aDLLHandle, 'ma_data_converter_uninit');
  ma_data_source_config_init := GetProcAddress(aDLLHandle, 'ma_data_source_config_init');
  ma_data_source_get_current := GetProcAddress(aDLLHandle, 'ma_data_source_get_current');
  ma_data_source_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_get_cursor_in_pcm_frames');
  ma_data_source_get_cursor_in_seconds := GetProcAddress(aDLLHandle, 'ma_data_source_get_cursor_in_seconds');
  ma_data_source_get_data_format := GetProcAddress(aDLLHandle, 'ma_data_source_get_data_format');
  ma_data_source_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_get_length_in_pcm_frames');
  ma_data_source_get_length_in_seconds := GetProcAddress(aDLLHandle, 'ma_data_source_get_length_in_seconds');
  ma_data_source_get_loop_point_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_get_loop_point_in_pcm_frames');
  ma_data_source_get_next := GetProcAddress(aDLLHandle, 'ma_data_source_get_next');
  ma_data_source_get_next_callback := GetProcAddress(aDLLHandle, 'ma_data_source_get_next_callback');
  ma_data_source_get_range_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_get_range_in_pcm_frames');
  ma_data_source_init := GetProcAddress(aDLLHandle, 'ma_data_source_init');
  ma_data_source_is_looping := GetProcAddress(aDLLHandle, 'ma_data_source_is_looping');
  ma_data_source_node_config_init := GetProcAddress(aDLLHandle, 'ma_data_source_node_config_init');
  ma_data_source_node_init := GetProcAddress(aDLLHandle, 'ma_data_source_node_init');
  ma_data_source_node_is_looping := GetProcAddress(aDLLHandle, 'ma_data_source_node_is_looping');
  ma_data_source_node_set_looping := GetProcAddress(aDLLHandle, 'ma_data_source_node_set_looping');
  ma_data_source_node_uninit := GetProcAddress(aDLLHandle, 'ma_data_source_node_uninit');
  ma_data_source_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_read_pcm_frames');
  ma_data_source_seek_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_seek_pcm_frames');
  ma_data_source_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_data_source_seek_to_pcm_frame');
  ma_data_source_set_current := GetProcAddress(aDLLHandle, 'ma_data_source_set_current');
  ma_data_source_set_loop_point_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_set_loop_point_in_pcm_frames');
  ma_data_source_set_looping := GetProcAddress(aDLLHandle, 'ma_data_source_set_looping');
  ma_data_source_set_next := GetProcAddress(aDLLHandle, 'ma_data_source_set_next');
  ma_data_source_set_next_callback := GetProcAddress(aDLLHandle, 'ma_data_source_set_next_callback');
  ma_data_source_set_range_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_data_source_set_range_in_pcm_frames');
  ma_data_source_uninit := GetProcAddress(aDLLHandle, 'ma_data_source_uninit');
  ma_decode_file := GetProcAddress(aDLLHandle, 'ma_decode_file');
  ma_decode_from_vfs := GetProcAddress(aDLLHandle, 'ma_decode_from_vfs');
  ma_decode_memory := GetProcAddress(aDLLHandle, 'ma_decode_memory');
  ma_decoder_config_init := GetProcAddress(aDLLHandle, 'ma_decoder_config_init');
  ma_decoder_config_init_default := GetProcAddress(aDLLHandle, 'ma_decoder_config_init_default');
  ma_decoder_get_available_frames := GetProcAddress(aDLLHandle, 'ma_decoder_get_available_frames');
  ma_decoder_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_decoder_get_cursor_in_pcm_frames');
  ma_decoder_get_data_format := GetProcAddress(aDLLHandle, 'ma_decoder_get_data_format');
  ma_decoder_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_decoder_get_length_in_pcm_frames');
  ma_decoder_init := GetProcAddress(aDLLHandle, 'ma_decoder_init');
  ma_decoder_init_file := GetProcAddress(aDLLHandle, 'ma_decoder_init_file');
  ma_decoder_init_file_w := GetProcAddress(aDLLHandle, 'ma_decoder_init_file_w');
  ma_decoder_init_memory := GetProcAddress(aDLLHandle, 'ma_decoder_init_memory');
  ma_decoder_init_vfs := GetProcAddress(aDLLHandle, 'ma_decoder_init_vfs');
  ma_decoder_init_vfs_w := GetProcAddress(aDLLHandle, 'ma_decoder_init_vfs_w');
  ma_decoder_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_decoder_read_pcm_frames');
  ma_decoder_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_decoder_seek_to_pcm_frame');
  ma_decoder_uninit := GetProcAddress(aDLLHandle, 'ma_decoder_uninit');
  ma_decoding_backend_config_init := GetProcAddress(aDLLHandle, 'ma_decoding_backend_config_init');
  ma_default_vfs_init := GetProcAddress(aDLLHandle, 'ma_default_vfs_init');
  ma_deinterleave_pcm_frames := GetProcAddress(aDLLHandle, 'ma_deinterleave_pcm_frames');
  ma_delay_config_init := GetProcAddress(aDLLHandle, 'ma_delay_config_init');
  ma_delay_get_decay := GetProcAddress(aDLLHandle, 'ma_delay_get_decay');
  ma_delay_get_dry := GetProcAddress(aDLLHandle, 'ma_delay_get_dry');
  ma_delay_get_wet := GetProcAddress(aDLLHandle, 'ma_delay_get_wet');
  ma_delay_init := GetProcAddress(aDLLHandle, 'ma_delay_init');
  ma_delay_node_config_init := GetProcAddress(aDLLHandle, 'ma_delay_node_config_init');
  ma_delay_node_get_decay := GetProcAddress(aDLLHandle, 'ma_delay_node_get_decay');
  ma_delay_node_get_dry := GetProcAddress(aDLLHandle, 'ma_delay_node_get_dry');
  ma_delay_node_get_wet := GetProcAddress(aDLLHandle, 'ma_delay_node_get_wet');
  ma_delay_node_init := GetProcAddress(aDLLHandle, 'ma_delay_node_init');
  ma_delay_node_set_decay := GetProcAddress(aDLLHandle, 'ma_delay_node_set_decay');
  ma_delay_node_set_dry := GetProcAddress(aDLLHandle, 'ma_delay_node_set_dry');
  ma_delay_node_set_wet := GetProcAddress(aDLLHandle, 'ma_delay_node_set_wet');
  ma_delay_node_uninit := GetProcAddress(aDLLHandle, 'ma_delay_node_uninit');
  ma_delay_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_delay_process_pcm_frames');
  ma_delay_set_decay := GetProcAddress(aDLLHandle, 'ma_delay_set_decay');
  ma_delay_set_dry := GetProcAddress(aDLLHandle, 'ma_delay_set_dry');
  ma_delay_set_wet := GetProcAddress(aDLLHandle, 'ma_delay_set_wet');
  ma_delay_uninit := GetProcAddress(aDLLHandle, 'ma_delay_uninit');
  ma_device_config_init := GetProcAddress(aDLLHandle, 'ma_device_config_init');
  ma_device_get_context := GetProcAddress(aDLLHandle, 'ma_device_get_context');
  ma_device_get_info := GetProcAddress(aDLLHandle, 'ma_device_get_info');
  ma_device_get_log := GetProcAddress(aDLLHandle, 'ma_device_get_log');
  ma_device_get_master_volume := GetProcAddress(aDLLHandle, 'ma_device_get_master_volume');
  ma_device_get_master_volume_db := GetProcAddress(aDLLHandle, 'ma_device_get_master_volume_db');
  ma_device_get_name := GetProcAddress(aDLLHandle, 'ma_device_get_name');
  ma_device_get_state := GetProcAddress(aDLLHandle, 'ma_device_get_state');
  ma_device_handle_backend_data_callback := GetProcAddress(aDLLHandle, 'ma_device_handle_backend_data_callback');
  ma_device_init := GetProcAddress(aDLLHandle, 'ma_device_init');
  ma_device_init_ex := GetProcAddress(aDLLHandle, 'ma_device_init_ex');
  ma_device_is_started := GetProcAddress(aDLLHandle, 'ma_device_is_started');
  ma_device_job_thread_config_init := GetProcAddress(aDLLHandle, 'ma_device_job_thread_config_init');
  ma_device_job_thread_init := GetProcAddress(aDLLHandle, 'ma_device_job_thread_init');
  ma_device_job_thread_next := GetProcAddress(aDLLHandle, 'ma_device_job_thread_next');
  ma_device_job_thread_post := GetProcAddress(aDLLHandle, 'ma_device_job_thread_post');
  ma_device_job_thread_uninit := GetProcAddress(aDLLHandle, 'ma_device_job_thread_uninit');
  ma_device_post_init := GetProcAddress(aDLLHandle, 'ma_device_post_init');
  ma_device_set_master_volume := GetProcAddress(aDLLHandle, 'ma_device_set_master_volume');
  ma_device_set_master_volume_db := GetProcAddress(aDLLHandle, 'ma_device_set_master_volume_db');
  ma_device_start := GetProcAddress(aDLLHandle, 'ma_device_start');
  ma_device_stop := GetProcAddress(aDLLHandle, 'ma_device_stop');
  ma_device_uninit := GetProcAddress(aDLLHandle, 'ma_device_uninit');
  ma_duplex_rb_init := GetProcAddress(aDLLHandle, 'ma_duplex_rb_init');
  ma_duplex_rb_uninit := GetProcAddress(aDLLHandle, 'ma_duplex_rb_uninit');
  ma_encoder_config_init := GetProcAddress(aDLLHandle, 'ma_encoder_config_init');
  ma_encoder_init := GetProcAddress(aDLLHandle, 'ma_encoder_init');
  ma_encoder_init_file := GetProcAddress(aDLLHandle, 'ma_encoder_init_file');
  ma_encoder_init_file_w := GetProcAddress(aDLLHandle, 'ma_encoder_init_file_w');
  ma_encoder_init_vfs := GetProcAddress(aDLLHandle, 'ma_encoder_init_vfs');
  ma_encoder_init_vfs_w := GetProcAddress(aDLLHandle, 'ma_encoder_init_vfs_w');
  ma_encoder_uninit := GetProcAddress(aDLLHandle, 'ma_encoder_uninit');
  ma_encoder_write_pcm_frames := GetProcAddress(aDLLHandle, 'ma_encoder_write_pcm_frames');
  ma_engine_config_init := GetProcAddress(aDLLHandle, 'ma_engine_config_init');
  ma_engine_find_closest_listener := GetProcAddress(aDLLHandle, 'ma_engine_find_closest_listener');
  ma_engine_get_channels := GetProcAddress(aDLLHandle, 'ma_engine_get_channels');
  ma_engine_get_device := GetProcAddress(aDLLHandle, 'ma_engine_get_device');
  ma_engine_get_endpoint := GetProcAddress(aDLLHandle, 'ma_engine_get_endpoint');
  ma_engine_get_gain_db := GetProcAddress(aDLLHandle, 'ma_engine_get_gain_db');
  ma_engine_get_listener_count := GetProcAddress(aDLLHandle, 'ma_engine_get_listener_count');
  ma_engine_get_log := GetProcAddress(aDLLHandle, 'ma_engine_get_log');
  ma_engine_get_node_graph := GetProcAddress(aDLLHandle, 'ma_engine_get_node_graph');
  ma_engine_get_resource_manager := GetProcAddress(aDLLHandle, 'ma_engine_get_resource_manager');
  ma_engine_get_sample_rate := GetProcAddress(aDLLHandle, 'ma_engine_get_sample_rate');
  ma_engine_get_time := GetProcAddress(aDLLHandle, 'ma_engine_get_time');
  ma_engine_get_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_engine_get_time_in_milliseconds');
  ma_engine_get_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_engine_get_time_in_pcm_frames');
  ma_engine_get_volume := GetProcAddress(aDLLHandle, 'ma_engine_get_volume');
  ma_engine_init := GetProcAddress(aDLLHandle, 'ma_engine_init');
  ma_engine_listener_get_cone := GetProcAddress(aDLLHandle, 'ma_engine_listener_get_cone');
  ma_engine_listener_get_direction := GetProcAddress(aDLLHandle, 'ma_engine_listener_get_direction');
  ma_engine_listener_get_position := GetProcAddress(aDLLHandle, 'ma_engine_listener_get_position');
  ma_engine_listener_get_velocity := GetProcAddress(aDLLHandle, 'ma_engine_listener_get_velocity');
  ma_engine_listener_get_world_up := GetProcAddress(aDLLHandle, 'ma_engine_listener_get_world_up');
  ma_engine_listener_is_enabled := GetProcAddress(aDLLHandle, 'ma_engine_listener_is_enabled');
  ma_engine_listener_set_cone := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_cone');
  ma_engine_listener_set_direction := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_direction');
  ma_engine_listener_set_enabled := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_enabled');
  ma_engine_listener_set_position := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_position');
  ma_engine_listener_set_velocity := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_velocity');
  ma_engine_listener_set_world_up := GetProcAddress(aDLLHandle, 'ma_engine_listener_set_world_up');
  ma_engine_node_config_init := GetProcAddress(aDLLHandle, 'ma_engine_node_config_init');
  ma_engine_node_get_heap_size := GetProcAddress(aDLLHandle, 'ma_engine_node_get_heap_size');
  ma_engine_node_init := GetProcAddress(aDLLHandle, 'ma_engine_node_init');
  ma_engine_node_init_preallocated := GetProcAddress(aDLLHandle, 'ma_engine_node_init_preallocated');
  ma_engine_node_uninit := GetProcAddress(aDLLHandle, 'ma_engine_node_uninit');
  ma_engine_play_sound := GetProcAddress(aDLLHandle, 'ma_engine_play_sound');
  ma_engine_play_sound_ex := GetProcAddress(aDLLHandle, 'ma_engine_play_sound_ex');
  ma_engine_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_engine_read_pcm_frames');
  ma_engine_set_gain_db := GetProcAddress(aDLLHandle, 'ma_engine_set_gain_db');
  ma_engine_set_time := GetProcAddress(aDLLHandle, 'ma_engine_set_time');
  ma_engine_set_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_engine_set_time_in_milliseconds');
  ma_engine_set_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_engine_set_time_in_pcm_frames');
  ma_engine_set_volume := GetProcAddress(aDLLHandle, 'ma_engine_set_volume');
  ma_engine_start := GetProcAddress(aDLLHandle, 'ma_engine_start');
  ma_engine_stop := GetProcAddress(aDLLHandle, 'ma_engine_stop');
  ma_engine_uninit := GetProcAddress(aDLLHandle, 'ma_engine_uninit');
  ma_event_init := GetProcAddress(aDLLHandle, 'ma_event_init');
  ma_event_signal := GetProcAddress(aDLLHandle, 'ma_event_signal');
  ma_event_uninit := GetProcAddress(aDLLHandle, 'ma_event_uninit');
  ma_event_wait := GetProcAddress(aDLLHandle, 'ma_event_wait');
  ma_fader_config_init := GetProcAddress(aDLLHandle, 'ma_fader_config_init');
  ma_fader_get_current_volume := GetProcAddress(aDLLHandle, 'ma_fader_get_current_volume');
  ma_fader_get_data_format := GetProcAddress(aDLLHandle, 'ma_fader_get_data_format');
  ma_fader_init := GetProcAddress(aDLLHandle, 'ma_fader_init');
  ma_fader_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_fader_process_pcm_frames');
  ma_fader_set_fade := GetProcAddress(aDLLHandle, 'ma_fader_set_fade');
  ma_fader_set_fade_ex := GetProcAddress(aDLLHandle, 'ma_fader_set_fade_ex');
  ma_fence_acquire := GetProcAddress(aDLLHandle, 'ma_fence_acquire');
  ma_fence_init := GetProcAddress(aDLLHandle, 'ma_fence_init');
  ma_fence_release := GetProcAddress(aDLLHandle, 'ma_fence_release');
  ma_fence_uninit := GetProcAddress(aDLLHandle, 'ma_fence_uninit');
  ma_fence_wait := GetProcAddress(aDLLHandle, 'ma_fence_wait');
  ma_free := GetProcAddress(aDLLHandle, 'ma_free');
  ma_gainer_config_init := GetProcAddress(aDLLHandle, 'ma_gainer_config_init');
  ma_gainer_get_heap_size := GetProcAddress(aDLLHandle, 'ma_gainer_get_heap_size');
  ma_gainer_get_master_volume := GetProcAddress(aDLLHandle, 'ma_gainer_get_master_volume');
  ma_gainer_init := GetProcAddress(aDLLHandle, 'ma_gainer_init');
  ma_gainer_init_preallocated := GetProcAddress(aDLLHandle, 'ma_gainer_init_preallocated');
  ma_gainer_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_gainer_process_pcm_frames');
  ma_gainer_set_gain := GetProcAddress(aDLLHandle, 'ma_gainer_set_gain');
  ma_gainer_set_gains := GetProcAddress(aDLLHandle, 'ma_gainer_set_gains');
  ma_gainer_set_master_volume := GetProcAddress(aDLLHandle, 'ma_gainer_set_master_volume');
  ma_gainer_uninit := GetProcAddress(aDLLHandle, 'ma_gainer_uninit');
  ma_get_backend_from_name := GetProcAddress(aDLLHandle, 'ma_get_backend_from_name');
  ma_get_backend_name := GetProcAddress(aDLLHandle, 'ma_get_backend_name');
  ma_get_bytes_per_sample := GetProcAddress(aDLLHandle, 'ma_get_bytes_per_sample');
  ma_get_enabled_backends := GetProcAddress(aDLLHandle, 'ma_get_enabled_backends');
  ma_get_format_name := GetProcAddress(aDLLHandle, 'ma_get_format_name');
  ma_hishelf_node_config_init := GetProcAddress(aDLLHandle, 'ma_hishelf_node_config_init');
  ma_hishelf_node_init := GetProcAddress(aDLLHandle, 'ma_hishelf_node_init');
  ma_hishelf_node_reinit := GetProcAddress(aDLLHandle, 'ma_hishelf_node_reinit');
  ma_hishelf_node_uninit := GetProcAddress(aDLLHandle, 'ma_hishelf_node_uninit');
  ma_hishelf2_config_init := GetProcAddress(aDLLHandle, 'ma_hishelf2_config_init');
  ma_hishelf2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_hishelf2_get_heap_size');
  ma_hishelf2_get_latency := GetProcAddress(aDLLHandle, 'ma_hishelf2_get_latency');
  ma_hishelf2_init := GetProcAddress(aDLLHandle, 'ma_hishelf2_init');
  ma_hishelf2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_hishelf2_init_preallocated');
  ma_hishelf2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_hishelf2_process_pcm_frames');
  ma_hishelf2_reinit := GetProcAddress(aDLLHandle, 'ma_hishelf2_reinit');
  ma_hishelf2_uninit := GetProcAddress(aDLLHandle, 'ma_hishelf2_uninit');
  ma_hpf_config_init := GetProcAddress(aDLLHandle, 'ma_hpf_config_init');
  ma_hpf_get_heap_size := GetProcAddress(aDLLHandle, 'ma_hpf_get_heap_size');
  ma_hpf_get_latency := GetProcAddress(aDLLHandle, 'ma_hpf_get_latency');
  ma_hpf_init := GetProcAddress(aDLLHandle, 'ma_hpf_init');
  ma_hpf_init_preallocated := GetProcAddress(aDLLHandle, 'ma_hpf_init_preallocated');
  ma_hpf_node_config_init := GetProcAddress(aDLLHandle, 'ma_hpf_node_config_init');
  ma_hpf_node_init := GetProcAddress(aDLLHandle, 'ma_hpf_node_init');
  ma_hpf_node_reinit := GetProcAddress(aDLLHandle, 'ma_hpf_node_reinit');
  ma_hpf_node_uninit := GetProcAddress(aDLLHandle, 'ma_hpf_node_uninit');
  ma_hpf_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_hpf_process_pcm_frames');
  ma_hpf_reinit := GetProcAddress(aDLLHandle, 'ma_hpf_reinit');
  ma_hpf_uninit := GetProcAddress(aDLLHandle, 'ma_hpf_uninit');
  ma_hpf1_config_init := GetProcAddress(aDLLHandle, 'ma_hpf1_config_init');
  ma_hpf1_get_heap_size := GetProcAddress(aDLLHandle, 'ma_hpf1_get_heap_size');
  ma_hpf1_get_latency := GetProcAddress(aDLLHandle, 'ma_hpf1_get_latency');
  ma_hpf1_init := GetProcAddress(aDLLHandle, 'ma_hpf1_init');
  ma_hpf1_init_preallocated := GetProcAddress(aDLLHandle, 'ma_hpf1_init_preallocated');
  ma_hpf1_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_hpf1_process_pcm_frames');
  ma_hpf1_reinit := GetProcAddress(aDLLHandle, 'ma_hpf1_reinit');
  ma_hpf1_uninit := GetProcAddress(aDLLHandle, 'ma_hpf1_uninit');
  ma_hpf2_config_init := GetProcAddress(aDLLHandle, 'ma_hpf2_config_init');
  ma_hpf2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_hpf2_get_heap_size');
  ma_hpf2_get_latency := GetProcAddress(aDLLHandle, 'ma_hpf2_get_latency');
  ma_hpf2_init := GetProcAddress(aDLLHandle, 'ma_hpf2_init');
  ma_hpf2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_hpf2_init_preallocated');
  ma_hpf2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_hpf2_process_pcm_frames');
  ma_hpf2_reinit := GetProcAddress(aDLLHandle, 'ma_hpf2_reinit');
  ma_hpf2_uninit := GetProcAddress(aDLLHandle, 'ma_hpf2_uninit');
  ma_interleave_pcm_frames := GetProcAddress(aDLLHandle, 'ma_interleave_pcm_frames');
  ma_is_backend_enabled := GetProcAddress(aDLLHandle, 'ma_is_backend_enabled');
  ma_is_loopback_supported := GetProcAddress(aDLLHandle, 'ma_is_loopback_supported');
  ma_job_init := GetProcAddress(aDLLHandle, 'ma_job_init');
  ma_job_process := GetProcAddress(aDLLHandle, 'ma_job_process');
  ma_job_queue_config_init := GetProcAddress(aDLLHandle, 'ma_job_queue_config_init');
  ma_job_queue_get_heap_size := GetProcAddress(aDLLHandle, 'ma_job_queue_get_heap_size');
  ma_job_queue_init := GetProcAddress(aDLLHandle, 'ma_job_queue_init');
  ma_job_queue_init_preallocated := GetProcAddress(aDLLHandle, 'ma_job_queue_init_preallocated');
  ma_job_queue_next := GetProcAddress(aDLLHandle, 'ma_job_queue_next');
  ma_job_queue_post := GetProcAddress(aDLLHandle, 'ma_job_queue_post');
  ma_job_queue_uninit := GetProcAddress(aDLLHandle, 'ma_job_queue_uninit');
  ma_linear_resampler_config_init := GetProcAddress(aDLLHandle, 'ma_linear_resampler_config_init');
  ma_linear_resampler_get_expected_output_frame_count := GetProcAddress(aDLLHandle, 'ma_linear_resampler_get_expected_output_frame_count');
  ma_linear_resampler_get_heap_size := GetProcAddress(aDLLHandle, 'ma_linear_resampler_get_heap_size');
  ma_linear_resampler_get_input_latency := GetProcAddress(aDLLHandle, 'ma_linear_resampler_get_input_latency');
  ma_linear_resampler_get_output_latency := GetProcAddress(aDLLHandle, 'ma_linear_resampler_get_output_latency');
  ma_linear_resampler_get_required_input_frame_count := GetProcAddress(aDLLHandle, 'ma_linear_resampler_get_required_input_frame_count');
  ma_linear_resampler_init := GetProcAddress(aDLLHandle, 'ma_linear_resampler_init');
  ma_linear_resampler_init_preallocated := GetProcAddress(aDLLHandle, 'ma_linear_resampler_init_preallocated');
  ma_linear_resampler_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_linear_resampler_process_pcm_frames');
  ma_linear_resampler_reset := GetProcAddress(aDLLHandle, 'ma_linear_resampler_reset');
  ma_linear_resampler_set_rate := GetProcAddress(aDLLHandle, 'ma_linear_resampler_set_rate');
  ma_linear_resampler_set_rate_ratio := GetProcAddress(aDLLHandle, 'ma_linear_resampler_set_rate_ratio');
  ma_linear_resampler_uninit := GetProcAddress(aDLLHandle, 'ma_linear_resampler_uninit');
  ma_log_callback_init := GetProcAddress(aDLLHandle, 'ma_log_callback_init');
  ma_log_init := GetProcAddress(aDLLHandle, 'ma_log_init');
  ma_log_level_to_string := GetProcAddress(aDLLHandle, 'ma_log_level_to_string');
  ma_log_post := GetProcAddress(aDLLHandle, 'ma_log_post');
  ma_log_postf := GetProcAddress(aDLLHandle, 'ma_log_postf');
  ma_log_postv := GetProcAddress(aDLLHandle, 'ma_log_postv');
  ma_log_register_callback := GetProcAddress(aDLLHandle, 'ma_log_register_callback');
  ma_log_uninit := GetProcAddress(aDLLHandle, 'ma_log_uninit');
  ma_log_unregister_callback := GetProcAddress(aDLLHandle, 'ma_log_unregister_callback');
  ma_loshelf_node_config_init := GetProcAddress(aDLLHandle, 'ma_loshelf_node_config_init');
  ma_loshelf_node_init := GetProcAddress(aDLLHandle, 'ma_loshelf_node_init');
  ma_loshelf_node_reinit := GetProcAddress(aDLLHandle, 'ma_loshelf_node_reinit');
  ma_loshelf_node_uninit := GetProcAddress(aDLLHandle, 'ma_loshelf_node_uninit');
  ma_loshelf2_config_init := GetProcAddress(aDLLHandle, 'ma_loshelf2_config_init');
  ma_loshelf2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_loshelf2_get_heap_size');
  ma_loshelf2_get_latency := GetProcAddress(aDLLHandle, 'ma_loshelf2_get_latency');
  ma_loshelf2_init := GetProcAddress(aDLLHandle, 'ma_loshelf2_init');
  ma_loshelf2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_loshelf2_init_preallocated');
  ma_loshelf2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_loshelf2_process_pcm_frames');
  ma_loshelf2_reinit := GetProcAddress(aDLLHandle, 'ma_loshelf2_reinit');
  ma_loshelf2_uninit := GetProcAddress(aDLLHandle, 'ma_loshelf2_uninit');
  ma_lpf_clear_cache := GetProcAddress(aDLLHandle, 'ma_lpf_clear_cache');
  ma_lpf_config_init := GetProcAddress(aDLLHandle, 'ma_lpf_config_init');
  ma_lpf_get_heap_size := GetProcAddress(aDLLHandle, 'ma_lpf_get_heap_size');
  ma_lpf_get_latency := GetProcAddress(aDLLHandle, 'ma_lpf_get_latency');
  ma_lpf_init := GetProcAddress(aDLLHandle, 'ma_lpf_init');
  ma_lpf_init_preallocated := GetProcAddress(aDLLHandle, 'ma_lpf_init_preallocated');
  ma_lpf_node_config_init := GetProcAddress(aDLLHandle, 'ma_lpf_node_config_init');
  ma_lpf_node_init := GetProcAddress(aDLLHandle, 'ma_lpf_node_init');
  ma_lpf_node_reinit := GetProcAddress(aDLLHandle, 'ma_lpf_node_reinit');
  ma_lpf_node_uninit := GetProcAddress(aDLLHandle, 'ma_lpf_node_uninit');
  ma_lpf_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_lpf_process_pcm_frames');
  ma_lpf_reinit := GetProcAddress(aDLLHandle, 'ma_lpf_reinit');
  ma_lpf_uninit := GetProcAddress(aDLLHandle, 'ma_lpf_uninit');
  ma_lpf1_clear_cache := GetProcAddress(aDLLHandle, 'ma_lpf1_clear_cache');
  ma_lpf1_config_init := GetProcAddress(aDLLHandle, 'ma_lpf1_config_init');
  ma_lpf1_get_heap_size := GetProcAddress(aDLLHandle, 'ma_lpf1_get_heap_size');
  ma_lpf1_get_latency := GetProcAddress(aDLLHandle, 'ma_lpf1_get_latency');
  ma_lpf1_init := GetProcAddress(aDLLHandle, 'ma_lpf1_init');
  ma_lpf1_init_preallocated := GetProcAddress(aDLLHandle, 'ma_lpf1_init_preallocated');
  ma_lpf1_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_lpf1_process_pcm_frames');
  ma_lpf1_reinit := GetProcAddress(aDLLHandle, 'ma_lpf1_reinit');
  ma_lpf1_uninit := GetProcAddress(aDLLHandle, 'ma_lpf1_uninit');
  ma_lpf2_clear_cache := GetProcAddress(aDLLHandle, 'ma_lpf2_clear_cache');
  ma_lpf2_config_init := GetProcAddress(aDLLHandle, 'ma_lpf2_config_init');
  ma_lpf2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_lpf2_get_heap_size');
  ma_lpf2_get_latency := GetProcAddress(aDLLHandle, 'ma_lpf2_get_latency');
  ma_lpf2_init := GetProcAddress(aDLLHandle, 'ma_lpf2_init');
  ma_lpf2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_lpf2_init_preallocated');
  ma_lpf2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_lpf2_process_pcm_frames');
  ma_lpf2_reinit := GetProcAddress(aDLLHandle, 'ma_lpf2_reinit');
  ma_lpf2_uninit := GetProcAddress(aDLLHandle, 'ma_lpf2_uninit');
  ma_malloc := GetProcAddress(aDLLHandle, 'ma_malloc');
  ma_mix_pcm_frames_f32 := GetProcAddress(aDLLHandle, 'ma_mix_pcm_frames_f32');
  ma_mutex_init := GetProcAddress(aDLLHandle, 'ma_mutex_init');
  ma_mutex_lock := GetProcAddress(aDLLHandle, 'ma_mutex_lock');
  ma_mutex_uninit := GetProcAddress(aDLLHandle, 'ma_mutex_uninit');
  ma_mutex_unlock := GetProcAddress(aDLLHandle, 'ma_mutex_unlock');
  ma_node_attach_output_bus := GetProcAddress(aDLLHandle, 'ma_node_attach_output_bus');
  ma_node_config_init := GetProcAddress(aDLLHandle, 'ma_node_config_init');
  ma_node_detach_all_output_buses := GetProcAddress(aDLLHandle, 'ma_node_detach_all_output_buses');
  ma_node_detach_output_bus := GetProcAddress(aDLLHandle, 'ma_node_detach_output_bus');
  ma_node_get_heap_size := GetProcAddress(aDLLHandle, 'ma_node_get_heap_size');
  ma_node_get_input_bus_count := GetProcAddress(aDLLHandle, 'ma_node_get_input_bus_count');
  ma_node_get_input_channels := GetProcAddress(aDLLHandle, 'ma_node_get_input_channels');
  ma_node_get_node_graph := GetProcAddress(aDLLHandle, 'ma_node_get_node_graph');
  ma_node_get_output_bus_count := GetProcAddress(aDLLHandle, 'ma_node_get_output_bus_count');
  ma_node_get_output_bus_volume := GetProcAddress(aDLLHandle, 'ma_node_get_output_bus_volume');
  ma_node_get_output_channels := GetProcAddress(aDLLHandle, 'ma_node_get_output_channels');
  ma_node_get_state := GetProcAddress(aDLLHandle, 'ma_node_get_state');
  ma_node_get_state_by_time := GetProcAddress(aDLLHandle, 'ma_node_get_state_by_time');
  ma_node_get_state_by_time_range := GetProcAddress(aDLLHandle, 'ma_node_get_state_by_time_range');
  ma_node_get_state_time := GetProcAddress(aDLLHandle, 'ma_node_get_state_time');
  ma_node_get_time := GetProcAddress(aDLLHandle, 'ma_node_get_time');
  ma_node_graph_config_init := GetProcAddress(aDLLHandle, 'ma_node_graph_config_init');
  ma_node_graph_get_channels := GetProcAddress(aDLLHandle, 'ma_node_graph_get_channels');
  ma_node_graph_get_endpoint := GetProcAddress(aDLLHandle, 'ma_node_graph_get_endpoint');
  ma_node_graph_get_time := GetProcAddress(aDLLHandle, 'ma_node_graph_get_time');
  ma_node_graph_init := GetProcAddress(aDLLHandle, 'ma_node_graph_init');
  ma_node_graph_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_node_graph_read_pcm_frames');
  ma_node_graph_set_time := GetProcAddress(aDLLHandle, 'ma_node_graph_set_time');
  ma_node_graph_uninit := GetProcAddress(aDLLHandle, 'ma_node_graph_uninit');
  ma_node_init := GetProcAddress(aDLLHandle, 'ma_node_init');
  ma_node_init_preallocated := GetProcAddress(aDLLHandle, 'ma_node_init_preallocated');
  ma_node_set_output_bus_volume := GetProcAddress(aDLLHandle, 'ma_node_set_output_bus_volume');
  ma_node_set_state := GetProcAddress(aDLLHandle, 'ma_node_set_state');
  ma_node_set_state_time := GetProcAddress(aDLLHandle, 'ma_node_set_state_time');
  ma_node_set_time := GetProcAddress(aDLLHandle, 'ma_node_set_time');
  ma_node_uninit := GetProcAddress(aDLLHandle, 'ma_node_uninit');
  ma_noise_config_init := GetProcAddress(aDLLHandle, 'ma_noise_config_init');
  ma_noise_get_heap_size := GetProcAddress(aDLLHandle, 'ma_noise_get_heap_size');
  ma_noise_init := GetProcAddress(aDLLHandle, 'ma_noise_init');
  ma_noise_init_preallocated := GetProcAddress(aDLLHandle, 'ma_noise_init_preallocated');
  ma_noise_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_noise_read_pcm_frames');
  ma_noise_set_amplitude := GetProcAddress(aDLLHandle, 'ma_noise_set_amplitude');
  ma_noise_set_seed := GetProcAddress(aDLLHandle, 'ma_noise_set_seed');
  ma_noise_set_type := GetProcAddress(aDLLHandle, 'ma_noise_set_type');
  ma_noise_uninit := GetProcAddress(aDLLHandle, 'ma_noise_uninit');
  ma_notch_node_config_init := GetProcAddress(aDLLHandle, 'ma_notch_node_config_init');
  ma_notch_node_init := GetProcAddress(aDLLHandle, 'ma_notch_node_init');
  ma_notch_node_reinit := GetProcAddress(aDLLHandle, 'ma_notch_node_reinit');
  ma_notch_node_uninit := GetProcAddress(aDLLHandle, 'ma_notch_node_uninit');
  ma_notch2_config_init := GetProcAddress(aDLLHandle, 'ma_notch2_config_init');
  ma_notch2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_notch2_get_heap_size');
  ma_notch2_get_latency := GetProcAddress(aDLLHandle, 'ma_notch2_get_latency');
  ma_notch2_init := GetProcAddress(aDLLHandle, 'ma_notch2_init');
  ma_notch2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_notch2_init_preallocated');
  ma_notch2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_notch2_process_pcm_frames');
  ma_notch2_reinit := GetProcAddress(aDLLHandle, 'ma_notch2_reinit');
  ma_notch2_uninit := GetProcAddress(aDLLHandle, 'ma_notch2_uninit');
  ma_offset_pcm_frames_const_ptr := GetProcAddress(aDLLHandle, 'ma_offset_pcm_frames_const_ptr');
  ma_offset_pcm_frames_ptr := GetProcAddress(aDLLHandle, 'ma_offset_pcm_frames_ptr');
  ma_paged_audio_buffer_config_init := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_config_init');
  ma_paged_audio_buffer_data_allocate_and_append_page := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_allocate_and_append_page');
  ma_paged_audio_buffer_data_allocate_page := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_allocate_page');
  ma_paged_audio_buffer_data_append_page := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_append_page');
  ma_paged_audio_buffer_data_free_page := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_free_page');
  ma_paged_audio_buffer_data_get_head := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_get_head');
  ma_paged_audio_buffer_data_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_get_length_in_pcm_frames');
  ma_paged_audio_buffer_data_get_tail := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_get_tail');
  ma_paged_audio_buffer_data_init := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_init');
  ma_paged_audio_buffer_data_uninit := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_data_uninit');
  ma_paged_audio_buffer_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_get_cursor_in_pcm_frames');
  ma_paged_audio_buffer_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_get_length_in_pcm_frames');
  ma_paged_audio_buffer_init := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_init');
  ma_paged_audio_buffer_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_read_pcm_frames');
  ma_paged_audio_buffer_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_seek_to_pcm_frame');
  ma_paged_audio_buffer_uninit := GetProcAddress(aDLLHandle, 'ma_paged_audio_buffer_uninit');
  ma_panner_config_init := GetProcAddress(aDLLHandle, 'ma_panner_config_init');
  ma_panner_get_mode := GetProcAddress(aDLLHandle, 'ma_panner_get_mode');
  ma_panner_get_pan := GetProcAddress(aDLLHandle, 'ma_panner_get_pan');
  ma_panner_init := GetProcAddress(aDLLHandle, 'ma_panner_init');
  ma_panner_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_panner_process_pcm_frames');
  ma_panner_set_mode := GetProcAddress(aDLLHandle, 'ma_panner_set_mode');
  ma_panner_set_pan := GetProcAddress(aDLLHandle, 'ma_panner_set_pan');
  ma_pcm_convert := GetProcAddress(aDLLHandle, 'ma_pcm_convert');
  ma_pcm_f32_to_s16 := GetProcAddress(aDLLHandle, 'ma_pcm_f32_to_s16');
  ma_pcm_f32_to_s24 := GetProcAddress(aDLLHandle, 'ma_pcm_f32_to_s24');
  ma_pcm_f32_to_s32 := GetProcAddress(aDLLHandle, 'ma_pcm_f32_to_s32');
  ma_pcm_f32_to_u8 := GetProcAddress(aDLLHandle, 'ma_pcm_f32_to_u8');
  ma_pcm_rb_acquire_read := GetProcAddress(aDLLHandle, 'ma_pcm_rb_acquire_read');
  ma_pcm_rb_acquire_write := GetProcAddress(aDLLHandle, 'ma_pcm_rb_acquire_write');
  ma_pcm_rb_available_read := GetProcAddress(aDLLHandle, 'ma_pcm_rb_available_read');
  ma_pcm_rb_available_write := GetProcAddress(aDLLHandle, 'ma_pcm_rb_available_write');
  ma_pcm_rb_commit_read := GetProcAddress(aDLLHandle, 'ma_pcm_rb_commit_read');
  ma_pcm_rb_commit_write := GetProcAddress(aDLLHandle, 'ma_pcm_rb_commit_write');
  ma_pcm_rb_get_channels := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_channels');
  ma_pcm_rb_get_format := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_format');
  ma_pcm_rb_get_sample_rate := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_sample_rate');
  ma_pcm_rb_get_subbuffer_offset := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_subbuffer_offset');
  ma_pcm_rb_get_subbuffer_ptr := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_subbuffer_ptr');
  ma_pcm_rb_get_subbuffer_size := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_subbuffer_size');
  ma_pcm_rb_get_subbuffer_stride := GetProcAddress(aDLLHandle, 'ma_pcm_rb_get_subbuffer_stride');
  ma_pcm_rb_init := GetProcAddress(aDLLHandle, 'ma_pcm_rb_init');
  ma_pcm_rb_init_ex := GetProcAddress(aDLLHandle, 'ma_pcm_rb_init_ex');
  ma_pcm_rb_pointer_distance := GetProcAddress(aDLLHandle, 'ma_pcm_rb_pointer_distance');
  ma_pcm_rb_reset := GetProcAddress(aDLLHandle, 'ma_pcm_rb_reset');
  ma_pcm_rb_seek_read := GetProcAddress(aDLLHandle, 'ma_pcm_rb_seek_read');
  ma_pcm_rb_seek_write := GetProcAddress(aDLLHandle, 'ma_pcm_rb_seek_write');
  ma_pcm_rb_set_sample_rate := GetProcAddress(aDLLHandle, 'ma_pcm_rb_set_sample_rate');
  ma_pcm_rb_uninit := GetProcAddress(aDLLHandle, 'ma_pcm_rb_uninit');
  ma_pcm_s16_to_f32 := GetProcAddress(aDLLHandle, 'ma_pcm_s16_to_f32');
  ma_pcm_s16_to_s24 := GetProcAddress(aDLLHandle, 'ma_pcm_s16_to_s24');
  ma_pcm_s16_to_s32 := GetProcAddress(aDLLHandle, 'ma_pcm_s16_to_s32');
  ma_pcm_s16_to_u8 := GetProcAddress(aDLLHandle, 'ma_pcm_s16_to_u8');
  ma_pcm_s24_to_f32 := GetProcAddress(aDLLHandle, 'ma_pcm_s24_to_f32');
  ma_pcm_s24_to_s16 := GetProcAddress(aDLLHandle, 'ma_pcm_s24_to_s16');
  ma_pcm_s24_to_s32 := GetProcAddress(aDLLHandle, 'ma_pcm_s24_to_s32');
  ma_pcm_s24_to_u8 := GetProcAddress(aDLLHandle, 'ma_pcm_s24_to_u8');
  ma_pcm_s32_to_f32 := GetProcAddress(aDLLHandle, 'ma_pcm_s32_to_f32');
  ma_pcm_s32_to_s16 := GetProcAddress(aDLLHandle, 'ma_pcm_s32_to_s16');
  ma_pcm_s32_to_s24 := GetProcAddress(aDLLHandle, 'ma_pcm_s32_to_s24');
  ma_pcm_s32_to_u8 := GetProcAddress(aDLLHandle, 'ma_pcm_s32_to_u8');
  ma_pcm_u8_to_f32 := GetProcAddress(aDLLHandle, 'ma_pcm_u8_to_f32');
  ma_pcm_u8_to_s16 := GetProcAddress(aDLLHandle, 'ma_pcm_u8_to_s16');
  ma_pcm_u8_to_s24 := GetProcAddress(aDLLHandle, 'ma_pcm_u8_to_s24');
  ma_pcm_u8_to_s32 := GetProcAddress(aDLLHandle, 'ma_pcm_u8_to_s32');
  ma_peak_node_config_init := GetProcAddress(aDLLHandle, 'ma_peak_node_config_init');
  ma_peak_node_init := GetProcAddress(aDLLHandle, 'ma_peak_node_init');
  ma_peak_node_reinit := GetProcAddress(aDLLHandle, 'ma_peak_node_reinit');
  ma_peak_node_uninit := GetProcAddress(aDLLHandle, 'ma_peak_node_uninit');
  ma_peak2_config_init := GetProcAddress(aDLLHandle, 'ma_peak2_config_init');
  ma_peak2_get_heap_size := GetProcAddress(aDLLHandle, 'ma_peak2_get_heap_size');
  ma_peak2_get_latency := GetProcAddress(aDLLHandle, 'ma_peak2_get_latency');
  ma_peak2_init := GetProcAddress(aDLLHandle, 'ma_peak2_init');
  ma_peak2_init_preallocated := GetProcAddress(aDLLHandle, 'ma_peak2_init_preallocated');
  ma_peak2_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_peak2_process_pcm_frames');
  ma_peak2_reinit := GetProcAddress(aDLLHandle, 'ma_peak2_reinit');
  ma_peak2_uninit := GetProcAddress(aDLLHandle, 'ma_peak2_uninit');
  ma_pulsewave_config_init := GetProcAddress(aDLLHandle, 'ma_pulsewave_config_init');
  ma_pulsewave_init := GetProcAddress(aDLLHandle, 'ma_pulsewave_init');
  ma_pulsewave_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_pulsewave_read_pcm_frames');
  ma_pulsewave_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_pulsewave_seek_to_pcm_frame');
  ma_pulsewave_set_amplitude := GetProcAddress(aDLLHandle, 'ma_pulsewave_set_amplitude');
  ma_pulsewave_set_duty_cycle := GetProcAddress(aDLLHandle, 'ma_pulsewave_set_duty_cycle');
  ma_pulsewave_set_frequency := GetProcAddress(aDLLHandle, 'ma_pulsewave_set_frequency');
  ma_pulsewave_set_sample_rate := GetProcAddress(aDLLHandle, 'ma_pulsewave_set_sample_rate');
  ma_pulsewave_uninit := GetProcAddress(aDLLHandle, 'ma_pulsewave_uninit');
  ma_rb_acquire_read := GetProcAddress(aDLLHandle, 'ma_rb_acquire_read');
  ma_rb_acquire_write := GetProcAddress(aDLLHandle, 'ma_rb_acquire_write');
  ma_rb_available_read := GetProcAddress(aDLLHandle, 'ma_rb_available_read');
  ma_rb_available_write := GetProcAddress(aDLLHandle, 'ma_rb_available_write');
  ma_rb_commit_read := GetProcAddress(aDLLHandle, 'ma_rb_commit_read');
  ma_rb_commit_write := GetProcAddress(aDLLHandle, 'ma_rb_commit_write');
  ma_rb_get_subbuffer_offset := GetProcAddress(aDLLHandle, 'ma_rb_get_subbuffer_offset');
  ma_rb_get_subbuffer_ptr := GetProcAddress(aDLLHandle, 'ma_rb_get_subbuffer_ptr');
  ma_rb_get_subbuffer_size := GetProcAddress(aDLLHandle, 'ma_rb_get_subbuffer_size');
  ma_rb_get_subbuffer_stride := GetProcAddress(aDLLHandle, 'ma_rb_get_subbuffer_stride');
  ma_rb_init := GetProcAddress(aDLLHandle, 'ma_rb_init');
  ma_rb_init_ex := GetProcAddress(aDLLHandle, 'ma_rb_init_ex');
  ma_rb_pointer_distance := GetProcAddress(aDLLHandle, 'ma_rb_pointer_distance');
  ma_rb_reset := GetProcAddress(aDLLHandle, 'ma_rb_reset');
  ma_rb_seek_read := GetProcAddress(aDLLHandle, 'ma_rb_seek_read');
  ma_rb_seek_write := GetProcAddress(aDLLHandle, 'ma_rb_seek_write');
  ma_rb_uninit := GetProcAddress(aDLLHandle, 'ma_rb_uninit');
  ma_realloc := GetProcAddress(aDLLHandle, 'ma_realloc');
  ma_resampler_config_init := GetProcAddress(aDLLHandle, 'ma_resampler_config_init');
  ma_resampler_get_expected_output_frame_count := GetProcAddress(aDLLHandle, 'ma_resampler_get_expected_output_frame_count');
  ma_resampler_get_heap_size := GetProcAddress(aDLLHandle, 'ma_resampler_get_heap_size');
  ma_resampler_get_input_latency := GetProcAddress(aDLLHandle, 'ma_resampler_get_input_latency');
  ma_resampler_get_output_latency := GetProcAddress(aDLLHandle, 'ma_resampler_get_output_latency');
  ma_resampler_get_required_input_frame_count := GetProcAddress(aDLLHandle, 'ma_resampler_get_required_input_frame_count');
  ma_resampler_init := GetProcAddress(aDLLHandle, 'ma_resampler_init');
  ma_resampler_init_preallocated := GetProcAddress(aDLLHandle, 'ma_resampler_init_preallocated');
  ma_resampler_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resampler_process_pcm_frames');
  ma_resampler_reset := GetProcAddress(aDLLHandle, 'ma_resampler_reset');
  ma_resampler_set_rate := GetProcAddress(aDLLHandle, 'ma_resampler_set_rate');
  ma_resampler_set_rate_ratio := GetProcAddress(aDLLHandle, 'ma_resampler_set_rate_ratio');
  ma_resampler_uninit := GetProcAddress(aDLLHandle, 'ma_resampler_uninit');
  ma_resource_manager_config_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_config_init');
  ma_resource_manager_data_buffer_get_available_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_get_available_frames');
  ma_resource_manager_data_buffer_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_get_cursor_in_pcm_frames');
  ma_resource_manager_data_buffer_get_data_format := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_get_data_format');
  ma_resource_manager_data_buffer_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_get_length_in_pcm_frames');
  ma_resource_manager_data_buffer_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_init');
  ma_resource_manager_data_buffer_init_copy := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_init_copy');
  ma_resource_manager_data_buffer_init_ex := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_init_ex');
  ma_resource_manager_data_buffer_init_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_init_w');
  ma_resource_manager_data_buffer_is_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_is_looping');
  ma_resource_manager_data_buffer_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_read_pcm_frames');
  ma_resource_manager_data_buffer_result := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_result');
  ma_resource_manager_data_buffer_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_seek_to_pcm_frame');
  ma_resource_manager_data_buffer_set_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_set_looping');
  ma_resource_manager_data_buffer_uninit := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_buffer_uninit');
  ma_resource_manager_data_source_config_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_config_init');
  ma_resource_manager_data_source_get_available_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_get_available_frames');
  ma_resource_manager_data_source_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_get_cursor_in_pcm_frames');
  ma_resource_manager_data_source_get_data_format := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_get_data_format');
  ma_resource_manager_data_source_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_get_length_in_pcm_frames');
  ma_resource_manager_data_source_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_init');
  ma_resource_manager_data_source_init_copy := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_init_copy');
  ma_resource_manager_data_source_init_ex := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_init_ex');
  ma_resource_manager_data_source_init_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_init_w');
  ma_resource_manager_data_source_is_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_is_looping');
  ma_resource_manager_data_source_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_read_pcm_frames');
  ma_resource_manager_data_source_result := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_result');
  ma_resource_manager_data_source_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_seek_to_pcm_frame');
  ma_resource_manager_data_source_set_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_set_looping');
  ma_resource_manager_data_source_uninit := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_source_uninit');
  ma_resource_manager_data_stream_get_available_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_get_available_frames');
  ma_resource_manager_data_stream_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_get_cursor_in_pcm_frames');
  ma_resource_manager_data_stream_get_data_format := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_get_data_format');
  ma_resource_manager_data_stream_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_get_length_in_pcm_frames');
  ma_resource_manager_data_stream_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_init');
  ma_resource_manager_data_stream_init_ex := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_init_ex');
  ma_resource_manager_data_stream_init_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_init_w');
  ma_resource_manager_data_stream_is_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_is_looping');
  ma_resource_manager_data_stream_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_read_pcm_frames');
  ma_resource_manager_data_stream_result := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_result');
  ma_resource_manager_data_stream_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_seek_to_pcm_frame');
  ma_resource_manager_data_stream_set_looping := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_set_looping');
  ma_resource_manager_data_stream_uninit := GetProcAddress(aDLLHandle, 'ma_resource_manager_data_stream_uninit');
  ma_resource_manager_get_log := GetProcAddress(aDLLHandle, 'ma_resource_manager_get_log');
  ma_resource_manager_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_init');
  ma_resource_manager_next_job := GetProcAddress(aDLLHandle, 'ma_resource_manager_next_job');
  ma_resource_manager_pipeline_notifications_init := GetProcAddress(aDLLHandle, 'ma_resource_manager_pipeline_notifications_init');
  ma_resource_manager_post_job := GetProcAddress(aDLLHandle, 'ma_resource_manager_post_job');
  ma_resource_manager_post_job_quit := GetProcAddress(aDLLHandle, 'ma_resource_manager_post_job_quit');
  ma_resource_manager_process_job := GetProcAddress(aDLLHandle, 'ma_resource_manager_process_job');
  ma_resource_manager_process_next_job := GetProcAddress(aDLLHandle, 'ma_resource_manager_process_next_job');
  ma_resource_manager_register_decoded_data := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_decoded_data');
  ma_resource_manager_register_decoded_data_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_decoded_data_w');
  ma_resource_manager_register_encoded_data := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_encoded_data');
  ma_resource_manager_register_encoded_data_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_encoded_data_w');
  ma_resource_manager_register_file := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_file');
  ma_resource_manager_register_file_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_register_file_w');
  ma_resource_manager_uninit := GetProcAddress(aDLLHandle, 'ma_resource_manager_uninit');
  ma_resource_manager_unregister_data := GetProcAddress(aDLLHandle, 'ma_resource_manager_unregister_data');
  ma_resource_manager_unregister_data_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_unregister_data_w');
  ma_resource_manager_unregister_file := GetProcAddress(aDLLHandle, 'ma_resource_manager_unregister_file');
  ma_resource_manager_unregister_file_w := GetProcAddress(aDLLHandle, 'ma_resource_manager_unregister_file_w');
  ma_result_description := GetProcAddress(aDLLHandle, 'ma_result_description');
  ma_silence_pcm_frames := GetProcAddress(aDLLHandle, 'ma_silence_pcm_frames');
  ma_slot_allocator_alloc := GetProcAddress(aDLLHandle, 'ma_slot_allocator_alloc');
  ma_slot_allocator_config_init := GetProcAddress(aDLLHandle, 'ma_slot_allocator_config_init');
  ma_slot_allocator_free := GetProcAddress(aDLLHandle, 'ma_slot_allocator_free');
  ma_slot_allocator_get_heap_size := GetProcAddress(aDLLHandle, 'ma_slot_allocator_get_heap_size');
  ma_slot_allocator_init := GetProcAddress(aDLLHandle, 'ma_slot_allocator_init');
  ma_slot_allocator_init_preallocated := GetProcAddress(aDLLHandle, 'ma_slot_allocator_init_preallocated');
  ma_slot_allocator_uninit := GetProcAddress(aDLLHandle, 'ma_slot_allocator_uninit');
  ma_sound_at_end := GetProcAddress(aDLLHandle, 'ma_sound_at_end');
  ma_sound_config_init := GetProcAddress(aDLLHandle, 'ma_sound_config_init');
  ma_sound_config_init_2 := GetProcAddress(aDLLHandle, 'ma_sound_config_init_2');
  ma_sound_get_attenuation_model := GetProcAddress(aDLLHandle, 'ma_sound_get_attenuation_model');
  ma_sound_get_cone := GetProcAddress(aDLLHandle, 'ma_sound_get_cone');
  ma_sound_get_current_fade_volume := GetProcAddress(aDLLHandle, 'ma_sound_get_current_fade_volume');
  ma_sound_get_cursor_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_get_cursor_in_pcm_frames');
  ma_sound_get_cursor_in_seconds := GetProcAddress(aDLLHandle, 'ma_sound_get_cursor_in_seconds');
  ma_sound_get_data_format := GetProcAddress(aDLLHandle, 'ma_sound_get_data_format');
  ma_sound_get_data_source := GetProcAddress(aDLLHandle, 'ma_sound_get_data_source');
  ma_sound_get_direction := GetProcAddress(aDLLHandle, 'ma_sound_get_direction');
  ma_sound_get_direction_to_listener := GetProcAddress(aDLLHandle, 'ma_sound_get_direction_to_listener');
  ma_sound_get_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_sound_get_directional_attenuation_factor');
  ma_sound_get_doppler_factor := GetProcAddress(aDLLHandle, 'ma_sound_get_doppler_factor');
  ma_sound_get_engine := GetProcAddress(aDLLHandle, 'ma_sound_get_engine');
  ma_sound_get_length_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_get_length_in_pcm_frames');
  ma_sound_get_length_in_seconds := GetProcAddress(aDLLHandle, 'ma_sound_get_length_in_seconds');
  ma_sound_get_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_get_listener_index');
  ma_sound_get_max_distance := GetProcAddress(aDLLHandle, 'ma_sound_get_max_distance');
  ma_sound_get_max_gain := GetProcAddress(aDLLHandle, 'ma_sound_get_max_gain');
  ma_sound_get_min_distance := GetProcAddress(aDLLHandle, 'ma_sound_get_min_distance');
  ma_sound_get_min_gain := GetProcAddress(aDLLHandle, 'ma_sound_get_min_gain');
  ma_sound_get_pan := GetProcAddress(aDLLHandle, 'ma_sound_get_pan');
  ma_sound_get_pan_mode := GetProcAddress(aDLLHandle, 'ma_sound_get_pan_mode');
  ma_sound_get_pinned_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_get_pinned_listener_index');
  ma_sound_get_pitch := GetProcAddress(aDLLHandle, 'ma_sound_get_pitch');
  ma_sound_get_position := GetProcAddress(aDLLHandle, 'ma_sound_get_position');
  ma_sound_get_positioning := GetProcAddress(aDLLHandle, 'ma_sound_get_positioning');
  ma_sound_get_rolloff := GetProcAddress(aDLLHandle, 'ma_sound_get_rolloff');
  ma_sound_get_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_get_time_in_milliseconds');
  ma_sound_get_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_get_time_in_pcm_frames');
  ma_sound_get_velocity := GetProcAddress(aDLLHandle, 'ma_sound_get_velocity');
  ma_sound_get_volume := GetProcAddress(aDLLHandle, 'ma_sound_get_volume');
  ma_sound_group_config_init := GetProcAddress(aDLLHandle, 'ma_sound_group_config_init');
  ma_sound_group_config_init_2 := GetProcAddress(aDLLHandle, 'ma_sound_group_config_init_2');
  ma_sound_group_get_attenuation_model := GetProcAddress(aDLLHandle, 'ma_sound_group_get_attenuation_model');
  ma_sound_group_get_cone := GetProcAddress(aDLLHandle, 'ma_sound_group_get_cone');
  ma_sound_group_get_current_fade_volume := GetProcAddress(aDLLHandle, 'ma_sound_group_get_current_fade_volume');
  ma_sound_group_get_direction := GetProcAddress(aDLLHandle, 'ma_sound_group_get_direction');
  ma_sound_group_get_direction_to_listener := GetProcAddress(aDLLHandle, 'ma_sound_group_get_direction_to_listener');
  ma_sound_group_get_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_sound_group_get_directional_attenuation_factor');
  ma_sound_group_get_doppler_factor := GetProcAddress(aDLLHandle, 'ma_sound_group_get_doppler_factor');
  ma_sound_group_get_engine := GetProcAddress(aDLLHandle, 'ma_sound_group_get_engine');
  ma_sound_group_get_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_group_get_listener_index');
  ma_sound_group_get_max_distance := GetProcAddress(aDLLHandle, 'ma_sound_group_get_max_distance');
  ma_sound_group_get_max_gain := GetProcAddress(aDLLHandle, 'ma_sound_group_get_max_gain');
  ma_sound_group_get_min_distance := GetProcAddress(aDLLHandle, 'ma_sound_group_get_min_distance');
  ma_sound_group_get_min_gain := GetProcAddress(aDLLHandle, 'ma_sound_group_get_min_gain');
  ma_sound_group_get_pan := GetProcAddress(aDLLHandle, 'ma_sound_group_get_pan');
  ma_sound_group_get_pan_mode := GetProcAddress(aDLLHandle, 'ma_sound_group_get_pan_mode');
  ma_sound_group_get_pinned_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_group_get_pinned_listener_index');
  ma_sound_group_get_pitch := GetProcAddress(aDLLHandle, 'ma_sound_group_get_pitch');
  ma_sound_group_get_position := GetProcAddress(aDLLHandle, 'ma_sound_group_get_position');
  ma_sound_group_get_positioning := GetProcAddress(aDLLHandle, 'ma_sound_group_get_positioning');
  ma_sound_group_get_rolloff := GetProcAddress(aDLLHandle, 'ma_sound_group_get_rolloff');
  ma_sound_group_get_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_group_get_time_in_pcm_frames');
  ma_sound_group_get_velocity := GetProcAddress(aDLLHandle, 'ma_sound_group_get_velocity');
  ma_sound_group_get_volume := GetProcAddress(aDLLHandle, 'ma_sound_group_get_volume');
  ma_sound_group_init := GetProcAddress(aDLLHandle, 'ma_sound_group_init');
  ma_sound_group_init_ex := GetProcAddress(aDLLHandle, 'ma_sound_group_init_ex');
  ma_sound_group_is_playing := GetProcAddress(aDLLHandle, 'ma_sound_group_is_playing');
  ma_sound_group_is_spatialization_enabled := GetProcAddress(aDLLHandle, 'ma_sound_group_is_spatialization_enabled');
  ma_sound_group_set_attenuation_model := GetProcAddress(aDLLHandle, 'ma_sound_group_set_attenuation_model');
  ma_sound_group_set_cone := GetProcAddress(aDLLHandle, 'ma_sound_group_set_cone');
  ma_sound_group_set_direction := GetProcAddress(aDLLHandle, 'ma_sound_group_set_direction');
  ma_sound_group_set_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_sound_group_set_directional_attenuation_factor');
  ma_sound_group_set_doppler_factor := GetProcAddress(aDLLHandle, 'ma_sound_group_set_doppler_factor');
  ma_sound_group_set_fade_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_group_set_fade_in_milliseconds');
  ma_sound_group_set_fade_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_group_set_fade_in_pcm_frames');
  ma_sound_group_set_max_distance := GetProcAddress(aDLLHandle, 'ma_sound_group_set_max_distance');
  ma_sound_group_set_max_gain := GetProcAddress(aDLLHandle, 'ma_sound_group_set_max_gain');
  ma_sound_group_set_min_distance := GetProcAddress(aDLLHandle, 'ma_sound_group_set_min_distance');
  ma_sound_group_set_min_gain := GetProcAddress(aDLLHandle, 'ma_sound_group_set_min_gain');
  ma_sound_group_set_pan := GetProcAddress(aDLLHandle, 'ma_sound_group_set_pan');
  ma_sound_group_set_pan_mode := GetProcAddress(aDLLHandle, 'ma_sound_group_set_pan_mode');
  ma_sound_group_set_pinned_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_group_set_pinned_listener_index');
  ma_sound_group_set_pitch := GetProcAddress(aDLLHandle, 'ma_sound_group_set_pitch');
  ma_sound_group_set_position := GetProcAddress(aDLLHandle, 'ma_sound_group_set_position');
  ma_sound_group_set_positioning := GetProcAddress(aDLLHandle, 'ma_sound_group_set_positioning');
  ma_sound_group_set_rolloff := GetProcAddress(aDLLHandle, 'ma_sound_group_set_rolloff');
  ma_sound_group_set_spatialization_enabled := GetProcAddress(aDLLHandle, 'ma_sound_group_set_spatialization_enabled');
  ma_sound_group_set_start_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_group_set_start_time_in_milliseconds');
  ma_sound_group_set_start_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_group_set_start_time_in_pcm_frames');
  ma_sound_group_set_stop_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_group_set_stop_time_in_milliseconds');
  ma_sound_group_set_stop_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_group_set_stop_time_in_pcm_frames');
  ma_sound_group_set_velocity := GetProcAddress(aDLLHandle, 'ma_sound_group_set_velocity');
  ma_sound_group_set_volume := GetProcAddress(aDLLHandle, 'ma_sound_group_set_volume');
  ma_sound_group_start := GetProcAddress(aDLLHandle, 'ma_sound_group_start');
  ma_sound_group_stop := GetProcAddress(aDLLHandle, 'ma_sound_group_stop');
  ma_sound_group_uninit := GetProcAddress(aDLLHandle, 'ma_sound_group_uninit');
  ma_sound_init_copy := GetProcAddress(aDLLHandle, 'ma_sound_init_copy');
  ma_sound_init_ex := GetProcAddress(aDLLHandle, 'ma_sound_init_ex');
  ma_sound_init_from_data_source := GetProcAddress(aDLLHandle, 'ma_sound_init_from_data_source');
  ma_sound_init_from_file := GetProcAddress(aDLLHandle, 'ma_sound_init_from_file');
  ma_sound_init_from_file_w := GetProcAddress(aDLLHandle, 'ma_sound_init_from_file_w');
  ma_sound_is_looping := GetProcAddress(aDLLHandle, 'ma_sound_is_looping');
  ma_sound_is_playing := GetProcAddress(aDLLHandle, 'ma_sound_is_playing');
  ma_sound_is_spatialization_enabled := GetProcAddress(aDLLHandle, 'ma_sound_is_spatialization_enabled');
  ma_sound_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_sound_seek_to_pcm_frame');
  ma_sound_set_attenuation_model := GetProcAddress(aDLLHandle, 'ma_sound_set_attenuation_model');
  ma_sound_set_cone := GetProcAddress(aDLLHandle, 'ma_sound_set_cone');
  ma_sound_set_direction := GetProcAddress(aDLLHandle, 'ma_sound_set_direction');
  ma_sound_set_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_sound_set_directional_attenuation_factor');
  ma_sound_set_doppler_factor := GetProcAddress(aDLLHandle, 'ma_sound_set_doppler_factor');
  ma_sound_set_end_callback := GetProcAddress(aDLLHandle, 'ma_sound_set_end_callback');
  ma_sound_set_fade_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_set_fade_in_milliseconds');
  ma_sound_set_fade_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_set_fade_in_pcm_frames');
  ma_sound_set_fade_start_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_set_fade_start_in_milliseconds');
  ma_sound_set_fade_start_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_set_fade_start_in_pcm_frames');
  ma_sound_set_looping := GetProcAddress(aDLLHandle, 'ma_sound_set_looping');
  ma_sound_set_max_distance := GetProcAddress(aDLLHandle, 'ma_sound_set_max_distance');
  ma_sound_set_max_gain := GetProcAddress(aDLLHandle, 'ma_sound_set_max_gain');
  ma_sound_set_min_distance := GetProcAddress(aDLLHandle, 'ma_sound_set_min_distance');
  ma_sound_set_min_gain := GetProcAddress(aDLLHandle, 'ma_sound_set_min_gain');
  ma_sound_set_pan := GetProcAddress(aDLLHandle, 'ma_sound_set_pan');
  ma_sound_set_pan_mode := GetProcAddress(aDLLHandle, 'ma_sound_set_pan_mode');
  ma_sound_set_pinned_listener_index := GetProcAddress(aDLLHandle, 'ma_sound_set_pinned_listener_index');
  ma_sound_set_pitch := GetProcAddress(aDLLHandle, 'ma_sound_set_pitch');
  ma_sound_set_position := GetProcAddress(aDLLHandle, 'ma_sound_set_position');
  ma_sound_set_positioning := GetProcAddress(aDLLHandle, 'ma_sound_set_positioning');
  ma_sound_set_rolloff := GetProcAddress(aDLLHandle, 'ma_sound_set_rolloff');
  ma_sound_set_spatialization_enabled := GetProcAddress(aDLLHandle, 'ma_sound_set_spatialization_enabled');
  ma_sound_set_start_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_set_start_time_in_milliseconds');
  ma_sound_set_start_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_set_start_time_in_pcm_frames');
  ma_sound_set_stop_time_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_set_stop_time_in_milliseconds');
  ma_sound_set_stop_time_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_set_stop_time_in_pcm_frames');
  ma_sound_set_stop_time_with_fade_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_set_stop_time_with_fade_in_milliseconds');
  ma_sound_set_stop_time_with_fade_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_set_stop_time_with_fade_in_pcm_frames');
  ma_sound_set_velocity := GetProcAddress(aDLLHandle, 'ma_sound_set_velocity');
  ma_sound_set_volume := GetProcAddress(aDLLHandle, 'ma_sound_set_volume');
  ma_sound_start := GetProcAddress(aDLLHandle, 'ma_sound_start');
  ma_sound_stop := GetProcAddress(aDLLHandle, 'ma_sound_stop');
  ma_sound_stop_with_fade_in_milliseconds := GetProcAddress(aDLLHandle, 'ma_sound_stop_with_fade_in_milliseconds');
  ma_sound_stop_with_fade_in_pcm_frames := GetProcAddress(aDLLHandle, 'ma_sound_stop_with_fade_in_pcm_frames');
  ma_sound_uninit := GetProcAddress(aDLLHandle, 'ma_sound_uninit');
  ma_spatializer_config_init := GetProcAddress(aDLLHandle, 'ma_spatializer_config_init');
  ma_spatializer_get_attenuation_model := GetProcAddress(aDLLHandle, 'ma_spatializer_get_attenuation_model');
  ma_spatializer_get_cone := GetProcAddress(aDLLHandle, 'ma_spatializer_get_cone');
  ma_spatializer_get_direction := GetProcAddress(aDLLHandle, 'ma_spatializer_get_direction');
  ma_spatializer_get_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_spatializer_get_directional_attenuation_factor');
  ma_spatializer_get_doppler_factor := GetProcAddress(aDLLHandle, 'ma_spatializer_get_doppler_factor');
  ma_spatializer_get_heap_size := GetProcAddress(aDLLHandle, 'ma_spatializer_get_heap_size');
  ma_spatializer_get_input_channels := GetProcAddress(aDLLHandle, 'ma_spatializer_get_input_channels');
  ma_spatializer_get_master_volume := GetProcAddress(aDLLHandle, 'ma_spatializer_get_master_volume');
  ma_spatializer_get_max_distance := GetProcAddress(aDLLHandle, 'ma_spatializer_get_max_distance');
  ma_spatializer_get_max_gain := GetProcAddress(aDLLHandle, 'ma_spatializer_get_max_gain');
  ma_spatializer_get_min_distance := GetProcAddress(aDLLHandle, 'ma_spatializer_get_min_distance');
  ma_spatializer_get_min_gain := GetProcAddress(aDLLHandle, 'ma_spatializer_get_min_gain');
  ma_spatializer_get_output_channels := GetProcAddress(aDLLHandle, 'ma_spatializer_get_output_channels');
  ma_spatializer_get_position := GetProcAddress(aDLLHandle, 'ma_spatializer_get_position');
  ma_spatializer_get_positioning := GetProcAddress(aDLLHandle, 'ma_spatializer_get_positioning');
  ma_spatializer_get_relative_position_and_direction := GetProcAddress(aDLLHandle, 'ma_spatializer_get_relative_position_and_direction');
  ma_spatializer_get_rolloff := GetProcAddress(aDLLHandle, 'ma_spatializer_get_rolloff');
  ma_spatializer_get_velocity := GetProcAddress(aDLLHandle, 'ma_spatializer_get_velocity');
  ma_spatializer_init := GetProcAddress(aDLLHandle, 'ma_spatializer_init');
  ma_spatializer_init_preallocated := GetProcAddress(aDLLHandle, 'ma_spatializer_init_preallocated');
  ma_spatializer_listener_config_init := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_config_init');
  ma_spatializer_listener_get_channel_map := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_channel_map');
  ma_spatializer_listener_get_cone := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_cone');
  ma_spatializer_listener_get_direction := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_direction');
  ma_spatializer_listener_get_heap_size := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_heap_size');
  ma_spatializer_listener_get_position := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_position');
  ma_spatializer_listener_get_speed_of_sound := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_speed_of_sound');
  ma_spatializer_listener_get_velocity := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_velocity');
  ma_spatializer_listener_get_world_up := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_get_world_up');
  ma_spatializer_listener_init := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_init');
  ma_spatializer_listener_init_preallocated := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_init_preallocated');
  ma_spatializer_listener_is_enabled := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_is_enabled');
  ma_spatializer_listener_set_cone := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_cone');
  ma_spatializer_listener_set_direction := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_direction');
  ma_spatializer_listener_set_enabled := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_enabled');
  ma_spatializer_listener_set_position := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_position');
  ma_spatializer_listener_set_speed_of_sound := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_speed_of_sound');
  ma_spatializer_listener_set_velocity := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_velocity');
  ma_spatializer_listener_set_world_up := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_set_world_up');
  ma_spatializer_listener_uninit := GetProcAddress(aDLLHandle, 'ma_spatializer_listener_uninit');
  ma_spatializer_process_pcm_frames := GetProcAddress(aDLLHandle, 'ma_spatializer_process_pcm_frames');
  ma_spatializer_set_attenuation_model := GetProcAddress(aDLLHandle, 'ma_spatializer_set_attenuation_model');
  ma_spatializer_set_cone := GetProcAddress(aDLLHandle, 'ma_spatializer_set_cone');
  ma_spatializer_set_direction := GetProcAddress(aDLLHandle, 'ma_spatializer_set_direction');
  ma_spatializer_set_directional_attenuation_factor := GetProcAddress(aDLLHandle, 'ma_spatializer_set_directional_attenuation_factor');
  ma_spatializer_set_doppler_factor := GetProcAddress(aDLLHandle, 'ma_spatializer_set_doppler_factor');
  ma_spatializer_set_master_volume := GetProcAddress(aDLLHandle, 'ma_spatializer_set_master_volume');
  ma_spatializer_set_max_distance := GetProcAddress(aDLLHandle, 'ma_spatializer_set_max_distance');
  ma_spatializer_set_max_gain := GetProcAddress(aDLLHandle, 'ma_spatializer_set_max_gain');
  ma_spatializer_set_min_distance := GetProcAddress(aDLLHandle, 'ma_spatializer_set_min_distance');
  ma_spatializer_set_min_gain := GetProcAddress(aDLLHandle, 'ma_spatializer_set_min_gain');
  ma_spatializer_set_position := GetProcAddress(aDLLHandle, 'ma_spatializer_set_position');
  ma_spatializer_set_positioning := GetProcAddress(aDLLHandle, 'ma_spatializer_set_positioning');
  ma_spatializer_set_rolloff := GetProcAddress(aDLLHandle, 'ma_spatializer_set_rolloff');
  ma_spatializer_set_velocity := GetProcAddress(aDLLHandle, 'ma_spatializer_set_velocity');
  ma_spatializer_uninit := GetProcAddress(aDLLHandle, 'ma_spatializer_uninit');
  ma_spinlock_lock := GetProcAddress(aDLLHandle, 'ma_spinlock_lock');
  ma_spinlock_lock_noyield := GetProcAddress(aDLLHandle, 'ma_spinlock_lock_noyield');
  ma_spinlock_unlock := GetProcAddress(aDLLHandle, 'ma_spinlock_unlock');
  ma_splitter_node_config_init := GetProcAddress(aDLLHandle, 'ma_splitter_node_config_init');
  ma_splitter_node_init := GetProcAddress(aDLLHandle, 'ma_splitter_node_init');
  ma_splitter_node_uninit := GetProcAddress(aDLLHandle, 'ma_splitter_node_uninit');
  ma_version := GetProcAddress(aDLLHandle, 'ma_version');
  ma_version_string := GetProcAddress(aDLLHandle, 'ma_version_string');
  ma_vfs_close := GetProcAddress(aDLLHandle, 'ma_vfs_close');
  ma_vfs_info := GetProcAddress(aDLLHandle, 'ma_vfs_info');
  ma_vfs_open := GetProcAddress(aDLLHandle, 'ma_vfs_open');
  ma_vfs_open_and_read_file := GetProcAddress(aDLLHandle, 'ma_vfs_open_and_read_file');
  ma_vfs_open_w := GetProcAddress(aDLLHandle, 'ma_vfs_open_w');
  ma_vfs_read := GetProcAddress(aDLLHandle, 'ma_vfs_read');
  ma_vfs_seek := GetProcAddress(aDLLHandle, 'ma_vfs_seek');
  ma_vfs_tell := GetProcAddress(aDLLHandle, 'ma_vfs_tell');
  ma_vfs_write := GetProcAddress(aDLLHandle, 'ma_vfs_write');
  ma_volume_db_to_linear := GetProcAddress(aDLLHandle, 'ma_volume_db_to_linear');
  ma_volume_linear_to_db := GetProcAddress(aDLLHandle, 'ma_volume_linear_to_db');
  ma_waveform_config_init := GetProcAddress(aDLLHandle, 'ma_waveform_config_init');
  ma_waveform_init := GetProcAddress(aDLLHandle, 'ma_waveform_init');
  ma_waveform_read_pcm_frames := GetProcAddress(aDLLHandle, 'ma_waveform_read_pcm_frames');
  ma_waveform_seek_to_pcm_frame := GetProcAddress(aDLLHandle, 'ma_waveform_seek_to_pcm_frame');
  ma_waveform_set_amplitude := GetProcAddress(aDLLHandle, 'ma_waveform_set_amplitude');
  ma_waveform_set_frequency := GetProcAddress(aDLLHandle, 'ma_waveform_set_frequency');
  ma_waveform_set_sample_rate := GetProcAddress(aDLLHandle, 'ma_waveform_set_sample_rate');
  ma_waveform_set_type := GetProcAddress(aDLLHandle, 'ma_waveform_set_type');
  ma_waveform_uninit := GetProcAddress(aDLLHandle, 'ma_waveform_uninit');
  plm_audio_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_audio_create_with_buffer');
  plm_audio_decode := GetProcAddress(aDLLHandle, 'plm_audio_decode');
  plm_audio_destroy := GetProcAddress(aDLLHandle, 'plm_audio_destroy');
  plm_audio_get_samplerate := GetProcAddress(aDLLHandle, 'plm_audio_get_samplerate');
  plm_audio_get_time := GetProcAddress(aDLLHandle, 'plm_audio_get_time');
  plm_audio_has_ended := GetProcAddress(aDLLHandle, 'plm_audio_has_ended');
  plm_audio_has_header := GetProcAddress(aDLLHandle, 'plm_audio_has_header');
  plm_audio_rewind := GetProcAddress(aDLLHandle, 'plm_audio_rewind');
  plm_audio_set_time := GetProcAddress(aDLLHandle, 'plm_audio_set_time');
  plm_buffer_create_for_appending := GetProcAddress(aDLLHandle, 'plm_buffer_create_for_appending');
  plm_buffer_create_with_callbacks := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_callbacks');
  plm_buffer_create_with_capacity := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_capacity');
  plm_buffer_create_with_memory := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_memory');
  plm_buffer_destroy := GetProcAddress(aDLLHandle, 'plm_buffer_destroy');
  plm_buffer_get_remaining := GetProcAddress(aDLLHandle, 'plm_buffer_get_remaining');
  plm_buffer_get_size := GetProcAddress(aDLLHandle, 'plm_buffer_get_size');
  plm_buffer_has_ended := GetProcAddress(aDLLHandle, 'plm_buffer_has_ended');
  plm_buffer_rewind := GetProcAddress(aDLLHandle, 'plm_buffer_rewind');
  plm_buffer_set_load_callback := GetProcAddress(aDLLHandle, 'plm_buffer_set_load_callback');
  plm_buffer_signal_end := GetProcAddress(aDLLHandle, 'plm_buffer_signal_end');
  plm_buffer_write := GetProcAddress(aDLLHandle, 'plm_buffer_write');
  plm_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_create_with_buffer');
  plm_create_with_memory := GetProcAddress(aDLLHandle, 'plm_create_with_memory');
  plm_decode := GetProcAddress(aDLLHandle, 'plm_decode');
  plm_decode_audio := GetProcAddress(aDLLHandle, 'plm_decode_audio');
  plm_decode_video := GetProcAddress(aDLLHandle, 'plm_decode_video');
  plm_demux_create := GetProcAddress(aDLLHandle, 'plm_demux_create');
  plm_demux_decode := GetProcAddress(aDLLHandle, 'plm_demux_decode');
  plm_demux_destroy := GetProcAddress(aDLLHandle, 'plm_demux_destroy');
  plm_demux_get_duration := GetProcAddress(aDLLHandle, 'plm_demux_get_duration');
  plm_demux_get_num_audio_streams := GetProcAddress(aDLLHandle, 'plm_demux_get_num_audio_streams');
  plm_demux_get_num_video_streams := GetProcAddress(aDLLHandle, 'plm_demux_get_num_video_streams');
  plm_demux_get_start_time := GetProcAddress(aDLLHandle, 'plm_demux_get_start_time');
  plm_demux_has_ended := GetProcAddress(aDLLHandle, 'plm_demux_has_ended');
  plm_demux_has_headers := GetProcAddress(aDLLHandle, 'plm_demux_has_headers');
  plm_demux_probe := GetProcAddress(aDLLHandle, 'plm_demux_probe');
  plm_demux_rewind := GetProcAddress(aDLLHandle, 'plm_demux_rewind');
  plm_demux_seek := GetProcAddress(aDLLHandle, 'plm_demux_seek');
  plm_destroy := GetProcAddress(aDLLHandle, 'plm_destroy');
  plm_frame_to_abgr := GetProcAddress(aDLLHandle, 'plm_frame_to_abgr');
  plm_frame_to_argb := GetProcAddress(aDLLHandle, 'plm_frame_to_argb');
  plm_frame_to_bgr := GetProcAddress(aDLLHandle, 'plm_frame_to_bgr');
  plm_frame_to_bgra := GetProcAddress(aDLLHandle, 'plm_frame_to_bgra');
  plm_frame_to_rgb := GetProcAddress(aDLLHandle, 'plm_frame_to_rgb');
  plm_frame_to_rgba := GetProcAddress(aDLLHandle, 'plm_frame_to_rgba');
  plm_get_audio_enabled := GetProcAddress(aDLLHandle, 'plm_get_audio_enabled');
  plm_get_audio_lead_time := GetProcAddress(aDLLHandle, 'plm_get_audio_lead_time');
  plm_get_duration := GetProcAddress(aDLLHandle, 'plm_get_duration');
  plm_get_framerate := GetProcAddress(aDLLHandle, 'plm_get_framerate');
  plm_get_height := GetProcAddress(aDLLHandle, 'plm_get_height');
  plm_get_loop := GetProcAddress(aDLLHandle, 'plm_get_loop');
  plm_get_num_audio_streams := GetProcAddress(aDLLHandle, 'plm_get_num_audio_streams');
  plm_get_num_video_streams := GetProcAddress(aDLLHandle, 'plm_get_num_video_streams');
  plm_get_pixel_aspect_ratio := GetProcAddress(aDLLHandle, 'plm_get_pixel_aspect_ratio');
  plm_get_samplerate := GetProcAddress(aDLLHandle, 'plm_get_samplerate');
  plm_get_time := GetProcAddress(aDLLHandle, 'plm_get_time');
  plm_get_video_enabled := GetProcAddress(aDLLHandle, 'plm_get_video_enabled');
  plm_get_width := GetProcAddress(aDLLHandle, 'plm_get_width');
  plm_has_ended := GetProcAddress(aDLLHandle, 'plm_has_ended');
  plm_has_headers := GetProcAddress(aDLLHandle, 'plm_has_headers');
  plm_probe := GetProcAddress(aDLLHandle, 'plm_probe');
  plm_rewind := GetProcAddress(aDLLHandle, 'plm_rewind');
  plm_seek := GetProcAddress(aDLLHandle, 'plm_seek');
  plm_seek_frame := GetProcAddress(aDLLHandle, 'plm_seek_frame');
  plm_set_audio_decode_callback := GetProcAddress(aDLLHandle, 'plm_set_audio_decode_callback');
  plm_set_audio_enabled := GetProcAddress(aDLLHandle, 'plm_set_audio_enabled');
  plm_set_audio_lead_time := GetProcAddress(aDLLHandle, 'plm_set_audio_lead_time');
  plm_set_audio_stream := GetProcAddress(aDLLHandle, 'plm_set_audio_stream');
  plm_set_loop := GetProcAddress(aDLLHandle, 'plm_set_loop');
  plm_set_video_decode_callback := GetProcAddress(aDLLHandle, 'plm_set_video_decode_callback');
  plm_set_video_enabled := GetProcAddress(aDLLHandle, 'plm_set_video_enabled');
  plm_video_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_video_create_with_buffer');
  plm_video_decode := GetProcAddress(aDLLHandle, 'plm_video_decode');
  plm_video_destroy := GetProcAddress(aDLLHandle, 'plm_video_destroy');
  plm_video_get_framerate := GetProcAddress(aDLLHandle, 'plm_video_get_framerate');
  plm_video_get_height := GetProcAddress(aDLLHandle, 'plm_video_get_height');
  plm_video_get_pixel_aspect_ratio := GetProcAddress(aDLLHandle, 'plm_video_get_pixel_aspect_ratio');
  plm_video_get_time := GetProcAddress(aDLLHandle, 'plm_video_get_time');
  plm_video_get_width := GetProcAddress(aDLLHandle, 'plm_video_get_width');
  plm_video_has_ended := GetProcAddress(aDLLHandle, 'plm_video_has_ended');
  plm_video_has_header := GetProcAddress(aDLLHandle, 'plm_video_has_header');
  plm_video_rewind := GetProcAddress(aDLLHandle, 'plm_video_rewind');
  plm_video_set_no_delay := GetProcAddress(aDLLHandle, 'plm_video_set_no_delay');
  plm_video_set_time := GetProcAddress(aDLLHandle, 'plm_video_set_time');
  spAlphaTimeline_create := GetProcAddress(aDLLHandle, 'spAlphaTimeline_create');
  spAlphaTimeline_setFrame := GetProcAddress(aDLLHandle, 'spAlphaTimeline_setFrame');
  spAnimation_apply := GetProcAddress(aDLLHandle, 'spAnimation_apply');
  spAnimation_create := GetProcAddress(aDLLHandle, 'spAnimation_create');
  spAnimation_dispose := GetProcAddress(aDLLHandle, 'spAnimation_dispose');
  spAnimation_hasTimeline := GetProcAddress(aDLLHandle, 'spAnimation_hasTimeline');
  spAnimationState_addAnimation := GetProcAddress(aDLLHandle, 'spAnimationState_addAnimation');
  spAnimationState_addAnimationByName := GetProcAddress(aDLLHandle, 'spAnimationState_addAnimationByName');
  spAnimationState_addEmptyAnimation := GetProcAddress(aDLLHandle, 'spAnimationState_addEmptyAnimation');
  spAnimationState_apply := GetProcAddress(aDLLHandle, 'spAnimationState_apply');
  spAnimationState_clearListenerNotifications := GetProcAddress(aDLLHandle, 'spAnimationState_clearListenerNotifications');
  spAnimationState_clearNext := GetProcAddress(aDLLHandle, 'spAnimationState_clearNext');
  spAnimationState_clearTrack := GetProcAddress(aDLLHandle, 'spAnimationState_clearTrack');
  spAnimationState_clearTracks := GetProcAddress(aDLLHandle, 'spAnimationState_clearTracks');
  spAnimationState_create := GetProcAddress(aDLLHandle, 'spAnimationState_create');
  spAnimationState_dispose := GetProcAddress(aDLLHandle, 'spAnimationState_dispose');
  spAnimationState_disposeStatics := GetProcAddress(aDLLHandle, 'spAnimationState_disposeStatics');
  spAnimationState_getCurrent := GetProcAddress(aDLLHandle, 'spAnimationState_getCurrent');
  spAnimationState_setAnimation := GetProcAddress(aDLLHandle, 'spAnimationState_setAnimation');
  spAnimationState_setAnimationByName := GetProcAddress(aDLLHandle, 'spAnimationState_setAnimationByName');
  spAnimationState_setEmptyAnimation := GetProcAddress(aDLLHandle, 'spAnimationState_setEmptyAnimation');
  spAnimationState_setEmptyAnimations := GetProcAddress(aDLLHandle, 'spAnimationState_setEmptyAnimations');
  spAnimationState_update := GetProcAddress(aDLLHandle, 'spAnimationState_update');
  spAnimationStateData_create := GetProcAddress(aDLLHandle, 'spAnimationStateData_create');
  spAnimationStateData_dispose := GetProcAddress(aDLLHandle, 'spAnimationStateData_dispose');
  spAnimationStateData_getMix := GetProcAddress(aDLLHandle, 'spAnimationStateData_getMix');
  spAnimationStateData_setMix := GetProcAddress(aDLLHandle, 'spAnimationStateData_setMix');
  spAnimationStateData_setMixByName := GetProcAddress(aDLLHandle, 'spAnimationStateData_setMixByName');
  spArrayFloatArray_add := GetProcAddress(aDLLHandle, 'spArrayFloatArray_add');
  spArrayFloatArray_addAll := GetProcAddress(aDLLHandle, 'spArrayFloatArray_addAll');
  spArrayFloatArray_addAllValues := GetProcAddress(aDLLHandle, 'spArrayFloatArray_addAllValues');
  spArrayFloatArray_clear := GetProcAddress(aDLLHandle, 'spArrayFloatArray_clear');
  spArrayFloatArray_contains := GetProcAddress(aDLLHandle, 'spArrayFloatArray_contains');
  spArrayFloatArray_create := GetProcAddress(aDLLHandle, 'spArrayFloatArray_create');
  spArrayFloatArray_dispose := GetProcAddress(aDLLHandle, 'spArrayFloatArray_dispose');
  spArrayFloatArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spArrayFloatArray_ensureCapacity');
  spArrayFloatArray_peek := GetProcAddress(aDLLHandle, 'spArrayFloatArray_peek');
  spArrayFloatArray_pop := GetProcAddress(aDLLHandle, 'spArrayFloatArray_pop');
  spArrayFloatArray_removeAt := GetProcAddress(aDLLHandle, 'spArrayFloatArray_removeAt');
  spArrayFloatArray_setSize := GetProcAddress(aDLLHandle, 'spArrayFloatArray_setSize');
  spArrayShortArray_add := GetProcAddress(aDLLHandle, 'spArrayShortArray_add');
  spArrayShortArray_addAll := GetProcAddress(aDLLHandle, 'spArrayShortArray_addAll');
  spArrayShortArray_addAllValues := GetProcAddress(aDLLHandle, 'spArrayShortArray_addAllValues');
  spArrayShortArray_clear := GetProcAddress(aDLLHandle, 'spArrayShortArray_clear');
  spArrayShortArray_contains := GetProcAddress(aDLLHandle, 'spArrayShortArray_contains');
  spArrayShortArray_create := GetProcAddress(aDLLHandle, 'spArrayShortArray_create');
  spArrayShortArray_dispose := GetProcAddress(aDLLHandle, 'spArrayShortArray_dispose');
  spArrayShortArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spArrayShortArray_ensureCapacity');
  spArrayShortArray_peek := GetProcAddress(aDLLHandle, 'spArrayShortArray_peek');
  spArrayShortArray_pop := GetProcAddress(aDLLHandle, 'spArrayShortArray_pop');
  spArrayShortArray_removeAt := GetProcAddress(aDLLHandle, 'spArrayShortArray_removeAt');
  spArrayShortArray_setSize := GetProcAddress(aDLLHandle, 'spArrayShortArray_setSize');
  spAtlas_create := GetProcAddress(aDLLHandle, 'spAtlas_create');
  spAtlas_createFromFile := GetProcAddress(aDLLHandle, 'spAtlas_createFromFile');
  spAtlas_dispose := GetProcAddress(aDLLHandle, 'spAtlas_dispose');
  spAtlas_findRegion := GetProcAddress(aDLLHandle, 'spAtlas_findRegion');
  spAtlasAttachmentLoader_create := GetProcAddress(aDLLHandle, 'spAtlasAttachmentLoader_create');
  spAtlasPage_create := GetProcAddress(aDLLHandle, 'spAtlasPage_create');
  spAtlasPage_dispose := GetProcAddress(aDLLHandle, 'spAtlasPage_dispose');
  spAtlasPage_setCallbacks := GetProcAddress(aDLLHandle, 'spAtlasPage_setCallbacks');
  spAtlasRegion_create := GetProcAddress(aDLLHandle, 'spAtlasRegion_create');
  spAtlasRegion_dispose := GetProcAddress(aDLLHandle, 'spAtlasRegion_dispose');
  spAttachment_copy := GetProcAddress(aDLLHandle, 'spAttachment_copy');
  spAttachment_dispose := GetProcAddress(aDLLHandle, 'spAttachment_dispose');
  spAttachmentLoader_configureAttachment := GetProcAddress(aDLLHandle, 'spAttachmentLoader_configureAttachment');
  spAttachmentLoader_createAttachment := GetProcAddress(aDLLHandle, 'spAttachmentLoader_createAttachment');
  spAttachmentLoader_dispose := GetProcAddress(aDLLHandle, 'spAttachmentLoader_dispose');
  spAttachmentLoader_disposeAttachment := GetProcAddress(aDLLHandle, 'spAttachmentLoader_disposeAttachment');
  spAttachmentTimeline_create := GetProcAddress(aDLLHandle, 'spAttachmentTimeline_create');
  spAttachmentTimeline_setFrame := GetProcAddress(aDLLHandle, 'spAttachmentTimeline_setFrame');
  spBone_create := GetProcAddress(aDLLHandle, 'spBone_create');
  spBone_dispose := GetProcAddress(aDLLHandle, 'spBone_dispose');
  spBone_getWorldRotationX := GetProcAddress(aDLLHandle, 'spBone_getWorldRotationX');
  spBone_getWorldRotationY := GetProcAddress(aDLLHandle, 'spBone_getWorldRotationY');
  spBone_getWorldScaleX := GetProcAddress(aDLLHandle, 'spBone_getWorldScaleX');
  spBone_getWorldScaleY := GetProcAddress(aDLLHandle, 'spBone_getWorldScaleY');
  spBone_isYDown := GetProcAddress(aDLLHandle, 'spBone_isYDown');
  spBone_localToWorld := GetProcAddress(aDLLHandle, 'spBone_localToWorld');
  spBone_localToWorldRotation := GetProcAddress(aDLLHandle, 'spBone_localToWorldRotation');
  spBone_rotateWorld := GetProcAddress(aDLLHandle, 'spBone_rotateWorld');
  spBone_setToSetupPose := GetProcAddress(aDLLHandle, 'spBone_setToSetupPose');
  spBone_setYDown := GetProcAddress(aDLLHandle, 'spBone_setYDown');
  spBone_update := GetProcAddress(aDLLHandle, 'spBone_update');
  spBone_updateAppliedTransform := GetProcAddress(aDLLHandle, 'spBone_updateAppliedTransform');
  spBone_updateWorldTransform := GetProcAddress(aDLLHandle, 'spBone_updateWorldTransform');
  spBone_updateWorldTransformWith := GetProcAddress(aDLLHandle, 'spBone_updateWorldTransformWith');
  spBone_worldToLocal := GetProcAddress(aDLLHandle, 'spBone_worldToLocal');
  spBone_worldToLocalRotation := GetProcAddress(aDLLHandle, 'spBone_worldToLocalRotation');
  spBone_worldToParent := GetProcAddress(aDLLHandle, 'spBone_worldToParent');
  spBoneData_create := GetProcAddress(aDLLHandle, 'spBoneData_create');
  spBoneData_dispose := GetProcAddress(aDLLHandle, 'spBoneData_dispose');
  spBoneDataArray_add := GetProcAddress(aDLLHandle, 'spBoneDataArray_add');
  spBoneDataArray_addAll := GetProcAddress(aDLLHandle, 'spBoneDataArray_addAll');
  spBoneDataArray_addAllValues := GetProcAddress(aDLLHandle, 'spBoneDataArray_addAllValues');
  spBoneDataArray_clear := GetProcAddress(aDLLHandle, 'spBoneDataArray_clear');
  spBoneDataArray_contains := GetProcAddress(aDLLHandle, 'spBoneDataArray_contains');
  spBoneDataArray_create := GetProcAddress(aDLLHandle, 'spBoneDataArray_create');
  spBoneDataArray_dispose := GetProcAddress(aDLLHandle, 'spBoneDataArray_dispose');
  spBoneDataArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spBoneDataArray_ensureCapacity');
  spBoneDataArray_peek := GetProcAddress(aDLLHandle, 'spBoneDataArray_peek');
  spBoneDataArray_pop := GetProcAddress(aDLLHandle, 'spBoneDataArray_pop');
  spBoneDataArray_removeAt := GetProcAddress(aDLLHandle, 'spBoneDataArray_removeAt');
  spBoneDataArray_setSize := GetProcAddress(aDLLHandle, 'spBoneDataArray_setSize');
  spBoundingBoxAttachment_create := GetProcAddress(aDLLHandle, 'spBoundingBoxAttachment_create');
  spClippingAttachment_create := GetProcAddress(aDLLHandle, 'spClippingAttachment_create');
  spColor_addColor := GetProcAddress(aDLLHandle, 'spColor_addColor');
  spColor_addFloats := GetProcAddress(aDLLHandle, 'spColor_addFloats');
  spColor_addFloats3 := GetProcAddress(aDLLHandle, 'spColor_addFloats3');
  spColor_clamp := GetProcAddress(aDLLHandle, 'spColor_clamp');
  spColor_create := GetProcAddress(aDLLHandle, 'spColor_create');
  spColor_dispose := GetProcAddress(aDLLHandle, 'spColor_dispose');
  spColor_setFromColor := GetProcAddress(aDLLHandle, 'spColor_setFromColor');
  spColor_setFromColor3 := GetProcAddress(aDLLHandle, 'spColor_setFromColor3');
  spColor_setFromFloats := GetProcAddress(aDLLHandle, 'spColor_setFromFloats');
  spColor_setFromFloats3 := GetProcAddress(aDLLHandle, 'spColor_setFromFloats3');
  spCurveTimeline_setLinear := GetProcAddress(aDLLHandle, 'spCurveTimeline_setLinear');
  spCurveTimeline_setStepped := GetProcAddress(aDLLHandle, 'spCurveTimeline_setStepped');
  spCurveTimeline1_getAbsoluteValue := GetProcAddress(aDLLHandle, 'spCurveTimeline1_getAbsoluteValue');
  spCurveTimeline1_getAbsoluteValue2 := GetProcAddress(aDLLHandle, 'spCurveTimeline1_getAbsoluteValue2');
  spCurveTimeline1_getCurveValue := GetProcAddress(aDLLHandle, 'spCurveTimeline1_getCurveValue');
  spCurveTimeline1_getRelativeValue := GetProcAddress(aDLLHandle, 'spCurveTimeline1_getRelativeValue');
  spCurveTimeline1_getScaleValue := GetProcAddress(aDLLHandle, 'spCurveTimeline1_getScaleValue');
  spCurveTimeline1_setFrame := GetProcAddress(aDLLHandle, 'spCurveTimeline1_setFrame');
  spCurveTimeline2_setFrame := GetProcAddress(aDLLHandle, 'spCurveTimeline2_setFrame');
  spDeformTimeline_create := GetProcAddress(aDLLHandle, 'spDeformTimeline_create');
  spDeformTimeline_setFrame := GetProcAddress(aDLLHandle, 'spDeformTimeline_setFrame');
  spDrawOrderTimeline_create := GetProcAddress(aDLLHandle, 'spDrawOrderTimeline_create');
  spDrawOrderTimeline_setFrame := GetProcAddress(aDLLHandle, 'spDrawOrderTimeline_setFrame');
  spEvent_create := GetProcAddress(aDLLHandle, 'spEvent_create');
  spEvent_dispose := GetProcAddress(aDLLHandle, 'spEvent_dispose');
  spEventData_create := GetProcAddress(aDLLHandle, 'spEventData_create');
  spEventData_dispose := GetProcAddress(aDLLHandle, 'spEventData_dispose');
  spEventTimeline_create := GetProcAddress(aDLLHandle, 'spEventTimeline_create');
  spEventTimeline_setFrame := GetProcAddress(aDLLHandle, 'spEventTimeline_setFrame');
  spFloatArray_add := GetProcAddress(aDLLHandle, 'spFloatArray_add');
  spFloatArray_addAll := GetProcAddress(aDLLHandle, 'spFloatArray_addAll');
  spFloatArray_addAllValues := GetProcAddress(aDLLHandle, 'spFloatArray_addAllValues');
  spFloatArray_clear := GetProcAddress(aDLLHandle, 'spFloatArray_clear');
  spFloatArray_contains := GetProcAddress(aDLLHandle, 'spFloatArray_contains');
  spFloatArray_create := GetProcAddress(aDLLHandle, 'spFloatArray_create');
  spFloatArray_dispose := GetProcAddress(aDLLHandle, 'spFloatArray_dispose');
  spFloatArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spFloatArray_ensureCapacity');
  spFloatArray_peek := GetProcAddress(aDLLHandle, 'spFloatArray_peek');
  spFloatArray_pop := GetProcAddress(aDLLHandle, 'spFloatArray_pop');
  spFloatArray_removeAt := GetProcAddress(aDLLHandle, 'spFloatArray_removeAt');
  spFloatArray_setSize := GetProcAddress(aDLLHandle, 'spFloatArray_setSize');
  spGlfwVertexArray_add := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_add');
  spGlfwVertexArray_addAll := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_addAll');
  spGlfwVertexArray_addAllValues := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_addAllValues');
  spGlfwVertexArray_clear := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_clear');
  spGlfwVertexArray_create := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_create');
  spGlfwVertexArray_dispose := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_dispose');
  spGlfwVertexArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_ensureCapacity');
  spGlfwVertexArray_peek := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_peek');
  spGlfwVertexArray_pop := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_pop');
  spGlfwVertexArray_removeAt := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_removeAt');
  spGlfwVertexArray_setSize := GetProcAddress(aDLLHandle, 'spGlfwVertexArray_setSize');
  spIkConstraint_apply1 := GetProcAddress(aDLLHandle, 'spIkConstraint_apply1');
  spIkConstraint_apply2 := GetProcAddress(aDLLHandle, 'spIkConstraint_apply2');
  spIkConstraint_create := GetProcAddress(aDLLHandle, 'spIkConstraint_create');
  spIkConstraint_dispose := GetProcAddress(aDLLHandle, 'spIkConstraint_dispose');
  spIkConstraint_setToSetupPose := GetProcAddress(aDLLHandle, 'spIkConstraint_setToSetupPose');
  spIkConstraint_update := GetProcAddress(aDLLHandle, 'spIkConstraint_update');
  spIkConstraintData_create := GetProcAddress(aDLLHandle, 'spIkConstraintData_create');
  spIkConstraintData_dispose := GetProcAddress(aDLLHandle, 'spIkConstraintData_dispose');
  spIkConstraintDataArray_add := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_add');
  spIkConstraintDataArray_addAll := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_addAll');
  spIkConstraintDataArray_addAllValues := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_addAllValues');
  spIkConstraintDataArray_clear := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_clear');
  spIkConstraintDataArray_contains := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_contains');
  spIkConstraintDataArray_create := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_create');
  spIkConstraintDataArray_dispose := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_dispose');
  spIkConstraintDataArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_ensureCapacity');
  spIkConstraintDataArray_peek := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_peek');
  spIkConstraintDataArray_pop := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_pop');
  spIkConstraintDataArray_removeAt := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_removeAt');
  spIkConstraintDataArray_setSize := GetProcAddress(aDLLHandle, 'spIkConstraintDataArray_setSize');
  spIkConstraintTimeline_create := GetProcAddress(aDLLHandle, 'spIkConstraintTimeline_create');
  spIkConstraintTimeline_setFrame := GetProcAddress(aDLLHandle, 'spIkConstraintTimeline_setFrame');
  spInheritTimeline_create := GetProcAddress(aDLLHandle, 'spInheritTimeline_create');
  spInheritTimeline_setFrame := GetProcAddress(aDLLHandle, 'spInheritTimeline_setFrame');
  spIntArray_add := GetProcAddress(aDLLHandle, 'spIntArray_add');
  spIntArray_addAll := GetProcAddress(aDLLHandle, 'spIntArray_addAll');
  spIntArray_addAllValues := GetProcAddress(aDLLHandle, 'spIntArray_addAllValues');
  spIntArray_clear := GetProcAddress(aDLLHandle, 'spIntArray_clear');
  spIntArray_contains := GetProcAddress(aDLLHandle, 'spIntArray_contains');
  spIntArray_create := GetProcAddress(aDLLHandle, 'spIntArray_create');
  spIntArray_dispose := GetProcAddress(aDLLHandle, 'spIntArray_dispose');
  spIntArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spIntArray_ensureCapacity');
  spIntArray_peek := GetProcAddress(aDLLHandle, 'spIntArray_peek');
  spIntArray_pop := GetProcAddress(aDLLHandle, 'spIntArray_pop');
  spIntArray_removeAt := GetProcAddress(aDLLHandle, 'spIntArray_removeAt');
  spIntArray_setSize := GetProcAddress(aDLLHandle, 'spIntArray_setSize');
  spKeyValueArray_add := GetProcAddress(aDLLHandle, 'spKeyValueArray_add');
  spKeyValueArray_addAll := GetProcAddress(aDLLHandle, 'spKeyValueArray_addAll');
  spKeyValueArray_addAllValues := GetProcAddress(aDLLHandle, 'spKeyValueArray_addAllValues');
  spKeyValueArray_clear := GetProcAddress(aDLLHandle, 'spKeyValueArray_clear');
  spKeyValueArray_contains := GetProcAddress(aDLLHandle, 'spKeyValueArray_contains');
  spKeyValueArray_create := GetProcAddress(aDLLHandle, 'spKeyValueArray_create');
  spKeyValueArray_dispose := GetProcAddress(aDLLHandle, 'spKeyValueArray_dispose');
  spKeyValueArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spKeyValueArray_ensureCapacity');
  spKeyValueArray_peek := GetProcAddress(aDLLHandle, 'spKeyValueArray_peek');
  spKeyValueArray_pop := GetProcAddress(aDLLHandle, 'spKeyValueArray_pop');
  spKeyValueArray_setSize := GetProcAddress(aDLLHandle, 'spKeyValueArray_setSize');
  spMeshAttachment_create := GetProcAddress(aDLLHandle, 'spMeshAttachment_create');
  spMeshAttachment_newLinkedMesh := GetProcAddress(aDLLHandle, 'spMeshAttachment_newLinkedMesh');
  spMeshAttachment_setParentMesh := GetProcAddress(aDLLHandle, 'spMeshAttachment_setParentMesh');
  spMeshAttachment_updateRegion := GetProcAddress(aDLLHandle, 'spMeshAttachment_updateRegion');
  spPathAttachment_create := GetProcAddress(aDLLHandle, 'spPathAttachment_create');
  spPathConstraint_computeWorldPositions := GetProcAddress(aDLLHandle, 'spPathConstraint_computeWorldPositions');
  spPathConstraint_create := GetProcAddress(aDLLHandle, 'spPathConstraint_create');
  spPathConstraint_dispose := GetProcAddress(aDLLHandle, 'spPathConstraint_dispose');
  spPathConstraint_setToSetupPose := GetProcAddress(aDLLHandle, 'spPathConstraint_setToSetupPose');
  spPathConstraint_update := GetProcAddress(aDLLHandle, 'spPathConstraint_update');
  spPathConstraintData_create := GetProcAddress(aDLLHandle, 'spPathConstraintData_create');
  spPathConstraintData_dispose := GetProcAddress(aDLLHandle, 'spPathConstraintData_dispose');
  spPathConstraintDataArray_add := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_add');
  spPathConstraintDataArray_addAll := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_addAll');
  spPathConstraintDataArray_addAllValues := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_addAllValues');
  spPathConstraintDataArray_clear := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_clear');
  spPathConstraintDataArray_contains := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_contains');
  spPathConstraintDataArray_create := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_create');
  spPathConstraintDataArray_dispose := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_dispose');
  spPathConstraintDataArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_ensureCapacity');
  spPathConstraintDataArray_peek := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_peek');
  spPathConstraintDataArray_pop := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_pop');
  spPathConstraintDataArray_removeAt := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_removeAt');
  spPathConstraintDataArray_setSize := GetProcAddress(aDLLHandle, 'spPathConstraintDataArray_setSize');
  spPathConstraintMixTimeline_create := GetProcAddress(aDLLHandle, 'spPathConstraintMixTimeline_create');
  spPathConstraintMixTimeline_setFrame := GetProcAddress(aDLLHandle, 'spPathConstraintMixTimeline_setFrame');
  spPathConstraintPositionTimeline_create := GetProcAddress(aDLLHandle, 'spPathConstraintPositionTimeline_create');
  spPathConstraintPositionTimeline_setFrame := GetProcAddress(aDLLHandle, 'spPathConstraintPositionTimeline_setFrame');
  spPathConstraintSpacingTimeline_create := GetProcAddress(aDLLHandle, 'spPathConstraintSpacingTimeline_create');
  spPathConstraintSpacingTimeline_setFrame := GetProcAddress(aDLLHandle, 'spPathConstraintSpacingTimeline_setFrame');
  spPhysicsConstraint_create := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_create');
  spPhysicsConstraint_dispose := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_dispose');
  spPhysicsConstraint_reset := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_reset');
  spPhysicsConstraint_rotate := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_rotate');
  spPhysicsConstraint_setToSetupPose := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_setToSetupPose');
  spPhysicsConstraint_translate := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_translate');
  spPhysicsConstraint_update := GetProcAddress(aDLLHandle, 'spPhysicsConstraint_update');
  spPhysicsConstraintData_create := GetProcAddress(aDLLHandle, 'spPhysicsConstraintData_create');
  spPhysicsConstraintData_dispose := GetProcAddress(aDLLHandle, 'spPhysicsConstraintData_dispose');
  spPhysicsConstraintDataArray_add := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_add');
  spPhysicsConstraintDataArray_addAll := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_addAll');
  spPhysicsConstraintDataArray_addAllValues := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_addAllValues');
  spPhysicsConstraintDataArray_clear := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_clear');
  spPhysicsConstraintDataArray_contains := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_contains');
  spPhysicsConstraintDataArray_create := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_create');
  spPhysicsConstraintDataArray_dispose := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_dispose');
  spPhysicsConstraintDataArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_ensureCapacity');
  spPhysicsConstraintDataArray_peek := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_peek');
  spPhysicsConstraintDataArray_pop := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_pop');
  spPhysicsConstraintDataArray_removeAt := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_removeAt');
  spPhysicsConstraintDataArray_setSize := GetProcAddress(aDLLHandle, 'spPhysicsConstraintDataArray_setSize');
  spPhysicsConstraintResetTimeline_create := GetProcAddress(aDLLHandle, 'spPhysicsConstraintResetTimeline_create');
  spPhysicsConstraintResetTimeline_setFrame := GetProcAddress(aDLLHandle, 'spPhysicsConstraintResetTimeline_setFrame');
  spPhysicsConstraintTimeline_create := GetProcAddress(aDLLHandle, 'spPhysicsConstraintTimeline_create');
  spPhysicsConstraintTimeline_setFrame := GetProcAddress(aDLLHandle, 'spPhysicsConstraintTimeline_setFrame');
  spPointAttachment_computeWorldPosition := GetProcAddress(aDLLHandle, 'spPointAttachment_computeWorldPosition');
  spPointAttachment_computeWorldRotation := GetProcAddress(aDLLHandle, 'spPointAttachment_computeWorldRotation');
  spPointAttachment_create := GetProcAddress(aDLLHandle, 'spPointAttachment_create');
  spPolygon_containsPoint := GetProcAddress(aDLLHandle, 'spPolygon_containsPoint');
  spPolygon_create := GetProcAddress(aDLLHandle, 'spPolygon_create');
  spPolygon_dispose := GetProcAddress(aDLLHandle, 'spPolygon_dispose');
  spPolygon_intersectsSegment := GetProcAddress(aDLLHandle, 'spPolygon_intersectsSegment');
  spPropertyIdArray_add := GetProcAddress(aDLLHandle, 'spPropertyIdArray_add');
  spPropertyIdArray_addAll := GetProcAddress(aDLLHandle, 'spPropertyIdArray_addAll');
  spPropertyIdArray_addAllValues := GetProcAddress(aDLLHandle, 'spPropertyIdArray_addAllValues');
  spPropertyIdArray_clear := GetProcAddress(aDLLHandle, 'spPropertyIdArray_clear');
  spPropertyIdArray_contains := GetProcAddress(aDLLHandle, 'spPropertyIdArray_contains');
  spPropertyIdArray_create := GetProcAddress(aDLLHandle, 'spPropertyIdArray_create');
  spPropertyIdArray_dispose := GetProcAddress(aDLLHandle, 'spPropertyIdArray_dispose');
  spPropertyIdArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spPropertyIdArray_ensureCapacity');
  spPropertyIdArray_peek := GetProcAddress(aDLLHandle, 'spPropertyIdArray_peek');
  spPropertyIdArray_pop := GetProcAddress(aDLLHandle, 'spPropertyIdArray_pop');
  spPropertyIdArray_removeAt := GetProcAddress(aDLLHandle, 'spPropertyIdArray_removeAt');
  spPropertyIdArray_setSize := GetProcAddress(aDLLHandle, 'spPropertyIdArray_setSize');
  spRegionAttachment_computeWorldVertices := GetProcAddress(aDLLHandle, 'spRegionAttachment_computeWorldVertices');
  spRegionAttachment_create := GetProcAddress(aDLLHandle, 'spRegionAttachment_create');
  spRegionAttachment_updateRegion := GetProcAddress(aDLLHandle, 'spRegionAttachment_updateRegion');
  spRGB2Timeline_create := GetProcAddress(aDLLHandle, 'spRGB2Timeline_create');
  spRGB2Timeline_setFrame := GetProcAddress(aDLLHandle, 'spRGB2Timeline_setFrame');
  spRGBA2Timeline_create := GetProcAddress(aDLLHandle, 'spRGBA2Timeline_create');
  spRGBA2Timeline_setFrame := GetProcAddress(aDLLHandle, 'spRGBA2Timeline_setFrame');
  spRGBATimeline_create := GetProcAddress(aDLLHandle, 'spRGBATimeline_create');
  spRGBATimeline_setFrame := GetProcAddress(aDLLHandle, 'spRGBATimeline_setFrame');
  spRGBTimeline_create := GetProcAddress(aDLLHandle, 'spRGBTimeline_create');
  spRGBTimeline_setFrame := GetProcAddress(aDLLHandle, 'spRGBTimeline_setFrame');
  spRotateTimeline_create := GetProcAddress(aDLLHandle, 'spRotateTimeline_create');
  spRotateTimeline_setFrame := GetProcAddress(aDLLHandle, 'spRotateTimeline_setFrame');
  spScaleTimeline_create := GetProcAddress(aDLLHandle, 'spScaleTimeline_create');
  spScaleTimeline_setFrame := GetProcAddress(aDLLHandle, 'spScaleTimeline_setFrame');
  spScaleXTimeline_create := GetProcAddress(aDLLHandle, 'spScaleXTimeline_create');
  spScaleXTimeline_setFrame := GetProcAddress(aDLLHandle, 'spScaleXTimeline_setFrame');
  spScaleYTimeline_create := GetProcAddress(aDLLHandle, 'spScaleYTimeline_create');
  spScaleYTimeline_setFrame := GetProcAddress(aDLLHandle, 'spScaleYTimeline_setFrame');
  spSequence_apply := GetProcAddress(aDLLHandle, 'spSequence_apply');
  spSequence_copy := GetProcAddress(aDLLHandle, 'spSequence_copy');
  spSequence_create := GetProcAddress(aDLLHandle, 'spSequence_create');
  spSequence_dispose := GetProcAddress(aDLLHandle, 'spSequence_dispose');
  spSequence_getPath := GetProcAddress(aDLLHandle, 'spSequence_getPath');
  spSequenceTimeline_create := GetProcAddress(aDLLHandle, 'spSequenceTimeline_create');
  spSequenceTimeline_setFrame := GetProcAddress(aDLLHandle, 'spSequenceTimeline_setFrame');
  spShearTimeline_create := GetProcAddress(aDLLHandle, 'spShearTimeline_create');
  spShearTimeline_setFrame := GetProcAddress(aDLLHandle, 'spShearTimeline_setFrame');
  spShearXTimeline_create := GetProcAddress(aDLLHandle, 'spShearXTimeline_create');
  spShearXTimeline_setFrame := GetProcAddress(aDLLHandle, 'spShearXTimeline_setFrame');
  spShearYTimeline_create := GetProcAddress(aDLLHandle, 'spShearYTimeline_create');
  spShearYTimeline_setFrame := GetProcAddress(aDLLHandle, 'spShearYTimeline_setFrame');
  spShortArray_add := GetProcAddress(aDLLHandle, 'spShortArray_add');
  spShortArray_addAll := GetProcAddress(aDLLHandle, 'spShortArray_addAll');
  spShortArray_addAllValues := GetProcAddress(aDLLHandle, 'spShortArray_addAllValues');
  spShortArray_clear := GetProcAddress(aDLLHandle, 'spShortArray_clear');
  spShortArray_contains := GetProcAddress(aDLLHandle, 'spShortArray_contains');
  spShortArray_create := GetProcAddress(aDLLHandle, 'spShortArray_create');
  spShortArray_dispose := GetProcAddress(aDLLHandle, 'spShortArray_dispose');
  spShortArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spShortArray_ensureCapacity');
  spShortArray_peek := GetProcAddress(aDLLHandle, 'spShortArray_peek');
  spShortArray_pop := GetProcAddress(aDLLHandle, 'spShortArray_pop');
  spShortArray_removeAt := GetProcAddress(aDLLHandle, 'spShortArray_removeAt');
  spShortArray_setSize := GetProcAddress(aDLLHandle, 'spShortArray_setSize');
  spSkeleton_create := GetProcAddress(aDLLHandle, 'spSkeleton_create');
  spSkeleton_dispose := GetProcAddress(aDLLHandle, 'spSkeleton_dispose');
  spSkeleton_findBone := GetProcAddress(aDLLHandle, 'spSkeleton_findBone');
  spSkeleton_findIkConstraint := GetProcAddress(aDLLHandle, 'spSkeleton_findIkConstraint');
  spSkeleton_findPathConstraint := GetProcAddress(aDLLHandle, 'spSkeleton_findPathConstraint');
  spSkeleton_findPhysicsConstraint := GetProcAddress(aDLLHandle, 'spSkeleton_findPhysicsConstraint');
  spSkeleton_findSlot := GetProcAddress(aDLLHandle, 'spSkeleton_findSlot');
  spSkeleton_findTransformConstraint := GetProcAddress(aDLLHandle, 'spSkeleton_findTransformConstraint');
  spSkeleton_getAttachmentForSlotIndex := GetProcAddress(aDLLHandle, 'spSkeleton_getAttachmentForSlotIndex');
  spSkeleton_getAttachmentForSlotName := GetProcAddress(aDLLHandle, 'spSkeleton_getAttachmentForSlotName');
  spSkeleton_physicsRotate := GetProcAddress(aDLLHandle, 'spSkeleton_physicsRotate');
  spSkeleton_physicsTranslate := GetProcAddress(aDLLHandle, 'spSkeleton_physicsTranslate');
  spSkeleton_setAttachment := GetProcAddress(aDLLHandle, 'spSkeleton_setAttachment');
  spSkeleton_setBonesToSetupPose := GetProcAddress(aDLLHandle, 'spSkeleton_setBonesToSetupPose');
  spSkeleton_setSkin := GetProcAddress(aDLLHandle, 'spSkeleton_setSkin');
  spSkeleton_setSkinByName := GetProcAddress(aDLLHandle, 'spSkeleton_setSkinByName');
  spSkeleton_setSlotsToSetupPose := GetProcAddress(aDLLHandle, 'spSkeleton_setSlotsToSetupPose');
  spSkeleton_setToSetupPose := GetProcAddress(aDLLHandle, 'spSkeleton_setToSetupPose');
  spSkeleton_update := GetProcAddress(aDLLHandle, 'spSkeleton_update');
  spSkeleton_updateCache := GetProcAddress(aDLLHandle, 'spSkeleton_updateCache');
  spSkeleton_updateWorldTransform := GetProcAddress(aDLLHandle, 'spSkeleton_updateWorldTransform');
  spSkeletonBinary_create := GetProcAddress(aDLLHandle, 'spSkeletonBinary_create');
  spSkeletonBinary_createWithLoader := GetProcAddress(aDLLHandle, 'spSkeletonBinary_createWithLoader');
  spSkeletonBinary_dispose := GetProcAddress(aDLLHandle, 'spSkeletonBinary_dispose');
  spSkeletonBinary_readSkeletonData := GetProcAddress(aDLLHandle, 'spSkeletonBinary_readSkeletonData');
  spSkeletonBinary_readSkeletonDataFile := GetProcAddress(aDLLHandle, 'spSkeletonBinary_readSkeletonDataFile');
  spSkeletonBounds_aabbContainsPoint := GetProcAddress(aDLLHandle, 'spSkeletonBounds_aabbContainsPoint');
  spSkeletonBounds_aabbIntersectsSegment := GetProcAddress(aDLLHandle, 'spSkeletonBounds_aabbIntersectsSegment');
  spSkeletonBounds_aabbIntersectsSkeleton := GetProcAddress(aDLLHandle, 'spSkeletonBounds_aabbIntersectsSkeleton');
  spSkeletonBounds_containsPoint := GetProcAddress(aDLLHandle, 'spSkeletonBounds_containsPoint');
  spSkeletonBounds_create := GetProcAddress(aDLLHandle, 'spSkeletonBounds_create');
  spSkeletonBounds_dispose := GetProcAddress(aDLLHandle, 'spSkeletonBounds_dispose');
  spSkeletonBounds_getPolygon := GetProcAddress(aDLLHandle, 'spSkeletonBounds_getPolygon');
  spSkeletonBounds_intersectsSegment := GetProcAddress(aDLLHandle, 'spSkeletonBounds_intersectsSegment');
  spSkeletonBounds_update := GetProcAddress(aDLLHandle, 'spSkeletonBounds_update');
  spSkeletonClipping_clipEnd := GetProcAddress(aDLLHandle, 'spSkeletonClipping_clipEnd');
  spSkeletonClipping_clipEnd2 := GetProcAddress(aDLLHandle, 'spSkeletonClipping_clipEnd2');
  spSkeletonClipping_clipStart := GetProcAddress(aDLLHandle, 'spSkeletonClipping_clipStart');
  spSkeletonClipping_clipTriangles := GetProcAddress(aDLLHandle, 'spSkeletonClipping_clipTriangles');
  spSkeletonClipping_create := GetProcAddress(aDLLHandle, 'spSkeletonClipping_create');
  spSkeletonClipping_dispose := GetProcAddress(aDLLHandle, 'spSkeletonClipping_dispose');
  spSkeletonClipping_isClipping := GetProcAddress(aDLLHandle, 'spSkeletonClipping_isClipping');
  spSkeletonData_create := GetProcAddress(aDLLHandle, 'spSkeletonData_create');
  spSkeletonData_dispose := GetProcAddress(aDLLHandle, 'spSkeletonData_dispose');
  spSkeletonData_findAnimation := GetProcAddress(aDLLHandle, 'spSkeletonData_findAnimation');
  spSkeletonData_findBone := GetProcAddress(aDLLHandle, 'spSkeletonData_findBone');
  spSkeletonData_findEvent := GetProcAddress(aDLLHandle, 'spSkeletonData_findEvent');
  spSkeletonData_findIkConstraint := GetProcAddress(aDLLHandle, 'spSkeletonData_findIkConstraint');
  spSkeletonData_findPathConstraint := GetProcAddress(aDLLHandle, 'spSkeletonData_findPathConstraint');
  spSkeletonData_findPhysicsConstraint := GetProcAddress(aDLLHandle, 'spSkeletonData_findPhysicsConstraint');
  spSkeletonData_findSkin := GetProcAddress(aDLLHandle, 'spSkeletonData_findSkin');
  spSkeletonData_findSlot := GetProcAddress(aDLLHandle, 'spSkeletonData_findSlot');
  spSkeletonData_findTransformConstraint := GetProcAddress(aDLLHandle, 'spSkeletonData_findTransformConstraint');
  spSkeletonDrawable_create := GetProcAddress(aDLLHandle, 'spSkeletonDrawable_create');
  spSkeletonDrawable_dispose := GetProcAddress(aDLLHandle, 'spSkeletonDrawable_dispose');
  spSkeletonDrawable_draw := GetProcAddress(aDLLHandle, 'spSkeletonDrawable_draw');
  spSkeletonDrawable_update := GetProcAddress(aDLLHandle, 'spSkeletonDrawable_update');
  spSkeletonJson_create := GetProcAddress(aDLLHandle, 'spSkeletonJson_create');
  spSkeletonJson_createWithLoader := GetProcAddress(aDLLHandle, 'spSkeletonJson_createWithLoader');
  spSkeletonJson_dispose := GetProcAddress(aDLLHandle, 'spSkeletonJson_dispose');
  spSkeletonJson_readSkeletonData := GetProcAddress(aDLLHandle, 'spSkeletonJson_readSkeletonData');
  spSkeletonJson_readSkeletonDataFile := GetProcAddress(aDLLHandle, 'spSkeletonJson_readSkeletonDataFile');
  spSkin_addSkin := GetProcAddress(aDLLHandle, 'spSkin_addSkin');
  spSkin_attachAll := GetProcAddress(aDLLHandle, 'spSkin_attachAll');
  spSkin_clear := GetProcAddress(aDLLHandle, 'spSkin_clear');
  spSkin_copySkin := GetProcAddress(aDLLHandle, 'spSkin_copySkin');
  spSkin_create := GetProcAddress(aDLLHandle, 'spSkin_create');
  spSkin_dispose := GetProcAddress(aDLLHandle, 'spSkin_dispose');
  spSkin_getAttachment := GetProcAddress(aDLLHandle, 'spSkin_getAttachment');
  spSkin_getAttachmentName := GetProcAddress(aDLLHandle, 'spSkin_getAttachmentName');
  spSkin_getAttachments := GetProcAddress(aDLLHandle, 'spSkin_getAttachments');
  spSkin_setAttachment := GetProcAddress(aDLLHandle, 'spSkin_setAttachment');
  spSlot_create := GetProcAddress(aDLLHandle, 'spSlot_create');
  spSlot_dispose := GetProcAddress(aDLLHandle, 'spSlot_dispose');
  spSlot_setAttachment := GetProcAddress(aDLLHandle, 'spSlot_setAttachment');
  spSlot_setToSetupPose := GetProcAddress(aDLLHandle, 'spSlot_setToSetupPose');
  spSlotData_create := GetProcAddress(aDLLHandle, 'spSlotData_create');
  spSlotData_dispose := GetProcAddress(aDLLHandle, 'spSlotData_dispose');
  spSlotData_setAttachmentName := GetProcAddress(aDLLHandle, 'spSlotData_setAttachmentName');
  spTextureRegionArray_add := GetProcAddress(aDLLHandle, 'spTextureRegionArray_add');
  spTextureRegionArray_addAll := GetProcAddress(aDLLHandle, 'spTextureRegionArray_addAll');
  spTextureRegionArray_addAllValues := GetProcAddress(aDLLHandle, 'spTextureRegionArray_addAllValues');
  spTextureRegionArray_clear := GetProcAddress(aDLLHandle, 'spTextureRegionArray_clear');
  spTextureRegionArray_contains := GetProcAddress(aDLLHandle, 'spTextureRegionArray_contains');
  spTextureRegionArray_create := GetProcAddress(aDLLHandle, 'spTextureRegionArray_create');
  spTextureRegionArray_dispose := GetProcAddress(aDLLHandle, 'spTextureRegionArray_dispose');
  spTextureRegionArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spTextureRegionArray_ensureCapacity');
  spTextureRegionArray_peek := GetProcAddress(aDLLHandle, 'spTextureRegionArray_peek');
  spTextureRegionArray_pop := GetProcAddress(aDLLHandle, 'spTextureRegionArray_pop');
  spTextureRegionArray_removeAt := GetProcAddress(aDLLHandle, 'spTextureRegionArray_removeAt');
  spTextureRegionArray_setSize := GetProcAddress(aDLLHandle, 'spTextureRegionArray_setSize');
  spTimeline_apply := GetProcAddress(aDLLHandle, 'spTimeline_apply');
  spTimeline_dispose := GetProcAddress(aDLLHandle, 'spTimeline_dispose');
  spTimeline_getDuration := GetProcAddress(aDLLHandle, 'spTimeline_getDuration');
  spTimeline_setBezier := GetProcAddress(aDLLHandle, 'spTimeline_setBezier');
  spTimelineArray_add := GetProcAddress(aDLLHandle, 'spTimelineArray_add');
  spTimelineArray_addAll := GetProcAddress(aDLLHandle, 'spTimelineArray_addAll');
  spTimelineArray_addAllValues := GetProcAddress(aDLLHandle, 'spTimelineArray_addAllValues');
  spTimelineArray_clear := GetProcAddress(aDLLHandle, 'spTimelineArray_clear');
  spTimelineArray_contains := GetProcAddress(aDLLHandle, 'spTimelineArray_contains');
  spTimelineArray_create := GetProcAddress(aDLLHandle, 'spTimelineArray_create');
  spTimelineArray_dispose := GetProcAddress(aDLLHandle, 'spTimelineArray_dispose');
  spTimelineArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spTimelineArray_ensureCapacity');
  spTimelineArray_peek := GetProcAddress(aDLLHandle, 'spTimelineArray_peek');
  spTimelineArray_pop := GetProcAddress(aDLLHandle, 'spTimelineArray_pop');
  spTimelineArray_removeAt := GetProcAddress(aDLLHandle, 'spTimelineArray_removeAt');
  spTimelineArray_setSize := GetProcAddress(aDLLHandle, 'spTimelineArray_setSize');
  spTrackEntry_getAnimationTime := GetProcAddress(aDLLHandle, 'spTrackEntry_getAnimationTime');
  spTrackEntry_getTrackComplete := GetProcAddress(aDLLHandle, 'spTrackEntry_getTrackComplete');
  spTrackEntry_isNextReady := GetProcAddress(aDLLHandle, 'spTrackEntry_isNextReady');
  spTrackEntry_resetRotationDirections := GetProcAddress(aDLLHandle, 'spTrackEntry_resetRotationDirections');
  spTrackEntry_setMixDuration := GetProcAddress(aDLLHandle, 'spTrackEntry_setMixDuration');
  spTrackEntry_wasApplied := GetProcAddress(aDLLHandle, 'spTrackEntry_wasApplied');
  spTrackEntryArray_add := GetProcAddress(aDLLHandle, 'spTrackEntryArray_add');
  spTrackEntryArray_addAll := GetProcAddress(aDLLHandle, 'spTrackEntryArray_addAll');
  spTrackEntryArray_addAllValues := GetProcAddress(aDLLHandle, 'spTrackEntryArray_addAllValues');
  spTrackEntryArray_clear := GetProcAddress(aDLLHandle, 'spTrackEntryArray_clear');
  spTrackEntryArray_contains := GetProcAddress(aDLLHandle, 'spTrackEntryArray_contains');
  spTrackEntryArray_create := GetProcAddress(aDLLHandle, 'spTrackEntryArray_create');
  spTrackEntryArray_dispose := GetProcAddress(aDLLHandle, 'spTrackEntryArray_dispose');
  spTrackEntryArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spTrackEntryArray_ensureCapacity');
  spTrackEntryArray_peek := GetProcAddress(aDLLHandle, 'spTrackEntryArray_peek');
  spTrackEntryArray_pop := GetProcAddress(aDLLHandle, 'spTrackEntryArray_pop');
  spTrackEntryArray_removeAt := GetProcAddress(aDLLHandle, 'spTrackEntryArray_removeAt');
  spTrackEntryArray_setSize := GetProcAddress(aDLLHandle, 'spTrackEntryArray_setSize');
  spTransformConstraint_create := GetProcAddress(aDLLHandle, 'spTransformConstraint_create');
  spTransformConstraint_dispose := GetProcAddress(aDLLHandle, 'spTransformConstraint_dispose');
  spTransformConstraint_setToSetupPose := GetProcAddress(aDLLHandle, 'spTransformConstraint_setToSetupPose');
  spTransformConstraint_update := GetProcAddress(aDLLHandle, 'spTransformConstraint_update');
  spTransformConstraintData_create := GetProcAddress(aDLLHandle, 'spTransformConstraintData_create');
  spTransformConstraintData_dispose := GetProcAddress(aDLLHandle, 'spTransformConstraintData_dispose');
  spTransformConstraintDataArray_add := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_add');
  spTransformConstraintDataArray_addAll := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_addAll');
  spTransformConstraintDataArray_addAllValues := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_addAllValues');
  spTransformConstraintDataArray_clear := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_clear');
  spTransformConstraintDataArray_contains := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_contains');
  spTransformConstraintDataArray_create := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_create');
  spTransformConstraintDataArray_dispose := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_dispose');
  spTransformConstraintDataArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_ensureCapacity');
  spTransformConstraintDataArray_peek := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_peek');
  spTransformConstraintDataArray_pop := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_pop');
  spTransformConstraintDataArray_removeAt := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_removeAt');
  spTransformConstraintDataArray_setSize := GetProcAddress(aDLLHandle, 'spTransformConstraintDataArray_setSize');
  spTransformConstraintTimeline_create := GetProcAddress(aDLLHandle, 'spTransformConstraintTimeline_create');
  spTransformConstraintTimeline_setFrame := GetProcAddress(aDLLHandle, 'spTransformConstraintTimeline_setFrame');
  spTranslateTimeline_create := GetProcAddress(aDLLHandle, 'spTranslateTimeline_create');
  spTranslateTimeline_setFrame := GetProcAddress(aDLLHandle, 'spTranslateTimeline_setFrame');
  spTranslateXTimeline_create := GetProcAddress(aDLLHandle, 'spTranslateXTimeline_create');
  spTranslateXTimeline_setFrame := GetProcAddress(aDLLHandle, 'spTranslateXTimeline_setFrame');
  spTranslateYTimeline_create := GetProcAddress(aDLLHandle, 'spTranslateYTimeline_create');
  spTranslateYTimeline_setFrame := GetProcAddress(aDLLHandle, 'spTranslateYTimeline_setFrame');
  spTriangulator_create := GetProcAddress(aDLLHandle, 'spTriangulator_create');
  spTriangulator_decompose := GetProcAddress(aDLLHandle, 'spTriangulator_decompose');
  spTriangulator_dispose := GetProcAddress(aDLLHandle, 'spTriangulator_dispose');
  spTriangulator_triangulate := GetProcAddress(aDLLHandle, 'spTriangulator_triangulate');
  spUnsignedShortArray_add := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_add');
  spUnsignedShortArray_addAll := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_addAll');
  spUnsignedShortArray_addAllValues := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_addAllValues');
  spUnsignedShortArray_clear := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_clear');
  spUnsignedShortArray_contains := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_contains');
  spUnsignedShortArray_create := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_create');
  spUnsignedShortArray_dispose := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_dispose');
  spUnsignedShortArray_ensureCapacity := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_ensureCapacity');
  spUnsignedShortArray_peek := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_peek');
  spUnsignedShortArray_pop := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_pop');
  spUnsignedShortArray_removeAt := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_removeAt');
  spUnsignedShortArray_setSize := GetProcAddress(aDLLHandle, 'spUnsignedShortArray_setSize');
  spVertexAttachment_computeWorldVertices := GetProcAddress(aDLLHandle, 'spVertexAttachment_computeWorldVertices');
  spVertexAttachment_copyTo := GetProcAddress(aDLLHandle, 'spVertexAttachment_copyTo');
  sqlite3_aggregate_context := GetProcAddress(aDLLHandle, 'sqlite3_aggregate_context');
  sqlite3_aggregate_count := GetProcAddress(aDLLHandle, 'sqlite3_aggregate_count');
  sqlite3_auto_extension := GetProcAddress(aDLLHandle, 'sqlite3_auto_extension');
  sqlite3_autovacuum_pages := GetProcAddress(aDLLHandle, 'sqlite3_autovacuum_pages');
  sqlite3_backup_finish := GetProcAddress(aDLLHandle, 'sqlite3_backup_finish');
  sqlite3_backup_init := GetProcAddress(aDLLHandle, 'sqlite3_backup_init');
  sqlite3_backup_pagecount := GetProcAddress(aDLLHandle, 'sqlite3_backup_pagecount');
  sqlite3_backup_remaining := GetProcAddress(aDLLHandle, 'sqlite3_backup_remaining');
  sqlite3_backup_step := GetProcAddress(aDLLHandle, 'sqlite3_backup_step');
  sqlite3_bind_blob := GetProcAddress(aDLLHandle, 'sqlite3_bind_blob');
  sqlite3_bind_blob64 := GetProcAddress(aDLLHandle, 'sqlite3_bind_blob64');
  sqlite3_bind_double := GetProcAddress(aDLLHandle, 'sqlite3_bind_double');
  sqlite3_bind_int := GetProcAddress(aDLLHandle, 'sqlite3_bind_int');
  sqlite3_bind_int64 := GetProcAddress(aDLLHandle, 'sqlite3_bind_int64');
  sqlite3_bind_null := GetProcAddress(aDLLHandle, 'sqlite3_bind_null');
  sqlite3_bind_parameter_count := GetProcAddress(aDLLHandle, 'sqlite3_bind_parameter_count');
  sqlite3_bind_parameter_index := GetProcAddress(aDLLHandle, 'sqlite3_bind_parameter_index');
  sqlite3_bind_parameter_name := GetProcAddress(aDLLHandle, 'sqlite3_bind_parameter_name');
  sqlite3_bind_pointer := GetProcAddress(aDLLHandle, 'sqlite3_bind_pointer');
  sqlite3_bind_text := GetProcAddress(aDLLHandle, 'sqlite3_bind_text');
  sqlite3_bind_text16 := GetProcAddress(aDLLHandle, 'sqlite3_bind_text16');
  sqlite3_bind_text64 := GetProcAddress(aDLLHandle, 'sqlite3_bind_text64');
  sqlite3_bind_value := GetProcAddress(aDLLHandle, 'sqlite3_bind_value');
  sqlite3_bind_zeroblob := GetProcAddress(aDLLHandle, 'sqlite3_bind_zeroblob');
  sqlite3_bind_zeroblob64 := GetProcAddress(aDLLHandle, 'sqlite3_bind_zeroblob64');
  sqlite3_blob_bytes := GetProcAddress(aDLLHandle, 'sqlite3_blob_bytes');
  sqlite3_blob_close := GetProcAddress(aDLLHandle, 'sqlite3_blob_close');
  sqlite3_blob_open := GetProcAddress(aDLLHandle, 'sqlite3_blob_open');
  sqlite3_blob_read := GetProcAddress(aDLLHandle, 'sqlite3_blob_read');
  sqlite3_blob_reopen := GetProcAddress(aDLLHandle, 'sqlite3_blob_reopen');
  sqlite3_blob_write := GetProcAddress(aDLLHandle, 'sqlite3_blob_write');
  sqlite3_busy_handler := GetProcAddress(aDLLHandle, 'sqlite3_busy_handler');
  sqlite3_busy_timeout := GetProcAddress(aDLLHandle, 'sqlite3_busy_timeout');
  sqlite3_cancel_auto_extension := GetProcAddress(aDLLHandle, 'sqlite3_cancel_auto_extension');
  sqlite3_changes := GetProcAddress(aDLLHandle, 'sqlite3_changes');
  sqlite3_changes64 := GetProcAddress(aDLLHandle, 'sqlite3_changes64');
  sqlite3_clear_bindings := GetProcAddress(aDLLHandle, 'sqlite3_clear_bindings');
  sqlite3_close := GetProcAddress(aDLLHandle, 'sqlite3_close');
  sqlite3_close_v2 := GetProcAddress(aDLLHandle, 'sqlite3_close_v2');
  sqlite3_collation_needed := GetProcAddress(aDLLHandle, 'sqlite3_collation_needed');
  sqlite3_collation_needed16 := GetProcAddress(aDLLHandle, 'sqlite3_collation_needed16');
  sqlite3_column_blob := GetProcAddress(aDLLHandle, 'sqlite3_column_blob');
  sqlite3_column_bytes := GetProcAddress(aDLLHandle, 'sqlite3_column_bytes');
  sqlite3_column_bytes16 := GetProcAddress(aDLLHandle, 'sqlite3_column_bytes16');
  sqlite3_column_count := GetProcAddress(aDLLHandle, 'sqlite3_column_count');
  sqlite3_column_database_name := GetProcAddress(aDLLHandle, 'sqlite3_column_database_name');
  sqlite3_column_database_name16 := GetProcAddress(aDLLHandle, 'sqlite3_column_database_name16');
  sqlite3_column_decltype := GetProcAddress(aDLLHandle, 'sqlite3_column_decltype');
  sqlite3_column_decltype16 := GetProcAddress(aDLLHandle, 'sqlite3_column_decltype16');
  sqlite3_column_double := GetProcAddress(aDLLHandle, 'sqlite3_column_double');
  sqlite3_column_int := GetProcAddress(aDLLHandle, 'sqlite3_column_int');
  sqlite3_column_int64 := GetProcAddress(aDLLHandle, 'sqlite3_column_int64');
  sqlite3_column_name := GetProcAddress(aDLLHandle, 'sqlite3_column_name');
  sqlite3_column_name16 := GetProcAddress(aDLLHandle, 'sqlite3_column_name16');
  sqlite3_column_origin_name := GetProcAddress(aDLLHandle, 'sqlite3_column_origin_name');
  sqlite3_column_origin_name16 := GetProcAddress(aDLLHandle, 'sqlite3_column_origin_name16');
  sqlite3_column_table_name := GetProcAddress(aDLLHandle, 'sqlite3_column_table_name');
  sqlite3_column_table_name16 := GetProcAddress(aDLLHandle, 'sqlite3_column_table_name16');
  sqlite3_column_text := GetProcAddress(aDLLHandle, 'sqlite3_column_text');
  sqlite3_column_text16 := GetProcAddress(aDLLHandle, 'sqlite3_column_text16');
  sqlite3_column_type := GetProcAddress(aDLLHandle, 'sqlite3_column_type');
  sqlite3_column_value := GetProcAddress(aDLLHandle, 'sqlite3_column_value');
  sqlite3_commit_hook := GetProcAddress(aDLLHandle, 'sqlite3_commit_hook');
  sqlite3_compileoption_get := GetProcAddress(aDLLHandle, 'sqlite3_compileoption_get');
  sqlite3_compileoption_used := GetProcAddress(aDLLHandle, 'sqlite3_compileoption_used');
  sqlite3_complete := GetProcAddress(aDLLHandle, 'sqlite3_complete');
  sqlite3_complete16 := GetProcAddress(aDLLHandle, 'sqlite3_complete16');
  sqlite3_config := GetProcAddress(aDLLHandle, 'sqlite3_config');
  sqlite3_context_db_handle := GetProcAddress(aDLLHandle, 'sqlite3_context_db_handle');
  sqlite3_create_collation := GetProcAddress(aDLLHandle, 'sqlite3_create_collation');
  sqlite3_create_collation_v2 := GetProcAddress(aDLLHandle, 'sqlite3_create_collation_v2');
  sqlite3_create_collation16 := GetProcAddress(aDLLHandle, 'sqlite3_create_collation16');
  sqlite3_create_filename := GetProcAddress(aDLLHandle, 'sqlite3_create_filename');
  sqlite3_create_function := GetProcAddress(aDLLHandle, 'sqlite3_create_function');
  sqlite3_create_function_v2 := GetProcAddress(aDLLHandle, 'sqlite3_create_function_v2');
  sqlite3_create_function16 := GetProcAddress(aDLLHandle, 'sqlite3_create_function16');
  sqlite3_create_module := GetProcAddress(aDLLHandle, 'sqlite3_create_module');
  sqlite3_create_module_v2 := GetProcAddress(aDLLHandle, 'sqlite3_create_module_v2');
  sqlite3_create_window_function := GetProcAddress(aDLLHandle, 'sqlite3_create_window_function');
  sqlite3_data_count := GetProcAddress(aDLLHandle, 'sqlite3_data_count');
  sqlite3_database_file_object := GetProcAddress(aDLLHandle, 'sqlite3_database_file_object');
  sqlite3_db_cacheflush := GetProcAddress(aDLLHandle, 'sqlite3_db_cacheflush');
  sqlite3_db_config := GetProcAddress(aDLLHandle, 'sqlite3_db_config');
  sqlite3_db_filename := GetProcAddress(aDLLHandle, 'sqlite3_db_filename');
  sqlite3_db_handle := GetProcAddress(aDLLHandle, 'sqlite3_db_handle');
  sqlite3_db_mutex := GetProcAddress(aDLLHandle, 'sqlite3_db_mutex');
  sqlite3_db_name := GetProcAddress(aDLLHandle, 'sqlite3_db_name');
  sqlite3_db_readonly := GetProcAddress(aDLLHandle, 'sqlite3_db_readonly');
  sqlite3_db_release_memory := GetProcAddress(aDLLHandle, 'sqlite3_db_release_memory');
  sqlite3_db_status := GetProcAddress(aDLLHandle, 'sqlite3_db_status');
  sqlite3_declare_vtab := GetProcAddress(aDLLHandle, 'sqlite3_declare_vtab');
  sqlite3_deserialize := GetProcAddress(aDLLHandle, 'sqlite3_deserialize');
  sqlite3_drop_modules := GetProcAddress(aDLLHandle, 'sqlite3_drop_modules');
  sqlite3_enable_shared_cache := GetProcAddress(aDLLHandle, 'sqlite3_enable_shared_cache');
  sqlite3_errcode := GetProcAddress(aDLLHandle, 'sqlite3_errcode');
  sqlite3_errmsg := GetProcAddress(aDLLHandle, 'sqlite3_errmsg');
  sqlite3_errmsg16 := GetProcAddress(aDLLHandle, 'sqlite3_errmsg16');
  sqlite3_error_offset := GetProcAddress(aDLLHandle, 'sqlite3_error_offset');
  sqlite3_errstr := GetProcAddress(aDLLHandle, 'sqlite3_errstr');
  sqlite3_exec := GetProcAddress(aDLLHandle, 'sqlite3_exec');
  sqlite3_expanded_sql := GetProcAddress(aDLLHandle, 'sqlite3_expanded_sql');
  sqlite3_expired := GetProcAddress(aDLLHandle, 'sqlite3_expired');
  sqlite3_extended_errcode := GetProcAddress(aDLLHandle, 'sqlite3_extended_errcode');
  sqlite3_extended_result_codes := GetProcAddress(aDLLHandle, 'sqlite3_extended_result_codes');
  sqlite3_file_control := GetProcAddress(aDLLHandle, 'sqlite3_file_control');
  sqlite3_filename_database := GetProcAddress(aDLLHandle, 'sqlite3_filename_database');
  sqlite3_filename_journal := GetProcAddress(aDLLHandle, 'sqlite3_filename_journal');
  sqlite3_filename_wal := GetProcAddress(aDLLHandle, 'sqlite3_filename_wal');
  sqlite3_finalize := GetProcAddress(aDLLHandle, 'sqlite3_finalize');
  sqlite3_free := GetProcAddress(aDLLHandle, 'sqlite3_free');
  sqlite3_free_filename := GetProcAddress(aDLLHandle, 'sqlite3_free_filename');
  sqlite3_free_table := GetProcAddress(aDLLHandle, 'sqlite3_free_table');
  sqlite3_get_autocommit := GetProcAddress(aDLLHandle, 'sqlite3_get_autocommit');
  sqlite3_get_auxdata := GetProcAddress(aDLLHandle, 'sqlite3_get_auxdata');
  sqlite3_get_clientdata := GetProcAddress(aDLLHandle, 'sqlite3_get_clientdata');
  sqlite3_get_table := GetProcAddress(aDLLHandle, 'sqlite3_get_table');
  sqlite3_global_recover := GetProcAddress(aDLLHandle, 'sqlite3_global_recover');
  sqlite3_hard_heap_limit64 := GetProcAddress(aDLLHandle, 'sqlite3_hard_heap_limit64');
  sqlite3_initialize := GetProcAddress(aDLLHandle, 'sqlite3_initialize');
  sqlite3_interrupt := GetProcAddress(aDLLHandle, 'sqlite3_interrupt');
  sqlite3_is_interrupted := GetProcAddress(aDLLHandle, 'sqlite3_is_interrupted');
  sqlite3_keyword_check := GetProcAddress(aDLLHandle, 'sqlite3_keyword_check');
  sqlite3_keyword_count := GetProcAddress(aDLLHandle, 'sqlite3_keyword_count');
  sqlite3_keyword_name := GetProcAddress(aDLLHandle, 'sqlite3_keyword_name');
  sqlite3_last_insert_rowid := GetProcAddress(aDLLHandle, 'sqlite3_last_insert_rowid');
  sqlite3_libversion := GetProcAddress(aDLLHandle, 'sqlite3_libversion');
  sqlite3_libversion_number := GetProcAddress(aDLLHandle, 'sqlite3_libversion_number');
  sqlite3_limit := GetProcAddress(aDLLHandle, 'sqlite3_limit');
  sqlite3_log := GetProcAddress(aDLLHandle, 'sqlite3_log');
  sqlite3_malloc := GetProcAddress(aDLLHandle, 'sqlite3_malloc');
  sqlite3_malloc64 := GetProcAddress(aDLLHandle, 'sqlite3_malloc64');
  sqlite3_memory_alarm := GetProcAddress(aDLLHandle, 'sqlite3_memory_alarm');
  sqlite3_memory_highwater := GetProcAddress(aDLLHandle, 'sqlite3_memory_highwater');
  sqlite3_memory_used := GetProcAddress(aDLLHandle, 'sqlite3_memory_used');
  sqlite3_mprintf := GetProcAddress(aDLLHandle, 'sqlite3_mprintf');
  sqlite3_msize := GetProcAddress(aDLLHandle, 'sqlite3_msize');
  sqlite3_mutex_alloc := GetProcAddress(aDLLHandle, 'sqlite3_mutex_alloc');
  sqlite3_mutex_enter := GetProcAddress(aDLLHandle, 'sqlite3_mutex_enter');
  sqlite3_mutex_free := GetProcAddress(aDLLHandle, 'sqlite3_mutex_free');
  sqlite3_mutex_leave := GetProcAddress(aDLLHandle, 'sqlite3_mutex_leave');
  sqlite3_mutex_try := GetProcAddress(aDLLHandle, 'sqlite3_mutex_try');
  sqlite3_next_stmt := GetProcAddress(aDLLHandle, 'sqlite3_next_stmt');
  sqlite3_open := GetProcAddress(aDLLHandle, 'sqlite3_open');
  sqlite3_open_v2 := GetProcAddress(aDLLHandle, 'sqlite3_open_v2');
  sqlite3_open16 := GetProcAddress(aDLLHandle, 'sqlite3_open16');
  sqlite3_os_end := GetProcAddress(aDLLHandle, 'sqlite3_os_end');
  sqlite3_os_init := GetProcAddress(aDLLHandle, 'sqlite3_os_init');
  sqlite3_overload_function := GetProcAddress(aDLLHandle, 'sqlite3_overload_function');
  sqlite3_prepare := GetProcAddress(aDLLHandle, 'sqlite3_prepare');
  sqlite3_prepare_v2 := GetProcAddress(aDLLHandle, 'sqlite3_prepare_v2');
  sqlite3_prepare_v3 := GetProcAddress(aDLLHandle, 'sqlite3_prepare_v3');
  sqlite3_prepare16 := GetProcAddress(aDLLHandle, 'sqlite3_prepare16');
  sqlite3_prepare16_v2 := GetProcAddress(aDLLHandle, 'sqlite3_prepare16_v2');
  sqlite3_prepare16_v3 := GetProcAddress(aDLLHandle, 'sqlite3_prepare16_v3');
  sqlite3_profile := GetProcAddress(aDLLHandle, 'sqlite3_profile');
  sqlite3_progress_handler := GetProcAddress(aDLLHandle, 'sqlite3_progress_handler');
  sqlite3_randomness := GetProcAddress(aDLLHandle, 'sqlite3_randomness');
  sqlite3_realloc := GetProcAddress(aDLLHandle, 'sqlite3_realloc');
  sqlite3_realloc64 := GetProcAddress(aDLLHandle, 'sqlite3_realloc64');
  sqlite3_release_memory := GetProcAddress(aDLLHandle, 'sqlite3_release_memory');
  sqlite3_reset := GetProcAddress(aDLLHandle, 'sqlite3_reset');
  sqlite3_reset_auto_extension := GetProcAddress(aDLLHandle, 'sqlite3_reset_auto_extension');
  sqlite3_result_blob := GetProcAddress(aDLLHandle, 'sqlite3_result_blob');
  sqlite3_result_blob64 := GetProcAddress(aDLLHandle, 'sqlite3_result_blob64');
  sqlite3_result_double := GetProcAddress(aDLLHandle, 'sqlite3_result_double');
  sqlite3_result_error := GetProcAddress(aDLLHandle, 'sqlite3_result_error');
  sqlite3_result_error_code := GetProcAddress(aDLLHandle, 'sqlite3_result_error_code');
  sqlite3_result_error_nomem := GetProcAddress(aDLLHandle, 'sqlite3_result_error_nomem');
  sqlite3_result_error_toobig := GetProcAddress(aDLLHandle, 'sqlite3_result_error_toobig');
  sqlite3_result_error16 := GetProcAddress(aDLLHandle, 'sqlite3_result_error16');
  sqlite3_result_int := GetProcAddress(aDLLHandle, 'sqlite3_result_int');
  sqlite3_result_int64 := GetProcAddress(aDLLHandle, 'sqlite3_result_int64');
  sqlite3_result_null := GetProcAddress(aDLLHandle, 'sqlite3_result_null');
  sqlite3_result_pointer := GetProcAddress(aDLLHandle, 'sqlite3_result_pointer');
  sqlite3_result_subtype := GetProcAddress(aDLLHandle, 'sqlite3_result_subtype');
  sqlite3_result_text := GetProcAddress(aDLLHandle, 'sqlite3_result_text');
  sqlite3_result_text16 := GetProcAddress(aDLLHandle, 'sqlite3_result_text16');
  sqlite3_result_text16be := GetProcAddress(aDLLHandle, 'sqlite3_result_text16be');
  sqlite3_result_text16le := GetProcAddress(aDLLHandle, 'sqlite3_result_text16le');
  sqlite3_result_text64 := GetProcAddress(aDLLHandle, 'sqlite3_result_text64');
  sqlite3_result_value := GetProcAddress(aDLLHandle, 'sqlite3_result_value');
  sqlite3_result_zeroblob := GetProcAddress(aDLLHandle, 'sqlite3_result_zeroblob');
  sqlite3_result_zeroblob64 := GetProcAddress(aDLLHandle, 'sqlite3_result_zeroblob64');
  sqlite3_rollback_hook := GetProcAddress(aDLLHandle, 'sqlite3_rollback_hook');
  sqlite3_serialize := GetProcAddress(aDLLHandle, 'sqlite3_serialize');
  sqlite3_set_authorizer := GetProcAddress(aDLLHandle, 'sqlite3_set_authorizer');
  sqlite3_set_auxdata := GetProcAddress(aDLLHandle, 'sqlite3_set_auxdata');
  sqlite3_set_clientdata := GetProcAddress(aDLLHandle, 'sqlite3_set_clientdata');
  sqlite3_set_last_insert_rowid := GetProcAddress(aDLLHandle, 'sqlite3_set_last_insert_rowid');
  sqlite3_shutdown := GetProcAddress(aDLLHandle, 'sqlite3_shutdown');
  sqlite3_sleep := GetProcAddress(aDLLHandle, 'sqlite3_sleep');
  sqlite3_snprintf := GetProcAddress(aDLLHandle, 'sqlite3_snprintf');
  sqlite3_soft_heap_limit := GetProcAddress(aDLLHandle, 'sqlite3_soft_heap_limit');
  sqlite3_soft_heap_limit64 := GetProcAddress(aDLLHandle, 'sqlite3_soft_heap_limit64');
  sqlite3_sourceid := GetProcAddress(aDLLHandle, 'sqlite3_sourceid');
  sqlite3_sql := GetProcAddress(aDLLHandle, 'sqlite3_sql');
  sqlite3_status := GetProcAddress(aDLLHandle, 'sqlite3_status');
  sqlite3_status64 := GetProcAddress(aDLLHandle, 'sqlite3_status64');
  sqlite3_step := GetProcAddress(aDLLHandle, 'sqlite3_step');
  sqlite3_stmt_busy := GetProcAddress(aDLLHandle, 'sqlite3_stmt_busy');
  sqlite3_stmt_explain := GetProcAddress(aDLLHandle, 'sqlite3_stmt_explain');
  sqlite3_stmt_isexplain := GetProcAddress(aDLLHandle, 'sqlite3_stmt_isexplain');
  sqlite3_stmt_readonly := GetProcAddress(aDLLHandle, 'sqlite3_stmt_readonly');
  sqlite3_stmt_status := GetProcAddress(aDLLHandle, 'sqlite3_stmt_status');
  sqlite3_str_append := GetProcAddress(aDLLHandle, 'sqlite3_str_append');
  sqlite3_str_appendall := GetProcAddress(aDLLHandle, 'sqlite3_str_appendall');
  sqlite3_str_appendchar := GetProcAddress(aDLLHandle, 'sqlite3_str_appendchar');
  sqlite3_str_appendf := GetProcAddress(aDLLHandle, 'sqlite3_str_appendf');
  sqlite3_str_errcode := GetProcAddress(aDLLHandle, 'sqlite3_str_errcode');
  sqlite3_str_finish := GetProcAddress(aDLLHandle, 'sqlite3_str_finish');
  sqlite3_str_length := GetProcAddress(aDLLHandle, 'sqlite3_str_length');
  sqlite3_str_new := GetProcAddress(aDLLHandle, 'sqlite3_str_new');
  sqlite3_str_reset := GetProcAddress(aDLLHandle, 'sqlite3_str_reset');
  sqlite3_str_value := GetProcAddress(aDLLHandle, 'sqlite3_str_value');
  sqlite3_str_vappendf := GetProcAddress(aDLLHandle, 'sqlite3_str_vappendf');
  sqlite3_strglob := GetProcAddress(aDLLHandle, 'sqlite3_strglob');
  sqlite3_stricmp := GetProcAddress(aDLLHandle, 'sqlite3_stricmp');
  sqlite3_strlike := GetProcAddress(aDLLHandle, 'sqlite3_strlike');
  sqlite3_strnicmp := GetProcAddress(aDLLHandle, 'sqlite3_strnicmp');
  sqlite3_system_errno := GetProcAddress(aDLLHandle, 'sqlite3_system_errno');
  sqlite3_table_column_metadata := GetProcAddress(aDLLHandle, 'sqlite3_table_column_metadata');
  sqlite3_test_control := GetProcAddress(aDLLHandle, 'sqlite3_test_control');
  sqlite3_thread_cleanup := GetProcAddress(aDLLHandle, 'sqlite3_thread_cleanup');
  sqlite3_threadsafe := GetProcAddress(aDLLHandle, 'sqlite3_threadsafe');
  sqlite3_total_changes := GetProcAddress(aDLLHandle, 'sqlite3_total_changes');
  sqlite3_total_changes64 := GetProcAddress(aDLLHandle, 'sqlite3_total_changes64');
  sqlite3_trace := GetProcAddress(aDLLHandle, 'sqlite3_trace');
  sqlite3_trace_v2 := GetProcAddress(aDLLHandle, 'sqlite3_trace_v2');
  sqlite3_transfer_bindings := GetProcAddress(aDLLHandle, 'sqlite3_transfer_bindings');
  sqlite3_txn_state := GetProcAddress(aDLLHandle, 'sqlite3_txn_state');
  sqlite3_update_hook := GetProcAddress(aDLLHandle, 'sqlite3_update_hook');
  sqlite3_uri_boolean := GetProcAddress(aDLLHandle, 'sqlite3_uri_boolean');
  sqlite3_uri_int64 := GetProcAddress(aDLLHandle, 'sqlite3_uri_int64');
  sqlite3_uri_key := GetProcAddress(aDLLHandle, 'sqlite3_uri_key');
  sqlite3_uri_parameter := GetProcAddress(aDLLHandle, 'sqlite3_uri_parameter');
  sqlite3_user_data := GetProcAddress(aDLLHandle, 'sqlite3_user_data');
  sqlite3_value_blob := GetProcAddress(aDLLHandle, 'sqlite3_value_blob');
  sqlite3_value_bytes := GetProcAddress(aDLLHandle, 'sqlite3_value_bytes');
  sqlite3_value_bytes16 := GetProcAddress(aDLLHandle, 'sqlite3_value_bytes16');
  sqlite3_value_double := GetProcAddress(aDLLHandle, 'sqlite3_value_double');
  sqlite3_value_dup := GetProcAddress(aDLLHandle, 'sqlite3_value_dup');
  sqlite3_value_encoding := GetProcAddress(aDLLHandle, 'sqlite3_value_encoding');
  sqlite3_value_free := GetProcAddress(aDLLHandle, 'sqlite3_value_free');
  sqlite3_value_frombind := GetProcAddress(aDLLHandle, 'sqlite3_value_frombind');
  sqlite3_value_int := GetProcAddress(aDLLHandle, 'sqlite3_value_int');
  sqlite3_value_int64 := GetProcAddress(aDLLHandle, 'sqlite3_value_int64');
  sqlite3_value_nochange := GetProcAddress(aDLLHandle, 'sqlite3_value_nochange');
  sqlite3_value_numeric_type := GetProcAddress(aDLLHandle, 'sqlite3_value_numeric_type');
  sqlite3_value_pointer := GetProcAddress(aDLLHandle, 'sqlite3_value_pointer');
  sqlite3_value_subtype := GetProcAddress(aDLLHandle, 'sqlite3_value_subtype');
  sqlite3_value_text := GetProcAddress(aDLLHandle, 'sqlite3_value_text');
  sqlite3_value_text16 := GetProcAddress(aDLLHandle, 'sqlite3_value_text16');
  sqlite3_value_text16be := GetProcAddress(aDLLHandle, 'sqlite3_value_text16be');
  sqlite3_value_text16le := GetProcAddress(aDLLHandle, 'sqlite3_value_text16le');
  sqlite3_value_type := GetProcAddress(aDLLHandle, 'sqlite3_value_type');
  sqlite3_vfs_find := GetProcAddress(aDLLHandle, 'sqlite3_vfs_find');
  sqlite3_vfs_register := GetProcAddress(aDLLHandle, 'sqlite3_vfs_register');
  sqlite3_vfs_unregister := GetProcAddress(aDLLHandle, 'sqlite3_vfs_unregister');
  sqlite3_vmprintf := GetProcAddress(aDLLHandle, 'sqlite3_vmprintf');
  sqlite3_vsnprintf := GetProcAddress(aDLLHandle, 'sqlite3_vsnprintf');
  sqlite3_vtab_collation := GetProcAddress(aDLLHandle, 'sqlite3_vtab_collation');
  sqlite3_vtab_config := GetProcAddress(aDLLHandle, 'sqlite3_vtab_config');
  sqlite3_vtab_distinct := GetProcAddress(aDLLHandle, 'sqlite3_vtab_distinct');
  sqlite3_vtab_in := GetProcAddress(aDLLHandle, 'sqlite3_vtab_in');
  sqlite3_vtab_in_first := GetProcAddress(aDLLHandle, 'sqlite3_vtab_in_first');
  sqlite3_vtab_in_next := GetProcAddress(aDLLHandle, 'sqlite3_vtab_in_next');
  sqlite3_vtab_nochange := GetProcAddress(aDLLHandle, 'sqlite3_vtab_nochange');
  sqlite3_vtab_on_conflict := GetProcAddress(aDLLHandle, 'sqlite3_vtab_on_conflict');
  sqlite3_vtab_rhs_value := GetProcAddress(aDLLHandle, 'sqlite3_vtab_rhs_value');
  sqlite3_wal_autocheckpoint := GetProcAddress(aDLLHandle, 'sqlite3_wal_autocheckpoint');
  sqlite3_wal_checkpoint := GetProcAddress(aDLLHandle, 'sqlite3_wal_checkpoint');
  sqlite3_wal_checkpoint_v2 := GetProcAddress(aDLLHandle, 'sqlite3_wal_checkpoint_v2');
  sqlite3_wal_hook := GetProcAddress(aDLLHandle, 'sqlite3_wal_hook');
  sqlite3_win32_set_directory := GetProcAddress(aDLLHandle, 'sqlite3_win32_set_directory');
  sqlite3_win32_set_directory16 := GetProcAddress(aDLLHandle, 'sqlite3_win32_set_directory16');
  sqlite3_win32_set_directory8 := GetProcAddress(aDLLHandle, 'sqlite3_win32_set_directory8');
  stbi_convert_iphone_png_to_rgb := GetProcAddress(aDLLHandle, 'stbi_convert_iphone_png_to_rgb');
  stbi_failure_reason := GetProcAddress(aDLLHandle, 'stbi_failure_reason');
  stbi_flip_vertically_on_write := GetProcAddress(aDLLHandle, 'stbi_flip_vertically_on_write');
  stbi_hdr_to_ldr_gamma := GetProcAddress(aDLLHandle, 'stbi_hdr_to_ldr_gamma');
  stbi_hdr_to_ldr_scale := GetProcAddress(aDLLHandle, 'stbi_hdr_to_ldr_scale');
  stbi_image_free := GetProcAddress(aDLLHandle, 'stbi_image_free');
  stbi_info := GetProcAddress(aDLLHandle, 'stbi_info');
  stbi_info_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_info_from_callbacks');
  stbi_info_from_file := GetProcAddress(aDLLHandle, 'stbi_info_from_file');
  stbi_info_from_memory := GetProcAddress(aDLLHandle, 'stbi_info_from_memory');
  stbi_is_16_bit := GetProcAddress(aDLLHandle, 'stbi_is_16_bit');
  stbi_is_16_bit_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_is_16_bit_from_callbacks');
  stbi_is_16_bit_from_file := GetProcAddress(aDLLHandle, 'stbi_is_16_bit_from_file');
  stbi_is_16_bit_from_memory := GetProcAddress(aDLLHandle, 'stbi_is_16_bit_from_memory');
  stbi_is_hdr := GetProcAddress(aDLLHandle, 'stbi_is_hdr');
  stbi_is_hdr_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_is_hdr_from_callbacks');
  stbi_is_hdr_from_file := GetProcAddress(aDLLHandle, 'stbi_is_hdr_from_file');
  stbi_is_hdr_from_memory := GetProcAddress(aDLLHandle, 'stbi_is_hdr_from_memory');
  stbi_ldr_to_hdr_gamma := GetProcAddress(aDLLHandle, 'stbi_ldr_to_hdr_gamma');
  stbi_ldr_to_hdr_scale := GetProcAddress(aDLLHandle, 'stbi_ldr_to_hdr_scale');
  stbi_load := GetProcAddress(aDLLHandle, 'stbi_load');
  stbi_load_16 := GetProcAddress(aDLLHandle, 'stbi_load_16');
  stbi_load_16_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_load_16_from_callbacks');
  stbi_load_16_from_memory := GetProcAddress(aDLLHandle, 'stbi_load_16_from_memory');
  stbi_load_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_load_from_callbacks');
  stbi_load_from_file := GetProcAddress(aDLLHandle, 'stbi_load_from_file');
  stbi_load_from_file_16 := GetProcAddress(aDLLHandle, 'stbi_load_from_file_16');
  stbi_load_from_memory := GetProcAddress(aDLLHandle, 'stbi_load_from_memory');
  stbi_load_gif_from_memory := GetProcAddress(aDLLHandle, 'stbi_load_gif_from_memory');
  stbi_loadf := GetProcAddress(aDLLHandle, 'stbi_loadf');
  stbi_loadf_from_callbacks := GetProcAddress(aDLLHandle, 'stbi_loadf_from_callbacks');
  stbi_loadf_from_file := GetProcAddress(aDLLHandle, 'stbi_loadf_from_file');
  stbi_loadf_from_memory := GetProcAddress(aDLLHandle, 'stbi_loadf_from_memory');
  stbi_set_flip_vertically_on_load := GetProcAddress(aDLLHandle, 'stbi_set_flip_vertically_on_load');
  stbi_set_unpremultiply_on_load := GetProcAddress(aDLLHandle, 'stbi_set_unpremultiply_on_load');
  stbi_write_bmp := GetProcAddress(aDLLHandle, 'stbi_write_bmp');
  stbi_write_bmp_to_func := GetProcAddress(aDLLHandle, 'stbi_write_bmp_to_func');
  stbi_write_hdr := GetProcAddress(aDLLHandle, 'stbi_write_hdr');
  stbi_write_hdr_to_func := GetProcAddress(aDLLHandle, 'stbi_write_hdr_to_func');
  stbi_write_jpg := GetProcAddress(aDLLHandle, 'stbi_write_jpg');
  stbi_write_jpg_to_func := GetProcAddress(aDLLHandle, 'stbi_write_jpg_to_func');
  stbi_write_png := GetProcAddress(aDLLHandle, 'stbi_write_png');
  stbi_write_png_to_func := GetProcAddress(aDLLHandle, 'stbi_write_png_to_func');
  stbi_write_tga := GetProcAddress(aDLLHandle, 'stbi_write_tga');
  stbi_write_tga_to_func := GetProcAddress(aDLLHandle, 'stbi_write_tga_to_func');
  stbi_zlib_decode_buffer := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_buffer');
  stbi_zlib_decode_malloc := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_malloc');
  stbi_zlib_decode_malloc_guesssize := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_malloc_guesssize');
  stbi_zlib_decode_malloc_guesssize_headerflag := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_malloc_guesssize_headerflag');
  stbi_zlib_decode_noheader_buffer := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_noheader_buffer');
  stbi_zlib_decode_noheader_malloc := GetProcAddress(aDLLHandle, 'stbi_zlib_decode_noheader_malloc');
  stbrp_init_target := GetProcAddress(aDLLHandle, 'stbrp_init_target');
  stbrp_pack_rects := GetProcAddress(aDLLHandle, 'stbrp_pack_rects');
  stbrp_setup_allow_out_of_mem := GetProcAddress(aDLLHandle, 'stbrp_setup_allow_out_of_mem');
  stbrp_setup_heuristic := GetProcAddress(aDLLHandle, 'stbrp_setup_heuristic');
  stbtt_BakeFontBitmap := GetProcAddress(aDLLHandle, 'stbtt_BakeFontBitmap');
  stbtt_CompareUTF8toUTF16_bigendian := GetProcAddress(aDLLHandle, 'stbtt_CompareUTF8toUTF16_bigendian');
  stbtt_FindGlyphIndex := GetProcAddress(aDLLHandle, 'stbtt_FindGlyphIndex');
  stbtt_FindMatchingFont := GetProcAddress(aDLLHandle, 'stbtt_FindMatchingFont');
  stbtt_FindSVGDoc := GetProcAddress(aDLLHandle, 'stbtt_FindSVGDoc');
  stbtt_FreeBitmap := GetProcAddress(aDLLHandle, 'stbtt_FreeBitmap');
  stbtt_FreeSDF := GetProcAddress(aDLLHandle, 'stbtt_FreeSDF');
  stbtt_FreeShape := GetProcAddress(aDLLHandle, 'stbtt_FreeShape');
  stbtt_GetBakedQuad := GetProcAddress(aDLLHandle, 'stbtt_GetBakedQuad');
  stbtt_GetCodepointBitmap := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointBitmap');
  stbtt_GetCodepointBitmapBox := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointBitmapBox');
  stbtt_GetCodepointBitmapBoxSubpixel := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointBitmapBoxSubpixel');
  stbtt_GetCodepointBitmapSubpixel := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointBitmapSubpixel');
  stbtt_GetCodepointBox := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointBox');
  stbtt_GetCodepointHMetrics := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointHMetrics');
  stbtt_GetCodepointKernAdvance := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointKernAdvance');
  stbtt_GetCodepointSDF := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointSDF');
  stbtt_GetCodepointShape := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointShape');
  stbtt_GetCodepointSVG := GetProcAddress(aDLLHandle, 'stbtt_GetCodepointSVG');
  stbtt_GetFontBoundingBox := GetProcAddress(aDLLHandle, 'stbtt_GetFontBoundingBox');
  stbtt_GetFontNameString := GetProcAddress(aDLLHandle, 'stbtt_GetFontNameString');
  stbtt_GetFontOffsetForIndex := GetProcAddress(aDLLHandle, 'stbtt_GetFontOffsetForIndex');
  stbtt_GetFontVMetrics := GetProcAddress(aDLLHandle, 'stbtt_GetFontVMetrics');
  stbtt_GetFontVMetricsOS2 := GetProcAddress(aDLLHandle, 'stbtt_GetFontVMetricsOS2');
  stbtt_GetGlyphBitmap := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphBitmap');
  stbtt_GetGlyphBitmapBox := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphBitmapBox');
  stbtt_GetGlyphBitmapBoxSubpixel := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphBitmapBoxSubpixel');
  stbtt_GetGlyphBitmapSubpixel := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphBitmapSubpixel');
  stbtt_GetGlyphBox := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphBox');
  stbtt_GetGlyphHMetrics := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphHMetrics');
  stbtt_GetGlyphKernAdvance := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphKernAdvance');
  stbtt_GetGlyphSDF := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphSDF');
  stbtt_GetGlyphShape := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphShape');
  stbtt_GetGlyphSVG := GetProcAddress(aDLLHandle, 'stbtt_GetGlyphSVG');
  stbtt_GetKerningTable := GetProcAddress(aDLLHandle, 'stbtt_GetKerningTable');
  stbtt_GetKerningTableLength := GetProcAddress(aDLLHandle, 'stbtt_GetKerningTableLength');
  stbtt_GetNumberOfFonts := GetProcAddress(aDLLHandle, 'stbtt_GetNumberOfFonts');
  stbtt_GetPackedQuad := GetProcAddress(aDLLHandle, 'stbtt_GetPackedQuad');
  stbtt_GetScaledFontVMetrics := GetProcAddress(aDLLHandle, 'stbtt_GetScaledFontVMetrics');
  stbtt_InitFont := GetProcAddress(aDLLHandle, 'stbtt_InitFont');
  stbtt_IsGlyphEmpty := GetProcAddress(aDLLHandle, 'stbtt_IsGlyphEmpty');
  stbtt_MakeCodepointBitmap := GetProcAddress(aDLLHandle, 'stbtt_MakeCodepointBitmap');
  stbtt_MakeCodepointBitmapSubpixel := GetProcAddress(aDLLHandle, 'stbtt_MakeCodepointBitmapSubpixel');
  stbtt_MakeCodepointBitmapSubpixelPrefilter := GetProcAddress(aDLLHandle, 'stbtt_MakeCodepointBitmapSubpixelPrefilter');
  stbtt_MakeGlyphBitmap := GetProcAddress(aDLLHandle, 'stbtt_MakeGlyphBitmap');
  stbtt_MakeGlyphBitmapSubpixel := GetProcAddress(aDLLHandle, 'stbtt_MakeGlyphBitmapSubpixel');
  stbtt_MakeGlyphBitmapSubpixelPrefilter := GetProcAddress(aDLLHandle, 'stbtt_MakeGlyphBitmapSubpixelPrefilter');
  stbtt_PackBegin := GetProcAddress(aDLLHandle, 'stbtt_PackBegin');
  stbtt_PackEnd := GetProcAddress(aDLLHandle, 'stbtt_PackEnd');
  stbtt_PackFontRange := GetProcAddress(aDLLHandle, 'stbtt_PackFontRange');
  stbtt_PackFontRanges := GetProcAddress(aDLLHandle, 'stbtt_PackFontRanges');
  stbtt_PackFontRangesGatherRects := GetProcAddress(aDLLHandle, 'stbtt_PackFontRangesGatherRects');
  stbtt_PackFontRangesPackRects := GetProcAddress(aDLLHandle, 'stbtt_PackFontRangesPackRects');
  stbtt_PackFontRangesRenderIntoRects := GetProcAddress(aDLLHandle, 'stbtt_PackFontRangesRenderIntoRects');
  stbtt_PackSetOversampling := GetProcAddress(aDLLHandle, 'stbtt_PackSetOversampling');
  stbtt_PackSetSkipMissingCodepoints := GetProcAddress(aDLLHandle, 'stbtt_PackSetSkipMissingCodepoints');
  stbtt_Rasterize := GetProcAddress(aDLLHandle, 'stbtt_Rasterize');
  stbtt_ScaleForMappingEmToPixels := GetProcAddress(aDLLHandle, 'stbtt_ScaleForMappingEmToPixels');
  stbtt_ScaleForPixelHeight := GetProcAddress(aDLLHandle, 'stbtt_ScaleForPixelHeight');
  unzClose := GetProcAddress(aDLLHandle, 'unzClose');
  unzCloseCurrentFile := GetProcAddress(aDLLHandle, 'unzCloseCurrentFile');
  unzGetCurrentFileInfo64 := GetProcAddress(aDLLHandle, 'unzGetCurrentFileInfo64');
  unzLocateFile := GetProcAddress(aDLLHandle, 'unzLocateFile');
  unzOpen64 := GetProcAddress(aDLLHandle, 'unzOpen64');
  unzOpenCurrentFilePassword := GetProcAddress(aDLLHandle, 'unzOpenCurrentFilePassword');
  unzReadCurrentFile := GetProcAddress(aDLLHandle, 'unzReadCurrentFile');
  unztell64 := GetProcAddress(aDLLHandle, 'unztell64');
  zipClose := GetProcAddress(aDLLHandle, 'zipClose');
  zipCloseFileInZip := GetProcAddress(aDLLHandle, 'zipCloseFileInZip');
  zipOpen64 := GetProcAddress(aDLLHandle, 'zipOpen64');
  zipOpenNewFileInZip3_64 := GetProcAddress(aDLLHandle, 'zipOpenNewFileInZip3_64');
  zipWriteInFileInZip := GetProcAddress(aDLLHandle, 'zipWriteInFileInZip');
end;

{ImFontGlyph}

function ImFontGlyph.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImFontGlyph.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImFontAtlasCustomRect}

function ImFontAtlasCustomRect.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImFontAtlasCustomRect.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiBoxSelectState}

function ImGuiBoxSelectState.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiBoxSelectState.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiDockNode}

function ImGuiDockNode.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiDockNode.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiStackLevelInfo}

function ImGuiStackLevelInfo.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiStackLevelInfo.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiContext}

function ImGuiContext.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiContext.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiWindow}

function ImGuiWindow.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiWindow.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiWindow}

function ImGuiWindow.GetData1Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data1 shr Offset) and Mask;
end;

procedure ImGuiWindow.SetData1Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data1 := (Data1 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiTableColumn}

function ImGuiTableColumn.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiTableColumn.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiTable}

function ImGuiTable.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiTable.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;

{ImGuiTableColumnSettings}

function ImGuiTableColumnSettings.GetData0Value(const AIndex: Integer): Cardinal;
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Result := (Data0 shr Offset) and Mask;
end;

procedure ImGuiTableColumnSettings.SetData0Value(const AIndex: Integer; const AValue: Cardinal);
var
  BitCount, Offset, Mask: Cardinal;
begin
  BitCount := AIndex and $FF;
  Offset := AIndex shr 8;
  Mask := ((1 shl BitCount) - 1);
  Data0 := (Data0 and (not (Mask shl Offset))) or (AValue shl Offset);
end;


{$ENDREGION}

{$REGION ' Pyro.Common '}
{ TPyVirtualBuffer }
procedure TPyVirtualBuffer.Clear();
begin
  if (Memory <> nil) then
  begin
    if not UnmapViewOfFile(Memory) then
      raise Exception.Create('Error deallocating mapped memory');
  end;

  if (FHandle <> 0) then
  begin
    if not CloseHandle(FHandle) then
      raise Exception.Create('Error freeing memory mapping handle');
  end;
end;

constructor TPyVirtualBuffer.Create(aSize: Cardinal);
var
  P: Pointer;
begin
  inherited Create;
  FName := TPath.GetGUIDFileName;
  FHandle := CreateFileMapping(INVALID_HANDLE_VALUE, nil, PAGE_READWRITE, 0, aSize, PChar(FName));
  if FHandle = 0 then
    begin
      Clear;
      raise Exception.Create('Error creating memory mapping');
      FHandle := 0;
    end
  else
    begin
      P := MapViewOfFile(FHandle, FILE_MAP_ALL_ACCESS, 0, 0, 0);
      if P = nil then
        begin
          Clear;
          raise Exception.Create('Error creating memory mapping');
        end
      else
        begin
          Self.SetPointer(P, aSize);
          Position := 0;
        end;
    end;
end;

destructor TPyVirtualBuffer.Destroy();
begin
  Clear;
  inherited;
end;

function TPyVirtualBuffer.Write(const aBuffer; aCount: Longint): Longint;
var
  LPos: Int64;
begin
  if (Position >= 0) and (aCount >= 0) then
  begin
    LPos := Position + aCount;
    if LPos > 0 then
    begin
      if LPos > Size then
      begin
        Result := 0;
        Exit;
      end;
      System.Move(aBuffer, (PByte(Memory) + Position)^, aCount);
      Position := LPos;
      Result := aCount;
      Exit;
    end;
  end;
  Result := 0;
end;

function TPyVirtualBuffer.Write(const aBuffer: TBytes; aOffset, aCount: Longint): Longint;
var
  LPos: Int64;
begin
  if (Position >= 0) and (aCount >= 0) then
  begin
    LPos := Position + aCount;
    if LPos > 0 then
    begin
      if LPos > Size then
      begin
        Result := 0;
        Exit;
      end;
      System.Move(aBuffer[aOffset], (PByte(Memory) + Position)^, aCount);
      Position := LPos;
      Result := aCount;
      Exit;
    end;
  end;
  Result := 0;
end;

procedure TPyVirtualBuffer.SaveToFile(aFilename: string);
var
  LStream: TFileStream;
begin
  LStream := TFile.Create(aFilename);
  try
    LStream.Write(Memory^, Size);
  finally
    LStream.Free;
  end;
end;

class function TPyVirtualBuffer.LoadFromFile(const aFilename: string): TPyVirtualBuffer;
var
  LStream: TStream;
  LBuffer: TPyVirtualBuffer;
begin
  Result := nil;
  if aFilename.IsEmpty then Exit;
  if not TFile.Exists(aFilename) then Exit;
  LStream := TFile.OpenRead(aFilename);
  try
    LBuffer := TPyVirtualBuffer.Create(LStream.Size);
    if LBuffer <> nil then
    begin
      LBuffer.CopyFrom(LStream);
    end;
  finally
    FreeAndNil(LStream);
  end;
  Result := LBuffer;
end;

function  TPyVirtualBuffer.Eob(): Boolean;
begin
  Result := Boolean(Position >= Size);
end;

function  TPyVirtualBuffer.ReadString(): string;
var
  LLength: LongInt;
begin
  Read(LLength, SizeOf(LLength));
  SetLength(Result, LLength);
  if LLength > 0 then Read(Result[1], LLength * SizeOf(Char));
end;

{ TPyRingBuffer }
constructor TPyRingBuffer<T>.Create(ACapacity: Integer);
begin
  SetLength(FBuffer, ACapacity);
  FReadIndex := 0;
  FWriteIndex := 0;
  FCapacity := ACapacity;
  Clear;
end;

function TPyRingBuffer<T>.Write(const AData: array of T; ACount: Integer): Integer;
var
  i, WritePos: Integer;
begin
  PyUtils.EnterCriticalSection();
  try
    for i := 0 to ACount - 1 do
    begin
      WritePos := (FWriteIndex + i) mod FCapacity;
      FBuffer[WritePos] := AData[i];
    end;
    FWriteIndex := (FWriteIndex + ACount) mod FCapacity;
    Result := ACount;
  finally
    PyUtils.LeaveCriticalSection();
  end;
end;

function TPyRingBuffer<T>.Read(var AData: array of T; ACount: Integer): Integer;
var
  i, ReadPos: Integer;
begin
  for i := 0 to ACount - 1 do
  begin
    ReadPos := (FReadIndex + i) mod FCapacity;
    AData[i] := FBuffer[ReadPos];
  end;
  FReadIndex := (FReadIndex + ACount) mod FCapacity;
  Result := ACount;
end;

function TPyRingBuffer<T>.DirectReadPointer(ACount: Integer): Pointer;
begin
  Result := @FBuffer[FReadIndex mod FCapacity];
  FReadIndex := (FReadIndex + ACount) mod FCapacity;
end;

function TPyRingBuffer<T>.AvailableBytes(): Integer;
begin
  Result := (FCapacity + FWriteIndex - FReadIndex) mod FCapacity;
end;

procedure TPyRingBuffer<T>.Clear();
var
  I: Integer;
begin

  PyUtils.EnterCriticalSection();
  try
    for I := Low(FBuffer) to High(FBuffer) do
    begin
     FBuffer[i] := Default(T);
    end;

    FReadIndex := 0;
    FWriteIndex := 0;
  finally
    PyUtils.LeaveCriticalSection();
  end;
end;

{ TPyVirtualRingBuffer }
function TPyVirtualRingBuffer<T>.GetArrayValue(AIndex: Integer): T;
begin
  Result := PType(PByte(FBuffer.Memory) + AIndex * SizeOf(T))^;
end;

procedure TPyVirtualRingBuffer<T>.SetArrayValue(AIndex: Integer; AValue: T);
begin
  PType(PByte(FBuffer.Memory) + AIndex * SizeOf(T))^ := AValue;
end;

constructor TPyVirtualRingBuffer<T>.Create(ACapacity: Integer);
begin
  FBuffer := TPyVirtualBuffer.Create(ACapacity*SizeOf(T));
  FReadIndex := 0;
  FWriteIndex := 0;
  FCapacity := ACapacity;
  Clear;
end;

destructor TPyVirtualRingBuffer<T>.Destroy;
begin
  FBuffer.Free;
  inherited;
end;

function TPyVirtualRingBuffer<T>.Write(const AData: array of T; ACount: Integer): Integer;
var
  i, WritePos: Integer;
begin
  PyUtils.EnterCriticalSection();
  try
    for i := 0 to ACount - 1 do
    begin
      WritePos := (FWriteIndex + i) mod FCapacity;
      SetArrayValue(WritePos, AData[i]);
    end;
    FWriteIndex := (FWriteIndex + ACount) mod FCapacity;
    Result := ACount;
  finally
    PyUtils.LeaveCriticalSection();
  end;
end;

function TPyVirtualRingBuffer<T>.Read(var AData: array of T; ACount: Integer): Integer;
var
  i, ReadPos: Integer;
begin
  for i := 0 to ACount - 1 do
  begin
    ReadPos := (FReadIndex + i) mod FCapacity;
    AData[i] := GetArrayValue(ReadPos);
  end;
  FReadIndex := (FReadIndex + ACount) mod FCapacity;
  Result := ACount;
end;

function TPyVirtualRingBuffer<T>.DirectReadPointer(ACount: Integer): Pointer;
begin
  Result := PType(PByte(FBuffer.Memory) + (FReadIndex mod FCapacity) * SizeOf(T));
  FReadIndex := (FReadIndex + ACount) mod FCapacity;
end;

function TPyVirtualRingBuffer<T>.AvailableBytes(): Integer;
begin
  Result := (FCapacity + FWriteIndex - FReadIndex) mod FCapacity;
end;

procedure TPyVirtualRingBuffer<T>.Clear();
var
  I: Integer;
begin

  PyUtils.EnterCriticalSection();
  try
    for I := 0 to FCapacity-1 do
    begin
     SetArrayValue(I, Default(T));
    end;

    FReadIndex := 0;
    FWriteIndex := 0;
  finally
    PyUtils.LeaveCriticalSection();
  end;
end;

{ TPyTimer }
class operator TPyTimer.Initialize (out ADest: TPyTimer);
begin
  ADest.FLastTime := 0;
  ADest.FInterval := 0;
  ADest.FSpeed := 0;
end;

procedure TPyTimer.InitMS(const AValue: Double);
begin
  FInterval := AValue / 1000.0; // convert milliseconds to seconds
  FLastTime := glfwGetTime;
  FSpeed := AValue;
end;

procedure TPyTimer.InitFPS(const AValue: Double);
begin
  if AValue > 0 then
    FInterval := 1.0 / AValue
  else
    FInterval := 0; // Prevent division by zero if FPS is not positive
  FLastTime := glfwGetTime;
  FSpeed := AValue;
end;

function TPyTimer.Check(): Boolean;
begin
  Result := (glfwGetTime - FLastTime) >= FInterval;
  if Result then
    FLastTime := glfwGetTime; // Auto-reset on check
end;

procedure TPyTimer.Reset();
begin
  FLastTime := glfwGetTime;
end;

function  TPyTimer.Speed(): Double;
begin
  Result := FSpeed;
end;

{ TPyBaseObject }
constructor TPyBaseObject.Create();
begin
  inherited;
end;

destructor TPyBaseObject.Destroy();
begin
  inherited;
end;

{ TPyAsyncThread }
constructor TPyAsyncThread.Create();
begin
  inherited Create(True);

  FTask := nil;
  FWait := nil;
  FFinished := False;
end;

destructor TPyAsyncThread.Destroy();
begin
  inherited;
end;

procedure TPyAsyncThread.Execute();
begin
  FFinished := False;

  if Assigned(FTask) then
  begin
    FTask();
  end;

  FFinished := True;
end;

{ TPyAsync }
constructor TPyAsync.Create();
begin
  inherited;

  FQueue := TList<TPyAsyncThread>.Create;
  FBusy := TDictionary<string, TBusyData>.Create;
end;

destructor TPyAsync.Destroy();
begin

  FBusy.Free();
  FQueue.Free();

  inherited;
end;

procedure TPyAsync.Clear();
begin
  WaitForAllToTerminate();
  FBusy.Clear();
  FQueue.Clear();
end;

procedure TPyAsync.Process();
var
  LAsyncThread: TPyAsyncThread;
  LAsyncThread2: TPyAsyncThread;
  LIndex: TBusyData;
  LBusy: TBusyData;
begin
  Enter();

  if TThread.CurrentThread.ThreadID = MainThreadID then
  begin
    for LAsyncThread in FQueue do
    begin
      if Assigned(LAsyncThread) then
      begin
        if LAsyncThread.Finished then
        begin
          LAsyncThread.WaitFor();
          if Assigned(LAsyncThread.WaitProc) then
            LAsyncThread.WaitProc();
          FQueue.Remove(LAsyncThread);
          for LIndex in FBusy.Values do
          begin
            if Lindex.Thread = LAsyncThread then
            begin
              LBusy := LIndex;
              LBusy.Flag := False;
              FBusy.AddOrSetValue(LBusy.Name, LBusy);
              Break;
            end;
          end;
          LAsyncThread2 := LAsyncThread;
          FreeAndNil(LAsyncThread2);
        end;
      end;
    end;
    FQueue.Pack;
  end;

  Leave();
end;

procedure TPyAsync.Exec(const AName: string; const ABackgroundTask: TPyAsyncProc; const AWaitForgroundTask: TPyAsyncProc);
var
  LAsyncThread: TPyAsyncThread;
  LBusy: TBusyData;
begin
  if not Assigned(ABackgroundTask) then Exit;
  if AName.IsEmpty then Exit;
  if Busy(AName) then Exit;
  Enter;
  LAsyncThread := TPyAsyncThread.Create;
  LAsyncThread.TaskProc := ABackgroundTask;
  LAsyncThread.WaitProc := AWaitForgroundTask;
  FQueue.Add(LAsyncThread);
  LBusy.Name := AName;
  LBusy.Thread := LAsyncThread;
  LBusy.Flag := True;
  LBusy.Terminate := False;
  FBusy.AddOrSetValue(AName, LBusy);
  LAsyncThread.Start;
  Leave;
end;

function  TPyAsync.Busy(const AName: string): Boolean;
var
  LBusy: TBusyData;
begin
  Result := False;
  if AName.IsEmpty then Exit;
  Enter;
  FBusy.TryGetValue(AName, LBusy);
  Leave;
  Result := LBusy.Flag;
end;

procedure TPyAsync.SetTerminate(const AName: string; const ATerminate: Boolean);
var
  LBusy: TBusyData;
begin
  if AName.IsEmpty then Exit;
  Enter();
  FBusy.TryGetValue(AName, LBusy);
  LBusy.Terminate := ATerminate;
  FBusy.AddOrSetValue(AName, LBusy);
  Leave();
end;

function  TPyAsync.ShouldTerminate(const AName: string): Boolean;
var
  LBusy: TBusyData;
begin
  Result := False;
  if AName.IsEmpty then Exit;
  Enter();
  FBusy.TryGetValue(AName, LBusy);
  Result := LBusy.Terminate;
  Leave();
end;

procedure TPyAsync.TerminateAll();
var
  LBusy: TPair<string, TBusyData>;
begin
  for LBusy in FBusy do
  begin
    SetTerminate(LBusy.Key, True);
  end;
end;

procedure TPyAsync.WaitForAllToTerminate();
var
  LDone: Boolean;
begin
  TerminateAll();
  Resume();
  LDone := False;
  while not LDone do
  begin
    if FQueue.Count = 0 then
      Break;
    Process();
    Sleep(0);
  end;
end;

procedure TPyAsync.Suspend();
var
  LAsyncThread: TPyAsyncThread;
begin
  for LAsyncThread in FQueue do
  begin
    if not LAsyncThread.Suspended then
      LAsyncThread.Suspend;
  end;
end;

procedure TPyAsync.Resume();
var
  LAsyncThread: TPyAsyncThread;
begin
  for LAsyncThread in FQueue do
  begin
    if LAsyncThread.Suspended then
      LAsyncThread.Resume;
  end;
end;

procedure TPyAsync.Enter();
begin
  PyUtils.EnterCriticalSection();
end;

procedure TPyAsync.Leave();
begin
  PyUtils.LeaveCriticalSection();
end;

{$ENDREGION}

{$REGION ' Pyro.Utils '}
{ PyUtils }
class procedure PyUtils.UnitInit();
begin
  // force constructor call
end;

class constructor PyUtils.Create();
begin
  FCriticalSection := TCriticalSection.Create();
  FAsync := TPyAsync.Create();
end;

class destructor PyUtils.Destroy();
begin
  FAsync.Free();
  FCriticalSection.Free();
end;

class function  PyUtils.UnitToScalarValue(const aValue, aMaxValue: Double): Double;
var
  LGain: Double;
  LFactor: Double;
  LVolume: Double;
begin
  LGain := (EnsureRange(aValue, 0.0, 1.0) * 50) - 50;
  LFactor := Power(10, LGain * 0.05);
  LVolume := EnsureRange(aMaxValue * LFactor, 0, aMaxValue);
  Result := LVolume;
end;

class procedure PyUtils.FreeNilObject(const [ref] AObject: TObject);
var
  LTemp: TObject;
begin
  if not Assigned(AObject) then Exit;
  try
    FCriticalSection.Enter;
    LTemp := AObject;
    TObject(Pointer(@AObject)^) := nil;
    LTemp.Free;
  finally
    FCriticalSection.Leave;
  end;
end;

class function PyUtils.SampleTimeToPosition(SampleRate: Integer; TimeInSeconds: Double; Channels: Integer; SampleSizeInBits: Integer): Int64;
begin
  Result := Round(SampleRate * TimeInSeconds * Channels * (SampleSizeInBits div 8));
end;

class function PyUtils.FloatToSmallInt(Value: Single): SmallInt;
begin
  Result := Round(EnsureRange(Value, -1.0, 1.0) * 32767);
end;

class procedure PyUtils.ClearKeyboardBuffer();
var
  inputRecord: TInputRecord;
  eventsRead: DWORD;
begin
  // Flush the keyboard buffer by reading all pending input events
  while PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), inputRecord, 1,
    eventsRead) and (eventsRead > 0) do
  begin
    ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE), inputRecord, 1,
      eventsRead);
    // Optionally, you can process the input events if needed
  end;
end;

class function PyUtils.WasRunFromConsole() : Boolean;
var
  SI: TStartupInfo;
begin
  SI.cb := SizeOf(TStartupInfo);
  GetStartupInfo(SI);
  Result := ((SI.dwFlags and STARTF_USESHOWWINDOW) = 0);
end;

class function PyUtils.IsStartedFromDelphiIDE: Boolean;
begin
  // Check if the IDE environment variable is present
  Result := (GetEnvironmentVariable('BDS') <> '');
end;

class function  PyUtils.GetTempStaticBuffer(): PByte;
begin
  Result := @TempStaticBuffer[0];
end;

class function  PyUtils.GetTempStaticBufferSize(): Integer;
begin
  Result := CTempStaticBufferSize;
end;

class procedure PyUtils.EnterCriticalSection();
begin
  FCriticalSection.Enter;
end;

class procedure PyUtils.LeaveCriticalSection();
begin
  FCriticalSection.Leave;
end;

class function PyUtils.EnableVirtualTerminalProcessing(): DWORD;
var
  HOut: THandle;
  LMode: DWORD;
begin
  HOut := GetStdHandle(STD_OUTPUT_HANDLE);
  if HOut = INVALID_HANDLE_VALUE then
  begin
    Result := GetLastError;
    Exit;
  end;

  if not GetConsoleMode(HOut, LMode) then
  begin
    Result := GetLastError;
    Exit;
  end;

  LMode := LMode or ENABLE_VIRTUAL_TERMINAL_PROCESSING;
  if not SetConsoleMode(HOut, LMode) then
  begin
    Result := GetLastError;
    Exit;
  end;

  Result := 0;  // Success
end;

class function PyUtils.HasConsoleOutput: Boolean;
var
  Stdout: THandle;
begin
  Stdout := GetStdHandle(Std_Output_Handle);
  Win32Check(Stdout <> Invalid_Handle_Value);
  Result := Stdout <> 0;
end;

class function PyUtils.IsValidWin64PE(const AFilePath: string): Boolean;
var
  LFile: TFileStream;
  LDosHeader: TImageDosHeader;
  LPEHeaderOffset: DWORD;
  LPEHeaderSignature: DWORD;
  LFileHeader: TImageFileHeader;
begin
  Result := False;

  if not FileExists(AFilePath) then
    Exit;

  LFile := TFileStream.Create(AFilePath, fmOpenRead or fmShareDenyWrite);
  try
    // Check if file is large enough for DOS header
    if LFile.Size < SizeOf(TImageDosHeader) then
      Exit;

    // Read DOS header
    LFile.ReadBuffer(LDosHeader, SizeOf(TImageDosHeader));

    // Check DOS signature
    if LDosHeader.e_magic <> IMAGE_DOS_SIGNATURE then // 'MZ'
      Exit;

      // Validate PE header offset
    LPEHeaderOffset := LDosHeader._lfanew;
    if LFile.Size < LPEHeaderOffset + SizeOf(DWORD) + SizeOf(TImageFileHeader) then
      Exit;

    // Seek to the PE header
    LFile.Position := LPEHeaderOffset;

    // Read and validate the PE signature
    LFile.ReadBuffer(LPEHeaderSignature, SizeOf(DWORD));
    if LPEHeaderSignature <> IMAGE_NT_SIGNATURE then // 'PE\0\0'
      Exit;

   // Read the file header
    LFile.ReadBuffer(LFileHeader, SizeOf(TImageFileHeader));

    // Check if it is a 64-bit executable
    if LFileHeader.Machine <> IMAGE_FILE_MACHINE_AMD64 then   Exit;

    // If all checks pass, it's a valid Win64 PE file
    Result := True;
  finally
    LFile.Free;
  end;
end;

class function PyUtils.AddResFromMemory(const aModuleFile: string; const aName: string; aData: Pointer; aSize: Cardinal): Boolean;
var
  LHandle: THandle;
begin
  Result := False;
  if not TFile.Exists(aModuleFile) then Exit;
  LHandle := WinApi.Windows.BeginUpdateResourceW(PWideChar(aModuleFile), False);
  if LHandle <> 0 then
  begin
    WinApi.Windows.UpdateResourceW(LHandle, RT_RCDATA, PChar(aName), 1033 {ENGLISH, ENGLISH_US}, aData, aSize);
    Result := WinApi.Windows.EndUpdateResourceW(LHandle, False);
  end;
end;

class function PyUtils.ResourceExists(aInstance: THandle; const aResName: string): Boolean;
begin
  Result := Boolean((FindResource(aInstance, PChar(aResName), RT_RCDATA) <> 0));
end;

class function PyUtils.RemoveBOM(const AString: string): string;
const
  UTF8BOM: array[0..2] of Byte = ($EF, $BB, $BF);
var
  LBytes: TBytes;
begin
  // Convert the input string to a byte array
  LBytes := TEncoding.UTF8.GetBytes(AString);

  // Check for UTF-8 BOM at the beginning
  if (Length(LBytes) >= 3) and
     (LBytes[0] = UTF8BOM[0]) and
     (LBytes[1] = UTF8BOM[1]) and
     (LBytes[2] = UTF8BOM[2]) then
  begin
    // Remove the BOM by copying the bytes after it
    Result := TEncoding.UTF8.GetString(LBytes, 3, Length(LBytes) - 3);
  end
  else
  begin
    // Return the original string if no BOM is detected
    Result := AString;
  end;
end;

class function PyUtils.RemoveBOM(const ABytes: TBytes): TBytes;
const
  UTF8BOM: array[0..2] of Byte = ($EF, $BB, $BF);
  UTF16LEBOM: array[0..1] of Byte = ($FF, $FE);
  UTF16BEBOM: array[0..1] of Byte = ($FE, $FF);
var
  LStartIndex: Integer;
begin
  Result := ABytes;

  // Check for UTF-8 BOM
  if (Length(ABytes) >= 3) and
     (ABytes[0] = UTF8BOM[0]) and
     (ABytes[1] = UTF8BOM[1]) and
     (ABytes[2] = UTF8BOM[2]) then
  begin
    LStartIndex := 3; // Skip the UTF-8 BOM
  end
  // Check for UTF-16 LE BOM
  else if (Length(ABytes) >= 2) and
          (ABytes[0] = UTF16LEBOM[0]) and
          (ABytes[1] = UTF16LEBOM[1]) then
  begin
    LStartIndex := 2; // Skip the UTF-16 LE BOM
  end
  // Check for UTF-16 BE BOM
  else if (Length(ABytes) >= 2) and
          (ABytes[0] = UTF16BEBOM[0]) and
          (ABytes[1] = UTF16BEBOM[1]) then
  begin
    LStartIndex := 2; // Skip the UTF-16 BE BOM
  end
  else
  begin
    Exit; // No BOM found, return the original array
  end;

  // Create a new array without the BOM
  Result := Copy(ABytes, LStartIndex, Length(ABytes) - LStartIndex);
end;

class function PyUtils.AsUTF8(const AText: string; const AArgs: array of const; const AUseArgs: Boolean; const ARemoveBOM: Boolean): Pointer;
var
  LText: string;
begin
  if ARemoveBOM then
    LText := RemoveBOM(AText)
  else
    LText := AText;

  if AUseArgs then
    LText := Format(LText, AArgs);
  Result := Marshaller.AsUtf8(LText).ToPointer;
end;

class procedure PyUtils.UpdateIconResource(const AExeFilePath, AIconFilePath: string);
type
  TIconDir = packed record
    idReserved: Word;  // Reserved, must be 0
    idType: Word;      // Resource type, 1 for icons
    idCount: Word;     // Number of images in the file
  end;
  PIconDir = ^TIconDir;

  TGroupIconDirEntry = packed record
    bWidth: Byte;            // Width of the icon (0 means 256)
    bHeight: Byte;           // Height of the icon (0 means 256)
    bColorCount: Byte;       // Number of colors in the palette (0 if more than 256)
    bReserved: Byte;         // Reserved, must be 0
    wPlanes: Word;           // Color planes
    wBitCount: Word;         // Bits per pixel
    dwBytesInRes: Cardinal;  // Size of the image data
    nID: Word;               // Resource ID of the icon
  end;

  TGroupIconDir = packed record
    idReserved: Word;  // Reserved, must be 0
    idType: Word;      // Resource type, 1 for icons
    idCount: Word;     // Number of images in the file
    Entries: array[0..0] of TGroupIconDirEntry; // Variable-length array
  end;

  TIconResInfo = packed record
    bWidth: Byte;            // Width of the icon (0 means 256)
    bHeight: Byte;           // Height of the icon (0 means 256)
    bColorCount: Byte;       // Number of colors in the palette (0 if more than 256)
    bReserved: Byte;         // Reserved, must be 0
    wPlanes: Word;           // Color planes (should be 1)
    wBitCount: Word;         // Bits per pixel
    dwBytesInRes: Cardinal;  // Size of the image data
    dwImageOffset: Cardinal; // Offset of the image data in the file
  end;
  PIconResInfo = ^TIconResInfo;

var
  LUpdateHandle: THandle;
  LIconStream: TMemoryStream;
  LIconDir: PIconDir;
  LIconGroup: TMemoryStream;
  LIconRes: PByte;
  LIconID: Word;
  I: Integer;
  LGroupEntry: TGroupIconDirEntry;
begin

  if not FileExists(AExeFilePath) then
    raise Exception.Create('The specified executable file does not exist.');

  if not FileExists(AIconFilePath) then
    raise Exception.Create('The specified icon file does not exist.');

  LIconStream := TMemoryStream.Create;
  LIconGroup := TMemoryStream.Create;
  try
    // Load the icon file
    LIconStream.LoadFromFile(AIconFilePath);

    // Read the ICONDIR structure from the icon file
    LIconDir := PIconDir(LIconStream.Memory);
    if LIconDir^.idReserved <> 0 then
      raise Exception.Create('Invalid icon file format.');

    // Begin updating the executable's resources
    LUpdateHandle := BeginUpdateResource(PChar(AExeFilePath), False);
    if LUpdateHandle = 0 then
      raise Exception.Create('Failed to begin resource update.');

    try
      // Process each icon image in the .ico file
      LIconRes := PByte(LIconStream.Memory) + SizeOf(TIconDir);
      for I := 0 to LIconDir^.idCount - 1 do
      begin
        // Assign a unique resource ID for the RT_ICON
        LIconID := I + 1;

        // Add the icon image data as an RT_ICON resource
        if not UpdateResource(LUpdateHandle, RT_ICON, PChar(LIconID), LANG_NEUTRAL,
          Pointer(PByte(LIconStream.Memory) + PIconResInfo(LIconRes)^.dwImageOffset),
          PIconResInfo(LIconRes)^.dwBytesInRes) then
          raise Exception.CreateFmt('Failed to add RT_ICON resource for image %d.', [I]);

        // Move to the next icon entry
        Inc(LIconRes, SizeOf(TIconResInfo));
      end;

      // Create the GROUP_ICON resource
      LIconGroup.Clear;
      LIconGroup.Write(LIconDir^, SizeOf(TIconDir)); // Write ICONDIR header

      LIconRes := PByte(LIconStream.Memory) + SizeOf(TIconDir);
      // Write each GROUP_ICON entry
      for I := 0 to LIconDir^.idCount - 1 do
      begin
        // Populate the GROUP_ICON entry
        LGroupEntry.bWidth := PIconResInfo(LIconRes)^.bWidth;
        LGroupEntry.bHeight := PIconResInfo(LIconRes)^.bHeight;
        LGroupEntry.bColorCount := PIconResInfo(LIconRes)^.bColorCount;
        LGroupEntry.bReserved := 0;
        LGroupEntry.wPlanes := PIconResInfo(LIconRes)^.wPlanes;
        LGroupEntry.wBitCount := PIconResInfo(LIconRes)^.wBitCount;
        LGroupEntry.dwBytesInRes := PIconResInfo(LIconRes)^.dwBytesInRes;
        LGroupEntry.nID := I + 1; // Match resource ID for RT_ICON

        // Write the populated GROUP_ICON entry to the stream
        LIconGroup.Write(LGroupEntry, SizeOf(TGroupIconDirEntry));

        // Move to the next ICONDIRENTRY
        Inc(LIconRes, SizeOf(TIconResInfo));
      end;

      // Add the GROUP_ICON resource to the executable
      if not UpdateResource(LUpdateHandle, RT_GROUP_ICON, 'MAINICON', LANG_NEUTRAL,
        LIconGroup.Memory, LIconGroup.Size) then
        raise Exception.Create('Failed to add RT_GROUP_ICON resource.');

      // Commit the resource updates
      if not EndUpdateResource(LUpdateHandle, False) then
        raise Exception.Create('Failed to commit resource updates.');
    except
      EndUpdateResource(LUpdateHandle, True); // Discard changes on failure
      raise;
    end;
  finally
    LIconStream.Free;
    LIconGroup.Free;
  end;
end;

class procedure PyUtils.UpdateVersionInfoResource(const PEFilePath: string; const AMajor, AMinor, APatch: Word; const AProductName, ADescription, AFilename, ACompanyName, ACopyright: string);
type
  { TVSFixedFileInfo }
  TVSFixedFileInfo = packed record
    dwSignature: DWORD;        // e.g. $FEEF04BD
    dwStrucVersion: DWORD;     // e.g. $00010000 for version 1.0
    dwFileVersionMS: DWORD;    // e.g. $00030075 for version 3.75
    dwFileVersionLS: DWORD;    // e.g. $00000031 for version 0.31
    dwProductVersionMS: DWORD; // Same format as dwFileVersionMS
    dwProductVersionLS: DWORD; // Same format as dwFileVersionLS
    dwFileFlagsMask: DWORD;    // = $3F for version "0011 1111"
    dwFileFlags: DWORD;        // e.g. VFF_DEBUG | VFF_PRERELEASE
    dwFileOS: DWORD;           // e.g. VOS_NT_WINDOWS32
    dwFileType: DWORD;         // e.g. VFT_APP
    dwFileSubtype: DWORD;      // e.g. VFT2_UNKNOWN
    dwFileDateMS: DWORD;       // file date
    dwFileDateLS: DWORD;       // file date
  end;

  { TStringPair }
  TStringPair = record
    Key: string;
    Value: string;
  end;

var
  LHandleUpdate: THandle;
  LVersionInfoStream: TMemoryStream;
  LFixedInfo: TVSFixedFileInfo;
  LDataPtr: Pointer;
  LDataSize: Integer;
  LStringFileInfoStart, LStringTableStart, LVarFileInfoStart: Int64;
  LStringPairs: array of TStringPair;
  LVErsion: string;
  LMajor, LMinor,LPatch: Word;
  LVSVersionInfoStart: Int64;
  LPair: TStringPair;
  LStringInfoEnd, LStringStart: Int64;
  LStringEnd, LFinalPos: Int64;
  LTranslationStart: Int64;

  procedure AlignStream(const AStream: TMemoryStream; const AAlignment: Integer);
  var
    LPadding: Integer;
    LPadByte: Byte;
  begin
    LPadding := (AAlignment - (AStream.Position mod AAlignment)) mod AAlignment;
    LPadByte := 0;
    while LPadding > 0 do
    begin
      AStream.WriteBuffer(LPadByte, 1);
      Dec(LPadding);
    end;
  end;

  procedure WriteWideString(const AStream: TMemoryStream; const AText: string);
  var
    LWideText: WideString;
  begin
    LWideText := WideString(AText);
    AStream.WriteBuffer(PWideChar(LWideText)^, (Length(LWideText) + 1) * SizeOf(WideChar));
  end;

  procedure SetFileVersionFromString(const AVersion: string; out AFileVersionMS, AFileVersionLS: DWORD);
  var
    LVersionParts: TArray<string>;
    LMajor, LMinor, LBuild, LRevision: Word;
  begin
    // Split the version string into its components
    LVersionParts := AVersion.Split(['.']);
    if Length(LVersionParts) <> 4 then
      raise Exception.Create('Invalid version string format. Expected "Major.Minor.Build.Revision".');

    // Parse each part into a Word
    LMajor := StrToIntDef(LVersionParts[0], 0);
    LMinor := StrToIntDef(LVersionParts[1], 0);
    LBuild := StrToIntDef(LVersionParts[2], 0);
    LRevision := StrToIntDef(LVersionParts[3], 0);

    // Set the high and low DWORD values
    AFileVersionMS := (DWORD(LMajor) shl 16) or DWORD(LMinor);
    AFileVersionLS := (DWORD(LBuild) shl 16) or DWORD(LRevision);
  end;

begin
  LMajor := EnsureRange(AMajor, 0, MaxWord);
  LMinor := EnsureRange(AMinor, 0, MaxWord);
  LPatch := EnsureRange(APatch, 0, MaxWord);
  LVersion := Format('%d.%d.%d.0', [LMajor, LMinor, LPatch]);

  SetLength(LStringPairs, 8);
  LStringPairs[0].Key := 'CompanyName';
  LStringPairs[0].Value := ACompanyName;
  LStringPairs[1].Key := 'FileDescription';
  LStringPairs[1].Value := ADescription;
  LStringPairs[2].Key := 'FileVersion';
  LStringPairs[2].Value := LVersion;
  LStringPairs[3].Key := 'InternalName';
  LStringPairs[3].Value := ADescription;
  LStringPairs[4].Key := 'LegalCopyright';
  LStringPairs[4].Value := ACopyright;
  LStringPairs[5].Key := 'OriginalFilename';
  LStringPairs[5].Value := AFilename;
  LStringPairs[6].Key := 'ProductName';
  LStringPairs[6].Value := AProductName;
  LStringPairs[7].Key := 'ProductVersion';
  LStringPairs[7].Value := LVersion;

  // Initialize fixed info structure
  FillChar(LFixedInfo, SizeOf(LFixedInfo), 0);
  LFixedInfo.dwSignature := $FEEF04BD;
  LFixedInfo.dwStrucVersion := $00010000;
  LFixedInfo.dwFileVersionMS := $00010000;
  LFixedInfo.dwFileVersionLS := $00000000;
  LFixedInfo.dwProductVersionMS := $00010000;
  LFixedInfo.dwProductVersionLS := $00000000;
  LFixedInfo.dwFileFlagsMask := $3F;
  LFixedInfo.dwFileFlags := 0;
  LFixedInfo.dwFileOS := VOS_NT_WINDOWS32;
  LFixedInfo.dwFileType := VFT_APP;
  LFixedInfo.dwFileSubtype := 0;
  LFixedInfo.dwFileDateMS := 0;
  LFixedInfo.dwFileDateLS := 0;

  // SEt MS and LS for FileVersion and ProductVersion
  SetFileVersionFromString(LVersion, LFixedInfo.dwFileVersionMS, LFixedInfo.dwFileVersionLS);
  SetFileVersionFromString(LVersion, LFixedInfo.dwProductVersionMS, LFixedInfo.dwProductVersionLS);

  LVersionInfoStream := TMemoryStream.Create;
  try
    // VS_VERSION_INFO
    LVSVersionInfoStart := LVersionInfoStream.Position;

    LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
    LVersionInfoStream.WriteData<Word>(SizeOf(TVSFixedFileInfo));  // Value length
    LVersionInfoStream.WriteData<Word>(0);  // Type = 0
    WriteWideString(LVersionInfoStream, 'VS_VERSION_INFO');
    AlignStream(LVersionInfoStream, 4);

    // VS_FIXEDFILEINFO
    LVersionInfoStream.WriteBuffer(LFixedInfo, SizeOf(TVSFixedFileInfo));
    AlignStream(LVersionInfoStream, 4);

    // StringFileInfo
    LStringFileInfoStart := LVersionInfoStream.Position;
    LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
    LVersionInfoStream.WriteData<Word>(0);  // Value length = 0
    LVersionInfoStream.WriteData<Word>(1);  // Type = 1
    WriteWideString(LVersionInfoStream, 'StringFileInfo');
    AlignStream(LVersionInfoStream, 4);

    // StringTable
    LStringTableStart := LVersionInfoStream.Position;
    LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
    LVersionInfoStream.WriteData<Word>(0);  // Value length = 0
    LVersionInfoStream.WriteData<Word>(1);  // Type = 1
    WriteWideString(LVersionInfoStream, '040904B0'); // Match Delphi's default code page
    AlignStream(LVersionInfoStream, 4);

    // Write string pairs
    for LPair in LStringPairs do
    begin
      LStringStart := LVersionInfoStream.Position;

      LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
      LVersionInfoStream.WriteData<Word>((Length(LPair.Value) + 1) * 2);  // Value length
      LVersionInfoStream.WriteData<Word>(1);  // Type = 1
      WriteWideString(LVersionInfoStream, LPair.Key);
      AlignStream(LVersionInfoStream, 4);
      WriteWideString(LVersionInfoStream, LPair.Value);
      AlignStream(LVersionInfoStream, 4);

      LStringEnd := LVersionInfoStream.Position;
      LVersionInfoStream.Position := LStringStart;
      LVersionInfoStream.WriteData<Word>(LStringEnd - LStringStart);
      LVersionInfoStream.Position := LStringEnd;
    end;

    LStringInfoEnd := LVersionInfoStream.Position;

    // Write StringTable length
    LVersionInfoStream.Position := LStringTableStart;
    LVersionInfoStream.WriteData<Word>(LStringInfoEnd - LStringTableStart);

    // Write StringFileInfo length
    LVersionInfoStream.Position := LStringFileInfoStart;
    LVersionInfoStream.WriteData<Word>(LStringInfoEnd - LStringFileInfoStart);

    // Start VarFileInfo where StringFileInfo ended
    LVarFileInfoStart := LStringInfoEnd;
    LVersionInfoStream.Position := LVarFileInfoStart;

    // VarFileInfo header
    LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
    LVersionInfoStream.WriteData<Word>(0);  // Value length = 0
    LVersionInfoStream.WriteData<Word>(1);  // Type = 1 (text)
    WriteWideString(LVersionInfoStream, 'VarFileInfo');
    AlignStream(LVersionInfoStream, 4);

    // Translation value block
    LTranslationStart := LVersionInfoStream.Position;
    LVersionInfoStream.WriteData<Word>(0);  // Length placeholder
    LVersionInfoStream.WriteData<Word>(4);  // Value length = 4 (size of translation value)
    LVersionInfoStream.WriteData<Word>(0);  // Type = 0 (binary)
    WriteWideString(LVersionInfoStream, 'Translation');
    AlignStream(LVersionInfoStream, 4);

    // Write translation value
    LVersionInfoStream.WriteData<Word>($0409);  // Language ID (US English)
    LVersionInfoStream.WriteData<Word>($04B0);  // Unicode code page

    LFinalPos := LVersionInfoStream.Position;

    // Update VarFileInfo block length
    LVersionInfoStream.Position := LVarFileInfoStart;
    LVersionInfoStream.WriteData<Word>(LFinalPos - LVarFileInfoStart);

    // Update translation block length
    LVersionInfoStream.Position := LTranslationStart;
    LVersionInfoStream.WriteData<Word>(LFinalPos - LTranslationStart);

    // Update total version info length
    LVersionInfoStream.Position := LVSVersionInfoStart;
    LVersionInfoStream.WriteData<Word>(LFinalPos);

    LDataPtr := LVersionInfoStream.Memory;
    LDataSize := LVersionInfoStream.Size;

    // Update the resource
    LHandleUpdate := BeginUpdateResource(PChar(PEFilePath), False);
    if LHandleUpdate = 0 then
      RaiseLastOSError;

    try
      if not UpdateResourceW(LHandleUpdate, RT_VERSION, MAKEINTRESOURCE(1),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), LDataPtr, LDataSize) then
        RaiseLastOSError;

      if not EndUpdateResource(LHandleUpdate, False) then
        RaiseLastOSError;
    except
      EndUpdateResource(LHandleUpdate, True);
      raise;
    end;
  finally
    LVersionInfoStream.Free;
  end;
end;

class function PyUtils.HasEnoughDiskSpace(const APath: string; ARequiredSpace: Int64): Boolean;
var
  LFreeAvailable, LTotalSpace, LTotalFree: Int64;
  LDrive: string;
begin
  Result := False;

  // Resolve the absolute path in case of a relative path
  LDrive := ExtractFileDrive(TPath.GetFullPath(APath));

  // If there is no drive letter, use the current drive
  if LDrive = '' then
    LDrive := ExtractFileDrive(TDirectory.GetCurrentDirectory);

  // Ensure drive has a trailing backslash
  if LDrive <> '' then
    LDrive := LDrive + '\';

  if GetDiskFreeSpaceEx(PChar(LDrive), LFreeAvailable, LTotalSpace, @LTotalFree) then
    Result := LFreeAvailable >= ARequiredSpace;
end;

class function PyUtils.RemoveDuplicates(const aText: string): string;
var
  i, l: integer;
begin
  Result := '';
  l := Length(aText);
  for i := 1 to l do
  begin
    if (Pos(aText[i], result) = 0) then
    begin
      result := result + aText[i];
    end;
  end;
end;

class procedure PyUtils.ProcessMessages();
var
  LMsg: TMsg;
begin
  while Integer(PeekMessage(LMsg, 0, 0, 0, PM_REMOVE)) <> 0 do
  begin
    TranslateMessage(LMsg);
    DispatchMessage(LMsg);
  end;
end;

class procedure PyUtils.Wait(const AMilliseconds: Double);
var
  LFrequency, LStartCount, LCurrentCount: Int64;
  LElapsedTime: Double;
begin
  // Get the high-precision frequency of the system's performance counter
  QueryPerformanceFrequency(LFrequency);

  // Get the starting value of the performance counter
  QueryPerformanceCounter(LStartCount);

  // Convert milliseconds to seconds for precision timing
  repeat
    QueryPerformanceCounter(LCurrentCount);
    LElapsedTime := (LCurrentCount - LStartCount) / LFrequency * 1000.0; // Convert to milliseconds
  until LElapsedTime >= AMilliseconds;
end;

class function  PyUtils.HudTextItem(const AKey: string; const AValue: string; const APaddingWidth: Cardinal; const ASeperator: string): string;
begin
  Result := Format('%s %s %s', [aKey.PadRight(APaddingWidth), aSeperator, aValue]);
end;

class procedure PyUtils.AsyncProcess();
begin
  FAsync.Process();
end;

class procedure PyUtils.AsyncClear();
begin
  FAsync.Clear();
end;

class procedure PyUtils.AsyncRun(const AName: string; const ABackgroundTask: TPyAsyncProc; const AWaitForgroundTask: TPyAsyncProc);
begin
  FAsync.Exec(AName, ABackgroundTask, AWaitForgroundTask);
end;

class function  PyUtils.AsyncIsBusy(const AName: string): Boolean;
begin
  Result := FAsync.Busy(AName);
end;

class procedure PyUtils.AsyncSetTerminate(const AName: string; const ATerminate: Boolean);
begin
  FAsync.SetTerminate(AName, ATerminate);
end;

class function  PyUtils.AsyncShouldTerminate(const AName: string): Boolean;
begin
  Result := FAsync.ShouldTerminate(AName);
end;

class procedure PyUtils.AsyncTerminateAll();
begin
  FAsync.TerminateAll();
end;

class procedure PyUtils.AsyncWaitForAllToTerminate();
begin
  FAsync.WaitForAllToTerminate();
end;

class procedure PyUtils.AsyncSuspend();
begin
  FAsync.Suspend();
end;

class procedure PyUtils.AsyncResume();
begin
  FAsync.Resume();
end;

{$ENDREGION}

{$REGION ' Pyro.Error '}
// Callback function for GLFW errors
procedure ErrorCallback(AErrorCode: Integer; const ADescription: PUTF8Char); cdecl;
begin
  PyError.SetError('GLFW Error %d: %s', [AErrorCode, string(ADescription)]);
end;

{ PyError }
class constructor PyError.Create();
begin
  FError := '';
end;

class destructor PyError.Destroy();
begin
end;

class procedure PyError.UnitInit();
begin
  glfwSetErrorCallback(ErrorCallback);
end;

class procedure PyError.SetError(const AText: string; const AArgs: array of const);
begin
  FError := Format('%s', AArgs);
end;

class function PyError.GetError(): string;
begin
  Result := FError;
end;

{$ENDREGION}

{$REGION ' Pyro.Math '}
{ PyMath }
class constructor PyMath.Create();
var
  I: Integer;
begin
  // init sin/cos tables
  for I := 0 to 360 do
  begin
    FCosTable[I] := cos((I * PI / 180.0));
    FSinTable[I] := sin((I * PI / 180.0));
  end;
end;

class destructor PyMath.Destroy();
begin
end;

class procedure PyMath.UnitInit();
begin
end;

class function PyMath.Point(const X, Y: Single): TPyPoint;
begin
  Result.x := X;
  Result.y := Y;
end;

class function PyMath.Vector(const X, Y: Single): TPyVector;
begin
  Result.x := X;
  Result.y := Y;
  Result.z := 0;
  Result.w := 0;
end;

class function PyMath.Size(const W, H: Single): TPySize;
begin
  Result.w := W;
  Result.h := H;
end;

class function PyMath.Rect(const X, Y, W, H: Single): TPyRect;
begin
  Result.pos.x := X;
  Result.pos.y := Y;
  Result.size.w := W;
  Result.size.h := H;
end;

class function PyMath.Extent(const AMinX, AMinY, AMaxX, AMaxY: Single): TPyExtent;
begin
  Result.min.x := AMinX;
  Result.min.y := AMinY;

  Result.max.x := AMaxX;
  Result.max.y := AMaxY;
end;

class procedure PyMath.AssignVector(var A: TPyVector; const B: TPyVector);
begin
  A := B;
end;

class procedure PyMath.ClearVector(var A: TPyVector);
begin
  A := Default(TPyVector);
end;

class procedure PyMath.AddVector(var A: TPyVector; const B: TPyVector);
begin
  A.x := A.x + B.x;
  A.y := A.y + B.y;
end;

class procedure PyMath.SubVector(var A: TPyVector; const B: TPyVector);
begin
  A.x := A.x - B.x;
  A.y := A.y - B.y;
end;

class procedure PyMath.MulVector(var A: TPyVector; const B: TPyVector);
begin
  A.x := A.x * B.x;
  A.y := A.y * B.y;
end;

class procedure PyMath.DivideVector(var A: TPyVector; const B: TPyVector);
begin
  A.x := A.x / B.x;
  A.y := A.y / B.y;
end;

class procedure PyMath.DivideVictor(var A: TPyVector; const AValue: Single);
begin
begin
  A.x := A.x / AValue;
  A.y := A.y / AValue;
end;
end;

class function  PyMath.VectorMagnitude(const A: TPyVector): Single;
begin
  Result := Sqrt((A.x * A.x) + (A.y * A.y));
end;

class function  PyMath.VectorMagnitudeTruncate(const A: TPyVector; const AMaxMagnitude: Single): TPyVector;
var
  LMaxMagSqrd: Single;
  LVecMagSqrd: Single;
  LTruc: Single;
begin
  Result := Default(TPyVector);
  Result.x := A.x;
  Result.y := A.y;

  LMaxMagSqrd := AMaxMagnitude * AMaxMagnitude;
  LVecMagSqrd := VectorMagnitude(Result);
  if LVecMagSqrd > LMaxMagSqrd then
  begin
    LTruc := (AMaxMagnitude / Sqrt(LVecMagSqrd));
    Result.x := Result.x * LTruc;
    Result.y := Result.y * LTruc;
  end;
end;

class function  PyMath.VectorDistance(const A, B: TPyVector): Single;
var
  LDirVec: TPyVector;
begin
  LDirVec.x := A.x - B.x;
  LDirVec.y := A.y - B.y;
  Result := VectorMagnitude(LDirVec);
end;

class procedure PyMath.NormalizeVector(var A: TPyVector);
var
  LLen, LOOL: Single;
begin
  LLen := VectorMagnitude(A);
  if LLen <> 0 then
  begin
    LOOL := 1.0 / LLen;
    A.x := A.x * LOOL;
    A.y := A.y * LOOL;
  end;
end;

class function  PyMath.VectorAngle(const A, B: TPyVector): Single;
var
  LXOY: Single;
  LR: TPyVector;
begin
  AssignVector(LR, A);
  SubVector(LR, B);
  NormalizeVector(LR);

  if LR.y = 0 then
  begin
    LR.y := 0.001;
  end;

  LXOY := LR.x / LR.y;

  Result := ArcTan(LXOY) * PyRADTODEG;
  if LR.y < 0 then
    Result := Result + 180.0;
end;


class procedure PyMath.ThrustVector(var A: TPyVector; const AAngle, ASpeed: Single);
var
  LA: Single;
begin
  LA := AAngle + 90.0;
  ClipValuef(LA, 0, 360, True);

  A.x := A.x + AngleCos(Round(LA)) * -(aSpeed);
  A.y := A.y + AngleSin(Round(LA)) * -(aSpeed);
end;

class function  PyMath.VectorMagnitudeSquared(const A: TPyVector): Single;
begin
  Result := (A.x * A.x) + (A.y * A.y);
end;

class function  PyMath.VectorDotProduct(const A, B: TPyVector): Single;
begin
  Result := (A.x * B.x) + (A.y * B.y);
end;

class procedure PyMath.ScaleVectory(var A: TPyVector; const AValue: Single);
begin
  A.x := A.x * AValue;
  A.y := A.y * AValue;
end;

class function  PyMath.ProjectVector(const A, B: TPyVector): TPyVector;
var
  LDP: Single;
begin
  LDP :=  VectorDotProduct(A, B);
  Result.x := (LDP / (B.x * B.x + B.y * B.y)) * B.x;
  Result.y := (LDP / (B.x * B.x + B.y * B.y)) * B.y;
end;

class procedure PyMath.NegateVector(var A: TPyVector);
begin
  A.x := -A.x;
  A.y := -A.y;
end;

class function  PyMath.UnitToScalarValue(const AValue, AMaxValue: Double): Double;
var
  LGain: Double;
  LFactor: Double;
  LVolume: Double;
begin
  LGain := (EnsureRange(AValue, 0.0, 1.0) * 50) - 50;
  LFactor := Power(10, LGain * 0.05);
  LVolume := EnsureRange(AMaxValue * LFactor, 0, AMaxValue);
  Result := LVolume;
end;

class function PyMath.AngleCos(const AAngle: Cardinal): Single;
var
  LAngle: Cardinal;
begin
  LAngle := EnsureRange(AAngle, 0, 360);
  Result := FCosTable[LAngle];
end;

class function PyMath.AngleSin(const AAngle: Cardinal): Single;
var
  LAngle: Cardinal;
begin
  LAngle := EnsureRange(AAngle, 0, 360);
  Result := FSinTable[LAngle];
end;

function _RandomRange(const aFrom, aTo: Integer): Integer;
var
  LFrom: Integer;
  LTo: Integer;
begin
  LFrom := aFrom;
  LTo := aTo;

  if AFrom > ATo then
    Result := Random(LFrom - LTo) + ATo
  else
    Result := Random(LTo - LFrom) + AFrom;
end;

class function  PyMath.RandomRange(const AMin, AMax: Integer): Integer;
begin
  Result := _RandomRange(AMin, AMax + 1);
end;

class function  PyMath.RandomRangef(const AMin, AMax: Single): Single;
var
  LNum: Single;
begin
  LNum := _RandomRange(0, MaxInt) / MaxInt;
  Result := AMin + (LNum * (AMax - AMin));
end;

class function  PyMath.RandomBool(): Boolean;
begin
  Result := Boolean(_RandomRange(0, 2) = 1);
end;

class function  PyMath.GetRandomSeed(): Integer;
begin
  Result := System.RandSeed;
end;

class procedure PyMath.SetRandomSeed(const AVaLue: Integer);
begin
  System.RandSeed := AVaLue;
end;

class function  PyMath.ClipVaLuef(var AVaLue: Single; const AMin, AMax: Single; const AWrap: Boolean): Single;
begin
  if AWrap then
    begin
      if (AVaLue > AMax) then
      begin
        AVaLue := AMin + Abs(AVaLue - AMax);
        if AVaLue > AMax then
          AVaLue := AMax;
      end
      else if (AVaLue < AMin) then
      begin
        AVaLue := AMax - Abs(AVaLue - AMin);
        if AVaLue < AMin then
          AVaLue := AMin;
      end
    end
  else
    begin
      if AVaLue < AMin then
        AVaLue := AMin
      else if AVaLue > AMax then
        AVaLue := AMax;
    end;

  Result := AVaLue;
end;

class function  PyMath.ClipVaLue(var AVaLue: Integer; const aMin, AMax: Integer; const AWrap: Boolean): Integer;
begin
  if AWrap then
    begin
      if (AVaLue > AMax) then
      begin
        AVaLue := aMin + Abs(AVaLue - AMax);
        if AVaLue > AMax then
          AVaLue := AMax;
      end
      else if (AVaLue < aMin) then
      begin
        AVaLue := AMax - Abs(AVaLue - aMin);
        if AVaLue < aMin then
          AVaLue := aMin;
      end
    end
  else
    begin
      if AVaLue < aMin then
        AVaLue := aMin
      else if AVaLue > AMax then
        AVaLue := AMax;
    end;

  Result := AVaLue;
end;

class function  PyMath.SameSign(const AVaLue1, AVaLue2: Integer): Boolean;
begin
  if Sign(AVaLue1) = Sign(AVaLue2) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.SameSignf(const AVaLue1, AVaLue2: Single): Boolean;
begin
  if System.Math.Sign(AVaLue1) = System.Math.Sign(AVaLue2) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.SameValue(const AA, AB: Double; const AEpsilon: Double = 0): Boolean;
begin
  Result := System.Math.SameVaLue(AA, AB, AEpsilon);
end;

class function  PyMath.SameVaLuef(const AA, AB: Single; const AEpsilon: Single = 0): Boolean;
begin
  Result := System.Math.SameVaLue(AA, AB, AEpsilon);
end;

class function  PyMath.AngleDiff(const ASrcAngle, ADestAngle: Single): Single;
var
  LAngleDiff: Single;
begin
  LAngleDiff := ADestAngle-ASrcAngle-(Floor((ADestAngle-ASrcAngle)/360.0)*360.0);

  if LAngleDiff >= (360.0 / 2) then
  begin
    LAngleDiff := LAngleDiff - 360.0;
  end;
  Result := LAngleDiff;
end;

class procedure PyMath.AngleRotatePos(const AAngle: Single; var AX, AY: Single);
var
  LNX,LNY: Single;
  LIA: Integer;
  LAngle: Single;
begin
  LAngle := EnsureRange(AAngle, 0, 360);

  LIA := Round(LAngle);

  LNX := AX*FCosTable[LIA] - AY*FSinTable[LIA];
  LNY := AY*FCosTable[LIA] + AX*FSinTable[LIA];

  AX := LNX;
  AY := LNY;
end;

class procedure PyMath.SmoothMove(var AVaLue: Single; const AAmount, AMax, ADrag: Single);
var
  LAmt: Single;
begin
  LAmt := AAmount;

  if LAmt > 0 then
  begin
    AVaLue := AVaLue + LAmt;
    if AVaLue > AMax then
      AVaLue := AMax;
  end else if LAmt < 0 then
  begin
    AVaLue := AVaLue + LAmt;
    if AVaLue < -AMax then
      AVaLue := -AMax;
  end else
  begin
    if AVaLue > 0 then
    begin
      AVaLue := AVaLue - ADrag;
      if AVaLue < 0 then
        AVaLue := 0;
    end else if AVaLue < 0 then
    begin
      AVaLue := AVaLue + ADrag;
      if AVaLue > 0 then
        AVaLue := 0;
    end;
  end;
end;

class function  PyMath.Lerp(const AFrom, ATo, ATime: Double): Double;
begin
  if ATime <= 0.5 then
    Result := AFrom + (ATo - AFrom) * ATime
  else
    Result := ATo - (ATo - AFrom) * (1.0 - ATime);
end;

class function  PyMath.PointInRectangle(APoint: TPyVector; ARect: TPyRect): Boolean;
begin
  if ((APoint.x >= ARect.pos.x) and (APoint.x <= (ARect.pos.x + ARect.size.w)) and
    (APoint.y >= ARect.pos.y) and (APoint.y <= (ARect.pos.y + ARect.size.h))) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.PointInCircle(APoint, ACenter: TPyVector; ARadius: Single): Boolean;
begin
  Result := CirclesOverlap(APoint, 0, ACenter, ARadius);
end;

class function  PyMath.PointInTriangle(APoint, AP1, AP2, AP3: TPyVector): Boolean;
var
  LAlpha, LBeta, LGamma: Single;
begin
  LAlpha := ((AP2.y - AP3.y) * (APoint.x - AP3.x) + (AP3.x - AP2.x) *
    (APoint.y - AP3.y)) / ((AP2.y - AP3.y) * (AP1.x - AP3.x) + (AP3.x - AP2.x) *
    (AP1.y - AP3.y));

  LBeta := ((AP3.y - AP1.y) * (APoint.x - AP3.x) + (AP1.x - AP3.x) *
    (APoint.y - AP3.y)) / ((AP2.y - AP3.y) * (AP1.x - AP3.x) + (AP3.x - AP2.x) *
    (AP1.y - AP3.y));

  LGamma := 1.0 - LAlpha - LBeta;

  if ((LAlpha > 0) and (LBeta > 0) and (LGamma > 0)) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.CirclesOverlap(ACenter1: TPyVector; ARadius1: Single; ACenter2: TPyVector; ARadius2: Single): Boolean;
var
  LDX, LDY, LDistance: Single;
begin
  LDX := ACenter2.x - ACenter1.x; // X distance between centers
  LDY := ACenter2.y - ACenter1.y; // Y distance between centers

  LDistance := sqrt(LDX * LDX + LDY * LDY); // Distance between centers

  if (LDistance <= (ARadius1 + ARadius2)) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.CircleInRectangle(ACenter: TPyVector; ARadius: Single; ARect: TPyRect): Boolean;
var
  LDX, LDY: Single;
  LCornerDistanceSq: Single;
  LRecCenterX: Integer;
  LRecCenterY: Integer;
begin
  LRecCenterX := Round(ARect.pos.x + ARect.size.w / 2);
  LRecCenterY := Round(ARect.pos.y + ARect.size.h / 2);

  LDX := abs(ACenter.x - LRecCenterX);
  LDY := abs(ACenter.y - LRecCenterY);

  if (LDX > (ARect.size.w / 2.0 + ARadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDY > (ARect.size.h / 2.0 + ARadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDX <= (ARect.size.w / 2.0)) then
  begin
    Result := True;
    Exit;
  end;
  if (LDY <= (ARect.size.h / 2.0)) then
  begin
    Result := True;
    Exit;
  end;

  LCornerDistanceSq := (LDX - ARect.size.w / 2.0) * (LDX - ARect.size.w / 2.0) +
    (LDY - ARect.size.h / 2.0) * (LDY - ARect.size.h / 2.0);

  Result := Boolean(LCornerDistanceSq <= (ARadius * ARadius));
end;

class function  PyMath.RectanglesOverlap(ARect1: TPyRect; ARect2: TPyRect): Boolean;
var
  LDX, LDY: Single;
begin
  LDX := abs((ARect1.pos.x + ARect1.size.w / 2) - (ARect2.pos.x + ARect2.size.w / 2));
  LDY := abs((ARect1.pos.y + ARect1.size.h / 2) - (ARect2.pos.y + ARect2.size.h / 2));

  if ((LDX <= (ARect1.size.w / 2 + ARect2.size.w / 2)) and
    ((LDY <= (ARect1.size.h / 2 + ARect2.size.h / 2)))) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.RectangleIntersection(ARect1, ARect2: TPyRect): TPyRect;
var
  LDXX, LDYY: Single;
begin
  Result := Rect(0, 0, 0, 0);

  if RectanglesOverlap(ARect1, ARect2) then
  begin
    LDXX := abs(ARect1.pos.x - ARect2.pos.x);
    LDYY := abs(ARect1.pos.y - ARect2.pos.y);

    if (ARect1.pos.x <= ARect2.pos.x) then
    begin
      if (ARect1.pos.y <= ARect2.pos.y) then
      begin
        Result.pos.x := ARect2.pos.x;
        Result.pos.y := ARect2.pos.y;
        Result.size.w := ARect1.size.w - LDXX;
        Result.size.h := ARect1.size.h - LDYY;
      end
      else
      begin
        Result.pos.x := ARect2.pos.x;
        Result.pos.y := ARect1.pos.y;
        Result.size.w := ARect1.size.w - LDXX;
        Result.size.h := ARect2.size.h - LDYY;
      end
    end
    else
    begin
      if (ARect1.pos.y <= ARect2.pos.y) then
      begin
        Result.pos.x := ARect1.pos.x;
        Result.pos.y := ARect2.pos.y;
        Result.size.w := ARect2.size.w - LDXX;
        Result.size.h := ARect1.size.h - LDYY;
      end
      else
      begin
        Result.pos.x := ARect1.pos.x;
        Result.pos.y := ARect1.pos.y;
        Result.size.w := ARect2.size.w - LDXX;
        Result.size.h := ARect2.size.h - LDYY;
      end
    end;

    if (ARect1.size.w > ARect2.size.w) then
    begin
      if (Result.size.w >= ARect2.size.w) then
        Result.size.w := ARect2.size.w;
    end
    else
    begin
      if (Result.size.w >= ARect1.size.w) then
        Result.size.w := ARect1.size.w;
    end;

    if (ARect1.size.h > ARect2.size.h) then
    begin
      if (Result.size.h >= ARect2.size.h) then
        Result.size.h := ARect2.size.h;
    end
    else
    begin
      if (Result.size.h >= ARect1.size.h) then
        Result.size.h := ARect1.size.h;
    end
  end;
end;

class function  PyMath.LineIntersection(AX1, AY1, AX2, AY2, AX3, AY3, AX4, AY4: Integer; var AX: Integer; var AY: Integer): TPyLineIntersection;
var
  LAX, LBX, LCX, LAY, LBY, LCY, LD, LE, LF, LNum: Integer;
  LOffset: Integer;
  LX1Lo, LX1Hi, LY1Lo, LY1Hi: Integer;
begin
  Result := liNone;

  LAX := AX2 - AX1;
  LBX := AX3 - AX4;

  if (LAX < 0) then // X bound box test
  begin
    LX1Lo := AX2;
    LX1Hi := AX1;
  end
  else
  begin
    LX1Hi := AX2;
    LX1Lo := AX1;
  end;

  if (LBX > 0) then
  begin
    if (LX1Hi < AX4) or (AX3 < LX1Lo) then
      Exit;
  end
  else
  begin
    if (LX1Hi < AX3) or (AX4 < LX1Lo) then
      Exit;
  end;

  LAY := AY2 - AY1;
  LBY := AY3 - AY4;

  if (LAY < 0) then // Y bound box test
  begin
    LY1Lo := AY2;
    LY1Hi := AY1;
  end
  else
  begin
    LY1Hi := AY2;
    LY1Lo := AY1;
  end;

  if (LBY > 0) then
  begin
    if (LY1Hi < AY4) or (AY3 < LY1Lo) then
      Exit;
  end
  else
  begin
    if (LY1Hi < AY3) or (AY4 < LY1Lo) then
      Exit;
  end;

  LCX := AX1 - AX3;
  LCY := AY1 - AY3;
  LD := LBY * LCX - LBX * LCY; // alpha numerator
  LF := LAY * LBX - LAX * LBY; // both denominator

  if (LF > 0) then // alpha tests
  begin
    if (LD < 0) or (LD > LF) then
      Exit;
  end
  else
  begin
    if (LD > 0) or (LD < LF) then
      Exit
  end;

  LE := LAX * LCY - LAY * LCX; // beta numerator
  if (LF > 0) then // beta tests
  begin
    if (LE < 0) or (LE > LF) then
      Exit;
  end
  else
  begin
    if (LE > 0) or (LE < LF) then
      Exit;
  end;

  // compute intersection coordinates
  if (LF = 0) then
  begin
    Result := liParallel;
    Exit;
  end;

  LNum := LD * LAX; // numerator
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then

    LOffset := LF div 2
  else
    LOffset := -LF div 2;
  AX := AX1 + (LNum + LOffset) div LF; // intersection x

  LNum := LD * LAY;
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then
    LOffset := LF div 2
  else
    LOffset := -LF div 2;

  AY := AY1 + (LNum + LOffset) div LF; // intersection y

  Result := liTrue;
end;

class function  PyMath.RadiusOverlap(ARadius1, AX1, AY1, ARadius2, AX2, AY2, AShrinkFactor: Single): Boolean;
var
  LDist: Single;
  LR1, LR2: Single;
  LV1, LV2: TPyVector;
begin
  LR1 := ARadius1 * AShrinkFactor;
  LR2 := ARadius2 * AShrinkFactor;

  LV1.x := AX1;
  LV1.y := AY1;
  LV2.x := AX2;
  LV2.y := AY2;

  //LDist := LV1.distance(LV2);
  LDist := VectorDistance(LV1, LV2);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
    Result := False;
end;

class function  PyMath.EaseValue(ACurrentTime: Double; AStartValue: Double; AChangeInValue: Double; ADuration: Double; AEaseType: TPyEaseType): Double;
begin
  Result := 0;
  case AEaseType of
    etLinearTween:
      begin
        Result := AChangeInValue * ACurrentTime / ADuration + AStartValue;
      end;

    etInQuad:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := AChangeInValue * ACurrentTime * ACurrentTime + AStartValue;
      end;

    etOutQuad:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := -AChangeInValue * ACurrentTime * (ACurrentTime-2) + AStartValue;
      end;

    etInOutQuad:
      begin
        ACurrentTime := ACurrentTime / (ADuration / 2);
        if ACurrentTime < 1 then
          Result := AChangeInValue / 2 * ACurrentTime * ACurrentTime + AStartValue
        else
        begin
          ACurrentTime := ACurrentTime - 1;
          Result := -AChangeInValue / 2 * (ACurrentTime * (ACurrentTime - 2) - 1) + AStartValue;
        end;
      end;

    etInCubic:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := AChangeInValue * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue;
      end;

    etOutCubic:
      begin
        ACurrentTime := (ACurrentTime / ADuration) - 1;
        Result := AChangeInValue * ( ACurrentTime * ACurrentTime * ACurrentTime + 1) + AStartValue;
      end;

    etInOutCubic:
      begin
        ACurrentTime := ACurrentTime / (ADuration/2);
        if ACurrentTime < 1 then
          Result := AChangeInValue / 2 * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue
        else
        begin
          ACurrentTime := ACurrentTime - 2;
          Result := AChangeInValue / 2 * (ACurrentTime * ACurrentTime * ACurrentTime + 2) + AStartValue;
        end;
      end;

    etInQuart:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := AChangeInValue * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue;
      end;

    etOutQuart:
      begin
        ACurrentTime := (ACurrentTime / ADuration) - 1;
        Result := -AChangeInValue * (ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime - 1) + AStartValue;
      end;

    etInOutQuart:
      begin
        ACurrentTime := ACurrentTime / (ADuration / 2);
        if ACurrentTime < 1 then
          Result := AChangeInValue / 2 * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue
        else
        begin
          ACurrentTime := ACurrentTime - 2;
          Result := -AChangeInValue / 2 * (ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime - 2) + AStartValue;
        end;
      end;

    etInQuint:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := AChangeInValue * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue;
      end;

    etOutQuint:
      begin
        ACurrentTime := (ACurrentTime / ADuration) - 1;
        Result := AChangeInValue * (ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + 1) + AStartValue;
      end;

    etInOutQuint:
      begin
        ACurrentTime := ACurrentTime / (ADuration / 2);
        if ACurrentTime < 1 then
          Result := AChangeInValue / 2 * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + AStartValue
        else
        begin
          ACurrentTime := ACurrentTime - 2;
          Result := AChangeInValue / 2 * (ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime * ACurrentTime + 2) + AStartValue;
        end;
      end;

    etInSine:
      begin
        Result := -AChangeInValue * Cos(ACurrentTime / ADuration * (PI / 2)) + AChangeInValue + AStartValue;
      end;

    etOutSine:
      begin
        Result := AChangeInValue * Sin(ACurrentTime / ADuration * (PI / 2)) + AStartValue;
      end;

    etInOutSine:
      begin
        Result := -AChangeInValue / 2 * (Cos(PI * ACurrentTime / ADuration) - 1) + AStartValue;
      end;

    etInExpo:
      begin
        Result := AChangeInValue * Power(2, 10 * (ACurrentTime/ADuration - 1) ) + AStartValue;
      end;

    etOutExpo:
      begin
        Result := AChangeInValue * (-Power(2, -10 * ACurrentTime / ADuration ) + 1 ) + AStartValue;
      end;

    etInOutExpo:
      begin
        ACurrentTime := ACurrentTime / (ADuration/2);
        if ACurrentTime < 1 then
          Result := AChangeInValue / 2 * Power(2, 10 * (ACurrentTime - 1) ) + AStartValue
        else
         begin
           ACurrentTime := ACurrentTime - 1;
           Result := AChangeInValue / 2 * (-Power(2, -10 * ACurrentTime) + 2 ) + AStartValue;
         end;
      end;

    etInCircle:
      begin
        ACurrentTime := ACurrentTime / ADuration;
        Result := -AChangeInValue * (Sqrt(1 - ACurrentTime * ACurrentTime) - 1) + AStartValue;
      end;

    etOutCircle:
      begin
        ACurrentTime := (ACurrentTime / ADuration) - 1;
        Result := AChangeInValue * Sqrt(1 - ACurrentTime * ACurrentTime) + AStartValue;
      end;

    etInOutCircle:
      begin
        ACurrentTime := ACurrentTime / (ADuration / 2);
        if ACurrentTime < 1 then
          Result := -AChangeInValue / 2 * (Sqrt(1 - ACurrentTime * ACurrentTime) - 1) + AStartValue
        else
        begin
          ACurrentTime := ACurrentTime - 2;
          Result := AChangeInValue / 2 * (Sqrt(1 - ACurrentTime * ACurrentTime) + 1) + AStartValue;
        end;
      end;
  end;
end;

class function  PyMath.EasePosition(AStartPos: Double; AEndPos: Double; ACurrentPos: Double; AEaseType: TPyEaseType): Double;
var
  LT, LB, LC, LD: Double;
begin
  LC := AEndPos - AStartPos;
  LD := 100;
  LT := ACurrentPos;
  LB := AStartPos;
  Result := EaseValue(LT, LB, LC, LD, AEaseType);
  if Result > 100 then
    Result := 100;
end;

class function  PyMath.OBBIntersect(const AObbA, AObbB: TPyOBB): Boolean;
var
  LAxes: array[0..3] of TPyPoint;
  I: Integer;
  LProjA, LProjB: TPyPoint;

  function Dot(const A, B: TPyPoint): Single;
  begin
    Result := A.x * B.x + A.y * B.y;
  end;

  function Rotate(const V: TPyPoint; AAngle: Single): TPyPoint;
  var
    s, c: Single;
    LAngle: Cardinal;
  begin
    LAngle := Abs(Round(AAngle));
    s := PyMath.AngleSin(LAngle);
    c := PyMath.AngleCos(LAngle);
    Result.x := V.x * c - V.y * s;
    Result.y := V.x * s + V.y * c;
  end;

  function Project(const AObb: TPyOBB; const AAxis: TPyPoint): TPyPoint;
  var
    LCorners: array[0..3] of TPyPoint;
    I: Integer;
    LDot: Single;
  begin
    LCorners[0] := Rotate(PyMath.Point(AObb.Extents.x, AObb.Extents.y), AObb.Rotation);
    LCorners[1] := Rotate(PyMath.Point(-AObb.Extents.x, AObb.Extents.y), AObb.Rotation);
    LCorners[2] := Rotate(PyMath.Point(AObb.Extents.x, -AObb.Extents.y), AObb.Rotation);
    LCorners[3] := Rotate(PyMath.Point(-AObb.Extents.x, -AObb.Extents.y), AObb.Rotation);

    Result.x := Dot(AAxis, PyMath.Point(AObb.Center.x + LCorners[0].x, AObb.Center.y + LCorners[0].y));
    Result.y := Result.x;

    for I := 1 to 3 do
    begin
      LDot := Dot(AAxis, PyMath.Point(AObb.Center.x + LCorners[I].x, AObb.Center.y + LCorners[I].y));
      if LDot < Result.x then Result.x := LDot;
      if LDot > Result.y then Result.y := LDot;
    end;
  end;

begin
  LAxes[0] := Rotate(PyMath.Point(1, 0), AObbA.Rotation);
  LAxes[1] := Rotate(PyMath.Point(0, 1), AObbA.Rotation);
  LAxes[2] := Rotate(PyMath.Point(1, 0), AObbB.Rotation);
  LAxes[3] := Rotate(PyMath.Point(0, 1), AObbB.Rotation);

  for I := 0 to 3 do
  begin
    LProjA := Project(AObbA, LAxes[I]);
    LProjB := Project(AObbB, LAxes[I]);
    if (LProjA.y < LProjB.x) or (LProjB.y < LProjA.x) then Exit(False);
  end;

  Result := True;
end;

{$ENDREGION}

{$REGION ' Pyro.Console '}
{ PyConsole }
class constructor PyConsole.Create();
begin
  FTeletypeDelay := 0;

  // save current console codepage
  FInputCodePage := GetConsoleCP();
  FOutputCodePage := GetConsoleOutputCP();

  // set code page to UTF8
  SetConsoleCP(CP_UTF8);
  SetConsoleOutputCP(CP_UTF8);

  PyUtils.EnableVirtualTerminalProcessing();
end;

class destructor PyConsole.Destroy();
begin
  // restore code page
  SetConsoleCP(FInputCodePage);
  SetConsoleOutputCP(FOutputCodePage);
end;

class procedure PyConsole.UnitInit();
begin
end;

class procedure PyConsole.Print(const AMsg: string);
begin
  if not HasOutput() then Exit;
  Write(AMsg+PyCSIResetFormat);
end;

class procedure PyConsole.PrintLn(const AMsg: string);
begin
  if not HasOutput() then Exit;
  WriteLn(AMsg+PyCSIResetFormat);
end;

class procedure PyConsole.Print(const AMsg: string; const AArgs: array of const);
begin
  if not HasOutput() then Exit;
  Write(Format(AMsg, AArgs)+PyCSIResetFormat);
end;

class procedure PyConsole.PrintLn(const AMsg: string; const AArgs: array of const);
begin
  if not HasOutput() then Exit;
  WriteLn(Format(AMsg, AArgs)+PyCSIResetFormat);
end;

class procedure PyConsole.Print();
begin
  if not HasOutput() then Exit;
  Write(PyCSIResetFormat);
end;

class procedure PyConsole.PrintLn();
begin
  if not HasOutput() then Exit;
  WriteLn(PyCSIResetFormat);
end;

class procedure PyConsole.GetCursorPos(X, Y: PInteger);
var
  hConsole: THandle;
  BufferInfo: TConsoleScreenBufferInfo;
begin
  hConsole := GetStdHandle(STD_OUTPUT_HANDLE);
  if hConsole = INVALID_HANDLE_VALUE then
    Exit;

  if not GetConsoleScreenBufferInfo(hConsole, BufferInfo) then
    Exit;

  if Assigned(X) then
    X^ := BufferInfo.dwCursorPosition.X;
  if Assigned(Y) then
    Y^ := BufferInfo.dwCursorPosition.Y;
end;

class procedure PyConsole.SetCursorPos(const X, Y: Integer);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSICursorPos, [X, Y]));
end;

class procedure PyConsole.SetCursorVisible(const AVisible: Boolean);
var
  ConsoleInfo: TConsoleCursorInfo;
  ConsoleHandle: THandle;
begin
  ConsoleHandle := GetStdHandle(STD_OUTPUT_HANDLE);
  ConsoleInfo.dwSize := 25; // You can adjust cursor size if needed
  ConsoleInfo.bVisible := AVisible;
  SetConsoleCursorInfo(ConsoleHandle, ConsoleInfo);
end;

class procedure PyConsole.HideCursor();
begin
  if not HasOutput() then Exit;
  Write(PyCSIHideCursor);
end;

class procedure PyConsole.ShowCursor();
begin
  if not HasOutput() then Exit;
  Write(PyCSIShowCursor);
end;

class procedure PyConsole.SaveCursorPos();
begin
  if not HasOutput() then Exit;
  Write(PyCSISaveCursorPos);
end;

class procedure PyConsole.RestoreCursorPos();
begin
  if not HasOutput() then Exit;
  Write(PyCSIRestoreCursorPos);
end;

class procedure PyConsole.MoveCursorUp(const ALines: Integer);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSICursorUp, [ALines]));
end;

class procedure PyConsole.MoveCursorDown(const ALines: Integer);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSICursorDown, [ALines]));
end;

class procedure PyConsole.MoveCursorForward(const ACols: Integer);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSICursorForward, [ACols]));
end;

class procedure PyConsole.MoveCursorBack(const ACols: Integer);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSICursorBack, [ACols]));
end;

class procedure PyConsole.ClearScreen();
begin
  if not HasOutput() then Exit;
  Write(PyCSIClearScreen);
  SetCursorPos(0, 0);
end;

class procedure PyConsole.ClearLine();
begin
  if not HasOutput() then Exit;
  Write(PyCSIClearLine);
end;

class procedure PyConsole.ClearLineFromCursor(const AColor: string);
var
  LConsoleOutput: THandle;
  LConsoleInfo: TConsoleScreenBufferInfo;
  LNumCharsWritten: DWORD;
  LCoord: TCoord;
begin
  LConsoleOutput := GetStdHandle(STD_OUTPUT_HANDLE);

  if GetConsoleScreenBufferInfo(LConsoleOutput, LConsoleInfo) then
  begin
    LCoord.X := 0;
    LCoord.Y := LConsoleInfo.dwCursorPosition.Y;

    Print(AColor, []);
    FillConsoleOutputCharacter(LConsoleOutput, ' ', LConsoleInfo.dwSize.X
      - LConsoleInfo.dwCursorPosition.X, LCoord, LNumCharsWritten);
    SetConsoleCursorPosition(LConsoleOutput, LCoord);
  end;
end;

class procedure PyConsole.SetBoldText();
begin
  if not HasOutput() then Exit;
  Write(PyCSIBold);
end;

class procedure PyConsole.ResetTextFormat();
begin
  if not HasOutput() then Exit;
  Write(PyCSIResetFormat);
end;

class procedure PyConsole.SetForegroundColor(const AColor: string);
begin
  if not HasOutput() then Exit;
  Write(AColor);
end;

class procedure PyConsole.SetBackgroundColor(const AColor: string);
begin
  if not HasOutput() then Exit;
  Write(AColor);
end;

class procedure PyConsole.SetForegroundRGB(const ARed, AGreen, ABlue: Byte);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSIFGRGB, [ARed, AGreen, ABlue]));
end;

class procedure PyConsole.SetBackgroundRGB(const ARed, AGreen, ABlue: Byte);
begin
  if not HasOutput() then Exit;
  Write(Format(PyCSIBGRGB, [ARed, AGreen, ABlue]));
end;

class procedure PyConsole.GetSize(AWidth: PInteger; AHeight: PInteger);
var
  LConsoleInfo: TConsoleScreenBufferInfo;
begin
  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), LConsoleInfo);
  if Assigned(AWidth) then
    AWidth^ := LConsoleInfo.dwSize.X;

  if Assigned(AHeight) then
  AHeight^ := LConsoleInfo.dwSize.Y;
end;

class procedure PyConsole.SetTitle(const ATitle: string);
begin
  WinApi.Windows.SetConsoleTitle(PChar(ATitle));
end;

class function  PyConsole.GetTitle(): string;
const
  MAX_TITLE_LENGTH = 1024;
var
  LTitle: array[0..MAX_TITLE_LENGTH] of WideChar;
  LTitleLength: DWORD;
begin
  // Get the console title and store it in LTitle
  LTitleLength := GetConsoleTitleW(LTitle, MAX_TITLE_LENGTH);

  // If the title is retrieved, assign it to the result
  if LTitleLength > 0 then
    Result := string(LTitle)
  else
    Result := '';
end;

class function  PyConsole.HasOutput(): Boolean;
var
  LStdHandle: THandle;
begin
  LStdHandle := GetStdHandle(STD_OUTPUT_HANDLE);
  Result := (LStdHandle <> INVALID_HANDLE_VALUE) and
            (GetFileType(LStdHandle) = FILE_TYPE_CHAR);
end;

class function  PyConsole.WasRunFrom(): Boolean;
var
  LStartupInfo: TStartupInfo;
begin
  LStartupInfo.cb := SizeOf(TStartupInfo);
  GetStartupInfo(LStartupInfo);
  Result := ((LStartupInfo.dwFlags and STARTF_USESHOWWINDOW) = 0);
end;

class procedure PyConsole.WaitForAnyKey();
var
  LInputRec: TInputRecord;
  LNumRead: Cardinal;
  LOldMode: DWORD;
  LStdIn: THandle;
begin
  LStdIn := GetStdHandle(STD_INPUT_HANDLE);
  GetConsoleMode(LStdIn, LOldMode);
  SetConsoleMode(LStdIn, 0);
  repeat
    ReadConsoleInput(LStdIn, LInputRec, 1, LNumRead);
  until (LInputRec.EventType and KEY_EVENT <> 0) and
    LInputRec.Event.KeyEvent.bKeyDown;
  SetConsoleMode(LStdIn, LOldMode);
end;

class function  PyConsole.AnyKeyPressed(): Boolean;
var
  LNumberOfEvents     : DWORD;
  LBuffer             : TInputRecord;
  LNumberOfEventsRead : DWORD;
  LStdHandle           : THandle;
begin
  Result:=false;
  //get the console handle
  LStdHandle := GetStdHandle(STD_INPUT_HANDLE);
  LNumberOfEvents:=0;
  //get the number of events
  GetNumberOfConsoleInputEvents(LStdHandle,LNumberOfEvents);
  if LNumberOfEvents<> 0 then
  begin
    //retrieve the event
    PeekConsoleInput(LStdHandle,LBuffer,1,LNumberOfEventsRead);
    if LNumberOfEventsRead <> 0 then
    begin
      if LBuffer.EventType = KEY_EVENT then //is a Keyboard event?
      begin
        if LBuffer.Event.KeyEvent.bKeyDown then //the key was pressed?
          Result:=true
        else
          FlushConsoleInputBuffer(LStdHandle); //flush the buffer
      end
      else
      FlushConsoleInputBuffer(LStdHandle);//flush the buffer
    end;
  end;
end;

class procedure PyConsole.ClearKeyStates();
begin
  FillChar(FKeyState, SizeOf(FKeyState), 0);
  ClearKeyboardBuffer();
end;

class procedure PyConsole.ClearKeyboardBuffer();
var
  LInputRecord: TInputRecord;
  LEventsRead: DWORD;
  LMsg: TMsg;
begin
  while PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), LInputRecord, 1, LEventsRead) and (LEventsRead > 0) do
  begin
    ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE), LInputRecord, 1, LEventsRead);
  end;

  while PeekMessage(LMsg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE) do
  begin
    // No operation; just removing messages from the queue
  end;
end;

class function  PyConsole.IsKeyPressed(AKey: Byte): Boolean;
begin
  Result := (GetAsyncKeyState(AKey) and $8000) <> 0;
end;

class function  PyConsole.WasKeyReleased(AKey: Byte): Boolean;
begin
  Result := False;
  if IsKeyPressed(AKey) and (not FKeyState[1, AKey]) then
  begin
    FKeyState[1, AKey] := True;
    Result := True;
  end
  else if (not IsKeyPressed(AKey)) and (FKeyState[1, AKey]) then
  begin
    FKeyState[1, AKey] := False;
    Result := False;
  end;
end;

class function  PyConsole.WasKeyPressed(AKey: Byte): Boolean;
begin
  Result := False;
  if IsKeyPressed(AKey) and (not FKeyState[1, AKey]) then
  begin
    FKeyState[1, AKey] := True;
    Result := False;
  end
  else if (not IsKeyPressed(AKey)) and (FKeyState[1, AKey]) then
  begin
    FKeyState[1, AKey] := False;
    Result := True;
  end;
end;

class function  PyConsole.ReadKey(): WideChar;
var
  LInputRecord: TInputRecord;
  LEventsRead: DWORD;
begin
  repeat
    ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE), LInputRecord, 1, LEventsRead);
  until (LInputRecord.EventType = KEY_EVENT) and LInputRecord.Event.KeyEvent.bKeyDown;
  Result := LInputRecord.Event.KeyEvent.UnicodeChar;
end;

class function  PyConsole.ReadLnX(const AAllowedChars: TPyCharSet; AMaxLength: Integer; const AColor: string): string;
var
  LInputChar: Char;
begin
  Result := '';

  repeat
    LInputChar := ReadKey;

    if CharInSet(LInputChar, AAllowedChars) then
    begin
      if Length(Result) < AMaxLength then
      begin
        if not CharInSet(LInputChar, [#10, #0, #13, #8])  then
        begin
          //Print(LInputChar, AColor);
          Print('%s%s', [AColor, LInputChar]);
          Result := Result + LInputChar;
        end;
      end;
    end;
    if LInputChar = #8 then
    begin
      if Length(Result) > 0 then
      begin
        //Print(#8 + ' ' + #8);
        Print(#8 + ' ' + #8, []);
        Delete(Result, Length(Result), 1);
      end;
    end;
  until (LInputChar = #13);

  PrintLn();
end;

class procedure PyConsole.Pause(const AForcePause: Boolean; AColor: string; const AMsg: string);
var
  LDoPause: Boolean;
begin
  if not HasOutput then Exit;

  ClearKeyboardBuffer();

  if not AForcePause then
  begin
    LDoPause := True;
    if WasRunFrom() then LDoPause := False;
    if PyUtils.IsStartedFromDelphiIDE() then LDoPause := True;
    if not LDoPause then Exit;
  end;

  WriteLn;
  if AMsg = '' then
    Print('%sPress any key to continue... ', [aColor])
  else
    Print('%s%s', [aColor, AMsg]);

  WaitForAnyKey();
  WriteLn;
end;

class function  PyConsole.WrapTextEx(const ALine: string; AMaxCol: Integer; const ABreakChars: TPyCharSet): string;
var
  LText: string;
  LPos: integer;
  LChar: Char;
  LLen: Integer;
  I: Integer;
begin
  LText := ALine.Trim;

  LPos := 0;
  LLen := 0;

  while LPos < LText.Length do
  begin
    Inc(LPos);

    LChar := LText[LPos];

    if LChar = #10 then
    begin
      LLen := 0;
      continue;
    end;

    Inc(LLen);

    if LLen >= AMaxCol then
    begin
      for I := LPos downto 1 do
      begin
        LChar := LText[I];

        if CharInSet(LChar, ABreakChars) then
        begin
          LText.Insert(I, #10);
          Break;
        end;
      end;

      LLen := 0;
    end;
  end;

  Result := LText;
end;

class procedure PyConsole.Teletype(const AText: string; const AColor: string; const AMargin: Integer; const AMinDelay: Integer; const AMaxDelay: Integer; const ABreakKey: Byte);
var
  LText: string;
  LMaxCol: Integer;
  LChar: Char;
  LWidth: Integer;
begin
  GetSize(@LWidth, nil);
  LMaxCol := LWidth - AMargin;

  LText := WrapTextEx(AText, LMaxCol);

  for LChar in LText do
  begin
    PyUtils.ProcessMessages();
    Print('%s%s', [AColor, LChar]);
    if not PyMath.RandomBool() then
      FTeletypeDelay := PyMath.RandomRange(AMinDelay, AMaxDelay);
    PyUtils.Wait(FTeletypeDelay);
    if IsKeyPressed(ABreakKey) then
    begin
      ClearKeyboardBuffer;
      Break;
    end;
  end;
end;

{$ENDREGION}

{$REGION ' Pyro.Lua '}
{ compatibility }
function lua_istable(L: Plua_State; N: Integer): Boolean;
begin
  Result := lua_type(L, N) = LUA_TTABLE;
end;

function lua_isfunction(aState: Pointer; n: Integer): Boolean;
begin
  Result := Boolean(lua_type(aState, n) = LUA_TFUNCTION);
end;

function lua_isvariable(aState: Pointer; n: Integer): Boolean;
var
  aType: Integer;
begin
  aType := lua_type(aState, n);

  if (aType = LUA_TBOOLEAN) or (aType = LUA_TLIGHTUSERDATA) or (aType = LUA_TNUMBER) or (aType = LUA_TSTRING) then
    Result := True
  else
    Result := False;
end;

procedure lua_newtable(aState: Pointer);
begin
  lua_createtable(aState, 0, 0);
end;

procedure lua_pop(aState: Pointer; n: Integer);
begin
  lua_settop(aState, -n - 1);
end;

function lua_getglobal(L: Plua_State; const AName: PAnsiChar): Integer;
begin
  // Get the value directly from the globals table
  lua_getfield(L, LUA_GLOBALSINDEX, AName);

  // Return the type of the value
  Result := lua_type(L, -1);
end;

procedure lua_setglobal(aState: Pointer; aName: PAnsiChar);
begin
  lua_setfield(aState, LUA_GLOBALSINDEX, aName);
end;

procedure lua_pushcfunction(aState: Pointer; aFunc: lua_CFunction);
begin
  lua_pushcclosure(aState, aFunc, 0);
end;

function lua_isnil(aState: Pointer; n: Integer): Boolean;
begin
  Result := Boolean(lua_type(aState, n) = LUA_TNIL);
end;

function lua_tostring(aState: Pointer; idx: Integer): string;
begin
  Result := string(lua_tolstring(aState, idx, nil));
end;

function luaL_dofile(aState: Pointer; aFilename: PAnsiChar): Integer;
Var
  Res: Integer;
begin
  Res := luaL_loadfile(aState, aFilename);
  if Res = 0 then
    Res := lua_pcall(aState, 0, 0, 0);
  Result := Res;
end;

function luaL_dostring(aState: Pointer; aStr: PAnsiChar): Integer;
Var
  Res: Integer;
begin
  Res := luaL_loadstring(aState, aStr);
  if Res = 0 then
    Res := lua_pcall(aState, 0, 0, 0);
  Result := Res;
end;

function luaL_dobuffer(aState: Pointer; aBuffer: Pointer; aSize: NativeUInt;
  aName: PAnsiChar): Integer;
var
  Res: Integer;
begin
  Res := luaL_loadbuffer(aState, aBuffer, aSize, aName);
  if Res = 0 then
    Res := lua_pcall(aState, 0, 0, 0);
  Result := Res;
end;

function lua_upvalueindex(i: Integer): Integer;
begin
  Result := LUA_GLOBALSINDEX - i;
end;

function luaL_checkstring(L: Plua_State; n: Integer): PAnsiChar;
begin
  Result := luaL_checklstring(L, n, nil);
end;

procedure luaL_requiref(L: Plua_State; modname: PAnsiChar; openf: lua_CFunction; glb: Integer);
begin
  lua_pushcfunction(L, openf);  // Push the module loader function
  lua_pushstring(L, modname);   // Push module name as argument

  // Use pcall instead of call for error handling
  if lua_pcall(L, 1, 1, 0) <> 0 then
  begin
    // Get error message and raise
    raise EPyLuaException.CreateFmt('Error loading module "%s": %s',
      [modname, string(lua_tostring(L, -1))]);
  end;

  // Get _LOADED table from registry
  lua_getfield(L, LUA_REGISTRYINDEX, '_LOADED');
  if not lua_istable(L, -1) then
  begin
    lua_pop(L, 2);  // Pop module and non-table value
    raise EPyLuaException.Create('_LOADED is not a table');
  end;

  // Store module in _LOADED[modname]
  lua_pushvalue(L, -2);        // Copy the module
  lua_setfield(L, -2, modname);
  lua_pop(L, 1);              // Pop _LOADED table

  // If global is requested, set it
  if glb <> 0 then
  begin
    lua_pushvalue(L, -1);     // Copy the module again
    lua_setglobal(L, modname);
  end;
end;

function luaL_getmetatable(L: Plua_State; const ATableName: PAnsiChar): Boolean;
begin
  // Get the metatable directly from the registry
  lua_getfield(L, LUA_REGISTRYINDEX, ATableName);

  // Check if the field exists and is a table
  Result := lua_type(L, -1) = LUA_TTABLE;
  if not Result then
    lua_pop(L, 1); // Remove the nil value from the stack if not found
end;

procedure lua_updateargs(L: Plua_State; StartIndex: Integer);
var
  I: Integer;
begin
  // Delete the existing 'arg' table by assigning nil to it
  lua_pushnil(L);
  lua_setglobal(L, 'arg');

  // Create a new 'arg' table
  lua_newtable(L);

  // Populate the 'arg' table starting from StartIndex
  for I := StartIndex to ParamCount do
  begin
    lua_pushstring(L, PAnsiChar(UTF8Encode(ParamStr(I)))); // Push each argument as UTF-8 string
    lua_rawseti(L, -2, I - StartIndex);                    // Set table index (starting from 0)
  end;

  // Assign the new table to the global 'arg'
  lua_setglobal(L, 'arg');
end;

{$HINTS OFF}
function LuaPanic(L: Plua_State): Integer; cdecl;
begin
  // Get the error message from the Lua stack
  if LongBool(lua_isstring(L, -1)) then
    raise EPyLuaException.Create('Lua panic: ' + string(lua_tostring(L, -1)))
  else
    raise EPyLuaException.Create('Lua panic occurred without error message.');

  // Return value to conform to the Lua API; this will not be executed
  Result := 0;
end;
{$HINTS ON}

const
  DEBUGGER_LUA =
'''
--[[---------------------------------------------------------------------------
Acknowledgment:
   This code is based on the original debugger.lua project by
   slembcke, available at:
     https://github.com/slembcke/debugger.lua
   Credit goes to the original developer for their foundational work, which
   this unit builds upon.
-----------------------------------------------------------------------------]]

local dbg = {}

-- ANSI Colors
local COLOR_GRAY = string.char(27) .. "[90m"
local COLOR_RED = string.char(27) .. "[91m"
local COLOR_BLUE = string.char(27) .. "[94m"
local COLOR_YELLOW = string.char(27) .. "[33m"
local COLOR_RESET = string.char(27) .. "[0m"
local GREEN_CARET = string.char(27) .. "[92m => " .. COLOR_RESET

-- Check for Windows
local function is_windows()
    return package.config:sub(1,1) == '\\'
end

-- Check if colors are supported
local function supports_colors()
    if is_windows() then
        -- Windows 10+ supports ANSI colors
        local version = os.getenv("WINVER") or os.getenv("VERSION")
        return version ~= nil
    else
        -- Unix-like systems
        return os.getenv("TERM") and os.getenv("TERM") ~= "dumb"
    end
end

-- Disable colors if terminal doesn't support them
if not supports_colors then
    COLOR_GRAY = ""
    COLOR_RED = ""
    COLOR_BLUE = ""
    COLOR_YELLOW = ""
    COLOR_RESET = ""
    GREEN_CARET = " => "
end

-- State tracking
local current_frame = 0
local step_mode = nil
local current_func = nil
local last_cmd = "h"  -- Move last_cmd to file scope

-- Source cache
local source_cache = {}

local function pretty(obj, max_depth)
    max_depth = max_depth or 3
    local function pp(obj, depth)
        if depth > max_depth then return tostring(obj) end
        if type(obj) == "string" then return string.format("%q", obj) end
        if type(obj) ~= "table" then return tostring(obj) end
        local mt = getmetatable(obj)
        if mt and mt.__tostring then return tostring(obj) end

        local parts = {}
        for k, v in pairs(obj) do
            local key = type(k) == "string" and k or "[" .. pp(k, depth) .. "]"
            table.insert(parts, key .. " = " .. pp(v, depth + 1))
        end
        return "{" .. table.concat(parts, ", ") .. "}"
    end
    return pp(obj, 1)
end

local function get_locals(level)
    local vars = {}
    local i = 1
    while true do
        local name, value = debug.getlocal(level, i)
        if not name then break end
        if name:sub(1, 1) ~= "(" then  -- Skip internal variables
            vars[name] = value
        end
        i = i + 1
    end
    return vars
end

local function get_upvalues(func)
    local vars = {}
    local i = 1
    while true do
        local name, value = debug.getupvalue(func, i)
        if not name then break end
        vars[name] = value
        i = i + 1
    end
    return vars
end

local function get_source_lines(info)
    if source_cache[info.source] then
        return source_cache[info.source]
    end

    local lines = {}
    if info.source:sub(1, 1) == "@" then
        local file = io.open(info.source:sub(2))
        if file then
            for line in file:lines() do
                table.insert(lines, line)
            end
            file:close()
        end
    else
        for line in info.source:gmatch("[^\n]+") do
            table.insert(lines, line)
        end
    end
    source_cache[info.source] = lines
    return lines
end

local function get_short_src(source)
    if source:sub(1, 1) == "@" then
        return source:sub(2)  -- Remove @ prefix
    end
    -- For non-file sources, return just "[string]"
    return "[string]"
end

local function print_break_location(info, reason)
    reason = reason or "dbg()"
    local short_src = get_short_src(info.source)
    local prefix = reason and (COLOR_YELLOW .. "break via " .. COLOR_RED .. reason .. GREEN_CARET) or ""
    print(string.format("%s%s%s:%s%d%s in %s",
        prefix,
        COLOR_BLUE, short_src,
        COLOR_YELLOW, info.currentline,
        COLOR_RESET,
        info.name or "main chunk"
    ))
end

local function print_frame_source(info, context_lines)
    context_lines = context_lines or 2
    local lines = get_source_lines(info)
    if not lines then return end

    local line_num = info.currentline
    for i = math.max(1, line_num - context_lines),
             math.min(#lines, line_num + context_lines) do
        local marker = i == line_num and GREEN_CARET or "    "
        print(string.format(COLOR_GRAY .. "% 4d%s%s",
            i, marker, lines[i] .. COLOR_RESET))
    end
end

local function evaluate_expression(expr, level)
    if not expr or expr == "" then
        print(COLOR_RED .. "Usage: p <expression>" .. COLOR_RESET)
        return
    end

    local locals = get_locals(level)
    local info = debug.getinfo(level, "f")
    local upvalues = get_upvalues(info.func)

    -- Create environment with locals, upvalues, and globals
    local env = setmetatable(locals, {__index = _G})
    for k, v in pairs(upvalues) do env[k] = v end

    local chunk, err = load("return " .. expr, "=expr", "t", env)
    if not chunk then
        print(COLOR_RED .. "Error: " .. err .. COLOR_RESET)
        return
    end

    local success, result = pcall(chunk)
    if not success then
        print(COLOR_RED .. "Error: " .. result .. COLOR_RESET)
        return
    end

    print(COLOR_BLUE .. expr .. GREEN_CARET .. pretty(result))
end

local function print_locals(level)
    local locals = get_locals(level)
    local info = debug.getinfo(level, "f")
    local upvalues = get_upvalues(info.func)

    print(COLOR_BLUE .. "Local variables:" .. COLOR_RESET)
    local sorted_locals = {}
    for name, value in pairs(locals) do
        table.insert(sorted_locals, {name = name, value = value})
    end
    table.sort(sorted_locals, function(a, b) return a.name < b.name end)

    for _, var in ipairs(sorted_locals) do
        print(string.format("  %s = %s", var.name, pretty(var.value)))
    end

    if next(upvalues) then
        print(COLOR_BLUE .. "\nUpvalues:" .. COLOR_RESET)
        local sorted_upvalues = {}
        for name, value in pairs(upvalues) do
            table.insert(sorted_upvalues, {name = name, value = value})
        end
        table.sort(sorted_upvalues, function(a, b) return a.name < b.name end)

        for _, var in ipairs(sorted_upvalues) do
            print(string.format("  %s = %s", var.name, pretty(var.value)))
        end
    end
end

local function print_help()
    local help = {
        {cmd = "<return>", desc = "re-run last command"},
        {cmd = "c(ontinue)", desc = "continue execution"},
        {cmd = "s(tep)", desc = "step forward by one line (into functions)"},
        {cmd = "n(ext)", desc = "step forward by one line (skipping over functions)"},
        {cmd = "f(inish)", desc = "step forward until exiting the current function"},
        {cmd = "u(p)", desc = "move up the stack by one frame"},
        {cmd = "d(own)", desc = "move down the stack by one frame"},
        {cmd = "w(here) [count]", desc = "print source code around the current line"},
        {cmd = "p(rint) [expr]", desc = "evaluate expression and print the result"},
        {cmd = "t(race)", desc = "print the stack trace"},
        {cmd = "l(ocals)", desc = "print the function arguments, locals and upvalues"},
        {cmd = "h(elp)", desc = "print this message"},
        {cmd = "q(uit)", desc = "halt execution"},
    }

    for _, item in ipairs(help) do
        print(string.format("%s%s%s%s%s",
            COLOR_BLUE, item.cmd,
            COLOR_YELLOW, GREEN_CARET, item.desc))
    end
end

local function print_stack_trace()
    local level = 1
    print(COLOR_BLUE .. "Stack trace:" .. COLOR_RESET)
    while true do
        local info = debug.getinfo(level, "Snl")
        if not info then break end

        local is_current = level == current_frame + 2
        local marker = is_current and GREEN_CARET or "    "
        local name = info.name or "<unknown>"
        local source = get_short_src(info.source)

        print(string.format(COLOR_GRAY .. "% 4d%s%s:%d in %s",
            level - 1, marker, source, info.currentline, name))

        level = level + 1
    end
end

-- Debug hook
local function debug_hook(event, line)

    if event ~= "line" then return end

    if step_mode == "over" and current_func then
        local info = debug.getinfo(2, "f")
        if info.func ~= current_func then return end
    end

    local info = debug.getinfo(2, "Snl")
    if not info then return end

    print_break_location(info)
    print_frame_source(info)

    while true do
        io.write(COLOR_RED .. "dbg> " .. COLOR_RESET)
        local input = io.read()
        if not input then return end

        -- Handle empty input - reuse last command
        if input == "" then
            input = last_cmd
        else
            last_cmd = input  -- Update last_cmd only for non-empty input
        end

        local cmd, args = input:match("^(%S+)%s*(.*)")
        cmd = cmd or ""

        if cmd == "c" then
            step_mode = nil
            debug.sethook()
            return
        elseif cmd == "s" then
            step_mode = "into"
            return
        elseif cmd == "n" then
            step_mode = "over"
            current_func = debug.getinfo(2, "f").func
            return
        elseif cmd == "f" then
            step_mode = "out"
            current_func = debug.getinfo(2, "f").func
            return
        elseif cmd == "l" then
            print_locals(2 + current_frame)
        elseif cmd == "t" then
            print_stack_trace()
        elseif cmd == "w" then
            local count = tonumber(args) or 5
            print_frame_source(info, count)
        elseif cmd == "u" then
            local new_frame = current_frame + 1
            local frame_info = debug.getinfo(new_frame + 2, "Snl")
            if frame_info then
                current_frame = new_frame
                print_break_location(frame_info)
                print_frame_source(frame_info)
            else
                print("Already at top of stack")
            end
        elseif cmd == "d" then
            if current_frame > 0 then
                current_frame = current_frame - 1
                local frame_info = debug.getinfo(current_frame + 2, "Snl")
                print_break_location(frame_info)
                print_frame_source(frame_info)
            else
                print("Already at bottom of stack")
            end
        elseif cmd == "p" then
            evaluate_expression(args, 2 + current_frame)
        elseif cmd == "h" then
            print_help()
        elseif cmd == "q" then
            os.exit(0)
        else
            print(COLOR_RED .. "Unknown command. Type 'h' for help." .. COLOR_RESET)
        end
    end
end

-- Make dbg callable
setmetatable(dbg, {
    __call = function(_, condition)
        if condition then return end
        current_frame = 0
        step_mode = "into"
        debug.sethook(debug_hook, "l")
    end
})

-- Expose API
dbg.pretty = pretty
dbg.pretty_depth = 3
dbg.auto_where = false

return dbg
''';


function luaopen_debugger(lua: Plua_State): Integer; cdecl;
begin
  if (luaL_loadbufferx(lua, DEBUGGER_LUA, Length(DEBUGGER_LUA), '<debugger.lua>', nil) <> 0) or
     (lua_pcall(lua, 0, LUA_MULTRET, 0) <> 0) then
    lua_error(lua);
  Result := 1;
end;

const
  MODULE_NAME: PAnsiChar = 'DEBUGGER_LUA_MODULE';
  MSGH: PAnsiChar = 'DEBUGGER_LUA_MSGH';

procedure dbg_setup(lua: Plua_State; name: PAnsiChar; globalName: PAnsiChar; readFunc: lua_CFunction; writeFunc: lua_CFunction); cdecl;
begin
  // Check that the module name was not already defined.
  lua_getfield(lua, LUA_REGISTRYINDEX, MODULE_NAME);
  Assert(lua_isnil(lua, -1) or (System.AnsiStrings.StrComp(name, luaL_checkstring(lua, -1)) = 0));
  lua_pop(lua, 1);

  // Push the module name into the registry.
  lua_pushstring(lua, name);
  lua_setfield(lua, LUA_REGISTRYINDEX, MODULE_NAME);

  // Preload the module
  luaL_requiref(lua, name, luaopen_debugger, 0);

  // Insert the msgh function into the registry.
  lua_getfield(lua, -1, 'msgh');
  lua_setfield(lua, LUA_REGISTRYINDEX, MSGH);

  if Assigned(readFunc) then
  begin
    lua_pushcfunction(lua, readFunc);
    lua_setfield(lua, -2, 'read');
  end;

  if Assigned(writeFunc) then
  begin
    lua_pushcfunction(lua, writeFunc);
    lua_setfield(lua, -2, 'write');
  end;

  if globalName <> nil then
  begin
    lua_setglobal(lua, globalName);
  end else
  begin
    lua_pop(lua, 1);
  end;
end;

procedure dbg_setup_default(lua: Plua_State); cdecl;
begin
  dbg_setup(lua, 'debugger', 'dbg', nil, nil);
end;

function dbg_pcall(lua: Plua_State; nargs: Integer; nresults: Integer; msgh: Integer): Integer; cdecl;
begin
  // Call regular lua_pcall() if a message handler is provided.
  if msgh <> 0 then
    Exit(lua_pcall(lua, nargs, nresults, msgh));

  // Grab the msgh function out of the registry.
  lua_getfield(lua, LUA_REGISTRYINDEX, PUTF8Char(MSGH));
  if lua_isnil(lua, -1) then
    luaL_error(lua, 'Tried to call dbg_call() before calling dbg_setup().');

  // Move the error handler just below the function.
  msgh := lua_gettop(lua) - (1 + nargs);
  lua_insert(lua, msgh);

  // Call the function.
  Result := lua_pcall(lua, nargs, nresults, msgh);

  // Remove the debug handler.
  lua_remove(lua, msgh);
end;

function dbg_dofile(lua: Plua_State; filename: PAnsiChar): Integer;
begin
  Result := luaL_loadfile(lua, filename);
  if Result = 0 then
    Result := dbg_pcall(lua, 0, LUA_MULTRET, 0);
end;

const cLOADER_LUA : array[1..436] of Byte = (
$2D, $2D, $20, $55, $74, $69, $6C, $69, $74, $79, $20, $66, $75, $6E, $63, $74,
$69, $6F, $6E, $20, $66, $6F, $72, $20, $68, $61, $76, $69, $6E, $67, $20, $61,
$20, $77, $6F, $72, $6B, $69, $6E, $67, $20, $69, $6D, $70, $6F, $72, $74, $20,
$66, $75, $6E, $63, $74, $69, $6F, $6E, $0A, $2D, $2D, $20, $46, $65, $65, $6C,
$20, $66, $72, $65, $65, $20, $74, $6F, $20, $75, $73, $65, $20, $69, $74, $20,
$69, $6E, $20, $79, $6F, $75, $72, $20, $6F, $77, $6E, $20, $70, $72, $6F, $6A,
$65, $63, $74, $73, $0A, $28, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $29,
$0A, $20, $20, $20, $20, $6C, $6F, $63, $61, $6C, $20, $73, $63, $72, $69, $70,
$74, $5F, $63, $61, $63, $68, $65, $20, $3D, $20, $7B, $7D, $3B, $0A, $20, $20,
$20, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $20, $69, $6D, $70, $6F, $72,
$74, $28, $6E, $61, $6D, $65, $29, $0A, $20, $20, $20, $20, $20, $20, $20, $20,
$69, $66, $20, $73, $63, $72, $69, $70, $74, $5F, $63, $61, $63, $68, $65, $5B,
$6E, $61, $6D, $65, $5D, $20, $3D, $3D, $20, $6E, $69, $6C, $20, $74, $68, $65,
$6E, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $73, $63,
$72, $69, $70, $74, $5F, $63, $61, $63, $68, $65, $5B, $6E, $61, $6D, $65, $5D,
$20, $3D, $20, $6C, $6F, $61, $64, $66, $69, $6C, $65, $28, $6E, $61, $6D, $65,
$29, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $65, $6E, $64, $0A, $20, $20,
$20, $20, $20, $20, $20, $20, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $69,
$66, $20, $73, $63, $72, $69, $70, $74, $5F, $63, $61, $63, $68, $65, $5B, $6E,
$61, $6D, $65, $5D, $20, $7E, $3D, $20, $6E, $69, $6C, $20, $74, $68, $65, $6E,
$0A, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $72, $65, $74,
$75, $72, $6E, $20, $73, $63, $72, $69, $70, $74, $5F, $63, $61, $63, $68, $65,
$5B, $6E, $61, $6D, $65, $5D, $28, $29, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $65, $6E, $64, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $65, $72, $72,
$6F, $72, $28, $22, $46, $61, $69, $6C, $65, $64, $20, $74, $6F, $20, $6C, $6F,
$61, $64, $20, $73, $63, $72, $69, $70, $74, $20, $22, $20, $2E, $2E, $20, $6E,
$61, $6D, $65, $29, $0A, $20, $20, $20, $20, $65, $6E, $64, $0A, $65, $6E, $64,
$29, $28, $29, $0A
);

const cLUABUNDLE_LUA : array[1..3478] of Byte = (
$28, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $61, $72, $67, $73, $29, $0D,
$0A, $6C, $6F, $63, $61, $6C, $20, $6D, $6F, $64, $75, $6C, $65, $73, $20, $3D,
$20, $7B, $7D, $0D, $0A, $6D, $6F, $64, $75, $6C, $65, $73, $5B, $27, $61, $70,
$70, $2F, $62, $75, $6E, $64, $6C, $65, $5F, $6D, $61, $6E, $61, $67, $65, $72,
$2E, $6C, $75, $61, $27, $5D, $20, $3D, $20, $66, $75, $6E, $63, $74, $69, $6F,
$6E, $28, $2E, $2E, $2E, $29, $0D, $0A, $2D, $2D, $20, $43, $6C, $61, $73, $73,
$20, $66, $6F, $72, $20, $63, $6F, $6C, $6C, $65, $63, $74, $69, $6E, $67, $20,
$74, $68, $65, $20, $66, $69, $6C, $65, $27, $73, $20, $63, $6F, $6E, $74, $65,
$6E, $74, $20, $61, $6E, $64, $20, $62, $75, $69, $6C, $64, $69, $6E, $67, $20,
$61, $20, $62, $75, $6E, $64, $6C, $65, $20, $66, $69, $6C, $65, $0D, $0A, $6C,
$6F, $63, $61, $6C, $20, $73, $6F, $75, $72, $63, $65, $5F, $70, $61, $72, $73,
$65, $72, $20, $3D, $20, $69, $6D, $70, $6F, $72, $74, $28, $22, $61, $70, $70,
$2F, $73, $6F, $75, $72, $63, $65, $5F, $70, $61, $72, $73, $65, $72, $2E, $6C,
$75, $61, $22, $29, $0D, $0A, $0D, $0A, $72, $65, $74, $75, $72, $6E, $20, $66,
$75, $6E, $63, $74, $69, $6F, $6E, $28, $65, $6E, $74, $72, $79, $5F, $70, $6F,
$69, $6E, $74, $29, $0D, $0A, $20, $20, $20, $20, $6C, $6F, $63, $61, $6C, $20,
$73, $65, $6C, $66, $20, $3D, $20, $7B, $7D, $0D, $0A, $20, $20, $20, $20, $6C,
$6F, $63, $61, $6C, $20, $66, $69, $6C, $65, $73, $20, $3D, $20, $7B, $7D, $0D,
$0A, $20, $20, $20, $20, $0D, $0A, $20, $20, $20, $20, $2D, $2D, $20, $53, $65,
$61, $72, $63, $68, $65, $73, $20, $74, $68, $65, $20, $67, $69, $76, $65, $6E,
$20, $66, $69, $6C, $65, $20, $72, $65, $63, $75, $72, $73, $69, $76, $65, $6C,
$79, $20, $66, $6F, $72, $20, $69, $6D, $70, $6F, $72, $74, $20, $66, $75, $6E,
$63, $74, $69, $6F, $6E, $20, $63, $61, $6C, $6C, $73, $0D, $0A, $20, $20, $20,
$20, $73, $65, $6C, $66, $2E, $70, $72, $6F, $63, $65, $73, $73, $5F, $66, $69,
$6C, $65, $20, $3D, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $66, $69,
$6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $6C, $6F, $63, $61, $6C, $20, $70, $61, $72, $73, $65, $72, $20, $3D, $20,
$73, $6F, $75, $72, $63, $65, $5F, $70, $61, $72, $73, $65, $72, $28, $66, $69,
$6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $66, $69, $6C, $65, $73, $5B, $66, $69, $6C, $65, $6E, $61, $6D, $65, $5D,
$20, $3D, $20, $70, $61, $72, $73, $65, $72, $2E, $63, $6F, $6E, $74, $65, $6E,
$74, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $0D, $0A, $20, $20, $20,
$20, $20, $20, $20, $20, $66, $6F, $72, $20, $5F, $2C, $20, $66, $20, $69, $6E,
$20, $70, $61, $69, $72, $73, $28, $70, $61, $72, $73, $65, $72, $2E, $69, $6E,
$63, $6C, $75, $64, $65, $73, $29, $20, $64, $6F, $0D, $0A, $20, $20, $20, $20,
$20, $20, $20, $20, $20, $20, $20, $20, $73, $65, $6C, $66, $2E, $70, $72, $6F,
$63, $65, $73, $73, $5F, $66, $69, $6C, $65, $28, $66, $29, $0D, $0A, $20, $20,
$20, $20, $20, $20, $20, $20, $65, $6E, $64, $0D, $0A, $20, $20, $20, $20, $65,
$6E, $64, $0D, $0A, $20, $20, $20, $20, $0D, $0A, $20, $20, $20, $20, $2D, $2D,
$20, $43, $72, $65, $61, $74, $65, $20, $61, $20, $62, $75, $6E, $64, $6C, $65,
$20, $66, $69, $6C, $65, $20, $77, $68, $69, $63, $68, $20, $63, $6F, $6E, $74,
$61, $69, $6E, $73, $20, $74, $68, $65, $20, $64, $65, $74, $65, $63, $74, $65,
$64, $20, $66, $69, $6C, $65, $73, $0D, $0A, $20, $20, $20, $20, $73, $65, $6C,
$66, $2E, $62, $75, $69, $6C, $64, $5F, $62, $75, $6E, $64, $6C, $65, $20, $3D,
$20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $64, $65, $73, $74, $5F, $66,
$69, $6C, $65, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $6C, $6F,
$63, $61, $6C, $20, $66, $69, $6C, $65, $20, $3D, $20, $69, $6F, $2E, $6F, $70,
$65, $6E, $28, $64, $65, $73, $74, $5F, $66, $69, $6C, $65, $2C, $20, $22, $77,
$22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $0D, $0A, $20, $20,
$20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65,
$28, $22, $28, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $61, $72, $67, $73,
$29, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66,
$69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22, $6C, $6F, $63, $61, $6C,
$20, $6D, $6F, $64, $75, $6C, $65, $73, $20, $3D, $20, $7B, $7D, $5C, $6E, $22,
$29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $0D, $0A, $20, $20, $20,
$20, $20, $20, $20, $20, $2D, $2D, $20, $43, $72, $65, $61, $74, $65, $20, $61,
$20, $73, $6F, $72, $74, $65, $64, $20, $6C, $69, $73, $74, $20, $6F, $66, $20,
$6B, $65, $79, $73, $20, $73, $6F, $20, $74, $68, $65, $20, $6F, $75, $74, $70,
$75, $74, $20, $77, $69, $6C, $6C, $20, $62, $65, $20, $74, $68, $65, $20, $73,
$61, $6D, $65, $20, $77, $68, $65, $6E, $20, $74, $68, $65, $20, $69, $6E, $70,
$75, $74, $20, $64, $6F, $65, $73, $20, $6E, $6F, $74, $20, $63, $68, $61, $6E,
$67, $65, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $6C, $6F, $63, $61,
$6C, $20, $66, $69, $6C, $65, $6E, $61, $6D, $65, $73, $20, $3D, $20, $7B, $7D,
$0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66, $6F, $72, $20, $66, $69,
$6C, $65, $6E, $61, $6D, $65, $2C, $20, $5F, $20, $69, $6E, $20, $70, $61, $69,
$72, $73, $28, $66, $69, $6C, $65, $73, $29, $20, $64, $6F, $0D, $0A, $20, $20,
$20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $74, $61, $62, $6C, $65, $2E,
$69, $6E, $73, $65, $72, $74, $28, $66, $69, $6C, $65, $6E, $61, $6D, $65, $73,
$2C, $20, $66, $69, $6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20, $20, $20,
$20, $20, $20, $20, $20, $65, $6E, $64, $0D, $0A, $20, $20, $20, $20, $20, $20,
$20, $20, $74, $61, $62, $6C, $65, $2E, $73, $6F, $72, $74, $28, $66, $69, $6C,
$65, $6E, $61, $6D, $65, $73, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $2D, $2D, $20, $41, $64,
$64, $20, $66, $69, $6C, $65, $73, $20, $61, $73, $20, $6D, $6F, $64, $75, $6C,
$65, $73, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66, $6F, $72, $20,
$5F, $2C, $20, $66, $69, $6C, $65, $6E, $61, $6D, $65, $20, $69, $6E, $20, $70,
$61, $69, $72, $73, $28, $66, $69, $6C, $65, $6E, $61, $6D, $65, $73, $29, $20,
$64, $6F, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20,
$66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22, $6D, $6F, $64, $75,
$6C, $65, $73, $5B, $27, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28,
$66, $69, $6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20, $20, $20, $20, $20,
$20, $20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74,
$65, $28, $22, $27, $5D, $20, $3D, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E,
$28, $2E, $2E, $2E, $29, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20, $20,
$20, $20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74,
$65, $28, $66, $69, $6C, $65, $73, $5B, $66, $69, $6C, $65, $6E, $61, $6D, $65,
$5D, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20,
$66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22, $5C, $6E, $22, $29,
$0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $66, $69,
$6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22, $65, $6E, $64, $5C, $6E, $22,
$29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $65, $6E, $64, $0D, $0A,
$20, $20, $20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69,
$74, $65, $28, $22, $66, $75, $6E, $63, $74, $69, $6F, $6E, $20, $69, $6D, $70,
$6F, $72, $74, $28, $6E, $29, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20,
$20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22,
$72, $65, $74, $75, $72, $6E, $20, $6D, $6F, $64, $75, $6C, $65, $73, $5B, $6E,
$5D, $28, $74, $61, $62, $6C, $65, $2E, $75, $6E, $70, $61, $63, $6B, $28, $61,
$72, $67, $73, $29, $29, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20, $20,
$20, $20, $20, $66, $69, $6C, $65, $3A, $77, $72, $69, $74, $65, $28, $22, $65,
$6E, $64, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20,
$0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $77,
$72, $69, $74, $65, $28, $22, $6C, $6F, $63, $61, $6C, $20, $65, $6E, $74, $72,
$79, $20, $3D, $20, $69, $6D, $70, $6F, $72, $74, $28, $27, $22, $20, $2E, $2E,
$20, $65, $6E, $74, $72, $79, $5F, $70, $6F, $69, $6E, $74, $20, $2E, $2E, $20,
$22, $27, $29, $5C, $6E, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20,
$20, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66, $69, $6C, $65, $3A,
$77, $72, $69, $74, $65, $28, $22, $65, $6E, $64, $29, $28, $7B, $2E, $2E, $2E,
$7D, $29, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $66, $69,
$6C, $65, $3A, $66, $6C, $75, $73, $68, $28, $29, $0D, $0A, $20, $20, $20, $20,
$20, $20, $20, $20, $66, $69, $6C, $65, $3A, $63, $6C, $6F, $73, $65, $28, $29,
$0D, $0A, $20, $20, $20, $20, $65, $6E, $64, $0D, $0A, $20, $20, $20, $20, $0D,
$0A, $20, $20, $20, $20, $72, $65, $74, $75, $72, $6E, $20, $73, $65, $6C, $66,
$0D, $0A, $65, $6E, $64, $0D, $0A, $65, $6E, $64, $0D, $0A, $6D, $6F, $64, $75,
$6C, $65, $73, $5B, $27, $61, $70, $70, $2F, $6D, $61, $69, $6E, $2E, $6C, $75,
$61, $27, $5D, $20, $3D, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $2E,
$2E, $2E, $29, $0D, $0A, $2D, $2D, $20, $4D, $61, $69, $6E, $20, $66, $75, $6E,
$63, $74, $69, $6F, $6E, $20, $6F, $66, $20, $74, $68, $65, $20, $70, $72, $6F,
$67, $72, $61, $6D, $0D, $0A, $6C, $6F, $63, $61, $6C, $20, $62, $75, $6E, $64,
$6C, $65, $5F, $6D, $61, $6E, $61, $67, $65, $72, $20, $3D, $20, $69, $6D, $70,
$6F, $72, $74, $28, $22, $61, $70, $70, $2F, $62, $75, $6E, $64, $6C, $65, $5F,
$6D, $61, $6E, $61, $67, $65, $72, $2E, $6C, $75, $61, $22, $29, $0D, $0A, $0D,
$0A, $72, $65, $74, $75, $72, $6E, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E,
$28, $61, $72, $67, $73, $29, $0D, $0A, $20, $20, $20, $20, $69, $66, $20, $23,
$61, $72, $67, $73, $20, $3D, $3D, $20, $31, $20, $61, $6E, $64, $20, $61, $72,
$67, $73, $5B, $31, $5D, $20, $3D, $3D, $20, $22, $2D, $76, $22, $20, $74, $68,
$65, $6E, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $70, $72, $69, $6E,
$74, $28, $22, $6C, $75, $61, $62, $75, $6E, $64, $6C, $65, $20, $76, $30, $2E,
$30, $31, $22, $29, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $6F, $73,
$2E, $65, $78, $69, $74, $28, $29, $0D, $0A, $20, $20, $20, $20, $65, $6C, $73,
$65, $69, $66, $20, $23, $61, $72, $67, $73, $20, $7E, $3D, $20, $32, $20, $74,
$68, $65, $6E, $0D, $0A, $20, $20, $20, $20, $20, $20, $20, $20, $70, $72, $69,
$6E, $74, $28, $22, $75, $73, $61, $67, $65, $3A, $20, $6C, $75, $61, $62, $75,
$6E, $64, $6C, $65, $20, $69, $6E, $20, $6F, $75, $74, $22, $29, $0D, $0A, $20,
$20, $20, $20, $20, $20, $20, $20, $6F, $73, $2E, $65, $78, $69, $74, $28, $29,
$0D, $0A, $20, $20, $20, $20, $65, $6E, $64, $0D, $0A, $20, $20, $20, $20, $0D,
$0A, $20, $20, $20, $20, $6C, $6F, $63, $61, $6C, $20, $69, $6E, $66, $69, $6C,
$65, $20, $3D, $20, $61, $72, $67, $73, $5B, $31, $5D, $0D, $0A, $20, $20, $20,
$20, $6C, $6F, $63, $61, $6C, $20, $6F, $75, $74, $66, $69, $6C, $65, $20, $3D,
$20, $61, $72, $67, $73, $5B, $32, $5D, $0D, $0A, $20, $20, $20, $20, $6C, $6F,
$63, $61, $6C, $20, $62, $75, $6E, $64, $6C, $65, $20, $3D, $20, $62, $75, $6E,
$64, $6C, $65, $5F, $6D, $61, $6E, $61, $67, $65, $72, $28, $69, $6E, $66, $69,
$6C, $65, $29, $0D, $0A, $20, $20, $20, $20, $62, $75, $6E, $64, $6C, $65, $2E,
$70, $72, $6F, $63, $65, $73, $73, $5F, $66, $69, $6C, $65, $28, $69, $6E, $66,
$69, $6C, $65, $2C, $20, $62, $75, $6E, $64, $6C, $65, $29, $0D, $0A, $20, $20,
$20, $20, $0D, $0A, $20, $20, $20, $20, $62, $75, $6E, $64, $6C, $65, $2E, $62,
$75, $69, $6C, $64, $5F, $62, $75, $6E, $64, $6C, $65, $28, $6F, $75, $74, $66,
$69, $6C, $65, $29, $0D, $0A, $65, $6E, $64, $0D, $0A, $65, $6E, $64, $0D, $0A,
$6D, $6F, $64, $75, $6C, $65, $73, $5B, $27, $61, $70, $70, $2F, $73, $6F, $75,
$72, $63, $65, $5F, $70, $61, $72, $73, $65, $72, $2E, $6C, $75, $61, $27, $5D,
$20, $3D, $20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $2E, $2E, $2E, $29,
$0D, $0A, $2D, $2D, $20, $43, $6C, $61, $73, $73, $20, $66, $6F, $72, $20, $65,
$78, $74, $72, $61, $63, $74, $69, $6E, $67, $20, $69, $6D, $70, $6F, $72, $74,
$20, $66, $75, $6E, $63, $74, $69, $6F, $6E, $20, $63, $61, $6C, $6C, $73, $20,
$66, $72, $6F, $6D, $20, $73, $6F, $75, $72, $63, $65, $20, $66, $69, $6C, $65,
$73, $0D, $0A, $72, $65, $74, $75, $72, $6E, $20, $66, $75, $6E, $63, $74, $69,
$6F, $6E, $28, $66, $69, $6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20, $20,
$20, $20, $6C, $6F, $63, $61, $6C, $20, $66, $69, $6C, $65, $20, $3D, $20, $69,
$6F, $2E, $6F, $70, $65, $6E, $28, $66, $69, $6C, $65, $6E, $61, $6D, $65, $2C,
$20, $22, $72, $22, $29, $0D, $0A, $20, $20, $20, $20, $69, $66, $20, $66, $69,
$6C, $65, $20, $3D, $3D, $20, $6E, $69, $6C, $20, $74, $68, $65, $6E, $0D, $0A,
$20, $20, $20, $20, $20, $20, $20, $20, $65, $72, $72, $6F, $72, $28, $22, $46,
$69, $6C, $65, $20, $6E, $6F, $74, $20, $66, $6F, $75, $6E, $64, $3A, $20, $22,
$20, $2E, $2E, $20, $66, $69, $6C, $65, $6E, $61, $6D, $65, $29, $0D, $0A, $20,
$20, $20, $20, $65, $6E, $64, $0D, $0A, $20, $20, $20, $20, $6C, $6F, $63, $61,
$6C, $20, $66, $69, $6C, $65, $5F, $63, $6F, $6E, $74, $65, $6E, $74, $20, $3D,
$20, $66, $69, $6C, $65, $3A, $72, $65, $61, $64, $28, $22, $2A, $61, $22, $29,
$0D, $0A, $20, $20, $20, $20, $66, $69, $6C, $65, $3A, $63, $6C, $6F, $73, $65,
$28, $29, $0D, $0A, $20, $20, $20, $20, $6C, $6F, $63, $61, $6C, $20, $69, $6E,
$63, $6C, $75, $64, $65, $64, $5F, $66, $69, $6C, $65, $73, $20, $3D, $20, $7B,
$7D, $0D, $0A, $20, $20, $20, $20, $0D, $0A, $20, $20, $20, $20, $2D, $2D, $20,
$53, $65, $61, $72, $63, $68, $20, $66, $6F, $72, $20, $69, $6D, $70, $6F, $72,
$74, $28, $29, $20, $63, $61, $6C, $6C, $73, $20, $77, $69, $74, $68, $20, $64,
$6F, $62, $75, $6C, $65, $20, $71, $75, $6F, $74, $65, $73, $20, $28, $21, $29,
$0D, $0A, $20, $20, $20, $20, $66, $6F, $72, $20, $66, $20, $69, $6E, $20, $73,
$74, $72, $69, $6E, $67, $2E, $67, $6D, $61, $74, $63, $68, $28, $66, $69, $6C,
$65, $5F, $63, $6F, $6E, $74, $65, $6E, $74, $2C, $20, $27, $69, $6D, $70, $6F,
$72, $74, $25, $28, $5B, $22, $5C, $27, $5D, $28, $5B, $5E, $5C, $27, $22, $5D,
$2D, $29, $5B, $22, $5C, $27, $5D, $25, $29, $27, $29, $20, $64, $6F, $0D, $0A,
$20, $20, $20, $20, $20, $20, $20, $20, $74, $61, $62, $6C, $65, $2E, $69, $6E,
$73, $65, $72, $74, $28, $69, $6E, $63, $6C, $75, $64, $65, $64, $5F, $66, $69,
$6C, $65, $73, $2C, $20, $66, $29, $0D, $0A, $20, $20, $20, $20, $65, $6E, $64,
$0D, $0A, $20, $20, $20, $20, $0D, $0A, $20, $20, $20, $20, $73, $65, $6C, $66,
$20, $3D, $20, $7B, $7D, $0D, $0A, $20, $20, $20, $20, $73, $65, $6C, $66, $2E,
$66, $69, $6C, $65, $6E, $61, $6D, $65, $20, $3D, $20, $66, $69, $6C, $65, $6E,
$61, $6D, $65, $0D, $0A, $20, $20, $20, $20, $73, $65, $6C, $66, $2E, $63, $6F,
$6E, $74, $65, $6E, $74, $20, $3D, $20, $66, $69, $6C, $65, $5F, $63, $6F, $6E,
$74, $65, $6E, $74, $0D, $0A, $20, $20, $20, $20, $73, $65, $6C, $66, $2E, $69,
$6E, $63, $6C, $75, $64, $65, $73, $20, $3D, $20, $69, $6E, $63, $6C, $75, $64,
$65, $64, $5F, $66, $69, $6C, $65, $73, $0D, $0A, $20, $20, $20, $20, $72, $65,
$74, $75, $72, $6E, $20, $73, $65, $6C, $66, $0D, $0A, $65, $6E, $64, $0D, $0A,
$65, $6E, $64, $0D, $0A, $6D, $6F, $64, $75, $6C, $65, $73, $5B, $27, $6C, $75,
$61, $62, $75, $6E, $64, $6C, $65, $2E, $6C, $75, $61, $27, $5D, $20, $3D, $20,
$66, $75, $6E, $63, $74, $69, $6F, $6E, $28, $2E, $2E, $2E, $29, $0D, $0A, $2D,
$2D, $20, $45, $6E, $74, $72, $79, $20, $70, $6F, $69, $6E, $74, $20, $6F, $66,
$20, $74, $68, $65, $20, $70, $72, $6F, $67, $72, $61, $6D, $2E, $0D, $0A, $2D,
$2D, $20, $4F, $6E, $6C, $79, $20, $62, $61, $73, $69, $63, $20, $73, $74, $75,
$66, $66, $20, $69, $73, $20, $73, $65, $74, $20, $75, $70, $20, $68, $65, $72,
$65, $2C, $20, $74, $68, $65, $20, $61, $63, $74, $75, $61, $6C, $20, $70, $72,
$6F, $67, $72, $61, $6D, $20, $69, $73, $20, $69, $6E, $20, $61, $70, $70, $2F,
$6D, $61, $69, $6E, $2E, $6C, $75, $61, $0D, $0A, $6C, $6F, $63, $61, $6C, $20,
$61, $72, $67, $73, $20, $3D, $20, $7B, $2E, $2E, $2E, $7D, $0D, $0A, $0D, $0A,
$2D, $2D, $20, $43, $68, $65, $63, $6B, $20, $69, $66, $20, $77, $65, $20, $61,
$72, $65, $20, $61, $6C, $72, $65, $61, $64, $79, $20, $62, $75, $6E, $64, $6C,
$65, $64, $0D, $0A, $69, $66, $20, $69, $6D, $70, $6F, $72, $74, $20, $3D, $3D,
$20, $6E, $69, $6C, $20, $74, $68, $65, $6E, $0D, $0A, $20, $20, $20, $20, $64,
$6F, $66, $69, $6C, $65, $28, $22, $75, $74, $69, $6C, $2F, $6C, $6F, $61, $64,
$65, $72, $2E, $6C, $75, $61, $22, $29, $0D, $0A, $65, $6E, $64, $0D, $0A, $0D,
$0A, $69, $6D, $70, $6F, $72, $74, $28, $22, $61, $70, $70, $2F, $6D, $61, $69,
$6E, $2E, $6C, $75, $61, $22, $29, $28, $61, $72, $67, $73, $29, $0D, $0A, $65,
$6E, $64, $0D, $0A, $66, $75, $6E, $63, $74, $69, $6F, $6E, $20, $69, $6D, $70,
$6F, $72, $74, $28, $6E, $29, $0D, $0A, $72, $65, $74, $75, $72, $6E, $20, $6D,
$6F, $64, $75, $6C, $65, $73, $5B, $6E, $5D, $28, $74, $61, $62, $6C, $65, $2E,
$75, $6E, $70, $61, $63, $6B, $28, $61, $72, $67, $73, $29, $29, $0D, $0A, $65,
$6E, $64, $0D, $0A, $6C, $6F, $63, $61, $6C, $20, $65, $6E, $74, $72, $79, $20,
$3D, $20, $69, $6D, $70, $6F, $72, $74, $28, $27, $6C, $75, $61, $62, $75, $6E,
$64, $6C, $65, $2E, $6C, $75, $61, $27, $29, $0D, $0A, $65, $6E, $64, $29, $28,
$7B, $2E, $2E, $2E, $7D, $29
);

const
  cLuaAutoSetup = 'AutoSetup';

function LuaWrapperClosure(const aState: Pointer): Integer; cdecl;
var
  LMethod: TMethod;
  LClosure: TPyLuaFunction absolute LMethod;
  LLua: TPyLua;
begin
  // get lua object
  LLua := lua_touserdata(aState, lua_upvalueindex(1));

  // get lua class routine
  LMethod.Code := lua_touserdata(aState, lua_upvalueindex(2));
  LMethod.Data := lua_touserdata(aState, lua_upvalueindex(3));

  // init the context
  LLua.Context.Setup;

  // call class routines
  LClosure(LLua.Context);

  // return result count
  Result := LLua.Context.PushCount;

  // clean up stack
  LLua.Context.Cleanup;
end;

function LuaWrapperWriter(aState: Plua_State; const aBuffer: Pointer; aSize: NativeUInt; aData: Pointer): Integer; cdecl;
var
  LStream: TStream;
begin
  LStream := TStream(aData);
  try
    LStream.WriteBuffer(aBuffer^, aSize);
    Result := 0;
  except
    on E: EStreamError do
      Result := 1;
  end;
end;

{ TLuaValue }
class operator TPyLuaValue.Implicit(const AValue: Integer): TPyLuaValue;
begin
  Result.AsType := vtInteger;
  Result.AsInteger := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: Double): TPyLuaValue;
begin
  Result.AsType := vtDouble;
  Result.AsNumber := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: System.PChar): TPyLuaValue;
begin
  Result.AsType := vtString;
  Result.AsString := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: TPyLuaTable): TPyLuaValue;
begin
  Result.AsType := vtTable;
  Result.AsTable := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: Pointer): TPyLuaValue;
begin
  Result.AsType := vtPointer;
  Result.AsPointer := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: Boolean): TPyLuaValue;
begin
  Result.AsType := vtBoolean;
  Result.AsBoolean := AValue;
end;

class operator TPyLuaValue.Implicit(const AValue: TPyLuaValue): Integer;
begin
  Result := AValue.AsInteger;
end;

class operator TPyLuaValue.Implicit(const AValue: TPyLuaValue): Double;
begin
  Result := AValue.AsNumber;
end;

var TLuaValue_Implicit_LValue: string = '';
class operator TPyLuaValue.Implicit(const AValue: TPyLuaValue): System.PChar;
begin
  TLuaValue_Implicit_LValue := AValue.AsString;
  Result := PChar(TLuaValue_Implicit_LValue);
end;

class operator TPyLuaValue.Implicit(const AValue: TPyLuaValue): Pointer;
begin
  Result := AValue.AsPointer
end;

class operator TPyLuaValue.Implicit(const AValue: TPyLuaValue): Boolean;
begin
  Result := AValue.AsBoolean;
end;

{ Routines }
function ParseTableNames(const aNames: string): TStringDynArray;
var
  LItems: TArray<string>;
  LI: Integer;
begin
  LItems := aNames.Split(['.']);
  SetLength(Result, Length(LItems));
  for LI := 0 to High(LItems) do
  begin
    Result[LI] := LItems[LI];
  end;
end;

{ TLuaContext }
procedure TPyLuaContext.Setup();
begin
  FPushCount := 0;
  FPushFlag := True;
end;

procedure TPyLuaContext.Check();
begin
  if FPushFlag then
  begin
    FPushFlag := False;
    ClearStack;
  end;
end;

procedure TPyLuaContext.IncStackPushCount();
begin
  Inc(FPushCount);
end;

procedure TPyLuaContext.Cleanup();
begin
  if FPushFlag then
  begin
    ClearStack;
  end;
end;

function TPyLuaContext.PushTableForSet(const AName: array of string; const AIndex: Integer; var AStackIndex: Integer; var AFieldNameIndex: Integer): Boolean;
var
  LMarshall: TMarshaller;
  LI: Integer;
begin
  Result := False;

  // validate name array size
  AStackIndex := Length(AName);
  if AStackIndex < 1 then  Exit;

  // validate return aStackIndex and aFieldNameIndex
  if Length(AName) = 1 then
    AFieldNameIndex := 0
  else
    AFieldNameIndex := Length(AName) - 1;

  // table does not exist, exit
  if lua_type(FLua.State, AIndex) <> LUA_TTABLE then Exit;

  // process sub tables
  for LI := 0 to AStackIndex - 1 do
  begin
    // check if table at field aIndex[i] exits
    lua_getfield(FLua.State, LI + AIndex, LMarshall.AsAnsi(AName[LI]).ToPointer);

    // table field does not exists, create a new one
    if lua_type(FLua.State, -1) <> LUA_TTABLE then
    begin
      // clean up stack
      lua_pop(FLua.State, 1);

      // push new table
      lua_newtable(FLua.State);

      // set new table a field
      lua_setfield(FLua.State, LI + AIndex, LMarshall.AsAnsi(AName[LI]).ToPointer);

      // push field table back on stack
      lua_getfield(FLua.State, LI + AIndex, LMarshall.AsAnsi(AName[LI]).ToPointer);
    end;
  end;

  Result := True;
end;

function TPyLuaContext.PushTableForGet(const AName: array of string; const AIndex: Integer; var AStackIndex: Integer; var AFieldNameIndex: Integer): Boolean;
var
  LMarshall: TMarshaller;
  LI: Integer;
begin
  Result := False;

  // validate name array size
  AStackIndex := Length(AName);
  if AStackIndex < 1 then  Exit;

  // validate return aStackIndex and aFieldNameIndex
  if AStackIndex = 1 then
    AFieldNameIndex := 0
  else
    AFieldNameIndex := AStackIndex - 1;

  // table does not exist, exit
  if lua_type(FLua.State, AIndex) <> LUA_TTABLE then  Exit;

  // process sub tables
  for LI := 0 to AStackIndex - 2 do
  begin
    // check if table at field aIndex[i] exits
    lua_getfield(FLua.State, LI + AIndex, LMarshall.AsAnsi(AName[LI]).ToPointer);

    // table field does not exists, create a new one
    if lua_type(FLua.State, -1) <> LUA_TTABLE then Exit;
  end;

  Result := True;
end;

constructor TPyLuaContext.Create(const ALua: TPyLua);
begin
  FLua := ALua;
  FPushCount := 0;
  FPushFlag := False;
end;

destructor TPyLuaContext.Destroy();
begin
  FLua := nil;
  FPushCount := 0;
  FPushFlag := False;
  inherited;
end;

function TPyLuaContext.ArgCount(): Integer;
begin
  Result := lua_gettop(FLua.State);
end;

function TPyLuaContext.PushCount: Integer;
begin
  Result := FPushCount;
end;

procedure TPyLuaContext.ClearStack();
begin
  lua_pop(FLua.State, lua_gettop(FLua.State));
  FPushCount := 0;
  FPushFlag := False;
end;

procedure TPyLuaContext.PopStack(const ACount: Integer);
begin
  lua_pop(FLua.State, ACount);
end;

function TPyLuaContext.GetStackType(const AIndex: Integer): TPyLuaType;
begin
  Result := TPyLuaType(lua_type(FLua.State, AIndex));
end;

var TLuaContext_GetValue_LStr: string = '';
function TPyLuaContext.GetValue(const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue;
begin
  Result := Default(TPyLuaValue);
  case AType of
    vtInteger:
      begin
        Result.AsInteger := lua_tointeger(FLua.State, AIndex);
      end;
    vtDouble:
      begin
        Result.AsNumber := lua_tonumber(FLua.State, AIndex);
      end;
    vtString:
      begin
        TLuaContext_GetValue_LStr := lua_tostring(FLua.State, AIndex);
        Result := PChar(TLuaContext_GetValue_LStr);
      end;
    vtPointer:
      begin
        Result.AsPointer := lua_touserdata(FLua.State, AIndex);
      end;
    vtBoolean:
      begin
        Result.AsBoolean := Boolean(lua_toboolean(FLua.State, AIndex));
      end;
  else
    begin

    end;
  end;
end;

procedure TPyLuaContext.PushValue(const AValue: TPyLuaValue);
var
  LMarshall: TMarshaller;
begin
  Check;

  case AValue.AsType of
    vtInteger:
      begin
        lua_pushinteger(FLua.State, AValue);
      end;
    vtDouble:
      begin
        lua_pushnumber(FLua.State, AValue);
      end;
    vtString:
      begin
        lua_pushstring(FLua.State, LMarshall.AsAnsi(AValue.AsString).ToPointer);
      end;
    vtTable:
      begin
        lua_newtable(FLua.State);
      end;
    vtPointer:
      begin
        lua_pushlightuserdata(FLua.State, AValue);
      end;
    vtBoolean:
      begin
        lua_pushboolean(FLua.State, AValue.AsBoolean.ToInteger);
      end;
  end;

  IncStackPushCount();
end;

procedure TPyLuaContext.SetTableFieldValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer);
var
  LMarshall: TMarshaller;
  LStackIndex: Integer;
  LFieldNameIndex: Integer;
  LItems: TStringDynArray;
  LOk: Boolean;
begin
  LItems := ParseTableNames(AName);
  if not PushTableForSet(LItems, AIndex, LStackIndex, LFieldNameIndex) then Exit;
  LOk := True;

  case AValue.AsType of
    vtInteger:
      begin
        lua_pushinteger(FLua.State, AValue);
      end;
    vtDouble:
      begin
        lua_pushnumber(FLua.State, AValue);
      end;
    vtString:
      begin
        lua_pushstring(FLua.State, LMarshall.AsAnsi(AValue.AsString).ToPointer);
      end;
    vtPointer:
      begin
        lua_pushlightuserdata(FLua.State, AValue);
      end;
    vtBoolean:
      begin
        lua_pushboolean(FLua.State, AValue.AsBoolean.ToInteger);
      end;
  else
    begin
      LOk := False;
    end;
  end;

  if LOk then
  begin
    lua_setfield(FLua.State, LStackIndex + (AIndex - 1),
      LMarshall.AsAnsi(LItems[LFieldNameIndex]).ToPointer);
  end;

  PopStack(LStackIndex);
end;

var TLuaContext_GetTableFieldValue_LStr: string = '';
function TPyLuaContext.GetTableFieldValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer): TPyLuaValue;
var
  LMarshall: TMarshaller;
  LStackIndex: Integer;
  LFieldNameIndex: Integer;
  LItems: TStringDynArray;
begin
  LItems := ParseTableNames(AName);
  if not PushTableForGet(LItems, AIndex, LStackIndex, LFieldNameIndex) then
    Exit;
  lua_getfield(FLua.State, LStackIndex + (AIndex - 1),
    LMarshall.AsAnsi(LItems[LFieldNameIndex]).ToPointer);

  case AType of
    vtInteger:
      begin
        Result.AsInteger := lua_tointeger(FLua.State, -1);
      end;
    vtDouble:
      begin
        Result.AsNumber := lua_tonumber(FLua.State, -1);
      end;
    vtString:
      begin
        TLuaContext_GetTableFieldValue_LStr := lua_tostring(FLua.State, -1);
        Result := PChar(TLuaContext_GetTableFieldValue_LStr);
      end;
    vtPointer:
      begin
        Result.AsPointer := lua_touserdata(FLua.State, -1);
      end;
    vtBoolean:
      begin
        Result.AsBoolean := Boolean(lua_toboolean(FLua.State, -1));
      end;
  end;

  PopStack(LStackIndex);
end;

procedure TPyLuaContext.SetTableIndexValue(const AName: string; const AValue: TPyLuaValue; const AIndex: Integer; const AKey: Integer);
var
  LMarshall: TMarshaller;
  LStackIndex: Integer;
  LFieldNameIndex: Integer;
  LItems: TStringDynArray;
  LOk: Boolean;

  procedure LPushValue;
  begin
    LOk := True;

    case AValue.AsType of
      vtInteger:
        begin
          lua_pushinteger(FLua.State, AValue);
        end;
      vtDouble:
        begin
          lua_pushnumber(FLua.State, AValue);
        end;
      vtString:
        begin
          lua_pushstring(FLua.State, LMarshall.AsAnsi(AValue.AsString).ToPointer);
        end;
      vtPointer:
        begin
          lua_pushlightuserdata(FLua.State, AValue);
        end;
      vtBoolean:
        begin
          lua_pushboolean(FLua.State, AValue.AsBoolean.ToInteger);
        end;
    else
      begin
        LOk := False;
      end;
    end;
  end;

begin
  LItems := ParseTableNames(AName);
  if Length(LItems) > 0 then
    begin
      if not PushTableForGet(LItems, AIndex, LStackIndex, LFieldNameIndex) then  Exit;
      LPushValue;
      if LOk then
        lua_rawseti (FLua.State, LStackIndex + (AIndex - 1), AKey);
    end
  else
    begin
      LPushValue;
      if LOk then
      begin
        lua_rawseti (FLua.State, AIndex, AKey);
      end;
      LStackIndex := 0;
    end;

    PopStack(LStackIndex);
end;

var TLuaContext_GetTableIndexValue_LStr: string = '';
function TPyLuaContext.GetTableIndexValue(const AName: string; const AType: TPyLuaValueType; const AIndex: Integer; const AKey: Integer): TPyLuaValue;
var
  LStackIndex: Integer;
  LFieldNameIndex: Integer;
  LItems: TStringDynArray;
begin
  LItems := ParseTableNames(AName);
  if Length(LItems) > 0 then
    begin
      if not PushTableForGet(LItems, AIndex, LStackIndex, LFieldNameIndex) then Exit;
      lua_rawgeti (FLua.State, LStackIndex + (AIndex - 1), AKey);
    end
  else
    begin
      lua_rawgeti (FLua.State, AIndex, AKey);
      LStackIndex := 0;
    end;

  case AType of
    vtInteger:
      begin
        Result.AsInteger := lua_tointeger(FLua.State, -1);
      end;
    vtDouble:
      begin
        Result.AsNumber := lua_tonumber(FLua.State, -1);
      end;
    vtString:
      begin
        TLuaContext_GetTableIndexValue_LStr := lua_tostring(FLua.State, -1);
        Result := PChar(TLuaContext_GetTableIndexValue_LStr);
      end;
    vtPointer:
      begin
        Result.AsPointer := lua_touserdata(FLua.State, -1);
      end;
    vtBoolean:
      begin
        Result.AsBoolean := Boolean(lua_toboolean(FLua.State, -1));
      end;
  end;

  PopStack(LStackIndex);
end;

function  TPyLuaContext.Lua(): IPyLua;
begin
  Result := Self.FLua;
end;


{ TLua }
function TPyLua.Open(): Boolean;
begin
  Result := False;
  if FState <> nil then Exit;

  FState := luaL_newstate;
  SetGCStepSize(200);
  luaL_openlibs(FState);
  LoadBuffer(@cLOADER_LUA, Length(cLOADER_LUA));
  FContext := TPyLuaContext.Create(Self);

  SetVariable('Pyro.luaVersion', GetVariable('jit.version', vtString));
  SetVariable('Pyro.version', PYRO_VERSION);

  dbg_setup_default(FState);

  // Set the panic handler
  lua_atpanic(FState, @LuaPanic);

  // Create the 'arg' table
  lua_updateargs(FState, 0);

  Result := True;
end;

procedure TPyLua.Close();
begin
  if FState = nil then Exit;
  FreeAndNil(FContext);
  lua_close(FState);
  FState := nil;
end;

procedure TPyLua.CheckLuaError(const AError: Integer);
var
  LErr: string;
begin
  if FState = nil then Exit;

  case AError of
    // success
    0:
      begin

      end;
    // a runtime error.
    LUA_ERRRUN:
      begin
        LErr := lua_tostring(FState, -1);
        lua_pop(FState, 1);
        raise EPyLuaException.CreateFmt('Runtime error [%s]', [LErr]);
      end;
    // memory allocation error. For such errors, Lua does not call the error handler function.
    LUA_ERRMEM:
      begin
        LErr := lua_tostring(FState, -1);
        lua_pop(FState, 1);
        raise EPyLuaException.CreateFmt('Memory allocation error [%s]', [LErr]);
      end;
    // error while running the error handler function.
    LUA_ERRERR:
      begin
        LErr := lua_tostring(FState, -1);
        lua_pop(FState, 1);
        raise EPyLuaException.CreateFmt
          ('Error while running the error handler function [%s]', [LErr]);
      end;
    LUA_ERRSYNTAX:
      begin
        LErr := lua_tostring(FState, -1);
        lua_pop(FState, 1);
        raise EPyLuaException.CreateFmt('Syntax Error [%s]', [LErr]);
      end
  else
    begin
      LErr := lua_tostring(FState, -1);
      lua_pop(FState, 1);
      raise EPyLuaException.CreateFmt('Unknown Error [%s]', [LErr]);
    end;
  end;
end;

function TPyLua.PushGlobalTableForSet(const AName: array of string; var AIndex: Integer): Boolean;
var
  LMarshall: TMarshaller;
  LI: Integer;
begin
  Result := False;

  if FState = nil then Exit;

  if Length(AName) < 2 then Exit;

  AIndex := Length(AName) - 1;

  // check if global table exists
  lua_getglobal(FState, LMarshall.AsAnsi(AName[0]).ToPointer);

  // table does not exist, create new one
  if lua_type(FState, lua_gettop(FState)) <> LUA_TTABLE then
  begin
    // clean up stack
    lua_pop(FState, 1);

    // create new table
    lua_newtable(FState);

    // make it global
    lua_setglobal(FState, LMarshall.AsAnsi(AName[0]).ToPointer);

    // push global table back on stack
    lua_getglobal(FState, LMarshall.AsAnsi(AName[0]).ToPointer);
  end;

  // process tables in global table at index 1+
  // global table on stack, process remaining tables
  for LI := 1 to AIndex - 1 do
  begin
    // check if table at field aIndex[i] exits
    lua_getfield(FState, LI, LMarshall.AsAnsi(AName[LI]).ToPointer);

    // table field does not exists, create a new one
    if lua_type(FState, -1) <> LUA_TTABLE then
    begin
      // clean up stack
      lua_pop(FState, 1);

      // push new table
      lua_newtable(FState);

      // set new table a field
      lua_setfield(FState, LI, LMarshall.AsAnsi(AName[LI]).ToPointer);

      // push field table back on stack
      lua_getfield(FState, LI, LMarshall.AsAnsi(AName[LI]).ToPointer);
    end;
  end;

  Result := True;
end;

function TPyLua.PushGlobalTableForGet(const AName: array of string; var AIndex: Integer): Boolean;
var
  LMarshall: TMarshaller;
  LI: Integer;
begin
  // assume false
  Result := False;

  if FState = nil then Exit;

  // check for valid table name count
  if Length(AName) < 2 then Exit;

  // init stack index
  AIndex := Length(AName) - 1;

  // lookup global table
  lua_getglobal(FState, LMarshall.AsAnsi(AName[0]).ToPointer);

  // check of global table exits
  if lua_type(FState, lua_gettop(FState)) = LUA_TTABLE then
  begin
    // process tables in global table at index 1+
    // global table on stack, process remaining tables
    for LI := 1 to AIndex - 1 do
    begin
      // get table at field aIndex[i]
      lua_getfield(FState, LI, LMarshall.AsAnsi(AName[LI]).ToPointer);

      // table field does not exists, exit
      if lua_type(FState, -1) <> LUA_TTABLE then
      begin
        // table name does not exit so we are out of here with an error
        Exit;
      end;
    end;
  end;

  // all table names exits we are good
  Result := True;
end;

procedure TPyLua.PushTValue(const AValue: System.RTTI.TValue);
var
  LUtf8s: RawByteString;
begin
  if FState = nil then Exit;

  case AValue.Kind of
    tkUnknown, tkChar, tkSet, tkMethod, tkVariant, tkArray, tkProcedure, tkRecord, tkInterface, tkDynArray, tkClassRef:
      begin
        lua_pushnil(FState);
      end;
    tkInteger:
      lua_pushinteger(FState, AValue.AsInteger);
    tkEnumeration:
      begin
        if AValue.IsType<Boolean> then
        begin
          if AValue.AsBoolean then
            lua_pushboolean(FState, Ord(True))
          else
            lua_pushboolean(FState, Ord(False));
        end
        else
          lua_pushinteger(FState, AValue.AsInteger);
      end;
    tkFloat:
      lua_pushnumber(FState, AValue.AsExtended);
    tkString, tkWChar, tkLString, tkWString, tkUString:
      begin
        LUtf8s := UTF8Encode(AValue.AsString);
        lua_pushstring(FState, PAnsiChar(LUtf8s));
      end;
    //tkClass:
    //  lua_pushlightuserdata(FState, Pointer(aValue.AsObject));
    tkInt64:
      lua_pushnumber(FState, AValue.AsInt64);
    //tkPointer:
    //  lua_pushlightuserdata(FState, Pointer(aValue.AsObject));
  end;
end;

function TPyLua.CallFunction(const AParams: array of TValue): TValue;
var
  LP: System.RTTI.TValue;
  LR: Integer;
begin
  if FState = nil then Exit;

  for LP in AParams do
    PushTValue(LP);
  LR := lua_pcall(FState, Length(AParams), 1, 0);
  CheckLuaError(LR);
  lua_pop(FState, 1);
  case lua_type(FState, -1) of
    LUA_TNIL:
      begin
        Result := nil;
      end;

    LUA_TBOOLEAN:
      begin
        Result := Boolean(lua_toboolean(FState, -1));
      end;

    LUA_TNUMBER:
      begin
        Result := lua_tonumber(FState, -1);
      end;

    LUA_TSTRING:
      begin
        Result := lua_tostring(FState, -1);
      end;
  else
    Result := nil;
  end;
end;

procedure TPyLua.Bundle(const AInFilename: string; const AOutFilename: string);
var
  LInFilename: string;
  LOutFilename: string;
begin
  if FState = nil then Exit;

  if AInFilename.IsEmpty then  Exit;
  if AOutFilename.IsEmpty then Exit;
  LInFilename := AInFilename.Replace('\', '/');
  LOutFilename := AOutFilename.Replace('\', '/');
  LoadBuffer(@cLUABUNDLE_LUA, Length(cLUABUNDLE_LUA), False);
  DoCall([PChar(LInFilename), PChar(LOutFilename)]);
end;

procedure TPyLua.OnBeforeReset();
begin
  if Assigned(FOnBeforeReset.Handler) then
  begin
    FOnBeforeReset.Handler(FOnBeforeReset.UserData);
  end;
end;

procedure TPyLua.OnAfterReset();
begin
  if Assigned(FOnAfterReset.Handler) then
  begin
    FOnAfterReset.Handler(FOnAfterReset.UserData);
  end;
end;

constructor TPyLua.Create();
begin
  inherited;

  FState := nil;
  Open;
end;

destructor TPyLua.Destroy();
begin
  Close();
  inherited;
end;

function  TPyLua.GetBeforeResetCallback(): TPyLuaResetCallback;
begin
  Result := FOnBeforeReset.Handler;
end;

procedure TPyLua.SetBeforeResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
begin
  FOnBeforeReset.Handler := AHandler;
  FOnBeforeReset.UserData := AUserData;
end;

function  TPyLua.GetAfterResetCallback(): TPyLuaResetCallback;
begin
  Result := FOnAfterReset.Handler;
end;

procedure TPyLua.SetAfterResetCallback(const AHandler: TPyLuaResetCallback; const AUserData: Pointer);
begin
  FOnAfterReset.Handler := AHandler;
  FOnAfterReset.UserData := AUserData;
end;

procedure TPyLua.Reset();
begin
  if FState = nil then Exit;

  OnBeforeReset();
  Close;
  Open;
  OnAfterReset();
end;

procedure TPyLua.AddSearchPath(const APath: string);
var
  LPathToAdd: string;
  LCurrentPath: string;
begin
  if not Assigned(FState) then Exit;

  // Check if APath already ends with "?.lua"
  if APath.EndsWith('?.lua') then
    LPathToAdd := APath
  else
    LPathToAdd := IncludeTrailingPathDelimiter(APath) + '?.lua';

  // Retrieve the current package.path
  lua_getglobal(FState, 'package'); // Get the "package" table
  if not lua_istable(FState, -1) then
    raise Exception.Create('"package" is not a table in the Lua state');

  lua_getfield(FState, -1, 'path'); // Get the "package.path" field
  if LongBool(lua_isstring(FState, -1)) then
    LCurrentPath := string(lua_tostring(FState, -1))
  else
    LCurrentPath := ''; // Default to empty if "path" is not set

  lua_pop(FState, 1); // Pop the "package.path" field

  // Check if the path is already included
  if Pos(LPathToAdd, LCurrentPath) = 0 then
  begin
    // Append the new path if not already included
    LCurrentPath := LPathToAdd + ';' + LCurrentPath;

    // Update package.path
    lua_pushstring(FState, PyUtils.AsUTF8(LCurrentPath, [])); // Push the updated path
    lua_setfield(FState, -2, 'path'); // Update "package.path"
  end;

  lua_pop(FState, 1); // Pop the "package" table
end;

function TPyLua.LoadFile(const AFilename: string; const AAutoRun: Boolean): Boolean;
var
  LMarshall: TMarshaller;
  LErr: string;
  LRes: Integer;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  if AFilename.IsEmpty then Exit;

  if not TFile.Exists(AFilename) then Exit;
  if AAutoRun then
    LRes := luaL_dofile(FState, LMarshall.AsUtf8(AFilename).ToPointer)
  else
    LRes := luaL_loadfile(FState, LMarshall.AsUtf8(AFilename).ToPointer);
  if LRes <> 0 then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;

  Result := True;
end;

procedure TPyLua.LoadString(const AData: string; const AAutoRun: Boolean);
var
  LMarshall: TMarshaller;
  LErr: string;
  LRes: Integer;
  LData: string;
begin
  if not Assigned(FState) then Exit;

  LData := AData;
  if LData.IsEmpty then Exit;

  if AAutoRun then
    LRes := luaL_dostring(FState, LMarshall.AsAnsi(LData).ToPointer)
  else
    LRes := luaL_loadstring(FState, LMarshall.AsAnsi(LData).ToPointer);

  if LRes <> 0 then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;
end;

procedure TPyLua.LoadStream(const AStream: TStream; const ASize: NativeUInt; const AAutoRun: Boolean);
var
  LMemStream: TMemoryStream;
  LSize: NativeUInt;
begin
  if not Assigned(FState) then Exit;

  LMemStream := TMemoryStream.Create;
  try
    if ASize = 0 then
      LSize := AStream.Size
    else
      LSize := ASize;
    LMemStream.Position := 0;
    LMemStream.CopyFrom(AStream, LSize);
    LoadBuffer(LMemStream.Memory, LMemStream.size, AAutoRun);
  finally
    FreeAndNil(LMemStream);
  end;
end;

procedure TPyLua.LoadBuffer(const AData: Pointer; const ASize: NativeUInt; const AAutoRun: Boolean);
var
  LMemStream: TMemoryStream;
  LRes: Integer;
  LErr: string;
  LSize: NativeUInt;
begin
  if not Assigned(FState) then Exit;

  LMemStream := TMemoryStream.Create;
  try
    LMemStream.Write(AData^, ASize);
    LMemStream.Position := 0;
    LSize := LMemStream.Size;
    if AAutoRun then
      LRes := luaL_dobuffer(FState, LMemStream.Memory, LSize, 'LoadBuffer')
    else
      LRes := luaL_loadbuffer(FState, LMemStream.Memory, LSize, 'LoadBuffer');
  finally
    FreeAndNil(LMemStream);
  end;

  if LRes <> 0 then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;
end;

procedure TPyLua.SaveByteCode(const AStream: TStream);
var
  LRet: Integer;
begin
  if not Assigned(FState) then Exit;

  if lua_type(FState, lua_gettop(FState)) <> LUA_TFUNCTION then Exit;

  try
    LRet := lua_dump(FState, LuaWrapperWriter, AStream);
    if LRet <> 0 then
      raise EPyLuaException.CreateFmt('lua_dump returned code %d', [LRet]);
  finally
    lua_pop(FState, 1);
  end;
end;

procedure TPyLua.LoadByteCode(const AStream: TStream; const AName: string; const AAutoRun: Boolean);
var
  LRes: NativeUInt;
  LErr: string;
  LMemStream: TMemoryStream;
  LMarshall: TMarshaller;
begin
  if not Assigned(FState) then Exit;
  if not Assigned(AStream) then Exit;
  if AStream.size <= 0 then Exit;

  LMemStream := TMemoryStream.Create;

  try
    LMemStream.CopyFrom(AStream, AStream.size);

    if AAutoRun then
    begin
      LRes := luaL_dobuffer(FState, LMemStream.Memory, LMemStream.size,
        LMarshall.AsAnsi(AName).ToPointer)
    end
    else
      LRes := luaL_loadbuffer(FState, LMemStream.Memory, LMemStream.size,
        LMarshall.AsAnsi(AName).ToPointer);
  finally
    LMemStream.Free;
  end;

  if LRes <> 0 then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;
end;

procedure TPyLua.PushLuaValue(const AValue: TPyLuaValue);
begin
  if not Assigned(FState) then Exit;

  case AValue.AsType of
    vtInteger:
      begin
        lua_pushinteger(FState, AValue.AsInteger);
      end;
    vtDouble:
      begin
        lua_pushnumber(FState, AValue.AsNumber);
      end;
    vtString:
      begin
        lua_pushstring(FState, PAnsiChar(UTF8Encode(AValue.AsString)));
      end;
    vtPointer:
      begin
        lua_pushlightuserdata(FState, AValue.AsPointer);
      end;
    vtBoolean:
      begin
        lua_pushboolean(FState, AValue.AsBoolean.ToInteger);
      end;
  else
    begin
      lua_pushnil(FState);
    end;
  end;
end;

var TLua_GetLuaValue_LStr: string = '';
function TPyLua.GetLuaValue(const AIndex: Integer): TPyLuaValue;
begin
  Result := Default(TPyLuaValue);

  if not Assigned(FState) then Exit;

  case lua_type(FState, AIndex) of
    LUA_TNIL:
      begin
        Result := nil;
      end;

    LUA_TBOOLEAN:
      begin
        Result.AsBoolean := Boolean(lua_toboolean(FState, AIndex));
      end;

    LUA_TNUMBER:
      begin
        Result.AsNumber := lua_tonumber(FState, AIndex);
      end;

    LUA_TSTRING:
      begin
        TLua_GetLuaValue_LStr := lua_tostring(FState, AIndex);
        Result := PChar(TLua_GetLuaValue_LStr);
      end;
  else
    begin
      Result := Default(TPyLuaValue);
    end;
  end;
end;

function TPyLua.DoCall(const AParams: array of TPyLuaValue): TPyLuaValue;
var
  LValue: TPyLuaValue;
  LRes: Integer;
begin
  if not Assigned(FState) then Exit;

  for LValue in AParams do
  begin
    PushLuaValue(LValue);
  end;

  LRes := lua_pcall(FState, Length(AParams), 1, 0);
  CheckLuaError(LRes);
  Result := GetLuaValue(-1);
end;

function TPyLua.DoCall(const AParamCount: Integer): TPyLuaValue;
var
  LRes: Integer;
begin
  Result := nil;
  if not Assigned(FState) then Exit;

  LRes := lua_pcall(FState, AParamCount, 1, 0);
  CheckLuaError(LRes);
  Result := GetLuaValue(-1);
  CleanStack();
end;

procedure TPyLua.CleanStack();
begin
  if FState = nil then Exit;

  lua_pop(FState, lua_gettop(FState));
end;

function TPyLua.Call(const AName: string; const AParams: array of TPyLuaValue): TPyLuaValue;
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
begin
  Result := nil;
  if not Assigned(FState) then Exit;

  if AName.IsEmpty then Exit;

  CleanStack();

  LItems := ParseTableNames(AName);

  if Length(LItems) > 1 then
    begin
      if not PushGlobalTableForGet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;

      lua_getfield(FState,  LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer);
    end
  else
    begin
      lua_getglobal(FState, LMarshall.AsAnsi(LItems[0]).ToPointer);
    end;

  if not lua_isnil(FState, lua_gettop(FState)) then
  begin
    if lua_isfunction(FState, -1) then
    begin
      Result := DoCall(AParams);
    end;
  end;

  CleanStack();
end;

function TPyLua.PrepCall(const AName: string): Boolean;
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  if AName.IsEmpty then Exit;

  CleanStack;

  LItems := ParseTableNames(AName);

  if Length(LItems) > 1 then
    begin
      if not PushGlobalTableForGet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;

      lua_getfield(FState,  LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer);
    end
  else
    begin
      lua_getglobal(FState, LMarshall.AsAnsi(LItems[0]).ToPointer);
    end;

  Result := True;
end;

function TPyLua.Call(const AParamCount: Integer): TPyLuaValue;
begin
  Result := nil;
  if not Assigned(FState) then Exit;

  if not lua_isnil(FState, lua_gettop(FState)) then
  begin
    if lua_isfunction(FState, -1) then
    begin
      Result := DoCall(AParamCount);
    end;
  end;
end;

function TPyLua.RoutineExist(const AName: string): Boolean;
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
  LCount: Integer;
  LName: string;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  LName := AName;
  if LName.IsEmpty then  Exit;

  LItems := ParseTableNames(LName);

  LCount := Length(LItems);

  if LCount > 1 then
    begin
      if not PushGlobalTableForGet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;
      lua_getfield(FState, LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer);
    end
  else
    begin
      lua_getglobal(FState, LMarshall.AsAnsi(LName).ToPointer);
    end;

  if not lua_isnil(FState, lua_gettop(FState)) then
  begin
    if lua_isfunction(FState, -1) then
    begin
      Result := True;
    end;
  end;

  CleanStack();
end;

procedure TPyLua.Run;
var
  LErr: string;
  LRes: Integer;
begin
  if not Assigned(FState) then Exit;

  // Check if the stack has any values
  if lua_gettop(FState) = 0 then
    raise EPyLuaException.Create('Lua stack is empty. Nothing to run.');

  // Check if the top of the stack is a function
  if lua_type(FState, lua_gettop(FState)) <> LUA_TFUNCTION then
    raise EPyLuaException.Create('Top of the stack is not a callable function.');

  // Call the function on the stack
  LRes := lua_pcall(FState, 0, LUA_MULTRET, 0);

  // Handle errors from pcall
  if LRes <> LUA_OK then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;
end;


function TPyLua.VariableExist(const AName: string): Boolean;
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
  LCount: Integer;
  LName: string;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  LName := AName;
  if LName.IsEmpty then Exit;

  LItems := ParseTableNames(LName);
  LCount := Length(LItems);

  if LCount > 1 then
    begin
      if not PushGlobalTableForGet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;
      lua_getfield(FState, LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer);
    end
  else if LCount = 1 then
    begin
      lua_getglobal(FState, LMarshall.AsAnsi(LName).ToPointer);
    end
  else
    begin
      Exit;
    end;

  if not lua_isnil(FState, lua_gettop(FState)) then
  begin
    Result := lua_isvariable(FState, -1);
  end;

  CleanStack();
end;

var TLua_GetVariable_LStr: string = '';
function TPyLua.GetVariable(const AName: string; const AType: TPyLuaValueType): TPyLuaValue;
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
  LCount: Integer;
  LName: string;
begin
  Result := Default(TPyLuaValue);
  if not Assigned(FState) then Exit;

  LName := AName;
  if LName.IsEmpty then Exit;

  LItems := ParseTableNames(LName);
  LCount := Length(LItems);

  if LCount > 1 then
    begin
      if not PushGlobalTableForGet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;
      lua_getfield(FState, LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer);
    end
  else if LCount = 1 then
    begin
      lua_getglobal(FState, LMarshall.AsAnsi(LName).ToPointer);
    end
  else
    begin
      Exit;
    end;

  case AType of
    vtInteger:
      begin
        Result.AsInteger := lua_tointeger(FState, -1);
      end;
    vtDouble:
      begin
        Result.AsNumber := lua_tonumber(FState, -1);
      end;
    vtString:
      begin
        TLua_GetVariable_LStr := lua_tostring(FState, -1);
        Result := PChar(TLua_GetVariable_LStr);
      end;
    vtPointer:
      begin
        Result.AsPointer := lua_touserdata(FState, -1);
      end;
    vtBoolean:
      begin
        Result.AsBoolean := Boolean(lua_toboolean(FState, -1));
      end;
  end;

  CleanStack();
end;

procedure TPyLua.SetVariable(const AName: string; const AValue: TPyLuaValue);
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LItems: TStringDynArray;
  LOk: Boolean;
  LCount: Integer;
  LName: string;
begin
  if not Assigned(FState) then Exit;

  LName := AName;
  if LName.IsEmpty then Exit;

  LItems := ParseTableNames(AName);
  LCount := Length(LItems);

  if LCount > 1 then
    begin
      if not PushGlobalTableForSet(LItems, LIndex) then
      begin
        CleanStack;
        Exit;
      end;
    end
  else if LCount < 1 then
    begin
      Exit;
    end;

  LOk := True;

  case AValue.AsType of
    vtInteger:
      begin
        lua_pushinteger(FState, AValue);
      end;
    vtDouble:
      begin
        lua_pushnumber(FState, AValue);
      end;
    vtString:
      begin
        lua_pushstring(FState, LMarshall.AsUtf8(AValue).ToPointer);
      end;
    vtPointer:
      begin
        lua_pushlightuserdata(FState, AValue);
      end;
    vtBoolean:
      begin
        lua_pushboolean(FState, AValue.AsBoolean.ToInteger);
      end;
  else
    begin
      LOk := False;
    end;
  end;

  if LOk then
  begin
    if LCount > 1 then
      begin
        lua_setfield(FState, LIndex, LMarshall.AsAnsi(LItems[LIndex]).ToPointer)
      end
    else
      begin
        lua_setglobal(FState, LMarshall.AsAnsi(LName).ToPointer);
      end;
  end;

  CleanStack();
end;

procedure TPyLua.RegisterRoutine(const AName: string; const ARoutine: TPyLuaFunction);
var
  LMethod: TMethod;
  LMarshall: TMarshaller;
  LIndex: Integer;
  LNames: array of string;
  LI: Integer;
  LItems: TStringDynArray;
  LCount: Integer;
begin
  if not Assigned(FState) then Exit;
  if AName.IsEmpty then Exit;

  // parse table LNames in table.table.xxx format
  LItems := ParseTableNames(AName);

  LCount := Length(LItems);

  SetLength(LNames, Length(LItems));

  for LI := 0 to High(LItems) do
  begin
    LNames[LI] := LItems[LI];
  end;

  // init sub table LNames
  if LCount > 1 then
    begin
      // push global table to stack
      if not PushGlobalTableForSet(LNames, LIndex) then
      begin
        CleanStack;
        Exit;
      end;

      // push closure
      LMethod.Code := TMethod(ARoutine).Code;
      LMethod.Data := TMethod(ARoutine).Data;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setfield(FState, -2, LMarshall.AsAnsi(LNames[LIndex]).ToPointer);

      CleanStack();
    end
  else if (LCount = 1) then
    begin
      // push closure
      LMethod.Code := TMethod(ARoutine).Code;
      LMethod.Data := TMethod(ARoutine).Data;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // set as global
      lua_setglobal(FState, LMarshall.AsAnsi(LNames[0]).ToPointer);
    end;
end;

procedure TPyLua.RegisterRoutine(const AName: string; const AData: Pointer; const ACode: Pointer);
var
  LMarshall: TMarshaller;
  LIndex: Integer;
  LNames: array of string;
  LI: Integer;
  LItems: TStringDynArray;
  LCount: Integer;
begin
  if not Assigned(FState) then Exit;
  if AName.IsEmpty then Exit;

  // parse table LNames in table.table.xxx format
  LItems := ParseTableNames(AName);

  LCount := Length(LItems);

  SetLength(LNames, Length(LItems));

  for LI := 0 to High(LItems) do
  begin
    LNames[LI] := LItems[LI];
  end;

  // init sub table LNames
  if LCount > 1 then
    begin
      // push global table to stack
      if not PushGlobalTableForSet(LNames, LIndex) then
      begin
        CleanStack;
        Exit;
      end;

      // push closure
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, ACode);
      lua_pushlightuserdata(FState, AData);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setfield(FState, -2, LMarshall.AsAnsi(LNames[LIndex]).ToPointer);

      CleanStack();
    end
  else if (LCount = 1) then
    begin
      // push closure
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, ACode);
      lua_pushlightuserdata(FState, AData);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // set as global
      lua_setglobal(FState, LMarshall.AsAnsi(LNames[0]).ToPointer);
    end;
end;

procedure TPyLua.RegisterRoutines(const AClass: TClass);
var
  LRttiContext: TRttiContext;
  LRttiType: TRttiType;
  LRttiMethod: TRttiMethod;
  LMethodAutoSetup: TRttiMethod;

  LRttiParameters: TArray<System.Rtti.TRttiParameter>;
  LMethod: TMethod;
  LMarshall: TMarshaller;
begin
  if not Assigned(FState) then Exit;

  LRttiType := LRttiContext.GetType(AClass);
  LMethodAutoSetup := nil;

  for LRttiMethod in LRttiType.GetMethods do
  begin
    if (LRttiMethod.MethodKind <> mkClassProcedure) then continue;
    if (LRttiMethod.Visibility <> mvPublic) then continue;

    LRttiParameters := LRttiMethod.GetParameters;

    // check for public AutoSetup class function
    if SameText(LRttiMethod.Name, cLuaAutoSetup) then
    begin
      if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLua) then
      begin
        // call auto setup for this class
        // LRttiMethod.Invoke(aClass, [Self]);
        LMethodAutoSetup := LRttiMethod;
      end;
      continue;
    end;

    { Check if one parameter of type ILuaContext is present }
    if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLuaContext) then
    begin
      // push closure
      LMethod.Code := LRttiMethod.CodeAddress;
      LMethod.Data := AClass;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setglobal(FState, LMarshall.AsAnsi(LRttiMethod.Name).ToPointer);
    end;
  end;

  // clean up stack
  CleanStack();

  // invoke autosetup?
  if Assigned(LMethodAutoSetup) then
  begin
    // call auto setup LMethod
    LMethodAutoSetup.Invoke(AClass, [Self]);

    // clean up stack
    CleanStack();
  end;
end;

procedure TPyLua.RegisterRoutines(const AObject: TObject);
var
  LRttiContext: TRttiContext;
  LRttiType: TRttiType;
  LRttiMethod: TRttiMethod;
  LMethodAutoSetup: TRttiMethod;
  LRttiParameters: TArray<System.Rtti.TRttiParameter>;
  LMethod: TMethod;
  LMarshall: TMarshaller;
begin
  if not Assigned(FState) then Exit;

  LRttiType := LRttiContext.GetType(AObject.ClassType);
  LMethodAutoSetup := nil;
  for LRttiMethod in LRttiType.GetMethods do
  begin
    if (LRttiMethod.MethodKind <> mkProcedure) then  continue;
    if (LRttiMethod.Visibility <> mvPublic) then continue;

    LRttiParameters := LRttiMethod.GetParameters;

    // check for public AutoSetup class function
    if SameText(LRttiMethod.Name, cLuaAutoSetup) then
    begin
      if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLua) then
      begin
        // call auto setup for this class
        LMethodAutoSetup := LRttiMethod;
      end;
      continue;
    end;

    { Check if one parameter of type ILuaContext is present }
    if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLuaContext) then
    begin
      // push closure
      LMethod.Code := LRttiMethod.CodeAddress;
      LMethod.Data := AObject;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setglobal(FState, LMarshall.AsAnsi(LRttiMethod.Name).ToPointer);
    end;
  end;

  // clean up stack
  CleanStack();

  // invoke autosetup?
  if Assigned(LMethodAutoSetup) then
  begin
    // call auto setup LMethod
    LMethodAutoSetup.Invoke(AObject, [Self]);

    // clean up stack
    CleanStack();
  end;
end;

procedure TPyLua.RegisterRoutines(const ATables: string; const AClass: TClass; const ATableName: string);
var
  LRttiContext: TRttiContext;
  LRttiType: TRttiType;
  LRttiMethod: TRttiMethod;
  LMethodAutoSetup: TRttiMethod;

  LRttiParameters: TArray<System.Rtti.TRttiParameter>;
  LMethod: TMethod;
  LMarshall: TMarshaller;
  LIndex: Integer;
  LNames: array of string;
  TblName: string;
  LI: Integer;
  LItems: TStringDynArray;
  LLastIndex: Integer;
begin
  if not Assigned(FState) then Exit;

  // init the routines table name
  if ATableName.IsEmpty then
    TblName := AClass.ClassName
  else
    TblName := ATableName;

  // parse table LNames in table.table.xxx format
  LItems := ParseTableNames(ATables);

  // init sub table LNames
  if Length(LItems) > 0 then
  begin
    SetLength(LNames, Length(LItems) + 2);

    for LI := 0 to High(LItems) do
    begin
      LNames[LI] := LItems[LI];
    end;

    LLastIndex := Length(LItems);

    // set last as table name for functions
    LNames[LLastIndex] := TblName;
    LNames[LLastIndex + 1] := TblName;
  end
  else
  begin
    SetLength(LNames, 2);
    LNames[0] := TblName;
    LNames[1] := TblName;
  end;

  // push global table to stack
  if not PushGlobalTableForSet(LNames, LIndex) then
  begin
    CleanStack();
    Exit;
  end;

  LRttiType := LRttiContext.GetType(AClass);
  LMethodAutoSetup := nil;
  for LRttiMethod in LRttiType.GetMethods do
  begin
    if (LRttiMethod.MethodKind <> mkClassProcedure) then
      continue;
    if (LRttiMethod.Visibility <> mvPublic) then
      continue;

    LRttiParameters := LRttiMethod.GetParameters;

    // check for public AutoSetup class function
    if SameText(LRttiMethod.Name, cLuaAutoSetup) then
    begin
      if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLua) then
      begin
        // call auto setup for this class
        // LRttiMethod.Invoke(aClass, [Self]);
        LMethodAutoSetup := LRttiMethod;
      end;
      continue;
    end;

    { Check if one parameter of type ILuaContext is present }
    if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLuaContext) then
    begin
      // push closure
      LMethod.Code := LRttiMethod.CodeAddress;
      LMethod.Data := AClass;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setfield(FState, -2, LMarshall.AsAnsi(LRttiMethod.Name).ToPointer);
    end;
  end;

  // clean up stack
  CleanStack();

  // invoke autosetup?
  if Assigned(LMethodAutoSetup) then
  begin
    // call auto setup LMethod
    LMethodAutoSetup.Invoke(AClass, [Self]);

    // clean up stack
    CleanStack();
  end;
end;

procedure TPyLua.RegisterRoutines(const ATables: string; const AObject: TObject; const ATableName: string);
var
  LRttiContext: TRttiContext;
  LRttiType: TRttiType;
  LRttiMethod: TRttiMethod;
  LMethodAutoSetup: TRttiMethod;
  LRttiParameters: TArray<System.Rtti.TRttiParameter>;
  LMethod: TMethod;
  LMarshall: TMarshaller;
  LIndex: Integer;
  LNames: array of string;
  TblName: string;
  LI: Integer;
  LItems: TStringDynArray;
  LLastIndex: Integer;
begin
  if not Assigned(FState) then Exit;

  // init the routines table name
  if ATableName.IsEmpty then
    TblName := AObject.ClassName
  else
    TblName := ATableName;

  // parse table LNames in table.table.xxx format
  LItems := ParseTableNames(ATables);

  // init sub table LNames
  if Length(LItems) > 0 then
    begin
      SetLength(LNames, Length(LItems) + 2);

      LLastIndex := 0;
      for LI := 0 to High(LItems) do
      begin
        LNames[LI] := LItems[LI];
        LLastIndex := LI;
      end;

      // set last as table name for functions
      LNames[LLastIndex] := TblName;
      LNames[LLastIndex + 1] := TblName;
    end
  else
    begin
      SetLength(LNames, 2);
      LNames[0] := TblName;
      LNames[1] := TblName;
    end;

  // push global table to stack
  if not PushGlobalTableForSet(LNames, LIndex) then
  begin
    CleanStack();
    Exit;
  end;

  LRttiType := LRttiContext.GetType(AObject.ClassType);
  LMethodAutoSetup := nil;
  for LRttiMethod in LRttiType.GetMethods do
  begin
    if (LRttiMethod.MethodKind <> mkProcedure) then continue;
    if (LRttiMethod.Visibility <> mvPublic) then continue;

    LRttiParameters := LRttiMethod.GetParameters;

    // check for public AutoSetup class function
    if SameText(LRttiMethod.Name, cLuaAutoSetup) then
    begin
      if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLua) then
      begin
        // call auto setup for this class
        // LRttiMethod.Invoke(aObject.ClassType, [Self]);
        LMethodAutoSetup := LRttiMethod;
      end;
      continue;
    end;

    { Check if one parameter of type ILuaContext is present }
    if (Length(LRttiParameters) = 1) and (Assigned(LRttiParameters[0].ParamType)) and (LRttiParameters[0].ParamType.TypeKind = tkInterface) and (TRttiInterfaceType(LRttiParameters[0].ParamType).GUID = IPyLuaContext) then
    begin
      // push closure
      LMethod.Code := LRttiMethod.CodeAddress;
      LMethod.Data := AObject;
      lua_pushlightuserdata(FState, Self);
      lua_pushlightuserdata(FState, LMethod.Code);
      lua_pushlightuserdata(FState, LMethod.Data);
      lua_pushcclosure(FState, @LuaWrapperClosure, 3);

      // add field to table
      lua_setfield(FState, -2, LMarshall.AsAnsi(LRttiMethod.Name).ToPointer);
    end;
  end;

  // clean up stack
  CleanStack();

  // invoke autosetup?
  if Assigned(LMethodAutoSetup) then
  begin
    // call auto setup LMethod
    LMethodAutoSetup.Invoke(AObject, [Self]);

    // clean up stack
    CleanStack();
  end;
end;

procedure TPyLua.CompileToStream(const AFilename: string; const AStream: TStream; const ACleanOutput: Boolean);
var
  LInFilename: string;
  LBundleFilename: string;
begin
  if not Assigned(FState) then Exit;

  LInFilename := AFilename;
  LBundleFilename := TPath.GetFileNameWithoutExtension(LInFilename) + '_bundle.lua';
  LBundleFilename := TPath.Combine(TPath.GetDirectoryName(LInFilename), LBundleFilename);
  Bundle(LInFilename, LBundleFilename);
  LoadFile(PChar(LBundleFilename), False);
  SaveByteCode(AStream);
  CleanStack;

  if ACleanOutput then
  begin
    if TFile.Exists(LBundleFilename) then
    begin
      TFile.Delete(LBundleFilename);
    end;
  end;
end;

const
  PAYLOADID = 'fa12d33b4ed84bc6a6dc4c2fd07a31e8';

function TPyLua.PayloadExist(): Boolean;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  Result := PyUtils.ResourceExists(HInstance, PAYLOADID);
end;

function TPyLua.SavePayloadExe(const AFilename: string): Boolean;
  var
    LDestinationDir: string;
begin
  // Extract the directory portion of the destination path
  LDestinationDir := TPath.GetDirectoryName(AFilename);

  // Create the directory if it doesn't exist
  if not LDestinationDir.IsEmpty and not TDirectory.Exists(LDestinationDir) then
    TDirectory.CreateDirectory(LDestinationDir);

  // Perform the file copy
  TFile.Copy(ParamStr(0), AFilename, True);

  Result := TFile.Exists(AFilename);
end;

function TPyLua.StorePayload(const ASourceFilename, AEXEFilename: string): Boolean;
var
  LStream: TMemoryStream;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  if not TFile.Exists(ASourceFilename) then Exit;
  if not TFile.Exists(AEXEFilename) then Exit;
  if not PyUtils.IsValidWin64PE(AEXEFilename) then Exit;

  LStream := TMemoryStream.Create();
  try
    CompileToStream(ASourceFilename, LStream, True);
    if LStream.Size > 0 then
    begin
      Result := PyUtils.AddResFromMemory(AEXEFilename, PAYLOADID, LStream.Memory, LStream.Size);
    end;
  finally
    LStream.Free();
  end;
end;

function TPyLua.UpdatePayloadIcon(const AEXEFilename, AIconFilename: string): Boolean;
begin
  Result := False;
  if not TFile.Exists(AEXEFilename) then Exit;
  if not TFile.Exists(AIconFilename) then Exit;
  if not PyUtils.IsValidWin64PE(AEXEFilename) then Exit;
  PyUtils.UpdateIconResource(AEXEFilename, AIconFilename);
  Result := True;
end;

function TPyLua.UpdatePayloadVersionInfo(const AEXEFilename: string; const AMajor,
  AMinor, APatch: Word; const AProductName, ADescription, AFilename,
  ACompanyName, ACopyright: string): Boolean;
begin
  Result := False;
  if not TFile.Exists(AEXEFilename) then Exit;
  if not PyUtils.IsValidWin64PE(AEXEFilename) then Exit;
  PyUtils.UpdateVersionInfoResource(AEXEFilename, AMajor, AMinor, APatch, AProductName,
    ADescription, AFilename, ACompanyName, ACopyright);
  Result := True;
end;

function TPyLua.RunPayload(): Boolean;
var
  LResStream: TResourceStream;
  LErr: string;
  LRes: Integer;
begin
  Result := False;
  if not Assigned(FState) then Exit;

  if not PayloadExist() then Exit;

  Reset();

  LResStream := TResourceStream.Create(HInstance, PAYLOADID, RT_RCDATA);
  try
    LoadBuffer(LResStream.Memory, LResStream.Size, False);
    LResStream.Free();
    LResStream := nil;
  finally
    if Assigned(LResStream) then
      LResStream.Free();
  end;

  // Check if the stack has any values
  if lua_gettop(FState) = 0 then
    raise EPyLuaException.Create('Lua stack is empty. Nothing to run.');

  // Check if the top of the stack is a function
  if lua_type(FState, lua_gettop(FState)) <> LUA_TFUNCTION then
    raise EPyLuaException.Create('Top of the stack is not a callable function.');

  // Call the function on the stack
  LRes := lua_pcall(FState, 0, LUA_MULTRET, 0);

  // Handle errors from pcall
  if LRes <> LUA_OK then
  begin
    LErr := lua_tostring(FState, -1);
    lua_pop(FState, 1);
    raise EPyLuaException.Create(LErr);
  end;

  Result := True;
end;

procedure TPyLua.UpdateArgs(const AStartIndex: Integer);
var
  LStartIndex: Integer;
begin
  if not Assigned(FState) then Exit;

  LStartIndex := EnsureRange(AStartIndex, 0, ParamCount-1);
  lua_updateargs(FState, LStartIndex);
end;

procedure TPyLua.SetGCStepSize(const AStep: Integer);
begin
  FGCStep := AStep;
end;

function TPyLua.GetGCStepSize(): Integer;
begin
  Result := FGCStep;
end;

function TPyLua.GetGCMemoryUsed(): Integer;
begin
  Result := 0;
  if not Assigned(FState) then Exit;

  Result := lua_gc(FState, LUA_GCCOUNT, FGCStep);
end;

procedure TPyLua.CollectGarbage();
begin
  if not Assigned(FState) then Exit;

  lua_gc(FState, LUA_GCSTEP, FGCStep);
end;

procedure TPyLua.Print(const AText: string; const AArgs: array of const);
begin
  if not PyUtils.HasConsoleOutput() then Exit;
  Write(Format(AText, AArgs));
end;

procedure TPyLua.PrintLn(const AText: string; const AArgs: array of const);
begin
  if not PyUtils.HasConsoleOutput() then Exit;
  WriteLn(Format(AText, AArgs));
end;

{$ENDREGION}

{$REGION ' Pyro.Color '}
function  TPyColor.FromByte(const r, g, b, a: Byte): TPyColor;
begin
  Result.r := EnsureRange(r, 0, 255) / $FF;
  Result.g := EnsureRange(g, 0, 255) / $FF;
  Result.b := EnsureRange(b, 0, 255) / $FF;
  Result.a := EnsureRange(a, 0, 255) / $FF;

  Self := Result;
end;

function  TPyColor.FromFloat(const r, g, b, a: Single): TPyColor;
begin
  Result.r := EnsureRange(r, 0, 1);
  Result.g := EnsureRange(g, 0, 1);
  Result.b := EnsureRange(b, 0, 1);
  Result.a := EnsureRange(a, 0, 1);

  Self := Result;
end;

function  TPyColor.Fade(const ATo: TPyColor; const APos: Single): TPyColor;
var
  LPos: Single;
begin
  LPos := EnsureRange(APos, 0, 1);
  Result.r := r + ((ATo.r - r) * LPos);
  Result.g := g + ((ATo.g - g) * LPos);
  Result.b := b + ((ATo.b - b) * LPos);
  Result.a := a + ((ATo.a - a) * LPos);
end;

function  TPyColor.IsEqual(const AColor: TPyColor): Boolean;
begin
  Result := (r = AColor.r) and
            (g = AColor.g) and
            (b = AColor.b) and
            (a = AColor.a);
end;

{$ENDREGION}

{$REGION ' Pyro.Window '}
procedure Window_ResizeCallback(AWindow: PGLFWwindow; AWidth, AHeight: Integer); cdecl;
var
  LWindow: TPyWindow;
  LAspectRatio: Single;
  LNewWidth, LNewHeight: Integer;
  LXOffset, LYOffset: Integer;
  LWidth, LHeight: Integer;
begin
  LWindow := glfwGetWindowUserPointer(AWindow);
  if not Assigned(LWindow) then Exit;

  LWidth :=  Round(LWindow.GetVirtualSize().w);
  LHeight := Round(LWindow.GetVirtualSize().h);

  // Calculate aspect ratio based on the initial window size
  LAspectRatio := LWidth / LHeight;

  // Adjust the viewport based on the new window size
  if AWidth / LAspectRatio <= AHeight then
  begin
    LNewWidth := AWidth;
    LNewHeight := Round(AWidth / LAspectRatio);
    LXOffset := 0;
    LYOffset := (AHeight - LNewHeight) div 2;
  end
  else
  begin
    LNewWidth := Round(AHeight * LAspectRatio);
    LNewHeight := AHeight;
    LXOffset := (AWidth - LNewWidth) div 2;
    LYOffset := 0;
  end;

  // Set the viewport to maintain the aspect ratio and leave black bars
  glViewport(LXOffset, LYOffset, LNewWidth, LNewHeight);

  // Set the scissor box to match the virtual resolution area
  glScissor(LXOffset, LYOffset, LNewWidth, LNewHeight);

  // Set up the orthographic projection
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0, LWidth, LHeight, 0, -1, 1);  // Always map to the virtual coordinates

  // Back to modelview mode
  glMatrixMode(GL_MODELVIEW);

  LWindow.FViewport.pos.x := LXOffset;
  LWindow.FViewport.pos.y := LYOffset;
  LWindow.FViewport.size.w := LNewWidth;
  LWindow.FViewport.size.h := LNewHeight;
end;

procedure TWindow_ScrollCallback(AWindow: PGLFWwindow; AOffsetX, AOffsetY: Double); cdecl;
var
  LWindow: TPyWindow;
begin
  LWindow := glfwGetWindowUserPointer(AWindow);
  if not Assigned(LWindow) then Exit;

  // Save the scroll offsets
  LWindow.FMouseWheel := PyMath.Vector(AOffsetX, AOffsetY);
end;

procedure TPyWindow.SetDefaultIcon();
var
  IconHandle: HICON;
begin
  if not Assigned(FHandle) then Exit;

  IconHandle := LoadIcon(GetModuleHandle(nil), 'MAINICON');
  if IconHandle <> 0 then
  begin
    SendMessage(glfwGetWin32Window(FHandle), WM_SETICON, ICON_BIG, IconHandle);
  end;
end;

constructor TPyWindow.Create();
begin
  inherited;
end;

destructor TPyWindow.Destroy();
begin
  Close();
  inherited;
end;

function  TPyWindow.Open(const ATitle: string; const AVirtualWidth: Cardinal; const AVirtualHeight: Cardinal; const AParent: NativeUInt): Boolean;
var
  LWindow: PGLFWwindow;
  LWidth: Integer;
  LHeight: Integer;
  LHWNative: HWND;
  LStyle: NativeInt;
begin
  Result := False;

  if Assigned(FHandle) then Exit;

  LWidth := AVirtualWidth;
  LHeight := AVirtualHeight;

  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);

  // set hints if child or standalone window
  if AParent <> 0 then
    begin
      glfwWindowHint(GLFW_DECORATED, GLFW_FALSE);
      //glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);
    end
  else
    begin
      glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);
    end;

  glfwWindowHint(GLFW_SAMPLES, 4);

  // Create a windowed mode window and its OpenGL context
  LWindow := glfwCreateWindow(LWidth, LHeight, PyUtils.AsUTF8(ATitle, []), nil, nil);
  if LWindow = nil then Exit;

  // set hints if child or standalone window
  if AParent <> 0 then
  begin
    LHWNative := glfwGetWin32Window(LWindow);
    WinApi.Windows.SetParent(LHWNative, AParent);
    LStyle := GetWindowLong(LHWNative, GWL_STYLE);
    LStyle := LStyle and not WS_POPUP; // remove popup style
    LStyle := LStyle or WS_CHILDWINDOW; // add childwindow style
    SetWindowLong(LHWNative, GWL_STYLE, LStyle);
  end;

  // Make the window's context current
  glfwMakeContextCurrent(LWindow);

  // init OpenGL extensions
  if not LoadOpenGL() then
  begin
    glfwMakeContextCurrent(nil);
    glfwDestroyWindow(LWindow);
    Exit;
  end;

  // Set the resize callback
  glfwSetFramebufferSizeCallback(LWindow, Window_ResizeCallback);

  // Set the mouse scroll callback
  glfwSetScrollCallback(LWindow, TWindow_ScrollCallback);

  // Enable the scissor test
  glEnable(GL_SCISSOR_TEST);

  // Enable Line Smoothing
  glEnable(GL_LINE_SMOOTH);
  glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);

  // Enable Polygon Smoothing
  glEnable(GL_POLYGON_SMOOTH);
  glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);

  // Enable Point Smoothing
  glEnable(GL_POINT_SMOOTH);
  glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);

  // Enable Multisampling for anti-aliasing (if supported)
  glEnable(GL_MULTISAMPLE);

  FHandle := LWindow;

  glfwGetWindowPos(FHandle, @FWindowedPosX, @FWindowedPosY);
  glfwGetWindowSize(FHandle, @FWindowedWidth, @FWindowedHeight);

  FVirtualSize.w := LWidth;
  FVirtualSize.h := LHeight;
  FParent := AParent;

  glGetIntegerv(GL_MAX_TEXTURE_SIZE, @FMaxTextureSize);
  glfwSetInputMode(FHandle, GLFW_STICKY_KEYS, GLFW_TRUE);
  glfwSetInputMode(FHandle, GLFW_STICKY_MOUSE_BUTTONS, GLFW_TRUE);

  glfwSwapInterval(0);

  glfwSetWindowUserPointer(FHandle, Self);

  if FParent = 0 then
    Center();

  glfwGetWindowSize(FHandle, @LWidth, @LHeight);

  FViewport.pos.x := 0;
  FViewport.pos.x := 0;
  FViewport.size.w := LWidth;
  FViewport.size.h := LHeight;

  SetDefaultIcon();

  SetTargetFrameRate(PyDEFAULT_FPS);

  Result := True;
end;

procedure TPyWindow.Close();
begin
  if not Assigned(FHandle) then Exit;
  glfwMakeContextCurrent(nil);
  glfwDestroyWindow(FHandle);
  FHandle := nil;
end;

function  TPyWindow.GetTitle(): string;
var
  LHwnd: HWND;
  LLen: Integer;
  LTitle: PChar;
begin
  Result := '';
  if not Assigned(FHandle) then Exit;

  LHwnd := glfwGetWin32Window(FHandle);
  LLen := GetWindowTextLength(LHwnd);
  GetMem(LTitle, LLen + 1);
  try
    GetWindowText(LHwnd, LTitle, LLen + 1);
    Result := string(LTitle);
  finally
    FreeMem(LTitle);
  end;
end;

procedure TPyWindow.SetTitle(const ATitle: string);
begin
  if not Assigned(FHandle) then Exit;

  SetWindowText(glfwGetWin32Window(FHandle), ATitle);
end;

procedure TPyWindow.Resize(const AWidth, AHeight: Cardinal);
begin
  glfwSetWindowSize(FHandle, AWidth, AHeight);
end;

procedure TPyWindow.SetSizeLimits(const AMinWidth, AMinHeight, AMaxWidth, AMaxHeight: Integer);
var
  LScale: TPyPoint;
  LMinWidth, LMinHeight, LMaxWidth, LMaxHeight: Integer;
begin
  glfwGetWindowContentScale(FHandle, @LScale.x, @LScale.y);

  LMinWidth := AMinWidth;
  LMinHeight := AMinHeight;
  LMaxWidth := AMaxWidth;
  LMaxHeight := AMaxHeight;

  if LMinWidth <> GLFW_DONT_CARE then
    LMinWidth := Round(LMinWidth * LScale.x);

  if LMinHeight <> GLFW_DONT_CARE then
    LMinHeight := Round(LMinHeight * LScale.y);


  if LMaxWidth <> GLFW_DONT_CARE then
    LMaxWidth := Round(LMaxWidth * LScale.x);


  if LMaxHeight <> GLFW_DONT_CARE then
    LMaxHeight := Round(LMaxHeight * LScale.y);

  glfwSetWindowSizeLimits(FHandle,LMinWidth, LMinHeight, LMaxWidth, LMaxHeight);
end;

procedure TPyWindow.ToggleFullscreen();
var
  LMonitor: PGLFWmonitor;
  LMode: PGLFWvidmode;
begin
  if not Assigned(FHandle) then Exit;

  if FIsFullscreen then
    begin
      // Switch to windowed mode using the saved window position and size
      glfwSetWindowMonitor(FHandle, nil, FWindowedPosX, FWindowedPosY, FWindowedWidth, FWindowedHeight, 0);
      FIsFullscreen := False;
    end
  else
    begin
      // Get the primary monitor and its video mode
      LMonitor := glfwGetPrimaryMonitor();
      LMode := glfwGetVideoMode(LMonitor);

      // Save the windowed mode position and size
      glfwGetWindowPos(FHandle, @FWindowedPosX, @FWindowedPosY);
      glfwGetWindowSize(FHandle, @FWindowedWidth, @FWindowedHeight);

      // Switch to fullscreen mode at the desktop resolution
      glfwSetWindowMonitor(FHandle, LMonitor, 0, 0, LMode.Width, LMode.Height, LMode.RefreshRate);
      FIsFullscreen := True;
    end;
end;

function  TPyWindow.IsFullscreen(): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := FIsFullscreen;
end;

function  TPyWindow.GetVirtualSize(): TPySize;
begin
  Result.w := 0;
  Result.h := 0;
  if not Assigned(FHandle) then Exit;
  Result := FVirtualSize;
end;

function  TPyWindow.HasFocus(): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := Boolean(glfwGetWindowAttrib(FHandle, GLFW_FOCUSED) = GLFW_TRUE);
end;

function  TPyWindow.GetSize(): TPySize;
var
  LWindowWidth, LWindowHeight: Double;
begin
  Result.w := 0;
  Result.h := 0;
  if not Assigned(FHandle) then Exit;

  glfwGetWindowSize(FHandle, @LWindowWidth, @LWindowHeight);
  Result.w := LWindowWidth;
  Result.h := LWindowHeight;
end;

function  TPyWindow.GetScale(): TPySize;
begin
  Result.w := 0;
  Result.h := 0;
  if not Assigned(FHandle) then Exit;

  glfwGetWindowContentScale(FHandle, @Result.w, @Result.h);
end;

function  TPyWindow.GetMaxTextureSize(): Integer;
begin
  Result := FMaxTextureSize;
end;


function  TPyWindow.GetViewport(): TPyRect;
begin
  Result.pos.x := 0;
  Result.pos.y := 0;
  Result.size.w := 0;
  Result.size.h := 0;
  if not Assigned(FHandle) then Exit;
  Result := FViewport;
end;

procedure TPyWindow.Center();
var
  LMonitor: PGLFWmonitor;
  LVideoMode: PGLFWvidmode;
  LScreenWidth, LScreenHeight: Integer;
  LWindowWidth, LWindowHeight: Integer;
  LPosX, LPosY: Integer;
begin
  if not Assigned(FHandle) then Exit;

  if FIsFullscreen then Exit;

  // Get the primary monitor
  LMonitor := glfwGetPrimaryMonitor;

  // Get the video mode of the monitor (i.e., resolution)
  LVideoMode := glfwGetVideoMode(LMonitor);

  // Get the screen width and height
  LScreenWidth := LVideoMode.width;
  LScreenHeight := LVideoMode.height;

  // Get the window width and height
  glfwGetWindowSize(FHandle, @LWindowWidth, @LWindowHeight);

  // Calculate the position to center the window
  LPosX := (LScreenWidth - LWindowWidth) div 2;
  LPosY := (LScreenHeight - LWindowHeight) div 2;

  // Set the window position
  glfwSetWindowPos(FHandle, LPosX, LPosY);
end;

function  TPyWindow.ShouldClose(): Boolean;
begin
  Result := True;
  if not Assigned(FHandle) then Exit;
  Result := Boolean(glfwWindowShouldClose(FHandle) = GLFW_TRUE);
  if Result then
  begin
    PyUtils.AsyncWaitForAllToTerminate();
  end;
end;

procedure TPyWindow.SetShouldClose(const AClose: Boolean);
begin
  if not Assigned(FHandle) then Exit;
  glfwSetWindowShouldClose(FHandle, Ord(AClose))
end;

procedure TPyWindow.StartFrame();
begin
  if not Assigned(FHandle) then Exit;

  StartTiming();
  PyVideo.Update(Self);
  PyAudio.Update();
  PyUtils.AsyncProcess();
  glfwPollEvents();
end;

procedure TPyWindow.EndFrame();
begin
  if not Assigned(FHandle) then Exit;

  // Reset mouse wheel deltas
  FMouseWheel := PyMath.Vector(0,0);

  StopTiming();
end;

procedure TPyWindow.StartDrawing();
begin
  if not Assigned(FHandle) then Exit;

  // Clear the entire screen to black (this will create the black bars)
  glClearColor(0, 0, 0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  ResetDrawing();
end;

procedure TPyWindow.ResetDrawing();
begin
  if not Assigned(FHandle) then Exit;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0, FVirtualSize.w, FVirtualSize.h, 0, -1, 1);  // Set orthographic projection
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
end;

procedure TPyWindow.EndDrawing();
begin
  if not Assigned(FHandle) then Exit;
  glfwSwapBuffers(FHandle);
end;

procedure TPyWindow.Clear(const AColor: TPyColor);
begin
  if not Assigned(FHandle) then Exit;
  glClearColor(AColor.r, AColor.g, AColor.b, AColor.a);
  glClear(GL_COLOR_BUFFER_BIT); // Only the viewport area is affected
end;

procedure TPyWindow.DrawLine(const X1, Y1, X2, Y2: Single; const AColor: TPyColor; const AThickness: Single);
begin
  if not Assigned(FHandle) then Exit;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_LINES);
    glVertex2f(X1, Y1);
    glVertex2f(X2, Y2);
  glEnd;
end;

procedure TPyWindow.DrawRect(const X, Y, AWidth, AHeight, AThickness: Single; const AColor: TPyColor; const AAngle: Single);
var
  LHalfWidth, LHalfHeight: Single;
begin
  if not Assigned(FHandle) then Exit;

  LHalfWidth := AWidth / 2;
  LHalfHeight := AHeight / 2;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);

  glPushMatrix;  // Save the current matrix

  // Translate to the center point
  glTranslatef(X, Y, 0);

  // Rotate around the center
  glRotatef(AAngle, 0, 0, 1);

  glBegin(GL_LINE_LOOP);
    glVertex2f(-LHalfWidth, -LHalfHeight);      // Bottom-left corner
    glVertex2f(LHalfWidth, -LHalfHeight);       // Bottom-right corner
    glVertex2f(LHalfWidth, LHalfHeight);        // Top-right corner
    glVertex2f(-LHalfWidth, LHalfHeight);       // Top-left corner
  glEnd;

  glPopMatrix;  // Restore the original matrix
end;

procedure TPyWindow.DrawFilledRect(const X, Y, AWidth, AHeight: Single; const AColor: TPyColor; const AAngle: Single);
var
  LHalfWidth, LHalfHeight: Single;
begin
  if not Assigned(FHandle) then Exit;

  LHalfWidth := AWidth / 2;
  LHalfHeight := AHeight / 2;

  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);

  glPushMatrix;  // Save the current matrix

  // Translate to the center point
  glTranslatef(X, Y, 0);

  // Rotate around the center
  glRotatef(AAngle, 0, 0, 1);

  glBegin(GL_QUADS);
    glVertex2f(-LHalfWidth, -LHalfHeight);      // Bottom-left corner
    glVertex2f(LHalfWidth, -LHalfHeight);       // Bottom-right corner
    glVertex2f(LHalfWidth, LHalfHeight);        // Top-right corner
    glVertex2f(-LHalfWidth, LHalfHeight);       // Top-left corner
  glEnd;

  glPopMatrix;  // Restore the original matrix
end;

procedure TPyWindow.DrawCircle(const X, Y, ARadius, AThickness: Single; const AColor: TPyColor);
var
  I: Integer;
  LX, LY: Single;
begin
  if not Assigned(FHandle) then Exit;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_LINE_LOOP);
    LX := X;
    LY := Y;
    for I := 0 to 360 do
    begin
      glVertex2f(LX + ARadius * PyMath.AngleCos(I), LY - ARadius * PyMath.AngleSin(I));
    end;
  glEnd();
end;

procedure TPyWindow.DrawFilledCircle(const X, Y, ARadius: Single; const AColor: TPyColor);
var
  I: Integer;
  LX, LY: Single;
begin
  if not Assigned(FHandle) then Exit;

  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_TRIANGLE_FAN);
    LX := X;
    LY := Y;
    glVertex2f(LX, LY);
    for i := 0 to 360 do
    begin
      glVertex2f(LX + ARadius * PyMath.AngleCos(i), LY + ARadius * PyMath.AngleSin(i));
    end;
  glEnd();
end;

procedure TPyWindow.DrawTriangle(const X1, Y1, X2, Y2, X3, Y3, AThickness: Single; const AColor: TPyColor);
begin
  if not Assigned(FHandle) then Exit;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_LINE_LOOP);
    glVertex2f(X1, Y1);
    glVertex2f(X2, Y2);
    glVertex2f(X3, Y3);
  glEnd();
end;

procedure TPyWindow.DrawFilledTriangle(const X1, Y1, X2, Y2, X3, Y3: Single; const AColor: TPyColor);
begin
  if not Assigned(FHandle) then Exit;

  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_TRIANGLES);
    glVertex2f(X1, Y1);
    glVertex2f(X2, Y2);
    glVertex2f(X3, Y3);
  glEnd();
end;

procedure TPyWindow.DrawPolygon(const APoints: array of TPoint; const AThickness: Single; const AColor: TPyColor);
var
  I: Integer;
begin
  if not Assigned(FHandle) then Exit;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_LINE_LOOP);
    for i := Low(APoints) to High(APoints) do
    begin
      glVertex2f(APoints[i].X, APoints[i].Y);
    end;
  glEnd();
end;

procedure TPyWindow.DrawFilledPolygon(const APoints: array of TPoint; const AColor: TPyColor);
var
  I: Integer;
begin
  if not Assigned(FHandle) then Exit;

  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_POLYGON);
  for I := Low(APoints) to High(APoints) do
    begin
      glVertex2f(APoints[i].X, APoints[i].Y);
    end;
  glEnd();
end;

procedure TPyWindow.DrawPolyline(const APoints: array of TPoint; const AThickness: Single; const AColor: TPyColor);
var
  I: Integer;
begin
  if not Assigned(FHandle) then Exit;

  glLineWidth(AThickness);
  glColor4f(AColor.r, AColor.g, AColor.b, AColor.a);
  glBegin(GL_LINE_STRIP);
    for I := Low(APoints) to High(APoints) do
    begin
      glVertex2f(APoints[i].X, APoints[i].Y);
    end;
  glEnd();
end;

procedure TPyWindow.ClearInput();
begin
  if not Assigned(FHandle) then Exit;
  FillChar(FKeyState, SizeOf(FKeyState), 0);
  FillChar(FMouseButtonState, SizeOf(FMouseButtonState), 0);
  FillChar(FGamepadButtonState, SizeOf(FGamepadButtonState), 0);
end;

function  TPyWindow.GetKey(const AKey: Integer; const AState: TPyInputState): Boolean;

  function IsKeyPressed(const AKey: Integer): Boolean;
  begin
    Result :=  Boolean(glfwGetKey(FHandle, AKey) = GLFW_PRESS);
  end;

begin
  Result := False;

  if not Assigned(FHandle) then Exit;

  if not InRange(AKey,  PyKEY_SPACE, PyKEY_LAST) then Exit;

  case AState of
    isPressed:
    begin
      Result :=  IsKeyPressed(AKey);
    end;

    isWasPressed:
    begin
      if IsKeyPressed(AKey) and (not FKeyState[0, AKey]) then
      begin
        FKeyState[0, AKey] := True;
        Result := True;
      end
      else if (not IsKeyPressed(AKey)) and (FKeyState[0, AKey]) then
      begin
        FKeyState[0, AKey] := False;
        Result := False;
      end;
    end;

    isWasReleased:
    begin
      if IsKeyPressed(AKey) and (not FKeyState[0, AKey]) then
      begin
        FKeyState[0, AKey] := True;
        Result := False;
      end
      else if (not IsKeyPressed(AKey)) and (FKeyState[0, AKey]) then
      begin
        FKeyState[0, AKey] := False;
        Result := True;
      end;
    end;
  end;
end;

function  TPyWindow.GetMouseButton(const AButton: Byte; const AState: TPyInputState): Boolean;

  function IsButtonPressed(const AKey: Integer): Boolean;
  begin
    Result :=  Boolean(glfwGetMouseButton(FHandle, AButton) = GLFW_PRESS);
  end;

begin
  Result := False;

  if not Assigned(FHandle) then Exit;
  if not InRange(AButton,  PyMOUSE_BUTTON_1, PyMOUSE_BUTTON_MIDDLE) then Exit;

  case AState of
    isPressed:
    begin
      Result :=  IsButtonPressed(AButton);
    end;

    isWasPressed:
    begin
      if IsButtonPressed(AButton) and (not FMouseButtonState[0, AButton]) then
      begin
        FMouseButtonState[0, AButton] := True;
        Result := True;
      end
      else if (not IsButtonPressed(AButton)) and (FMouseButtonState[0, AButton]) then
      begin
        FMouseButtonState[0, AButton] := False;
        Result := False;
      end;
    end;

    isWasReleased:
    begin
      if IsButtonPressed(AButton) and (not FMouseButtonState[0, AButton]) then
      begin
        FMouseButtonState[0, AButton] := True;
        Result := False;
      end
      else if (not IsButtonPressed(AButton)) and (FMouseButtonState[0, AButton]) then
      begin
        FMouseButtonState[0, AButton] := False;
        Result := True;
      end;
    end;
  end;
end;

procedure TPyWindow.GetMousePos(const X, Y: System.PSingle);
var
  LPos: TPyPoint;
begin
  if not Assigned(FHandle) then Exit;

  LPos := GetMousePos();

  if Assigned(X) then
    X^ := LPos.x;

  if Assigned(Y) then
    Y^ := LPos.y;
end;

function TPyWindow.GetMousePos(): TPyPoint;
var
  LMouseX, LMouseY: Double;
begin
  if not Assigned(FHandle) then Exit;

  glfwGetCursorPos(FHandle, @LMouseX, @LMouseY);
  Result := VirtualToScreen(LMouseX, LMouseY);
end;

procedure TPyWindow.SetMousePos(const X, Y: Single);
var
  LPos: TPyPoint;
begin
  if not Assigned(FHandle) then Exit;

  LPos := ScreenToVirtual(X, Y);
  glfwSetCursorPos(FHandle, LPos.X, LPos.y);
end;

function  TPyWindow.GetMouseWheel(): TPyVector;
begin
  Result := PyMath.Vector(0,0);
  if not Assigned(FHandle) then Exit;
  Result := FMouseWheel;
end;

function  TPyWindow.GamepadPresent(const AGamepad: Byte): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  Result := Boolean(glfwJoystickIsGamepad(EnsureRange(AGamepad, PyGAMEPAD_1, PyGAMEPAD_LAST)));
end;

function  TPyWindow.GetGamepadName(const AGamepad: Byte): string;
begin
  Result := 'Not present';

  if not Assigned(FHandle) then Exit;
  if not GamepadPresent(AGamepad) then Exit;

  Result := string(glfwGetGamepadName(AGamepad));
end;

function  TPyWindow.GetGamepadButton(const AGamepad, AButton: Byte; const AState: TPyInputState): Boolean;
var
  LState: GLFWgamepadstate;

  function IsButtonPressed(const AButton: Byte): Boolean;
  begin
    Result :=  Boolean(LState.buttons[AButton]);
  end;

begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  if not Boolean(glfwGetGamepadState(EnsureRange(AGamepad, PyGAMEPAD_1, PyGAMEPAD_LAST), @LState)) then Exit;

  case AState of
    isPressed:
    begin
      Result :=  IsButtonPressed(AButton);
    end;

    isWasPressed:
    begin
      if IsButtonPressed(AButton) and (not FGamepadButtonState[0, AButton]) then
      begin
        FGamepadButtonState[0, AButton] := True;
        Result := True;
      end
      else if (not IsButtonPressed(AButton)) and (FGamepadButtonState[0, AButton]) then
      begin
        FGamepadButtonState[0, AButton] := False;
        Result := False;
      end;
    end;

    isWasReleased:
    begin
      if IsButtonPressed(AButton) and (not FGamepadButtonState[0, AButton]) then
      begin
        FGamepadButtonState[0, AButton] := True;
        Result := False;
      end
      else if (not IsButtonPressed(AButton)) and (FGamepadButtonState[0, AButton]) then
      begin
        FGamepadButtonState[0, AButton] := False;
        Result := True;
      end;
    end;
  end;
end;

function  TPyWindow.GetGamepadAxisValue(const AGamepad, AAxis: Byte): Single;
var
  LState: GLFWgamepadstate;
begin
  Result := 0;
  if not Assigned(FHandle) then Exit;

  if not Boolean(glfwGetGamepadState(EnsureRange(AGamepad, PyGAMEPAD_1, PyGAMEPAD_LAST), @LState)) then Exit;
  Result := LState.axes[EnsureRange(AAxis, PyGAMEPAD_AXIS_LEFT_X, GLFW_GAMEPAD_AXIS_LAST)];
end;

function  TPyWindow.VirtualToScreen(const X, Y: Single): TPyPoint;
var
  LWindowWidth, LWindowHeight: Integer;
  LScreenX, LScreenY: Double;
  LVirtualScreenX, LVirtualScreenY: Double;
  LScaleX, LScaleY, LDpiScaleX, LDpiScaleY: Single;
  LViewportOffsetX, LViewportOffsetY: Double;
begin
  Result.x := 0;
  Result.y := 0;
  if not Assigned(FHandle) then Exit;

  // Get the actual window size
  glfwGetWindowSize(FHandle, @LWindowWidth, @LWindowHeight);

  // Get the DPI scaling factors (from glfwGetWindowContentScale)
  glfwGetWindowContentScale(FHandle, @LDpiScaleX, @LDpiScaleY);

  // Safety check to avoid invalid DPI scale values
  if (LDpiScaleX = 0) or (LDpiScaleY = 0) then
  begin
    LDpiScaleX := 1.0; // Default to 1.0 if invalid DPI scale is retrieved
    LDpiScaleY := 1.0;
  end;

  // Adjust window size by DPI scaling
  LWindowWidth := Trunc(LWindowWidth / LDpiScaleX);
  LWindowHeight := Trunc(LWindowHeight / LDpiScaleY);

  // Calculate the scaling factors for X and Y axes
  LScaleX := FVirtualSize.w / FViewport.size.w;  // Scale based on viewport width
  LScaleY := FVirtualSize.h / FViewport.size.h;  // Scale based on viewport height

  // Get the screen position
  LScreenX := X;
  LScreenY := Y;

  // Calculate the viewport offset
  LViewportOffsetX := FViewport.pos.x;
  LViewportOffsetY := FViewport.pos.y;

  // Adjust the mouse position by subtracting the viewport offset
  LScreenX := LScreenX - LViewportOffsetX;
  LScreenY := LScreenY - LViewportOffsetY;

  // Convert the adjusted mouse position to virtual coordinates
  LVirtualScreenX := LScreenX * LScaleX;
  LVirtualScreenY := LScreenY * LScaleY;

  // Clamp the virtual mouse position within the virtual resolution
  Result.x := EnsureRange(LVirtualScreenX, 0, FVirtualSize.w - 1);
  Result.y := EnsureRange(LVirtualScreenY, 0, FVirtualSize.h - 1);
end;

function  TPyWindow.ScreenToVirtual(const X, Y: Single): TPyPoint;
var
  LScreenX, LScreenY: Double;
  LScaleX, LScaleY: Single;
  LViewportOffsetX, LViewportOffsetY: Double;
begin
  Result.x := 0;
  Result.y := 0;
  if not Assigned(FHandle) then Exit;

  // Calculate the scaling factors (consistent with GetMousePos)
  LScaleX := FVirtualSize.w / FViewport.size.w;
  LScaleY := FVirtualSize.h / FViewport.size.h;

  // Calculate the viewport offsets
  LViewportOffsetX := FViewport.pos.x;
  LViewportOffsetY := FViewport.pos.y;

  // Convert virtual coordinates to adjusted screen position
  LScreenX := (X / LScaleX) + LViewportOffsetX;
  LScreenY := (Y / LScaleY) + LViewportOffsetY;

  // Return the virtual screen position
  Result.x := LScreenX;
  Result.y := LScreenY;
end;

procedure TPyWindow.StartTiming();
begin
  FTiming.CurrentTime := glfwGetTime();
  FTiming.ElapsedTime := FTiming.CurrentTime - FTiming.LastTime;
end;


procedure TPyWindow.StopTiming();
begin
  Inc(FTiming.FrameCount);
  if (FTiming.CurrentTime - FTiming.LastFPSTime >= 1.0) then
  begin
    FTiming.Framerate := FTiming.FrameCount;
    FTiming.LastFPSTime := FTiming.CurrentTime;
    FTiming.FrameCount := 0;
  end;

  // Calculate delta time
  FTiming.DeltaTime := FTiming.CurrentTime - FTiming.LastTime;

  FTiming.LastTime := FTiming.CurrentTime;
  FTiming.RemainingTime := FTiming.TargetTime - (FTiming.CurrentTime - FTiming.LastTime);
  if (FTiming.RemainingTime > 0) then
   begin
      FTiming.Endtime := FTiming.CurrentTime + FTiming.RemainingTime;
      while glfwGetTime() < FTiming.Endtime do
      begin
        // Busy-wait for the remaining time
        Sleep(0); // allow other background tasks to run
      end;
    end;
end;

procedure TPyWindow.SetTargetFrameRate(const ATargetFrameRate: UInt32);
begin
  FTiming.LastTime := glfwGetTime();
  FTiming.LastFPSTime := FTiming.LastTime;
  FTiming.TargetFrameRate := ATargetFrameRate;
  FTiming.TargetTime := 1.0 / FTiming.TargetFrameRate;
  FTiming.FrameCount := 0;
  FTiming.Framerate :=0;
  FTiming.Endtime := 0;
end;

function  TPyWindow.GetTargetFrameRate(): UInt32;
begin
  Result := FTiming.TargetFrameRate;
end;

function  TPyWindow.GetTargetTime(): Double;
begin
  Result := FTiming.TargetTime;
end;

procedure TPyWindow.ResetTiming();
begin
  FTiming.LastTime := glfwGetTime();
  FTiming.LastFPSTime := FTiming.LastTime;
  FTiming.TargetTime := 1.0 / FTiming.TargetFrameRate;
  FTiming.FrameCount := 0;
  FTiming.Framerate :=0;
  FTiming.Endtime := 0;
end;

function  TPyWindow.GetFrameRate(): UInt32;
begin
  Result := FTiming.Framerate;
end;

function  TPyWindow.GetDeltaTime(): Double;
begin
  Result := FTiming.DeltaTime;
end;

class function  TPyWindow.Init(const ATitle: string; const AVirtualWidth: Cardinal=PyDEFAULT_WINDOW_WIDTH; const AVirtualHeight: Cardinal=PyDEFAULT_WINDOW_HEIGHT; const AParent: NativeUInt=0): TPyWindow;
begin
  Result := TPyWindow.Create();
  if not Result.Open(ATitle, AVirtualWidth, AVirtualHeight, AParent) then
  begin
    Result.Free();
    Result := nil;
  end;
end;

{$ENDREGION}

{$REGION ' Pyro.IO '}
{ TPyIO }
constructor TPyIO.Create();
begin
  inherited;
end;

destructor TPyIO.Destroy();
begin
  Close();
  inherited;
end;

function  TPyIO.IsOpen(): Boolean;
begin
  Result := False;
end;

procedure TPyIO.Close();
begin
end;

function  TPyIO.Size(): Int64;
begin
  Result := -1;
end;

function  TPyIO.Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64;
begin
  Result := -1;
end;

function  TPyIO.Read(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
end;

function  TPyIO.Write(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
end;

function  TPyIO.Pos(): Int64;
begin
  Result := -1;
end;

function  TPyIO.Eos(): Boolean;
begin
  Result := False;
end;

{$ENDREGION}

{$REGION ' Pyro.MemoryIO '}
{ TPyMemoryIO }
function  TPyMemoryIO.IsOpen(): Boolean;
begin
  Result := Assigned(FHandle);
end;

procedure TPyMemoryIO.Close();
begin
  if Assigned(FHandle) then
  begin
    FHandle.Free();
    FHandle := nil;
  end;
end;

function  TPyMemoryIO.Size(): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Size;
end;

function  TPyMemoryIO.Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Seek(AOffset, Ord(ASeek));
end;

function  TPyMemoryIO.Read(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

 Result := FHandle.Read(AData^, ASize);
end;

function  TPyMemoryIO.Write(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Write(AData^, ASize);
end;

function  TPyMemoryIO.Pos(): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Position;
end;

function  TPyMemoryIO.Eos(): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  Result := Boolean(Pos() >= Size());
end;

function  TPyMemoryIO.Open(const AData: Pointer; ASize: Int64): Boolean;
begin
  Result := False;
  if Assigned(FHandle) then Exit;

  FHandle := TMemoryStream.Create;
  FHandle.Write(AData^, ASize);
  FHandle.Position := 0;
end;

{$ENDREGION}

{$REGION ' Pyro.FileIO '}
{ TPyFileIO }
function  TPyFileIO.IsOpen(): Boolean;
begin
  Result := Assigned(FHandle);
end;

procedure TPyFileIO.Close();
begin
  if Assigned(FHandle) then
  begin
    FHandle.Free();
    FHandle := nil;
  end;
end;

function  TPyFileIO.Size(): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Size;
end;

function  TPyFileIO.Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64;
begin
  Result := FHandle.Seek(AOffset, Ord(ASeek));
end;

function  TPyFileIO.Read(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

 Result := FHandle.Read(AData^, ASize);
end;

function  TPyFileIO.Write(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Write(AData^, ASize);
end;

function  TPyFileIO.Pos(): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := FHandle.Position;
end;

function  TPyFileIO.Eos(): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  Result := Boolean(Pos() >= Size());
end;

function TPyFileIO.Open(const AFilename: string; const AMode: TPyIOMode): Boolean;
var
  LHandle: TFileStream;
  LMode: TPyIOMode;
begin
  Result := False;
  LHandle := nil;

  if AFilename.IsEmpty then Exit;

  if not TFile.Exists(AFilename) then
  begin
    Exit;
  end;

  LMode := AMode;

  try
    case AMode of
      iomRead:
      begin
        LHandle := TFile.OpenRead(AFilename);
      end;

      iomWrite:
      begin
        LHandle := TFile.OpenWrite(AFilename);
      end;
    end;
  except
    LHandle := nil;
  end;

  if not Assigned(LHandle) then
  begin
    Exit;
  end;

  FHandle := LHandle;
  FMode := LMode;

  Result := True;
end;

{$ENDREGION}

{$REGION ' Pyro.ZipFileIO '}
{ TPyZipFileIO }
function  TPyZipFileIO.IsOpen(): Boolean;
begin
  Result := Assigned(FHandle);
end;

procedure TPyZipFileIO.Close();
begin
  if not Assigned(FHandle) then Exit;

  Assert(unzCloseCurrentFile(FHandle) = UNZ_OK);
  Assert(unzClose(FHandle) = UNZ_OK);
  FHandle := nil;
end;

function  TPyZipFileIO.Size(): Int64;
var
  LInfo: unz_file_info64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  unzGetCurrentFileInfo64(FHandle, @LInfo, nil, 0, nil, 0, nil, 0);
  Result := LInfo.uncompressed_size;
end;

function  TPyZipFileIO.Seek(const AOffset: Int64; const ASeek: TPyIOSeek): Int64;
var
  LFileInfo: unz_file_info64;
  LCurrentOffset, LBytesToRead: UInt64;
  LOffset: Int64;

  procedure SeekToLoc;
  begin
    LBytesToRead := UInt64(LOffset) - unztell64(FHandle);
    while LBytesToRead > 0 do
    begin
      if LBytesToRead > PyUtils.GetTempStaticBufferSize() then
        unzReadCurrentFile(FHandle, PyUtils.GetTempStaticBuffer(), PyUtils.GetTempStaticBufferSize())
      else
        unzReadCurrentFile(FHandle, PyUtils.GetTempStaticBuffer(), LBytesToRead);

      LBytesToRead := UInt64(LOffset) - unztell64(FHandle);
    end;
  end;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  if (FHandle = nil) or (unzGetCurrentFileInfo64(FHandle, @LFileInfo, nil, 0, nil, 0, nil, 0) <> UNZ_OK) then
  begin
    Exit;
  end;

  LOffset := AOffset;

  LCurrentOffset := unztell64(FHandle);
  if LCurrentOffset = -1 then Exit;

  case ASeek of
    // offset is already relative to the start of the file
    iosStart: ;

    // offset is relative to current position
    iosCurrent: Inc(LOffset, LCurrentOffset);

    // offset is relative to end of the file
    iosEnd: Inc(LOffset, LFileInfo.uncompressed_size);
  else
    Exit;
  end;

  if LOffset < 0 then Exit

  else if AOffset > LCurrentOffset then
    begin
      SeekToLoc();
    end
  else // offset < current_offset
    begin
      unzCloseCurrentFile(FHandle);
      unzLocateFile(FHandle, PAnsiChar(FFilename), 0);
      unzOpenCurrentFilePassword(FHandle, PAnsiChar(FPassword));
      SeekToLoc();
    end;

  Result := unztell64(FHandle);
end;

function  TPyZipFileIO.Read(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := unzReadCurrentFile(FHandle, AData, ASize);
end;

function  TPyZipFileIO.Write(const AData: Pointer; const ASize: Int64): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;
end;

function  TPyZipFileIO.Pos(): Int64;
begin
  Result := -1;
  if not Assigned(FHandle) then Exit;

  Result := unztell64(FHandle);
end;

function  TPyZipFileIO.Eos(): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  Result := Boolean(Pos() >= Size());
end;

procedure TZipFileIO_BuildProgress(const AFilename: string; const AProgress: Integer; const ANewFile: Boolean; const AUserData: Pointer);
begin
  if aNewFile then PyConsole.PrintLn('', []);
  PyConsole.Print(PyCR+'Adding %s(%d%s)...', [ExtractFileName(string(aFilename)), aProgress, '%']);
end;

function TPyZipFileIO.Open(const AZipFilename, AFilename: string; const APassword: string): Boolean;
var
  LPassword: PAnsiChar;
  LZipFilename: PAnsiChar;
  LFilename: PAnsiChar;
  LFile: unzFile;
begin
  Result := False;

  LPassword := PAnsiChar(AnsiString(APassword));
  LZipFilename := PAnsiChar(AnsiString(StringReplace(string(AZipFilename), '/', '\', [rfReplaceAll])));
  LFilename := PAnsiChar(AnsiString(StringReplace(string(AFilename), '/', '\', [rfReplaceAll])));

  LFile := unzOpen64(LZipFilename);
  if not Assigned(LFile) then Exit;

  if unzLocateFile(LFile, LFilename, 0) <> UNZ_OK then
  begin
    unzClose(LFile);
    Exit;
  end;

  if unzOpenCurrentFilePassword(LFile, LPassword) <> UNZ_OK then
  begin
    unzClose(LFile);
    Exit;
  end;

  FHandle := LFile;
  FPassword := LPassword;
  FFilename := LFilename;

  Result := True;
end;

class function TPyZipFileIO.Init(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyZipFileIO;
begin
  Result := TPyZipFileIO.Create();
  if not Result.Open(AZipFilename, AFilename, APassword) then
  begin
    Result.Free();
    Result := nil;
  end;
end;

class function TPyZipFileIO.Load(const AZipFilename, AFilename: string; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TMemoryStream;
var
  LIO: TPyZipFileIO;
begin
  LIO := TPyZipFileIO.Init(AZipFilename, AFilename, APassword);
  Result := TMemoryStream.Create();
  Result.SetSize(LIO.Size());
  LIO.Read(Result.Memory, LIO.Size);
  LIO.Free();
  Result.Position := 0;
end;

class function TPyZipFileIO.Build(const AZipFilename, ADirectoryName: string; const AHandler: TPyZipFileIOBuildProgressCallback; const AUserData: Pointer; const APassword: string): Boolean;
var
  LFileList: TStringDynArray;
  LArchive: PAnsiChar;
  LFilename: string;
  LFilename2: PAnsiChar;
  LPassword: PAnsiChar;
  LZipFile: zipFile;
  LZipFileInfo: zip_fileinfo;
  LFile: System.Classes.TStream;
  LCrc: Cardinal;
  LBytesRead: Integer;
  LFileSize: Int64;
  LProgress: Single;
  LNewFile: Boolean;
  LHandler: TPyZipFileIOBuildProgressCallback;
  LUserData: Pointer;

  function GetCRC32(aStream: System.Classes.TStream): uLong;
  var
    LBytesRead: Integer;
    LBuffer: array of Byte;
  begin
    Result := crc32(0, nil, 0);
    repeat
      LBytesRead := AStream.Read(PyUtils.GetTempStaticBuffer()^, PyUtils.GetTempStaticBufferSize());
      Result := crc32(Result, PBytef(PyUtils.GetTempStaticBuffer()), LBytesRead);
    until LBytesRead = 0;

    LBuffer := nil;
  end;
begin
  Result := False;

  // check if directory exists
  if not TDirectory.Exists(ADirectoryName) then Exit;

  // init variabls
  FillChar(LZipFileInfo, SizeOf(LZipFileInfo), 0);

  // scan folder and build file list
  LFileList := TDirectory.GetFiles(ADirectoryName, '*',
    TSearchOption.soAllDirectories);

  LArchive := PAnsiChar(AnsiString(AZipFilename));
  LPassword := PAnsiChar(AnsiString(APassword));

  // create a zip file
  LZipFile := zipOpen64(LArchive, APPEND_STATUS_CREATE);

  // init handler
  LHandler := AHandler;
  LUserData := AUserData;

  if not Assigned(LHandler) then
    LHandler := TZipFileIO_BuildProgress;

  // process zip file
  if LZipFile <> nil then
  begin
    // loop through all files in list
    for LFilename in LFileList do
    begin
      // open file
      LFile := TFile.OpenRead(LFilename);

      // get file size
      LFileSize := LFile.Size;

      // get file crc
      LCrc := GetCRC32(LFile);

      // open new file in zip
      LFilename2 := PAnsiChar(AnsiString(LFilename));
      if ZipOpenNewFileInZip3_64(LZipFile, LFilename2, @LZipFileInfo, nil, 0,
        nil, 0, '',  Z_DEFLATED, 9, 0, 15, 9, Z_DEFAULT_STRATEGY,
        LPassword, LCrc, 1) = Z_OK then
      begin
        // make sure we start at star of stream
        LFile.Position := 0;

        LNewFile := True;

        // read through file
        repeat
          // read in a buffer length of file
          LBytesRead := LFile.Read(PyUtils.GetTempStaticBuffer()^, PyUtils.GetTempStaticBufferSize());

          // write buffer out to zip file
          zipWriteInFileInZip(LZipFile, PyUtils.GetTempStaticBuffer(), LBytesRead);

          // calc file progress percentage
          LProgress := 100.0 * (LFile.Position / LFileSize);

          // show progress
          if Assigned(LHandler) then
          begin
            LHandler(LFilename, Round(LProgress), LNewFile, LUserData);
          end;

          LNewFile := False;

        until LBytesRead = 0;

        // close file in zip
        zipCloseFileInZip(LZipFile);

        // free file stream
        LFile.Free;
      end;
    end;

    // close zip file
    zipClose(LZipFile, '');
  end;

  // return true if new zip file exits
  Result := TFile.Exists(LFilename);
end;

{$ENDREGION}

{$REGION ' Pyro.Texture '}
function  Texture_Read(AUser: Pointer; AData: PUTF8Char; ASize: Integer): Integer; cdecl;
var
  LIO: TPyIO;
begin
  Result := -1;

  LIO := TPyIO(AUser);
  if not Assigned(LIO) then Exit;

  Result := LIO.Read(AData, ASize);
end;

procedure Texture_Skip(AUser: Pointer; AOffset: Integer); cdecl;
var
  LIO: TPyIO;
begin
  LIO := TPyIO(AUser);
  if not Assigned(LIO) then Exit;

  LIO.Seek(AOffset, iosCurrent);
end;

function  Texture_Eof(AUser: Pointer): Integer;  cdecl;
var
  LIO: TPyIO;
begin
  Result := -1;

  LIO := TPyIO(AUser);
  if not Assigned(LIO) then Exit;

  Result := Ord(LIO.Eos);
end;

procedure TPyTexture.ConvertMaskToAlpha(Data: Pointer; Width, Height: Integer; MaskColor: TPyColor);
var
  I: Integer;
  LPixelPtr: PRGBA;
begin
  LPixelPtr := PRGBA(Data);
  if not Assigned(LPixelPtr) then Exit;

  for I := 0 to Width * Height - 1 do
  begin
    if (LPixelPtr^.R = Round(MaskColor.r * 256)) and
       (LPixelPtr^.G = Round(MaskColor.g * 256)) and
       (LPixelPtr^.B = Round(MaskColor.b * 256)) then
      LPixelPtr^.A := 0
    else
      LPixelPtr^.A := 255;

    Inc(LPixelPtr);
  end;
end;

constructor TPyTexture.Create();
begin
  inherited;
end;

destructor TPyTexture.Destroy();
begin
  Unload();
  inherited;
end;

function  TPyTexture.Alloc(const AWidth, AHeight: Integer): Boolean;
var
  LData: array of Byte;
begin
  Result := False;

  if FHandle <> 0 then Exit;

  // init RGBA data
  SetLength(LData, AWidth * AHeight * 4);

  glGenTextures(1, @FHandle);
  glBindTexture(GL_TEXTURE_2D, FHandle);

  // init the texture with transparent pixels
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, AWidth, AHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, @LData[0]);

  // set texture parameters
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  FSize.w := AWidth;
  FSize.h := AHeight;
  FChannels := 4;

  SetBlend(tbAlpha);
  SetColor(PyWHITE);
  SetScale(1.0);
  SetAngle(0.0);
  SetHFlip(False);
  SetVFlip(False);
  SetPivot(0.5, 0.5);
  SetAnchor(0.5, 0.5);
  SetPos(0.0, 0.0);
  ResetRegion();

  glBindTexture(GL_TEXTURE_2D, 0);

  Result := True;
end;

procedure TPyTexture.Fill(const AColor: TPyColor);
var
  X,Y,LWidth,LHeight: Integer;
begin
  if FHandle = 0 then Exit;

  LWidth := Round(FSize.w);
  LHeight := Round(FSize.h);

  glBindTexture(GL_TEXTURE_2D, FHandle);

  for X := 0 to LWidth-1 do
  begin
    for Y := 0 to LHeight-1 do
    begin
      glTexSubImage2D(GL_TEXTURE_2D, 0, X, Y, 1, 1, GL_RGBA, GL_FLOAT, @AColor);
    end;
  end;

  glBindTexture(GL_TEXTURE_2D, 0);
end;

function  TPyTexture.Load(const ARGBData: Pointer; const AWidth, AHeight: Integer): Boolean;
begin
  Result := False;

  if FHandle > 0 then Exit;

  if not Alloc(AWidth, AHeight) then Exit;

  glBindTexture(GL_TEXTURE_2D, FHandle);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, AWidth, AHeight, 0, GL_ALPHA, GL_UNSIGNED_BYTE, ARGBData);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glBindTexture(GL_TEXTURE_2D, 0);

  Result := True;
end;

function  TPyTexture.Load(const AIO: TPyIO; const AOwnIO: Boolean; const AColorKey: PPyColor): Boolean;
var
  LCallbacks: stbi_io_callbacks;
  LData: Pstbi_uc;
  LWidth,LHeight,LChannels: Integer;
  LIO: TPyIO;
begin
  Result := False;

  if FHandle > 0 then Exit;

  if not Assigned(AIO) then Exit;

  LIO := AIO;

  LCallbacks.read := Texture_Read;
  LCallbacks.skip := Texture_Skip;
  LCallbacks.eof := Texture_Eof;

  LData := stbi_load_from_callbacks(@LCallbacks, LIO, @LWidth, @LHeight, @LChannels, 4);
  if not Assigned(LData) then Exit;

  if Assigned(AColorKey) then
    ConvertMaskToAlpha(LData, LWidth, LHeight, AColorKey^);

  glGenTextures(1, @FHandle);
  glBindTexture(GL_TEXTURE_2D, FHandle);

  // Set texture parameters
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, LWidth, LHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, LData);

  stbi_image_free(LData);

  FSize.w := LWidth;
  FSize.h := LHeight;
  FChannels := LChannels;

  SetBlend(tbAlpha);
  SetColor(PyWHITE);
  SetScale(1.0);
  SetAngle(0.0);
  SetHFlip(False);
  SetVFlip(False);
  SetPivot(0.5, 0.5);
  SetAnchor(0.5, 0.5);
  SetPos(0.0, 0.0);
  ResetRegion();

  glBindTexture(GL_TEXTURE_2D, 0);

  if AOwnIO then
  begin
    AIO.Free();
  end;

  Result := True;
end;

function  TPyTexture.LoadFromFile(const AFilename: string; const AColorKey: PPyColor): Boolean;
var
  LIO: TPyFileIO;
begin
  Result := False;
  //if not IGet(IFileIO, LIO) then Exit;
  LIO := TPyFileIO.Create();
  try
    if not LIO.Open(AFilename, iomRead) then Exit;
    Result := Load(LIO, False, AColorKey);
  finally
    LIO.Free();
  end;
end;

function  TPyTexture.LoadFromZipFile(const AZipFilename, AFilename: string; const AColorKey: PPyColor; const APassword: string): Boolean;
var
  LIO: TPyZipFileIO;
begin
  Result := False;
  LIO := TPyZipFileIO.Create();
  try
    if not LIO.Open(AZipFilename, AFilename, APassword) then Exit;
    Result := Load(LIO, False, AColorkey);
  finally
    LIO.Free();
  end;
end;

function  TPyTexture.IsLoaded(): Boolean;
begin
  Result := Boolean(FHandle > 0);
end;

procedure TPyTexture.Unload();
begin
  if FHandle > 0 then
  begin
    glDeleteTextures(1, @FHandle);
  end;
  FHandle := 0;
end;

function  TPyTexture.GetHandle(): Cardinal;
begin
  Result := FHandle;
end;

function  TPyTexture.GetChannels(): Integer;
begin
  Result := -1;
  if FHandle = 0 then Exit;
  Result := FChannels;
end;

function  TPyTexture.GetSize(): TPySize;
begin
  Result := PyMath.Size(0,0);
  if FHandle = 0 then Exit;
  Result := FSize;
end;

function  TPyTexture.GetPivot(): TPyPoint;
begin
  Result := PyMath.Point(0,0);
  if FHandle = 0 then Exit;
  Result := FPivot;
end;

procedure TPyTexture.SetPivot(const APoint: TPyPoint);
begin
  if FHandle = 0 then Exit;
  SetPivot(APoint.X, APoint.Y);
end;

procedure TPyTexture.SetPivot(const X, Y: Single);
begin
  if FHandle = 0 then Exit;
  FPivot.x := EnsureRange(X, 0, 1);
  FPivot.y := EnsureRange(Y, 0, 1);
end;

function  TPyTexture.Anchor(): TPyPoint;
begin
  if FHandle = 0 then Exit;
  Result := FAnchor;
end;

procedure TPyTexture.SetAnchor(const APoint: TPyPoint);
begin
  if FHandle = 0 then Exit;
  SetAnchor(APoint.x, APoint.y);
end;

procedure TPyTexture.SetAnchor(const X, Y: Single);
begin
  if FHandle = 0 then Exit;
  FAnchor.x := EnsureRange(X, 0, 1);
  FAnchor.y := EnsureRange(Y, 0, 1);
end;

function  TPyTexture.GetBlend(): TPyTextureBlend;
begin
  Result := tbNone;
  if FHandle = 0 then Exit;
  Result := FBlend;
end;

procedure TPyTexture.SetBlend(const AValue: TPyTextureBlend);
begin
  if FHandle = 0 then Exit;
  FBlend := AValue;
end;

function  TPyTexture.GetPos(): TPyPoint;
begin
  if FHandle = 0 then Exit;
  Result := FPos;
end;

procedure TPyTexture.SetPos(const APos: TPyPoint);
begin
  if FHandle = 0 then Exit;
  FPos := APos;
end;

procedure TPyTexture.SetPos(const X, Y: Single);
begin
  if FHandle = 0 then Exit;
  FPos.x := X;
  FPos.y := Y;
end;

function  TPyTexture.GetScale(): Single;
begin
  Result := 0;
  if FHandle = 0 then Exit;
  Result := FScale;
end;

procedure TPyTexture.SetScale(const AScale: Single);
begin
  if FHandle = 0 then Exit;
  FScale := AScale;
end;

function  TPyTexture.GetColor(): TPyColor;
begin
  Result := PyBLANK;
  if FHandle = 0 then Exit;
  Result := FColor;
end;

procedure TPyTexture.SetColor(const AColor: TPyColor);
begin
  if FHandle = 0 then Exit;
  FColor := AColor;
end;

procedure TPyTexture.SetColor(const ARed, AGreen, ABlue, AAlpha: Single);
begin
  if FHandle = 0 then Exit;

  FColor.r:= EnsureRange(ARed, 0, 1);
  FColor.g := EnsureRange(AGreen, 0, 1);
  FColor.b := EnsureRange(ABlue, 0, 1);
  FColor.a := EnsureRange(AAlpha, 0, 1);
end;

function  TPyTexture.GetAngle(): Single;
begin
  Result := 0;
  if FHandle = 0 then Exit;
  Result := FAngle;
end;

procedure TPyTexture.SetAngle(const AAngle: Single);
begin
  if FHandle = 0 then Exit;
  FAngle := AAngle;
end;

function  TPyTexture.GetHFlip(): Boolean;
begin
  Result := FAlse;
  if FHandle = 0 then Exit;
  Result := FHFlip;
end;

procedure TPyTexture.SetHFlip(const AFlip: Boolean);
begin
  if FHandle = 0 then Exit;
  FHFlip := AFlip;
end;

function  TPyTexture.GetVFlip(): Boolean;
begin
  Result := False;
  if FHandle = 0 then Exit;
  Result := FVFlip;
end;

procedure TPyTexture.SetVFlip(const AFlip: Boolean);
begin
  if FHandle = 0 then Exit;
  FVFlip := AFlip;
end;

function  TPyTexture.GetRegion(): TPyRect;
begin
  Result := PyMath.Rect(0,0,0,0);
  if FHandle = 0 then Exit;
  Result := FRegion;
end;

procedure TPyTexture.SetRegion(const ARegion: TPyRect);
begin
  if FHandle = 0 then Exit;
  SetRegion(ARegion.pos.x, ARegion.pos.y, ARegion.size.w, ARegion.size.h);
end;

procedure TPyTexture.SetRegion(const X, Y, AWidth, AHeight: Single);
begin
  if FHandle = 0 then Exit;
 FRegion.pos.X := X;
 FRegion.pos.Y := Y;
 FRegion.size.w := AWidth;
 FRegion.size.h := AHeight;
end;

procedure TPyTexture.ResetRegion();
begin
  if FHandle = 0 then Exit;
  FRegion.pos.X := 0;
  FRegion.pos.Y := 0;
  FRegion.size.W := FSize.w;
  FRegion.size.H := FSize.h;
end;

procedure TPyTexture.Draw(const AWindow: TPyWindow);
var
  FlipX, FlipY: Single;
begin
  if FHandle = 0 then Exit;
  if not Assigned(AWindow) then Exit;

  glBindTexture(GL_TEXTURE_2D, FHandle);
  glEnable(GL_TEXTURE_2D);

  glPushMatrix();

  // Set the color
  glColor4f(FColor.r, FColor.g, FColor.b, FColor.a);

  // set blending
  case FBlend of
    tbNone: // no blending
    begin
      glDisable(GL_BLEND);
      glBlendFunc(GL_ONE, GL_ZERO);
    end;

    tbAlpha: // alpha blending
    begin
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    end;

    tbAdditiveAlpha: // addeditve blending
    begin
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE);
    end;
  end;

  // Use the normalized anchor value
  glTranslatef(FPos.X - (FAnchor.X * FRegion.size.w * FScale), FPos.Y - (FAnchor.Y * FRegion.size.h * FScale), 0);
  glScalef(FScale, FScale, 1);

  // Apply rotation using the normalized pivot value
  glTranslatef(FPivot.X * FRegion.size.w, FPivot.Y * FRegion.size.h, 0);
  glRotatef(FAngle, 0, 0, 1);
  glTranslatef(-FPivot.X * FRegion.size.w, -FPivot.Y * FRegion.size.h, 0);

  // Apply flip
  if FHFlip then FlipX := -1 else FlipX := 1;
  if FVFlip then FlipY := -1 else FlipY := 1;
  glScalef(FlipX, FlipY, 1);

  // Adjusted texture coordinates and vertices for the specified rectangle
  glBegin(GL_QUADS);
    glTexCoord2f(FRegion.pos.X/FSize.w, FRegion.pos.Y/FSize.h); glVertex2f(0, 0);
    glTexCoord2f((FRegion.pos.X + FRegion.size.w)/FSize.w, FRegion.pos.Y/FSize.h); glVertex2f(FRegion.size.w, 0);
    glTexCoord2f((FRegion.pos.X + FRegion.size.W)/FSize.w, (FRegion.pos.Y + FRegion.size.h)/FSize.h); glVertex2f(FRegion.size.w, FRegion.size.h);
    glTexCoord2f(FRegion.pos.X/FSize.w, (FRegion.pos.Y + FRegion.size.H)/FSize.h); glVertex2f(0, FRegion.size.h);
  glEnd();

  glPopMatrix();

  glDisable(GL_TEXTURE_2D);
  glBindTexture(GL_TEXTURE_2D, 0);
end;

procedure TPyTexture.DrawTiled(const AWindow: TPyWindow; const ADeltaX, ADeltaY: Single);
var
  LW,LH    : Integer;
  LOX,LOY  : Integer;
  LPX,LPY  : Single;
  LFX,LFY  : Single;
  LTX,LTY  : Integer;
  LVPW,LVPH: Integer;
  LVR,LVB  : Integer;
  LIX,LIY  : Integer;
  LViewport: TPyRect;
begin
  if FHandle = 0 then Exit;

  SetPivot(0, 0);
  SetAnchor(0, 0);

  LViewport := AWindow.GetViewport();
  LVPW := Round(LViewport.size.w);
  LVPH := Round(LViewport.size.h);

  LW := Round(FSize.w);
  LH := Round(FSize.h);

  LOX := -LW+1;
  LOY := -LH+1;

  LPX := aDeltaX;
  LPY := aDeltaY;

  LFX := LPX-floor(LPX);
  LFY := LPY-floor(LPY);

  LTX := floor(LPX)-LOX;
  LTY := floor(LPY)-LOY;

  if (LTX>=0) then LTX := LTX mod LW + LOX else LTX := LW - -LTX mod LW + LOX;
  if (LTY>=0) then LTY := LTY mod LH + LOY else LTY := LH - -LTY mod LH + LOY;

  LVR := LVPW;
  LVB := LVPH;
  LIY := LTY;

  while LIY<LVB do
  begin
    LIX := LTX;
    while LIX<LVR do
    begin
      SetPos(LIX+LFX, LIY+LFY);
      Draw(AWindow);
      LIX := LIX+LW;
    end;
   LIY := LIY+LH;
  end;
end;

function  TPyTexture.Save(const AFilename: string): Boolean;
var
  LData: array of Byte;
  LFilename: string;
begin
  Result := False;
  if FHandle = 0 then Exit;

  if AFilename.IsEmpty then Exit;

  // Allocate space for the texture data
  SetLength(LData, Round(FSize.w * FSize.h * 4)); // Assuming RGBA format

  // Bind the texture
  glBindTexture(GL_TEXTURE_2D, FHandle);

  // Read the texture data
  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, @LData[0]);

  LFilename := TPath.ChangeExtension(AFilename, 'png');

  // Use stb_image_write to save the texture to a PNG file
  Result := Boolean(stbi_write_png(PyUtils.AsUtf8(LFilename, []), Round(FSize.w), Round(FSize.h), 4, @LData[0], Round(FSize.w * 4)));

  // Unbind the texture
  glBindTexture(GL_TEXTURE_2D, 0);
end;

function  TPyTexture.Lock(): Boolean;
begin
  Result := False;
  if FHandle = 0 then Exit;

  if Assigned(FLock) then Exit;

  GetMem(FLock, Round(FSize.w*FSize.h*4));
  if not Assigned(FLock) then Exit;

  glBindTexture(GL_TEXTURE_2D, FHandle);
  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, FLock);
  glBindTexture(GL_TEXTURE_2D, 0);

  Result := True;
end;

procedure TPyTexture.Unlock();
begin
  if FHandle = 0 then Exit;

  if not Assigned(FLock) then Exit;

  glBindTexture(GL_TEXTURE_2D, FHandle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, Round(FSize.w), Round(FSize.h), GL_RGBA, GL_UNSIGNED_BYTE, FLock);
  glBindTexture(GL_TEXTURE_2D, 0);
  FreeMem(FLock);
  FLock := nil;
end;

function  TPyTexture.GetPixel(const X, Y: Single): TPyColor;
var
  LOffset: Integer;
  LPixel: Cardinal;
begin
  Result := PyBLANK;
  if FHandle = 0 then Exit;

  if not Assigned(FLock) then Exit;

  LOffset := Round((Y * FSize.w + X) * 4);
  LPixel := PCardinal(FLock + LOffset)^;

  Result.a := (LPixel shr 24) / $FF;
  Result.b := ((LPixel shr 16) and $FF) / $FF;
  Result.g := ((LPixel shr 8) and $FF) / $FF;
  Result.r := (LPixel and $FF) / $FF;
end;

procedure TPyTexture.SetPixel(const X, Y: Single; const AColor: TPyColor);
var
  LOffset: Integer;
begin
  if FHandle = 0 then Exit;

  if not Assigned(FLock) then Exit;

  LOffset := Round((Y * FSize.w + X) * 4);
  PCardinal(FLock + LOffset)^ :=
    (Round(AColor.a*$FF) shl 24) or
    (Round(AColor.b*$FF) shl 16) or
    (Round(AColor.g*$FF) shl 8) or
    Round(AColor.r*$FF);
end;

procedure TPyTexture.SetPixel(const X, Y: Single; const ARed, AGreen, ABlue, AAlpha: Byte);
var
  LOffset: Integer;
begin
  if FHandle = 0 then Exit;

  if not Assigned(FLock) then Exit;

  LOffset := Round((Y * FSize.w + X) * 4);
  PCardinal(FLock + LOffset)^ :=
    (AAlpha shl 24) or
    (ABlue shl 16) or
    (AGreen shl 8) or
    ARed;
end;

function  TPyTexture.CollideAABB(const ATexture: TPyTexture): Boolean;
var
  LA: TPyTexture;
  LB: TPyTexture;
  boxA, boxB: c2AABB;

  function _c2v(x, y: Single): c2v;
  begin
    result.x := x;
    result.y := y;
  end;

begin
  Result := False;

  LA := Self;
  LB := ATexture as TPyTexture;

  if not Assigned(LA) then Exit;
  if LA.FHandle = 0 then Exit;

  if not Assigned(LB) then Exit;
  if LB.FHandle = 0 then Exit;

  // Set up AABB for this texture
  boxA.min := _c2V(LA.FPos.X - (LA.FAnchor.X * LA.FRegion.size.w * LA.FScale), LA.FPos.Y - (LA.FAnchor.Y * LA.FRegion.size.h * LA.FScale));
  boxA.max := _c2V((LA.FPos.X - (LA.FAnchor.X * LA.FRegion.size.w * LA.FScale)) + LA.FRegion.size.w * LA.FScale, (LA.FPos.Y - (LA.FAnchor.Y * LA.FRegion.size.h * LA.FScale)) + LA.FRegion.size.h * LA.FScale);

  // Set up AABB for the other texture
  boxB.min := _c2V(LB.FPos.X - (LB.FAnchor.X * LB.FRegion.size.w * LB.FScale), LB.FPos.Y - (LB.FAnchor.Y * LB.FRegion.size.h * LB.FScale));
  boxB.max := _c2V((LB.FPos.X - (LB.FAnchor.X * LB.FRegion.size.w * LB.FScale)) + LB.FRegion.size.w * LB.FScale, (LB.FPos.Y - (LB.FAnchor.Y * LB.FRegion.size.h * LB.FScale)) + LB.FRegion.size.h * LB.FScale);

  // Check for collision and return result
  Result := Boolean(c2AABBtoAABB(boxA, boxB));
end;

function TPyTexture.CollideOBB(const ATexture: TPyTexture): Boolean;
var
  obbA, obbB: TPyOBB;
begin
  // Set up OBB for this texture
  obbA.Center := PyMath.Point(FPos.X, FPos.Y);
  obbA.Extents := PyMath.Point(FRegion.size.w * FScale / 2, FRegion.size.h * FScale / 2);
  obbA.Rotation := FAngle;

  // Set up OBB for the other texture
  obbB.Center := PyMath.Point(ATexture.GetPos().X, ATexture.GetPos().Y);
  obbB.Extents := PyMath.Point(ATexture.GetRegion().size.w * ATexture.GetScale() / 2, ATexture.GetRegion().size.h * ATexture.GetScale() / 2);
  obbB.Rotation := ATexture.GetAngle();

  // Check for collision and return result
  Result := PyMath.OBBIntersect(obbA, obbB);
end;

class function TPyTexture.Init(const AZipFilename, AFilename: string; const AColorKey: PPyColor=nil; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyTexture;
begin
  Result := TPyTexture.Create();
  if not Result.LoadFromZipFile(AZipFilename, AFilename, AColorKey, APassword) then
  begin
    Result.Free();
    Result := nil;
  end;
end;

class function TPyTexture.Spine(const AIO: TPyIO; const AOwnIO: Boolean=True): GLuint;
var
  LCallbacks: stbi_io_callbacks;
  LData: Pstbi_uc;
  LWidth,LHeight,LChannels: Integer;
  LIO: TPyIO;
  LPrevTexture: GLuint;
begin
  Result := 0;
  if not Assigned(AIO) then Exit;

  LIO := AIO;

  LCallbacks.read := Texture_Read;
  LCallbacks.skip := Texture_Skip;
  LCallbacks.eof := Texture_Eof;

  LData := stbi_load_from_callbacks(@LCallbacks, LIO, @LWidth, @LHeight, @LChannels, 4);
  if not Assigned(LData) then Exit;

  glGenTextures(1, @Result);

  glGetIntegerv(GL_TEXTURE_BINDING_2D, @LPrevTexture);

  glBindTexture(GL_TEXTURE_2D, Result);

  // Set texture parameters
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, LWidth, LHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, LData);

  stbi_image_free(LData);

  glBindTexture(GL_TEXTURE_2D, LPrevTexture);

  if AOwnIO then
  begin
    AIO.Free();
  end;
end;

class procedure TPyTexture.Delete(const ATexture: GLuint);
var
  LCurrentTexture: GLuInt;
begin
  // Exit if the texture pointer is not valid.
  if ATexture = 0 then Exit;

  // Save current texture
  glGetIntegerv(GL_TEXTURE_BINDING_2D, @LCurrentTexture);

  // Delete spine texture
  glDeleteTextures(1, @ATexture);

  // Restore current texture
  if LCurrentTexture <> 0 then
  begin
    glBindTexture(GL_TEXTURE_2D, LCurrentTexture);
  end;
end;

{$ENDREGION}

{$REGION ' Pyro.Font '}
{ TPyFont }
constructor TPyFont.Create();
begin
  inherited;
  FGlyph := TDictionary<Integer, TFontGlyph>.Create();
end;

destructor TPyFont.Destroy();
begin
  Unload();
  FGlyph.Free();

  inherited;
end;

function  TPyFont.Load(const AWindow: TPyWindow; const ASize: Cardinal; const AGlyphs: string): Boolean;
const
  CDefaultFontResName = 'db1184eec13447cb8cceb28a1052bd96';
var
  LResStream: TResourceStream;
  LIO: TPyMemoryIO;
begin
  Result := False;
  if not Assigned(AWindow) then Exit;
  if not PyUtils.ResourceExists(HInstance, CDefaultFontResName) then Exit;

  LResStream := TResourceStream.Create(HInstance, CDefaultFontResName, RT_RCDATA);
  try
    LIO := TPyMemoryIO.Create;
    LIO.Open(LResStream.Memory, LResStream.Size);
    if not Load(AWindow, LIO, ASize, AGlyphs) then Exit;
  finally
    LResStream.Free();
  end;
end;

function  TPyFont.Load(const AWindow: TPyWindow; const AIO: TPyIO; const ASize: Cardinal; const AGlyphs: string; const AOwnIO: Boolean): Boolean;
var
  LBuffer: TPyVirtualBuffer;
  LChars: TPyVirtualBuffer;
  LFileSize: Int64;
  LFontInfo: stbtt_fontinfo;
  NumOfGlyphs: Integer;
  LGlyphChars: string;
  LCodePoints: array of Integer;
  LBitmap: array of Byte;
  LPackContext: stbtt_pack_context;
  LPackRange: stbtt_pack_range;
  I: Integer;
  LGlyph: TFontGlyph;
  LChar: Pstbtt_packedchar;
  LScale: Single;
  LAscent: Integer;
  LSize: Single;
  LMaxTextureSize: Integer;
  LDpiScale: Single;
  LIO: TPyIO;
begin
  Result := False;
  if not Assigned(AWindow) then Exit;
  if not Assigned(AIO) then Exit;

  LIO := AIO;

  LDpiScale := AWindow.GetScale().h;
  LMaxTextureSize :=  AWindow.GetMaxTextureSize();

  LSize := aSize * LDpiScale;
  LFileSize :=  LIO.Size();
  LBuffer := TPyVirtualBuffer.Create(LFileSize);
  try
    LIO.Read(LBuffer.Memory, LFileSize);

    if stbtt_InitFont(@LFontInfo, LBuffer.Memory, 0) = 0 then Exit;
    LGlyphChars := DEFAULT_GLYPHS + aGlyphs;
    LGlyphChars := PyUtils.RemoveDuplicates(LGlyphChars);
    NumOfGlyphs :=  LGlyphChars.Length;
    SetLength(LCodePoints, NumOfGlyphs);

    for I := 1 to NumOfGlyphs do
    begin
      LCodePoints[I-1] := Integer(Char(LGlyphChars[I]));
    end;

    LChars := TPyVirtualBuffer.Create(SizeOf(stbtt_packedchar) * (NumOfGlyphs+1));
    try
      LPackRange.font_size := -LSize;
      LPackRange.first_unicode_codepoint_in_range := 0;
      LPackRange.array_of_unicode_codepoints := @LCodePoints[0];
      LPackRange.num_chars := NumOfGlyphs;
      LPackRange.chardata_for_range := LChars.Memory;
      LPackRange.h_oversample := 1;
      LPackRange.v_oversample := 1;

      FAtlasSize := 32;

      while True do
      begin
        SetLength(LBitmap, FAtlasSize * FAtlasSize);
        stbtt_PackBegin(@LPackContext, @LBitmap[0], FAtlasSize, FAtlasSize, 0, 1, nil);
        stbtt_PackSetOversampling(@LPackContext, 1, 1);
        if stbtt_PackFontRanges(@LPackContext, LBuffer.Memory, 0, @LPackRange, 1) = 0  then
          begin
            LBitmap := nil;
            stbtt_PackEnd(@LPackContext);
            FAtlasSize := FAtlasSize * 2;
            if (FAtlasSize > LMaxTextureSize) then
            begin
              raise Exception.Create(Format('Font texture too large. Max size: %d', [LMaxTextureSize]));
            end;
          end
        else
          begin
            stbtt_PackEnd(@LPackContext);
            break;
          end;
      end;

      FAtlas := TPyTexture.Create();
      FAtlas.Load(@LBitmap[0], FAtlasSize, FAtlasSize);
      FAtlas.SetPivot(0, 0);
      FAtlas.SetAnchor(0, 0);
      FAtlas.SetBlend(tbAlpha);
      FAtlas.SetColor(PyWHITE);

      LBitmap := nil;

      LScale := stbtt_ScaleForMappingEmToPixels(@LFontInfo, LSize);
      stbtt_GetFontVMetrics(@LFontInfo, @LAscent, nil, nil);
      FBaseline := LAscent * LScale;

      FGlyph.Clear();
      for I := Low(LCodePoints) to High(LCodePoints) do
      begin
        LChar := Pstbtt_packedchar(LChars.Memory);
        Inc(LChar, I);

        LGlyph.SrcRect.pos.x := LChar.x0;
        LGlyph.SrcRect.pos.y := LChar.y0;
        LGlyph.SrcRect.size.w := LChar.x1-LChar.x0;
        LGlyph.SrcRect.size.h := LChar.y1-LChar.y0;

        LGlyph.DstRect.pos.x := 0 + LChar.xoff;
        LGlyph.DstRect.pos.y := 0 + LChar.yoff + FBaseline;
        LGlyph.DstRect.size.w := (LChar.x1-LChar.x0);
        LGlyph.DstRect.size.h := (LChar.y1-LChar.y0);

        LGlyph.XAdvance := LChar.xadvance;

        FGlyph.Add(LCodePoints[I], LGlyph);
      end;

      if AOwnIO then
      begin
        LIO.Free();
      end;

      Result := True;

    finally
      LChars.Free();
    end;

  finally
    LBuffer.Free();
  end;
end;

function  TPyFont.LoadFromFile(const AWindow: TPyWindow; const AFilename: string; const ASize: Cardinal; const AGlyphs: string): Boolean;
var
  LIO: TPyFileIO;
begin
  Result := False;
  LIO := TPyFileIO.Create();
  try
    if not LIO.Open(AFilename, iomRead) then Exit;
    Result := Load(AWindow, LIO, ASize, AGlyphs, False);
  finally
    LIO.Free();
  end;
end;

function  TPyFont.LoadFromZipFile(const AWindow: TPyWindow; const AZipFilename, AFilename: string; const ASize: Cardinal; const AGlyphs: string; const APassword: string): Boolean;
var
  LIO: TPyZipFileIO;
begin
  Result := False;

  LIO := TPyZipFileIO.Create();
  if not LIO.Open(AZipFilename, AFilename, APassword) then
  begin
    LIO.Free();
    Exit;
  end;

  Result := Load(AWindow, LIO, ASize, AGlyphs, True);
end;

procedure TPyFont.Unload();
begin
  if Assigned(FAtlas) then
  begin
    FAtlas.Free();
    FGlyph.Clear();
  end;
end;

procedure TPyFont.DrawText(const AWindow: TPyWindow; const X, Y: Single; const AColor: TPyColor; AHAlign: TPyHAlign; const AText: string);
var
  LText: string;
  LChar: Integer;
  LGlyph: TFontGlyph;
  I, LLen: Integer;
  LX, LY: Single;
  LViewport: TPyRect;
  LWidth: Single;
begin
  LText := AText;
  LLen := LText.Length;

  LX := X;
  LY := Y;

  LViewport := AWindow.GetViewport();

  case aHAlign of
    haLeft:
      begin
      end;
    haCenter:
      begin
        LWidth := TextLength(AText, []);
        LX := (LViewport.size.w - LWidth)/2;
      end;
    haRight:
      begin
        LWidth := TextLength(AText, []);
        LX := LViewport.size.w - LWidth;
      end;
  end;

  FAtlas.SetColor(AColor);

  for I := 1 to LLen do
  begin
    LChar := Integer(Char(LText[I]));
    if FGlyph.TryGetValue(LChar, LGlyph) then
    begin
      LGlyph.DstRect.pos.x := LGlyph.DstRect.pos.x + LX;
      LGlyph.DstRect.pos.y := LGlyph.DstRect.pos.y + LY;

      FAtlas.SetRegion(LGlyph.SrcRect);
      FAtlas.SetPos(LGlyph.DstRect.pos.x, LGlyph.DstRect.pos.y);
      FAtlas.Draw(AWindow);
      LX := LX + LGlyph.XAdvance;
    end;
  end;
end;

procedure TPyFont.DrawText(const AWindow: TPyWindow; const X: Single; var Y: Single; const aLineSpace: Single; const aColor: TPyColor; AHAlign: TPyHAlign; const AText: string);
begin
  DrawText(AWindow, X, Y, aColor, aHAlign, AText);
  Y := Y + FBaseLine + ALineSpace;
end;

procedure TPyFont.DrawText(const AWindow: TPyWindow; const X, Y: Single; const AColor: TPyColor; AHAlign: TPyHAlign; const AText: string; const AArgs: array of const);
begin
  DrawText(AWindow, X, Y, AColor, AHAlign, Format(AText, AArgs));
end;

procedure TPyFont.DrawText(const AWindow: TPyWindow; const X: Single; var Y: Single; const aLineSpace: Single; const aColor: TPyColor; AHAlign: TPyHAlign; const AText: string; const AArgs: array of const);
begin
  DrawText(AWindow, X, Y, ALineSpace, AColor, AHAlign, Format(AText, AArgs));
end;

function  TPyFont.TextLength(const AText: string): Single;
var
  LText: string;
  LChar: Integer;
  LGlyph: TFontGlyph;
  I, LLen: Integer;
  LWidth: Single;
begin
  Result := 0;
  if not Assigned(FAtlas) then Exit;

  LText := AText;
  LLen := LText.Length;

  LWidth := 0;

  for I := 1 to LLen do
  begin
    LChar := Integer(Char(LText[I]));
    if FGlyph.TryGetValue(LChar, LGlyph) then
    begin
      LWidth := LWidth + LGlyph.XAdvance;
    end;
  end;

  Result := LWidth;
end;

function  TPyFont.TextLength(const AText: string; const AArgs: array of const): Single;
begin
  Result := TextLength(Format(AText, AArgs));
end;

function  TPyFont.TextHeight(): Single;
begin
  Result :=0;
  if not Assigned(FAtlas) then Exit;
  Result := FBaseLine;
end;

function  TPyFont.SaveTexture(const AFilename: string): Boolean;
begin
  Result := False;
  if not Assigned(FAtlas) then Exit;
  if AFilename.IsEmpty then Exit;
  FAtlas.Save(AFilename);
end;

class function TPyFont.Init(const AWindow: TPyWindow; const ASize: Cardinal; const AGlyphs: string=''): TPyFont;
begin
  Result := TPyFont.Create();
  Result.Load(AWindow, ASize, AGlyphs);
end;

class function TPyFont.Init(const AWindow: TPyWindow; const AZipFilename, AFilename: string; const ASize: Cardinal; const AGlyphs: string=''; const APassword: string=PyDEFAULT_ZIPFILE_PASSWORD): TPyFont;
begin
  Result := TPyFont.Create();
  if not Result.LoadFromZipFile(AWindow, AZipFilename, AFilename, ASize, AGlyphs, APassword) then
  begin
    Result.Free();
    Result := nil;
  end;
end;

{$ENDREGION}

{$REGION ' Pyro.Sprite '}
{ TPySprite }
constructor TPySprite.Create();
begin
  inherited;
  FTextures := nil;
  FGroups := nil;
  FPageCount := 0;
  FGroupCount := 0;
end;

destructor TPySprite.Destroy();
begin
  Clear();
  inherited;
end;

procedure TPySprite.Clear();
var
  I: Integer;
begin
  if FTextures <> nil then
  begin
    // free group data
    for I := 0 to FGroupCount - 1 do
    begin
      // free image array
      FGroups[I].Image := nil;
    end;

    // free page
    for I := 0 to FPageCount - 1 do
    begin
      if Assigned(FTextures[I]) then
      begin
        FTextures[I].Free();
      end;
    end;
  end;

  FTextures := nil;
  FGroups := nil;
  FPageCount := 0;
  FGroupCount := 0;
end;

function TPySprite.LoadPageFromFile(const AFilename: string; AColorKey: PPyColor): Integer;
var
  LTexture: TPyTexture;
begin
  Result := -1;
  LTexture := TPyTexture.Create();
  if not Assigned(LTexture) then Exit;
  if not LTexture.LoadFromFile(AFilename, AColorKey) then
  begin
    LTexture.Free();
    Exit;
  end;

  Result := FPageCount;
  Inc(FPageCount);
  SetLength(FTextures, FPageCount);
  FTextures[Result] := LTexture;
end;

function TPySprite.LoadPageFromZipFile(const AZipFilename, AFilename: string; AColorKey: PPyColor; const APassword: string): Integer;
var
  LTexture: TPyTexture;
begin
  Result := -1;
  LTexture := TPyTexture.Create();
  if not Assigned(LTexture) then Exit;
  if not LTexture.LoadFromZipFile(AZipFilename, AFilename, AColorkey, APassword) then
  begin
    LTexture.Free();
    Exit;
  end;

  Result := FPageCount;
  Inc(FPageCount);
  SetLength(FTextures, FPageCount);
  FTextures[Result] := LTexture;
end;

function TPySprite.AddGroup(): Integer;
begin
  Result := FGroupCount;
  Inc(FGroupCount);
  SetLength(FGroups, FGroupCount);
end;

function TPySprite.GetGroupCount(): Integer;
begin
  Result := FGroupCount;
end;

function TPySprite.AddImageFromRect(const APage, AGroup: Integer; const ARect: TPyRect; const AXOffset: Integer; const AYOffset: Integer): Integer;
begin
  Result := -1;
  if not InRange(APage, 0, FPageCount-1) then Exit;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;

  Result := FGroups[AGroup].Count;
  Inc(FGroups[AGroup].Count);
  SetLength(FGroups[AGroup].Image, FGroups[AGroup].Count);

  FGroups[AGroup].Image[Result].Rect.pos.X := ARect.pos.X + AXOffset;
  FGroups[AGroup].Image[Result].Rect.pos.Y := ARect.pos.Y + AYOffset;
  FGroups[AGroup].Image[Result].Rect.size.w := aRect.size.w;
  FGroups[AGroup].Image[Result].Rect.size.h := aRect.size.h;
  FGroups[AGroup].Image[Result].Page := APage;
end;

function TPySprite.AddImageFromGrid(const APage, AGroup, AGridX, AGridY, AGridWidth, AGridHeight: Integer; const AXOffset: Integer; const AYOffset: Integer): Integer;
begin
  Result := -1;
  if not InRange(APage, 0, FPageCount-1) then Exit;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;

  Result := FGroups[AGroup].Count;
  Inc(FGroups[AGroup].Count);
  SetLength(FGroups[AGroup].Image, FGroups[AGroup].Count);

  FGroups[AGroup].Image[Result].Rect.pos.X := (aGridWidth * aGridX) + AXOffset;
  FGroups[AGroup].Image[Result].Rect.pos.Y := (aGridHeight * aGridY) + AYOffset;
  FGroups[AGroup].Image[Result].Rect.size.w := aGridWidth;
  FGroups[AGroup].Image[Result].Rect.size.h := aGridHeight;
  FGroups[AGroup].Image[Result].Page := APage;
end;

function TPySprite.AddImages(const APage, AGroup, AColCount, ARowCount, AImageWidth, AImageHeight: Integer; const AXOffset: Integer=0; const AYOffset: Integer=0): Boolean;
var
  X, Y: Integer;
begin
  Result := False;
  for Y  := 0 to ARowCount-1 do
  begin
    for X := 0 to AColCount-1 do
    begin
      if AddImageFromGrid(APage, AGroup, X, Y,  AImageWidth, AImageHeight, AXOffset, AYOffset) = -1 then Exit;
    end;
  end;
  Result := True;
end;

function TPySprite.GetImageCount(const AGroup: Integer): Integer;
begin
  Result := -1;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;
  Result := FGroups[AGroup].Count;
end;

function TPySprite.GetImageWidth(const ANum, AGroup: Integer): Single;
begin
  Result := -1;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;
  if not InRange(ANum, 0, FGroups[AGroup].Count-1) then Exit;
  Result := FGroups[AGroup].Image[ANum].Rect.size.w;
end;

function TPySprite.GetImageHeight(const ANum, AGroup: Integer): Single;
begin
  Result := 0;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;
  if not InRange(ANum, 0, FGroups[AGroup].Count-1) then Exit;
  Result := FGroups[AGroup].Image[ANum].Rect.size.h;
end;

function TPySprite.GetImageTexture(const ANum, AGroup: Integer): TPyTexture;
begin
  Result := nil;
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;
  if not InRange(ANum, 0, FGroups[AGroup].Count-1) then Exit;
  Result := FTextures[FGroups[AGroup].Image[ANum].Page];
end;

function TPySprite.GetImageRegion(const ANum, AGroup: Integer): TPyRect;
begin
  Result := PyMath.Rect(-1,-1,-1,-1);
  if not InRange(AGroup, 0, FGroupCount-1) then Exit;
  if not InRange(ANum, 0, FGroups[AGroup].Count-1) then Exit;
  Result := FGroups[AGroup].Image[ANum].Rect;
end;

{$ENDREGION}

{$REGION ' Pyro.Entity '}
{ TPyEntity }
constructor TPyEntity.Create();
begin
  inherited;
end;

destructor TPyEntity.Destroy();
begin
  inherited;
end;

function TPyEntity.Init(const ASprite: TPySprite; const AGroup: Integer): Boolean;
begin
  Result := False;
  if not Assigned(ASprite) then Exit;
  if not InRange(AGroup, 0, ASprite.GetGroupCount()-1) then Exit;

  FSprite := aSprite;
  FGroup := AGroup;
  SetFrameRange(0, ASprite.GetImageCount(FGroup)-1);
  SetFrameSpeed(24);
  SetScaleAbs(1.0);
  RotateAbs(0);
  SetAngleOffset(0);
  SetColor(PyWHITE);
  SetHFlip(False);
  SetVFlip(False);
  SetLoopFrame(True);
  SetPosAbs(0, 0);
  SetBlend(tbAlpha);
  SetPivot(0.5, 0.5);
  SetAnchor(0.5, 0.5);
  SetFrame(0);

  Result := True;
end;

function  TPyEntity.GetPivot(): TPyPoint;
begin
  Result := FPivot;
end;

procedure TPyEntity.SetPivot(const APoint: TPyPoint);
begin
  FPivot := APoint;
end;

procedure TPyEntity.SetPivot(const X, Y: Single);
begin
  FPivot.x := X;
  FPivot.y := Y;
end;

function  TPyEntity.GetAnchor(): TPyPoint;
begin
  Result := FAnchor;
end;

procedure TPyEntity.SetAnchor(const APoint: TPyPoint);
begin
  FAnchor := APoint;
end;

procedure TPyEntity.SetAnchor(const X, Y: Single);
begin
  FAnchor.x := X;
  FAnchor.y := Y;
end;

procedure TPyEntity.SetFrameRange(const aFirst, aLast: Integer);
begin
  FFirstFrame := aFirst;
  FLastFrame  := aLast;
end;

function  TPyEntity.NextFrame(): Boolean;
begin
  Result := False;
  if FFrameTimer.Check() then
  begin
    Inc(FFrame);
    if FFrame > FLastFrame then
    begin
      if FLoopFrame then
        FFrame := FFirstFrame
      else
        FFrame := FLastFrame;
      Result := True;
    end;
    SetFrame(FFrame);
  end;
end;

function  TPyEntity.PrevFrame(): Boolean;
begin
  Result := False;
  if FFrameTimer.Check() then
  begin
    Dec(FFrame);
    if FFrame < FFirstFrame then
    begin
      if FLoopFrame then
        FFrame := FLastFrame
      else
        FFrame := FFirstFrame;
      Result := True;
    end;
    SetFrame(FFrame);
  end;
end;

function  TPyEntity.GetFrame(): Integer;
begin
  Result := FFrame;
end;

procedure TPyEntity.SetFrame(const AFrame: Integer);
var
  LW, LH, LR: Single;
begin
  FFrame := aFrame;
  EnsureRange(FFrame, 0, FSprite.GetImageCount(FGroup)-1);

  LW := FSprite.GetImageWidth(FFrame, FGroup);
  LH := FSprite.GetImageHeight(FFrame, FGroup);

  LR := (LW + LH) / 2;

  FWidth  := LW * FScale;
  FHeight := LH * FScale;
  FRadius := LR * FScale;
end;

function  TPyEntity.GetFrameSpeed(): Single;
begin
  Result := FFrameTimer.Speed();
end;

procedure TPyEntity.SetFrameSpeed(const AFrameSpeed: Single);
begin
  FFrameTimer.InitFPS(AFrameSpeed);
end;

function  TPyEntity.GetFirstFrame(): Integer;
begin
  Result := FFirstFrame;
end;

function  TPyEntity.GetLastFrame(): Integer;
begin
  Result := FLastFrame;
end;

procedure TPyEntity.SetPosAbs(const X, Y: Single);
begin
  FPos.X := X;
  FPos.Y := Y;
  FDir.X := 0;
  FDir.Y := 0;
end;

procedure TPyEntity.SetPosRel(const X, Y: Single);
begin
  FPos.X := FPos.X + X;
  FPos.Y := FPos.Y + Y;
  FDir.X := X;
  FDir.Y := Y;
end;

function  TPyEntity.GetPos(): TPyVector;
begin
  Result := FPos;
end;

function  TPyEntity.GetDir(): TPyVector;
begin
  Result := FDir;
end;

procedure TPyEntity.SetScaleAbs(const AScale: Single);
begin
  FScale := AScale;
  SetFrame(FFrame);
end;

procedure TPyEntity.SetScaleRel(const AScale: Single);
begin
  FScale := FScale + AScale;
  SetFrame(FFrame);
end;

function  TPyEntity.GetAngle(): Single;
begin
  Result := FAngle;
end;

function  TPyEntity.GetAngleOffset(): Single;
begin
  Result := FAngleOffset;
end;

procedure TPyEntity.SetAngleOffset(const AAngle: Single);
begin
  FAngleOffset := FAngleOffset + AAngle;
  PyMath.ClipValuef(FAngleOffset, 0, 360, True);
end;

procedure TPyEntity.RotateAbs(const AAngle: Single);
begin
  FAngle := AAngle;
  PyMath.ClipValuef(FAngle, 0, 360, True);
end;

procedure TPyEntity.RotateRel(const AAngle: Single);
begin
  FAngle := FAngle + AAngle;
  PyMath.ClipValuef(FAngle, 0, 360, True);
end;

function  TPyEntity.RotateToAngle(const AAngle, ASpeed: Single): Boolean;
var
  Step: Single;
  Len : Single;
  S   : Single;
begin
  Result := False;
  Step := PyMath.AngleDiff(FAngle, AAngle);
  Len  := Sqrt(Step*Step);
  if Len = 0 then
    Exit;
  S    := (Step / Len) * aSpeed;
  FAngle := FAngle + S;
  if PyMath.SameValuef(Step, 0, S) then
  begin
    RotateAbs(aAngle);
    Result := True;
  end;
end;

function  TPyEntity.RotateToPos(const X, Y, ASpeed: Single): Boolean;
var
  LAngle: Single;
  LStep: Single;
  LLen: Single;
  LS: Single;
  LTmpPos: TPyVector;
begin
  Result := False;
  LTmpPos.X  := X;
  LTmpPos.Y  := Y;

  //LAngle := -FPos.Angle(LTmpPos);
  LAngle := -PyMath.VectorAngle(FPos, LTmpPos);
  LStep := PyMath.AngleDiff(FAngle, LAngle);
  LLen  := Sqrt(LStep*LStep);
  if LLen = 0 then
    Exit;
  LS := (LStep / LLen) * aSpeed;

  if not PyMath.SameValuef(LStep, LS, aSpeed) then
    RotateRel(LS)
  else begin
    RotateRel(LStep);
    Result := True;
  end;
end;

function  TPyEntity.RotateToPosAt(const aSrcX, aSrcY, ADestX, ADestY, ASpeed: Single): Boolean;
var
  LAngle: Single;
  LStep : Single;
  LLen  : Single;
  LS    : Single;
  LSPos,LDPos : TPyVector;
begin
  Result := False;
  LSPos.X := aSrcX;
  LSPos.Y := aSrcY;
  LDPos.X  := aDestX;
  LDPos.Y  := aDestY;

  //LAngle := LSPos.Angle(LDPos);
  LAngle := PyMath.VectorAngle(LSPos, LDPos);
  LStep := PyMath.AngleDiff(FAngle, LAngle);
  LLen  := Sqrt(LStep*LStep);
  if LLen = 0 then
    Exit;
  LS := (LStep / LLen) * aSpeed;
  if not PyMath.SameValuef(LStep, LS, aSpeed) then
    RotateRel(LS)
  else begin
    RotateRel(LStep);
    Result := True;
  end;
end;

procedure TPyEntity.Thrust(const ASpeed: Single);
var
  LS: Single;
  LA: Integer;
begin
  LA := Abs(Round(FAngle + 90.0));
  LA := PyMath.ClipValue(LA, 0, 360, True);

  LS := -aSpeed;

  FDir.x := PyMath.AngleCos(LA) * LS;
  FDir.y := PyMath.AngleSin(LA) * LS;

  FPos.x := FPos.x + FDir.x;
  FPos.y := FPos.y + FDir.y;
end;

procedure TPyEntity.ThrustAngle(const AAngle, ASpeed: Single);
var
  LS: Single;
  LA: Integer;
begin
  LA := Abs(Round(AAngle));

  PyMath.ClipValue(LA, 0, 360, True);

  LS := -aSpeed;

  FDir.x := PyMath.AngleCos(LA) * LS;
  FDir.y := PyMath.AngleSin(LA) * LS;

  FPos.x := FPos.x + FDir.x;
  FPos.y := FPos.y + FDir.y;
end;

function  TPyEntity.ThrustToPos(const aThrustSpeed, ARotSpeed, ADestX, ADestY, ASlowdownDist, AStopDist, AStopSpeed, AStopSpeedEpsilon: Single): Boolean;
var
  LDist : Single;
  LStep : Single;
  LSpeed: Single;
  LDestPos: TPyVector;
  LStopDist: Single;
begin
  Result := False;

  if aSlowdownDist <= 0 then Exit;
  LStopDist := AStopDist;
  if LStopDist < 0 then LStopDist := 0;

  LDestPos.X := aDestX;
  LDestPos.Y := aDestY;
  //LDist := FPos.Distance(LDestPos);
  LDist := PyMath.VectorDistance(FPos, LDestPos);

  LDist := LDist - LStopDist;

  if LDist > aSlowdownDist then
    begin
      LSpeed := aThrustSpeed;
    end
  else
    begin
      LStep := (LDist/aSlowdownDist);
      LSpeed := (aThrustSpeed * LStep);
      if LSpeed <= aStopSpeed then
      begin
        LSpeed := 0;
        Result := True;
      end;
    end;

  if RotateToPos(aDestX, aDestY, aRotSpeed) then
  begin
    Thrust(LSpeed);
  end;
end;

function  TPyEntity.IsVisible(const AWindow: TPyWindow): Boolean;
var
  LHW,LHH: Single;
  LVPW,LVPH: Integer;
  LX,LY: Single;
begin
  Result := False;

  LHW := FWidth / 2;
  LHH := FHeight / 2;

  //AWindow.GetViewport(@LVPX, @LVPY, @LVPW, @LVPH);
  LVPW := Round(AWindow.GetVirtualSize().w);
  LVPH := Round(AWindow.GetVirtualSize().h);

  Dec(LVPW); Dec(LVPH);

  LX := FPos.X;
  LY := FPos.Y;

  if LX > (LVPW + LHW) then Exit;
  if LX < -LHW    then Exit;
  if LY > (LVPH + LHH) then Exit;
  if LY < -LHH    then Exit;

  Result := True;
end;

function  TPyEntity.IsFullyVisible(const AWindow: TPyWindow): Boolean;
var
  LHW,LHH: Single;
  LVPW,LVPH: Integer;
  LX,LY: Single;
begin
  Result := False;

  LHW := FWidth / 2;
  LHH := FHeight / 2;

  //AWindow.GetViewport(@LVPX, @LVPY, @LVPW, @LVPH);
  LVPW := Round(AWindow.GetVirtualSize().w);
  LVPH := Round(AWindow.GetVirtualSize().h);

  Dec(LVPW); Dec(LVPH);

  LX := FPos.X;
  LY := FPos.Y;

  if LX > (LVPW - LHW) then Exit;
  if LX <  LHW       then Exit;
  if LY > (LVPH - LHH) then Exit;
  if LY <  LHH       then Exit;

  Result := True;
end;

function  TPyEntity.Collide(const X, Y, aRadius, aShrinkFactor: Single): Boolean;
var
  LDist: Single;
  LR1,LR2: Single;
  LV0,LV1: TPyVector;
begin
  LR1  := FRadius * aShrinkFactor;
  LR2  := aRadius * aShrinkFactor;

  LV0.X := FPos.X;
  LV0.Y := FPos.Y;

  LV1.x := X;
  LV1.y := Y;

  //LDist := LV0.Distance(LV1);
  LDist := PyMath.VectorDistance(LV0, LV1);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
   Result := False;
end;

function  TPyEntity.Collide(const AEntity: TPyEntity; const AOverlap: TPyEntityOverlap): Boolean;
var
  LTextureA, LTextureB: TPyTexture;
begin
  Result := False;

  LTextureA := FSprite.GetImageTexture(FFrame, FGroup);
  LTextureB := AEntity.GetSprite().GetImageTexture(AEntity.GetFrame(), AEntity.GetGroup());

  LTextureA.SetPivot(FPivot);
  LTextureA.SetAnchor(FAnchor);
  LTextureA.SetPos(FPos.x, FPos.y);
  LTextureA.SetScale(FScale);
  LTextureA.SetAngle(FAngle);
  LTextureA.SetHFlip(FHFlip);
  LTextureA.SetVFlip(FVFlip);
  LTextureA.SetRegion(FSprite.GetImageRegion(FFrame, FGroup));

  LTextureB.SetPivot(AEntity.GetPivot());
  LTextureB.SetAnchor(AEntity.GetAnchor());
  LTextureB.SetPos(AEntity.GetPos().x, AEntity.GetPos().y);
  LTextureB.SetScale(AEntity.GetScale());
  LTextureB.SetAngle(AEntity.GetAngle());
  LTextureB.SetHFlip(AEntity.GetHFlip());
  LTextureB.SetVFlip(AEntity.GetVFlip());
  LTextureB.SetRegion(AEntity.GetSprite().GetImageRegion(FFrame, FGroup));

  case AOverlap of
    eoAABB: Result := LTextureA.CollideAABB(LTextureB);
    eoOBB : Result := LTextureA.CollideOBB(LTextureB);
  end;

end;

procedure TPyEntity.Render(const AWindow: TPyWindow);
var
  LTexture: TPyTexture;
begin
  LTexture := FSprite.GetImageTexture(FFrame, FGroup);
  LTexture.SetPivot(FPivot);
  LTexture.SetAnchor(FAnchor);
  LTexture.SetPos(FPos.x, FPos.y);
  LTexture.SetScale(FScale);
  LTexture.SetAngle(FAngle);
  LTexture.SetHFlip(FHFlip);
  LTexture.SetVFlip(FVFlip);
  LTexture.SetRegion(FSprite.GetImageRegion(FFrame, FGroup));
  LTexture.SetBlend(FBlend);
  LTexture.SetColor(FColor);
  LTexture.Draw(AWindow);
end;

procedure TPyEntity.RenderAt(const AWindow: TPyWindow; const X, Y: Single);
var
  LTexture: TPyTexture;
begin
  LTexture := FSprite.GetImageTexture(FFrame, FGroup);
  LTexture.SetPivot(FPivot);
  LTexture.SetAnchor(FAnchor);
  LTexture.SetPos(X, Y);
  LTexture.SetScale(FScale);
  LTexture.SetAngle(FAngle);
  LTexture.SetHFlip(FHFlip);
  LTexture.SetVFlip(FVFlip);
  LTexture.SetRegion(FSprite.GetImageRegion(FFrame, FGroup));
  LTexture.SetBlend(FBlend);
  LTexture.SetColor(FColor);
  LTexture.Draw(AWindow);
end;

function  TPyEntity.GetSprite(): TPySprite;
begin
  Result := FSprite;
end;

function  TPyEntity.GetGroup(): Integer;
begin
  Result := FGroup;
end;

function  TPyEntity.GetScale(): Single;
begin
  Result := FScale;
end;

function  TPyEntity.GetColor(): TPyColor;
begin
  Result := FColor;
end;

procedure TPyEntity.SetColor(const AColor: TPyColor);
begin
  FColor := AColor;
end;

function  TPyEntity.GetBlend(): TPyTextureBlend;
begin
  Result := FBlend;
end;

procedure TPyEntity.SetBlend(const AValue: TPyTextureBlend);
begin
  FBlend := AValue;
end;

function  TPyEntity.GetHFlip(): Boolean;
begin
  Result := FHFlip;
end;

procedure TPyEntity.SetHFlip(const AFlip: Boolean);
begin
  FHFlip := AFlip;
end;

function  TPyEntity.GetVFlip(): Boolean;
begin
  Result := FVFlip;
end;

procedure TPyEntity.SetVFlip(const AFlip: Boolean);
begin
  FVFlip := AFlip;
end;

function  TPyEntity.GetLoopFrame(): Boolean;
begin
  Result := FLoopFrame;
end;

procedure TPyEntity.SetLoopFrame(const aLoop: Boolean);
begin
  FLoopFrame := ALoop;
end;

function  TPyEntity.GetWidth(): Single;
begin
  Result := FWidth;
end;

function  TPyEntity.GetHeight(): Single;
begin
  Result := FHeight;
end;

function  TPyEntity.GetRadius(): Single;
begin
  Result := FRadius;
end;

{$ENDREGION}

{$REGION ' Pyro.Audio '}
{ TMaVPS }
function TMaVFS_OnOpen(AVFS: Pma_vfs; const AFilename: PUTF8Char; AOpenMode: ma_uint32; AFile: Pma_vfs_file): ma_result; cdecl;
var
  LIO: TPyIO;
begin
  Result := MA_ERROR;
  LIO := PPyMaVFS(AVFS).IO;
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen() then Exit;
  AFile^ := LIO;
  Result := MA_SUCCESS;
end;

function TMaVFS_OnOpenW(AVFS: Pma_vfs; const AFilename: PWideChar; AOpenMode: ma_uint32; pFile: Pma_vfs_file): ma_result; cdecl;
begin
  Result := MA_ERROR;
end;

function TMaVFS_OnClose(AVFS: Pma_vfs; file_: ma_vfs_file): ma_result; cdecl;
var
  LIO: TPyIO;
begin
  Result := MA_ERROR;
  LIO := TPyIO(File_);
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen then Exit;
  LIO.Free();
  Result := MA_SUCCESS;
end;

function TMaVFS_OnRead(AVFS: Pma_vfs; file_: ma_vfs_file; AData: Pointer; ASizeInBytes: NativeUInt; ABytesRead: PNativeUInt): ma_result; cdecl;
var
  LIO: TPyIO;
  LResult: Int64;
begin
  Result := MA_ERROR;
  LIO := TPyIO(File_);
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen then Exit;
  LResult := LIO.Read(AData, ASizeInBytes);
  if LResult < 0 then Exit;
  ABytesRead^ := LResult;
  Result := MA_SUCCESS;
end;

function TMaVFS_OnWrite(AVFS: Pma_vfs; AVFSFile: ma_vfs_file; const AData: Pointer; ASizeInBytes: NativeUInt; ABytesWritten: PNativeUInt): ma_result; cdecl;
begin
  Result := MA_ERROR;
end;

function TMaVFS_OnSeek(AVFS: Pma_vfs; file_: ma_vfs_file; AOffset: ma_int64;
  AOrigin: ma_seek_origin): ma_result; cdecl;
var
  LIO: TPyIO;
begin
  Result := MA_ERROR;
  LIO := TPyIO(File_);
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen then Exit;
  LIO.Seek(AOffset, TPyIOSeek(AOrigin));
  Result := MA_SUCCESS;
end;

function TMaVFS_OnTell(AVFS: Pma_vfs; file_: ma_vfs_file; ACursor: Pma_int64): ma_result; cdecl;
var
  LIO: TPyIO;
begin
  Result := MA_ERROR;
  LIO := TPyIO(File_);
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen then Exit;
  ACursor^ := LIO.Pos();
  Result := MA_SUCCESS;
end;

function TMaVFS_OnInfo(AVFS: Pma_vfs; AVFSFile: ma_vfs_file; AInfo: Pma_file_info): ma_result; cdecl;
var
  LIO: TPyIO;
  LResult: Int64;
begin
  Result := MA_ERROR;
  LIO := TPyIO(AVFSFile);
  if not Assigned(LIO) then Exit;
  if not LIO.IsOpen then Exit;

  LResult := LIO.Size;
  if LResult < 0 then Exit;

  AInfo.sizeInBytes := LResult;
  Result := MA_SUCCESS;
end;

constructor TPyMaVFS.Create(const AIO: TPyIO);
begin
  Self := Default(TPyMaVFS);
  Callbacks.onopen := TMaVFS_OnOpen;
  Callbacks.onOpenW := TMaVFS_OnOpenW;
  Callbacks.onRead := TMaVFS_OnRead;
  Callbacks.onWrite := TMaVFS_OnWrite;
  Callbacks.onclose := TMaVFS_OnClose;
  Callbacks.onread := TMaVFS_OnRead;
  Callbacks.onseek := TMaVFS_OnSeek;
  Callbacks.onTell := TMaVFS_OnTell;
  Callbacks.onInfo := TMaVFS_OnInfo;
  IO := AIO;
end;

class function PyAudio.FindFreeSoundSlot(): Integer;
var
  I: Integer;
begin
  Result := PyAUDIO_ERROR;
  for I := 0 to PyAUDIO_SOUND_COUNT-1 do
  begin
    if not FSound[I].InUse then
    begin
      Result := I;
      Exit;
    end;
  end;
end;

class function PyAudio.FindFreeChannelSlot(): Integer;
var
  I: Integer;
begin
  Result := PyAUDIO_ERROR;
  for I := 0 to PyAUDIO_SOUND_COUNT-1 do
  begin
    if (not FChannel[I].InUse) and (not FChannel[I].Reserved) then
    begin
      Result := I;
      Exit;
    end;
  end;
end;

class function PyAudio.ValidChannel(const AChannel: Integer): Boolean;
begin
  Result := False;
  if not InRange(AChannel, 0, PyAUDIO_CHANNEL_COUNT-1) then Exit;
  if not FChannel[AChannel].InUse then Exit;
  Result := True;
end;

class constructor PyAudio.Create();
begin
  inherited;
end;

class destructor PyAudio.Destroy();
begin
  Close();
  inherited;
end;

class function  PyAudio.Open(): Boolean;
begin
  Result := False;
  if IsOpen() then Exit;

  FVFS := TPyMaVFS.Create(nil);
  FEngineConfig := ma_engine_config_init;
  FEngineConfig.pResourceManagerVFS := @FVFS;
  if ma_engine_init(@FEngineConfig, @FEngine) <> MA_SUCCESS then Exit;

  FOpened := True;
  Result := IsOpen();
end;

class procedure PyAudio.Close();
begin
  if not IsOpen() then Exit;
  UnloadMusic();
  UnloadAllSounds();
  ma_engine_uninit(@FEngine);
  InitData;
end;

class function PyAudio.IsOpen(): Boolean;
begin
  Result := FOpened;
end;

class procedure PyAudio.InitData();
var
  I: Integer;
begin
  FEngine := Default(ma_engine);

  for I := Low(FSound) to High(FSound) do
    FSound[I] := Default(TSound);

  for I := Low(FChannel) to High(FChannel) do
    FChannel[i] := Default(TChannel);

  FOpened := False;
  FPaused := False;
end;

class procedure PyAudio.UnitInit();
begin
end;

class procedure PyAudio.Update();
var
  I: Integer;
begin
  if not IsOpen() then Exit;

  // check channels
  for I := 0 to PyAUDIO_CHANNEL_COUNT-1 do
  begin
    if FChannel[I].InUse then
    begin
      if ma_sound_is_playing(@FChannel[I].Handle) = MA_FALSE then
      begin
        ma_sound_uninit(@FChannel[I].Handle);
        FChannel[I].InUse := False;
      end;
    end;
  end;
end;

class function  PyAudio.IsPaused(): Boolean;
begin
  Result := FPaused;
end;

class procedure PyAudio.SetPause(const APause: Boolean);
begin
  if not IsOpen() then Exit;

  case aPause of
    True:
    begin
      if ma_engine_stop(@FEngine) = MA_SUCCESS then
        FPaused := aPause;
    end;

    False:
    begin
      if ma_engine_start(@FEngine) = MA_SUCCESS then
        FPaused := aPause;
    end;
  end;
end;

class function  PyAudio.PlayMusic(const AIO: TPyIO; const AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single): Boolean;
begin
  Result := FAlse;
  if not IsOpen then Exit;
  if not Assigned(AIO) then Exit;
  UnloadMusic();
  FVFS.IO := AIO;
  if ma_sound_init_from_file(@FEngine, PyUtils.AsUtf8(AFilename, []), Ord(MA_SOUND_FLAG_STREAM), nil,
    nil, @FMusic.Handle) <> MA_SUCCESS then
  FVFS.IO := nil;
  ma_sound_start(@FMusic);
  FMusic.Loaded := True;
  SetMusicLooping(ALoop);
  SetMusicVolume(AVolume);
  SetMusicPan(APan);
end;

class function  PyAudio.PlayMusicFromFile(const AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single): Boolean;
var
  LIO: TPyFileIO;
begin
  Result := False;
  //if not IGet(IFileIO, LIO) then Exit;
  LIO := TPyFileIO.Create();
  if not LIO.Open(AFilename,iomRead) then
  begin
    LIO.Free();
    Exit;
  end;

  Result := PlayMusic(LIO, AFilename, AVolume, ALoop, APan);
end;

class function  PyAudio.PlayMusicFromZipFile(const AZipFilename, AFilename: string; const AVolume: Single; const ALoop: Boolean; const APan: Single; const APassword: string): Boolean;
var
  LIO: TPyZipFileIO;
begin
  Result := False;
  LIO := TPyZipFileIO.Create();

  if not LIO.Open(AZipFilename, AFilename, APassword) then
  begin
    LIO.Free();
    Exit;
  end;
  Result := PlayMusic(LIO, AFilename, AVolume, ALoop, APan);
end;

class procedure PyAudio.UnloadMusic();
begin
  if not IsOpen() then Exit;
  if not FMusic.Loaded then Exit;
  ma_sound_stop(@FMusic.Handle);
  ma_sound_uninit(@FMusic.Handle);
  FMusic.Loaded := False;
end;

class function  PyAudio.IsMusicLooping(): Boolean;
begin
  Result := False;
  if not IsOpen() then Exit;
  Result := Boolean(ma_sound_is_looping(@FMusic.Handle));
end;

class procedure PyAudio.SetMusicLooping(const ALoop: Boolean);
begin
  if not IsOpen() then Exit;
  ma_sound_set_looping(@FMusic.Handle, Ord(ALoop))
end;

class function  PyAudio.MusicVolume(): Single;
begin
  Result := 0;
  if not IsOpen() then Exit;
  Result := FMusic.Volume;
end;

class procedure PyAudio.SetMusicVolume(const AVolume: Single);
begin
  if not IsOpen() then Exit;
  FMusic.Volume := AVolume;
  ma_sound_set_volume(@FMusic.Handle, PyMath.UnitToScalarValue(AVolume, 1));
end;

class function  PyAudio.MusicPan(): Single;
begin
  Result := 0;
  if not IsOpen() then Exit;

  Result := ma_sound_get_pan(@FMusic.Handle);
end;

class procedure PyAudio.SetMusicPan(const APan: Single);
begin
  if not IsOpen() then Exit;

  ma_sound_set_pan(@FMusic.Handle, EnsureRange(APan, -1, 1));
end;

class function  PyAudio.LoadSound(const AIO: TPyIO; const AFilename: string): Integer;
var
  LResult: Integer;
begin
  Result := PyAUDIO_ERROR;
  if not FOpened then Exit;
  if FPaused then Exit;
  LResult := FindFreeSoundSlot;
  if LResult = PyAUDIO_ERROR then Exit;

  FVFS.IO := AIO;
  if ma_sound_init_from_file(@FEngine, PyUtils.AsUtf8(AFilename, []), 0, nil, nil,
    @FSound[LResult].Handle) <> MA_SUCCESS then Exit;
  FVFS.IO := nil;
  FSound[LResult].InUse := True;
  Result := LResult;
end;

class function  PyAudio.LoadSoundFromFile(const AFilename: string): Integer;
var
  LIO: TPyFileIO;
begin
  Result := -1;
  if not IsOpen() then Exit;

  LIO := TPyFileIO.Create();
  try
    if not LIO.Open(AFilename, iomRead) then Exit;
    Result := LoadSound(LIO, AFilename);
  finally
    LIO.Free();
  end;
end;

class function  PyAudio.LoadSoundFromZipFile(const AZipFilename, AFilename: string; const APassword: string): Integer;
var
  LIO: TPyZipFileIO;
begin
  Result := -1;
  if not IsOpen() then Exit;

  LIO := TPyZipFileIO.Create();
  if not LIO.Open(AZipFilename, AFilename, APassword) then
  begin
    LIO.Free();
    Exit;
  end;

  Result := LoadSound(LIO, AFilename);
end;

class procedure PyAudio.UnloadSound(var aSound: Integer);
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not InRange(aSound, 0, PyAUDIO_SOUND_COUNT-1) then Exit;
  ma_sound_uninit(@FSound[aSound].Handle);
  FSound[aSound].InUse := False;
  aSound := PyAUDIO_ERROR;
end;

class procedure PyAudio.UnloadAllSounds();
var
  I: Integer;
begin
  if not IsOpen() then Exit;

  // close all channels
  for I := 0 to PyAUDIO_CHANNEL_COUNT-1 do
  begin
    if FChannel[I].InUse then
    begin
      ma_sound_stop(@FChannel[I].Handle);
      ma_sound_uninit(@FChannel[I].Handle);
    end;
  end;

  // close all sound buffers
  for I := 0 to PyAUDIO_SOUND_COUNT-1 do
  begin
    if FSound[I].InUse then
    begin
      ma_sound_uninit(@FSound[I].Handle);
    end;
  end;

end;

class function  PyAudio.PlaySound(const aSound, aChannel: Integer; const AVolume: Single; const ALoop: Boolean): Integer;
var
  LResult: Integer;
begin
  Result := PyAUDIO_ERROR;

  if not FOpened then Exit;
  if FPaused then Exit;
  if not InRange(aSound, 0, PyAUDIO_SOUND_COUNT-1) then Exit;

  if aChannel = PyAUDIO_CHANNEL_DYNAMIC then
    LResult := FindFreeChannelSlot
  else
    begin
      LResult := aChannel;
      if not InRange(aChannel, 0, PyAUDIO_CHANNEL_COUNT-1) then Exit;
      StopChannel(LResult);
    end;
  if LResult = PyAUDIO_ERROR then Exit;
  if ma_sound_init_copy(@FEngine, @FSound[ASound].Handle, 0, nil,
    @FChannel[LResult].Handle) <> MA_SUCCESS then Exit;
  FChannel[LResult].InUse := True;

  SetChannelVolume(LResult, aVolume);
  SetChannelPosition(LResult, 0, 0);
  SetChannelLoop(LResult, aLoop);

  if ma_sound_start(@FChannel[LResult].Handle) <> MA_SUCCESS then
  begin
    StopChannel(LResult);
    LResult := PyAUDIO_ERROR;
  end;

  Result := LResult;
end;

class procedure PyAudio.ReserveChannel(const aChannel: Integer; const aReserve: Boolean);
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not InRange(aChannel, 0, PyAUDIO_CHANNEL_COUNT-1) then Exit;
  FChannel[aChannel].Reserved := aReserve;
end;

class procedure PyAudio.StopChannel(const aChannel: Integer);
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;

  ma_sound_uninit(@FChannel[aChannel].Handle);
  FChannel[aChannel].InUse := False;
end;

class procedure PyAudio.SetChannelVolume(const aChannel: Integer; const AVolume: Single);
var
  LVolume: Single;
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not InRange(aVolume, 0, 1) then Exit;
  if not ValidChannel(aChannel) then Exit;

  FChannel[aChannel].Volume := aVolume;
  LVolume := PyMath.UnitToScalarValue(aVolume, 1);
  ma_sound_set_volume(@FChannel[aChannel].Handle, LVolume);
end;

class function  PyAudio.GetChannelVolume(const aChannel: Integer): Single;
begin
Result := 0;
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;
  Result := FChannel[aChannel].Volume;
end;

class procedure PyAudio.SetChannelPosition(const aChannel: Integer; const X, Y: Single);
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;

  ma_sound_set_position(@FChannel[aChannel].Handle, X, 0, Y);
end;

class procedure PyAudio.SetChannelLoop(const aChannel: Integer;
  const ALoop: Boolean);
begin
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;

  ma_sound_set_looping(@FChannel[aChannel].Handle, Ord(aLoop));
end;

class function  PyAudio.GetchannelLoop(const aChannel: Integer): Boolean;
begin
  Result := False;
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;

  Result := Boolean(ma_sound_is_looping(@FChannel[aChannel].Handle));
end;

class function  PyAudio.GetChannelPlaying(const aChannel: Integer): Boolean;
begin
  Result := False;
  if not FOpened then Exit;
  if FPaused then Exit;
  if not ValidChannel(aChannel) then Exit;

  Result := Boolean(ma_sound_is_playing(@FChannel[aChannel].Handle));
end;

{$ENDREGION}

{$REGION ' Pyro.Video '}
procedure TVideo_MADataCallback(ADevice: Pma_device; AOutput: Pointer; AInput: Pointer; AFrameCount: ma_uint32); cdecl;
var
  LReadPtr: PSingle;
  LFramesNeeded: Integer;
begin
  LFramesNeeded := AFrameCount * 2;
  LReadPtr := PSingle(PyVideo.FRingBuffer.DirectReadPointer(LFramesNeeded));

  if PyVideo.FRingBuffer.AvailableBytes >= LFramesNeeded then
    begin
      Move(LReadPtr^, AOutput^, LFramesNeeded * SizeOf(Single));
    end
  else
    begin
      FillChar(AOutput^, LFramesNeeded * SizeOf(Single), 0);
    end;
end;

procedure TVideo_PLMAudioDecodeCallback(APLM: Pplm_t; ASamples: Pplm_samples_t; AUserData: Pointer); cdecl;
begin
  PyVideo.FRingBuffer.Write(ASamples^.interleaved, ASamples^.count*2);
end;

procedure TVideo_PLMVideoDecodeCallback(APLM: Pplm_t; AFrame: Pplm_frame_t; AUserData: Pointer); cdecl;
begin
  // convert YUV to RGBA

  plm_frame_to_rgba(AFrame, @PyVideo.FRGBABuffer[0], Round(PyVideo.GetTexture().GetSize().w*4));

  // update OGL texture
  glBindTexture(GL_TEXTURE_2D, PyVideo.FTexture.GetHandle());
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, AFrame^.width, AFrame^.height, GL_RGBA, GL_UNSIGNED_BYTE, PyVideo.FRGBABuffer);
end;

procedure TVideo_PLMLoadBufferCallback(ABuffer: pplm_buffer_t; AUserData: pointer); cdecl;
var
  LBytesRead: Int64;
begin
  // read data from inputstream
  LBytesRead := PyVideo.FIO.Read(@PyVideo.FStaticPlmBuffer[0], PyVideo.BUFFERSIZE);

  // push LBytesRead to PLM buffer
  if LBytesRead > 0 then
    begin
      plm_buffer_write(aBuffer, @PyVideo.FStaticPlmBuffer[0], LBytesRead);
    end
  else
    begin
      // set status to stopped
      PyVideo.FStatus := vsStopped;
      PyVideo.FStatusFlag := True;
    end;
end;

class procedure PyVideo.OnStatusEvent();
begin
  if Assigned(FCallback.Handler) then
  begin
    FCallback.Handler(FCallback.UserData, FStatus, FFilename);
  end;
end;

class procedure PyVideo.UnitInit;
begin
end;

class constructor PyVideo.Create();
begin
end;

class destructor PyVideo.Destroy();
begin
  Stop();

end;

class function  PyVideo.GetStatusEvent(): TPyVideoStatusEvent;
begin
  Result := FCallback.Handler;
end;

class procedure PyVideo.SetStatusEvent(const ASender: Pointer; const AHandler: TPyVideoStatusEvent);
begin
  FCallback.Handler := AHandler;
  FCallback.UserData := ASender;
end;

class function  PyVideo.Play(const AIO: TPyIO;  const AFilename: string; const AVolume: Single; const ALoop: Boolean): Boolean;
var
  LBuffer: Pplm_buffer_t;
begin
  Result := False;

  Stop();

  // set volume & loop status
  FVolume := AVolume;
  FLoop := ALoop;

  // init ringbuffer
  FRingBuffer := TPyVirtualRingBuffer<Single>.Create(CSampleRate*2);
  if not Assigned(FRingBuffer) then Exit;

  // init device for audio playback
  FDeviceConfig := ma_device_config_init(ma_device_type_playback);
  FDeviceConfig.playback.format := ma_format_f32;
  FDeviceConfig.playback.channels := 2;
  FDeviceConfig.sampleRate := CSampleRate;
  FDeviceConfig.dataCallback := @TVideo_MADataCallback;
  if ma_device_init(nil, @FDeviceConfig, @FDevice) <> MA_SUCCESS then Exit;
  ma_device_start(@FDevice);
  SetVolume(AVolume);

  // set the input stream
  FIO := AIO;
  FFilename := AFilename;
  FStatus := vsPlaying;
  FStatusFlag := False;
  OnStatusEvent();

  // init plm buffer
  LBuffer := plm_buffer_create_with_capacity(BUFFERSIZE);
  if not Assigned(LBuffer) then
  begin
    ma_device_uninit(@FDevice);
    FRingBuffer.Free;
    Exit;
  end;

  plm_buffer_set_load_callback(LBuffer, TVideo_PLMLoadBufferCallback, PyVideo);
  FPLM := plm_create_with_buffer(LBuffer, 1);
  if not Assigned(FPLM) then
  begin
    plm_buffer_destroy(LBuffer);
    ma_device_uninit(@FDevice);
    FRingBuffer.Free;
    Exit;
  end;

  // create video render texture
  FTexture := TPyTexture.Create;
  FTexture.SetBlend(tbNone);
  FTexture.Alloc(plm_get_width(FPLM), plm_get_height(FPLM));

  // alloc the video rgba buffer
  SetLength(FRGBABuffer,
    Round(FTexture.GetSize.w*FTexture.GetSize.h*4));
  if not Assigned(FRGBABuffer) then
  begin
    plm_buffer_destroy(LBuffer);
    ma_device_uninit(@FDevice);
    FRingBuffer.Free;
    Exit;
  end;

  // set the audio lead time
  plm_set_audio_lead_time(FPLM, (CSampleSize*2)/FDeviceConfig.sampleRate);

  // set audio/video callbacks
  plm_set_audio_decode_callback(FPLM, TVideo_PLMAudioDecodeCallback, PyVideo);
  plm_set_video_decode_callback(FPLM, TVideo_PLMVideoDecodeCallback, PyVideo);

  FTexture.SetPivot(0, 0);
  FTexture.SetAnchor(0, 0);
  FTexture.SetBlend(tbNone);

  // return OK
  Result := True;
end;

class function  PyVideo.PlayFromZipFile(const AZipFilename, AFilename: string; const AVolume: Single; const ALoop: Boolean; const APassword: string): Boolean;
var
  LIO: TPyZipFileIO;
begin
  Result := False;

  LIO := TPyZipFileIO.Create();
  if not LIO.Open(AZipFilename, AFilename, APassword) then
  begin
    LIO.Free();
    Exit;
  end;

  Result := Play(LIO, AFilename, AVolume, ALoop);
end;

class procedure PyVideo.Stop();
begin
  if not Assigned(FPLM) then Exit;

  ma_device_stop(@FDevice);
  ma_device_uninit(@FDevice);

  plm_destroy(FPLM);

  //FIO.Free;
  FIO.Free();
  FTexture.Free;
  FRingBuffer.Free;

  FPLM := nil;
  FRingBuffer := nil;
  FStatus := vsStopped;
  FTexture := nil;
end;

class function  PyVideo.Update(const AWindow: TPyWindow): Boolean;
begin
  Result := False;
  if not Assigned(FPLM) then Exit;
  if FStatusFlag then
  begin
    FStatusFlag := False;
    OnStatusEvent();
  end;

  if FStatus = vsStopped then
  begin
    ma_device_stop(@FDevice);

    if FLoop then
    begin
      plm_rewind(FPLM);
      FIO.Seek(0, iosStart);
      FRingBuffer.Clear;
      ma_device_start(@FDevice);
      SetVolume(FVolume);
      FStatus := vsPlaying;
      plm_decode(FPLM, AWindow.GetTargetTime());
      OnStatusEvent();
      Exit;
    end;
    Result := True;
    Exit;
  end;

  plm_decode(FPLM, AWindow.GetTargetTime());
end;

class procedure PyVideo.Draw(const AWindow: TPyWindow; const X, Y, AScale: Single);
begin
  if FStatus <> vsPlaying then Exit;
  FTexture.SetPos(X, Y);
  FTexture.SetScale(AScale);
  FTexture.Draw(AWindow);
end;

class function  PyVideo.Status(): TPyVideoStatus;
begin
  Result := FStatus;
end;

class function  PyVideo.Volume(): Single;
begin
  Result := FVolume;
end;

class procedure PyVideo.SetVolume(const AVolume: Single);
begin
  FVolume := EnsureRange(AVolume, 0, 1);
  ma_device_set_master_volume(@FDevice, PyMath.UnitToScalarValue(FVolume, 1));
end;

class function  PyVideo.IsLooping(): Boolean;
begin
  Result := FLoop;
end;

class procedure PyVideo.SetLooping(const ALoop: Boolean);
begin
  FLoop := ALoop;
end;

class function  PyVideo.GetTexture(): TPyTexture;
begin
  Result := FTexture;
end;

{$ENDREGION}

{$REGION ' Pyro.Camera '}
{ TPyCamera }
constructor TPyCamera.Create();
begin
  inherited;
  FScale := 1;
end;

destructor TPyCamera.Destroy();
begin
  Reset();
  inherited;
end;

function  TPyCamera.GetX(): Single;
begin
  Result := FX;
end;

procedure TPyCamera.SetX(const AValue: Single);
begin
  FX := AValue;
end;

function  TPyCamera.GetY(): Single;
begin
  Result := FY;
end;

procedure TPyCamera.SetY(const AValue: Single);
begin
  FY := AValue;
end;

function  TPyCamera.GetRotation(): Single;
begin
  Result := FRotation;
end;

procedure TPyCamera.SetRotation(const AValue: Single);
begin
  FRotation := EnsureRange(AValue, 0, 360);
end;

function  TPyCamera.GetScale(): Single;
begin
  Result := FScale;
end;

procedure TPyCamera.SetScale(const AValue: Single);
begin
  FScale := AValue;
end;

procedure TPyCamera.Move(const X, Y: Single);
begin
  FX := FX + (X / FScale);
  FY := FY + (Y / FScale);
end;

procedure TPyCamera.Zoom(const AScale: Single);
begin
  FScale := FScale + (AScale * FScale);
end;

procedure TPyCamera.Rotate(const ARotation: Single);
begin
  FRotation := FRotation + ARotation;
end;

procedure TPyCamera.Use(const AWindow: TPyWindow);
begin
  if not Assigned(AWindow) then
  begin
    glPopMatrix();
    FWindow := nil;
    Exit;
  end;

  glPushMatrix();
  glTranslatef((AWindow.GetVirtualSize().w/2), (AWindow.GetVirtualSize().h/2), 0);
  glRotatef(FRotation, 0, 0, 1);
  glScalef(FScale, FScale, 1);
  glTranslatef(-FX, -FY, 0);
end;

procedure TPyCamera.Reset();
begin
  if Assigned(FWindow) then
  begin
    glPopMatrix();
  end;
  FX := 0;
  FY := 0;
  FRotation := 0;
  FScale := 1;
end;

{$ENDREGION}

{$REGION ' Pyro.LocalDb '}
{ TPyLocalDb }
procedure TPyLocalDb.SetMacroValue(const AName, AValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace('&'+AName, AValue);
end;

procedure TPyLocalDb.SetParamValue(const AName, AValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace(':'+AName, ''''+AValue+'''');
end;

procedure TPyLocalDb.Prepair();
var
  LKey: string;
begin
  FPrepairedSQL := FSQL.Text;

  // Substitute macros
  for LKey in FMacros.Keys do
  begin
    SetMacroValue(LKey, FMacros.Items[LKey]);
  end;

  // Substitute field params
  for LKey in FParams.Keys do
  begin
    SetParamValue(LKey, FParams.Items[LKey]);
  end;
end;

constructor TPyLocalDb.Create();
begin
  inherited;

  FSQL := TStringList.Create;
  FMacros := TDictionary<string, string>.Create;
  FParams := TDictionary<string, string>.Create;
end;

destructor TPyLocalDb.Destroy();
begin
  Close();
  FParams.Free();
  FMacros.Free();
  FSQL.Free();

  inherited;
end;

function TPyLocalDb.IsOpen(): Boolean;
begin
  Result := Assigned(FHandle);
end;

function TPyLocalDb.Open(const AFilename: string): Boolean;
begin
  Result := False;

  if IsOpen() then
  begin
    FLastError := 'Database already open';
    Exit;
  end;

  FDatabase := TPath.ChangeExtension(AFilename, 'db');
  if sqlite3_open(PAnsiChar(AnsiString(FDatabase)), @FHandle) <> SQLITE_OK then
  begin
    FLastError := string(sqlite3_errmsg(FHandle));
    sqlite3_close(FHandle);
    FHandle := nil;
  end;

  Result := IsOpen();
end;

procedure TPyLocalDb.Close();
begin
  if not IsOpen() then
  begin
    FLastError := 'Database was not open';
    Exit;
  end;

  if Assigned(FJSON) then
  begin
    FJSON.Free();
    FJSON := nil;
  end;

  if Assigned(FStmt) then
  begin
    sqlite3_finalize(FStmt);
    FStmt := nil;
  end;

  if Assigned(FHandle) then
  begin
    sqlite3_close(FHandle);
    FHandle := nil;
  end;

  ClearMacros();
  ClearParams();
  ClearSQLText();

  FDatabase := '';
  FResponseText := '';
  FLastError := '';
  FPrepairedSQL := '';
end;

procedure TPyLocalDb.ClearSQLText();
begin
  FSQL.Clear;
end;

procedure TPyLocalDb.AddSQLText(const AText: string);
begin
  FSQL.Add(AText);
end;

function TPyLocalDb.GetSQLText(): string;
begin
  Result := FSQL.Text;
end;

procedure TPyLocalDb.SetSQLText(const AText: string);
begin
  FSQL.Text := AText;
end;

function  TPyLocalDb.GetPrepairedSQL(): string;
begin
  Result := FPrepairedSQL;
end;

procedure TPyLocalDb.ClearMacros();
begin
  FMacros.Clear();
end;

function TPyLocalDb.GetMacro(const AName: string): string;
begin
  FMacros.TryGetValue(AName, Result);
end;

procedure TPyLocalDb.SetMacro(const AName, AValue: string);
begin
  FMacros.AddOrSetValue(AName, AValue);
end;

procedure TPyLocalDb.ClearParams();
begin
  FParams.Clear();
end;

function TPyLocalDb.GetParam(const AName: string): string;
begin
  FParams.TryGetValue(AName, Result);
end;

procedure TPyLocalDb.SetParam(const AName, AValue: string);
begin
  FParams.AddOrSetValue(AName, AValue);
end;

function TPyLocalDb.RecordCount(): Integer;
begin
  Result := 0;
  if not Assigned(FDataset) then Exit;
  Result := FDataset.Count;
end;

function TPyLocalDb.GetField(const AIndex: Cardinal; const AName: string): string;
begin
  Result := '';
  if not Assigned(FDataset) then Exit;
  if AIndex > Cardinal(FDataset.Count-1) then Exit;
  Result := FDataset.Items[AIndex].GetValue<string>(AName);
end;

function TPyLocalDb.Execute(): Boolean;
begin
  Prepair;
  Result := ExecuteSQL(FPrepairedSQL);
end;

function TPyLocalDb.ExecuteSQL(const ASQL: string): Boolean;
begin
  Result := ExecuteSQLInternal(ASQL);
end;

function TPyLocalDb.ExecuteSQLInternal(const ASQL: string): Boolean;
var
  LRes: Integer;
  I: Integer;
  LName: string;
  LValue: string;

  function GetTypeAsString(AStmt: Psqlite3_stmt; AColumn: Integer): string;
  begin
    case sqlite3_column_type(AStmt, AColumn) of
      SQLITE_INTEGER: Result := IntToStr(sqlite3_column_int(AStmt, AColumn));
      SQLITE_FLOAT: Result := FloatToStr(sqlite3_column_double(AStmt, AColumn));
      SQLITE_TEXT: Result := string(PWideChar(sqlite3_column_text16(AStmt, i)));
      SQLITE_BLOB: Result := '[Blob Data]';  // BLOB data typically needs special handling
      SQLITE_NULL: Result := 'NULL';
    else
      Result := 'Unknown';
    end;
  end;

begin
  Result := False;
  if not Assigned(FHandle) then Exit;

  LRes := sqlite3_prepare16_v2(FHandle, PChar(ASQL), -1, @FStmt, nil);
  if LRes <> SQLITE_OK then
  begin
    FLastError := string(PWideChar(sqlite3_errmsg16(FHandle)));
    Exit;
  end;

  if ASQL.StartsWith('with') then
  begin
    writeln('got here');
    writeln(sqlite3_bind_text16(FStmt, 1,PChar('firearm courtroom'), -1, sqlite3_destructor_type(0)));
  end;


  LRes := sqlite3_step(FStmt);
  if (LRes <> SQLITE_DONE) and (LRes <> SQLITE_ROW) then
  begin
    FLastError := string(PWideChar(sqlite3_errmsg16(FHandle)));
    sqlite3_finalize(FStmt);
    FStmt := nil;
    Exit;
  end;

  FResponseText := '';
  if LRes = SQLITE_ROW then
  begin
    FDataset := TJSONArray.Create;
    while LRes = SQLITE_ROW do
    begin
      var Row := TJSONObject.Create;
      for i := 0 to sqlite3_column_count(FStmt) - 1 do
      begin
        LName := string(PWideChar(sqlite3_column_name16(FStmt, i)));
        LValue := GetTypeAsString(FStmt, i);

        Row.AddPair(LName, LValue);
      end;
      FDataset.AddElement(Row);
      LRes := sqlite3_step(FStmt);
    end;
    FJSON := TJSONObject.Create;
    FJSON.AddPair('response', FDataset);
    FResponseText := FJson.Format();
  end;

  FLastError := '';
  Result := True;
  sqlite3_finalize(FStmt);
  FStmt := nil;
end;

function TPyLocalDb.GetLastError(): string;
begin
  Result := FLastError;
end;

function TPyLocalDb.GetResponseText(): string;
begin
  Result := FResponseText;
end;

{$ENDREGION}

{$REGION ' Pyro.RemoteDb '}
{ TPyRemoteDb }
procedure TPyRemoteDb.SetMacroValue(const AName, AValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace('&'+AName, AValue);
end;

procedure TPyRemoteDb.SetParamValue(const AName, AValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace(':'+AName, ''''+AValue+'''');
end;

procedure TPyRemoteDb.Prepair();
var
  LKey: string;
begin
  FPrepairedSQL := FSQL.Text;

  // substitue macros
  for LKey in FMacros.Keys do
  begin
    SetMacroValue(LKey, FMacros.Items[LKey]);
  end;

  // substitue field params
  for LKey in FParams.Keys do
  begin
    SetParamValue(LKey, FParams.Items[LKey]);
  end;
end;

constructor  TPyRemoteDb.Create();
begin
  inherited;
  FSQL := TStringList.Create;
  FHttp := THTTPClient.Create;
  FMacros := TDictionary<string, string>.Create;
  FParams := TDictionary<string, string>.Create;
end;

destructor TPyRemoteDb.Destroy();
begin
  if Assigned(FJson) then
  begin
    FJson.Free();
    FJson := nil;
  end;
  FParams.Free();
  FMacros.Free();
  FHttp.Free();
  FSQL.Free();
  inherited;
end;

procedure TPyRemoteDb.Setup(const AURL, AApiKey, ADatabase: string);
begin
  FUrl := AURL + cURL;
  FApiKey := AApiKey;
  FDatabase := ADatabase;
end;

procedure TPyRemoteDb.ClearSQLText();
begin
  FSQL.Clear();
end;

procedure TPyRemoteDb.AddSQLText(const AText: string;
  const AArgs: array of const);
begin
  FSQL.Add(Format(AText, AArgs));
end;

function  TPyRemoteDb.GetSQLText: string;
begin
  Result := FSQL.Text;
end;

procedure TPyRemoteDb.SetSQLText(const AText: string);
begin
  FSQL.Text := AText;
end;

function  TPyRemoteDb.GetPrepairedSQL: string;
begin
  Result := FPrepairedSQL;
end;

procedure TPyRemoteDb.ClearMacros();
begin
  FMacros.Clear();
end;

function  TPyRemoteDb.GetMacro(const AName: string): string;
begin
  FMacros.TryGetValue(AName, Result);
end;

procedure TPyRemoteDb.SetMacro(const AName, AValue: string);
begin
  FMacros.AddOrSetValue(AName, AValue);
end;

procedure TPyRemoteDb.ClearParams();
begin
  FParams.Clear();
end;

function  TPyRemoteDb.GetParam(const AName: string): string;
begin
  FParams.TryGetValue(AName, Result);
end;

procedure TPyRemoteDb.SetParam(const AName, AValue: string);
begin
  FParams.AddOrSetValue(AName, AValue);
end;

function  TPyRemoteDb.RecordCount(): Integer;
begin
  Result := 0;
  if not Assigned(FDataset) then Exit;
  Result := FDataset.Count;
end;

function  TPyRemoteDb.GetField(const AIndex: Cardinal;
  const AName: string): string;
begin
  Result := '';
  if not Assigned(FDataset) then Exit;
  if AIndex > Cardinal(FDataset.Count-1) then Exit;
  Result := FDataset.Items[AIndex].GetValue<string>(AName);
end;

function  TPyRemoteDb.GetQueryURL(const ASQL: string): string;
begin
  Result := Format(FUrl, [FApiKey, FDatabase, ASQL]);
end;


function TPyRemoteDb.Execute(): Boolean;
begin
  Prepair;
  Result := ExecuteSQL(FPrepairedSQL);
end;

function  TPyRemoteDb.ExecuteSQL(const ASQL: string): Boolean;
var
  LResponse: IHTTPResponse;
begin
  Result := False;
  if ASQL.IsEmpty then Exit;
  LResponse := FHttp.Get(GetQueryURL(ASQL));
  FResponseText := LResponse.ContentAsString;
  if Assigned(FJson) then
  begin
    if Assigned(FJSON) then
    begin
      FJson.Free();
      FJson := nil;
    end;

    FDataset := nil;
  end;
  FJson := TJSONObject.ParseJSONValue(FResponseText) as TJSONObject;
  FLastError := FJson.GetValue('response').Value;
  Result := Boolean(FLastError.IsEmpty or SameText(FLastError, 'true'));
  if FLastError.IsEmpty then
  begin
    if Assigned(FDataset) then
    begin
      FDataset.Free();
      FDataset := nil;
    end;
    FJson.TryGetValue('response', FDataset);
  end;
  if not Assigned(FDataset) then
  begin
    FJson.Free();
    FJson := nil;
  end;
end;

function TPyRemoteDb.GetLastError(): string;
begin
  Result := FLastError;
end;

function TPyRemoteDb.GetResponseText(): string;
begin
  Result:= FResponseText;
end;

{$ENDREGION}

{$REGION ' Pyro.ConfigFile '}
{ TPyConfigFile }
constructor TPyConfigFile.Create();
begin
  inherited;
  FHandle := nil;
  FSection := TStringList.Create();
end;

destructor TPyConfigFile.Destroy();
begin
  Close;
  FSection.Free();
  inherited;
end;

function  TPyConfigFile.Open(const AFilename: string=''): Boolean;
var
  LFilename: string;
begin
  Close;
  LFilename := AFilename;
  if LFilename.IsEmpty then LFilename := TPath.ChangeExtension(ParamStr(0), 'ini');
  FHandle := TIniFile.Create(LFilename);
  Result := Boolean(FHandle <> nil);
  FFilename := LFilename;
end;

procedure TPyConfigFile.Close();
begin
  if not Opened then Exit;
  FHandle.UpdateFile;
  FreeAndNil(FHandle);
end;

function  TPyConfigFile.Opened(): Boolean;
begin
  Result := Boolean(FHandle <> nil);
end;

procedure TPyConfigFile.Update();
begin
  if not Opened then Exit;
  FHandle.UpdateFile;
end;

function  TPyConfigFile.RemoveSection(const AName: string): Boolean;
var
  LName: string;
begin
  Result := False;
  if not Opened then Exit;
  LName := AName;
  if LName.IsEmpty then Exit;
  FHandle.EraseSection(LName);
  Result := True;
end;

procedure TPyConfigFile.SetValue(const ASection, AKey, AValue: string);
begin
  if not Opened then Exit;
  FHandle.WriteString(ASection, AKey, AValue);
end;

procedure TPyConfigFile.SetValue(const ASection, AKey: string; AValue: Integer);
begin
  if not Opened then Exit;
  SetValue(ASection, AKey, AValue.ToString);
end;

procedure TPyConfigFile.SetValue(const ASection, AKey: string; AValue: Boolean);
begin
  if not Opened then Exit;
  SetValue(ASection, AKey, AValue.ToInteger);
end;

procedure TPyConfigFile.SetValue(const ASection, AKey: string; AValue: Pointer; AValueSize: Cardinal);
var
  LValue: TMemoryStream;
begin
  if not Opened then Exit;
  if AValue = nil then Exit;
  LValue := TMemoryStream.Create;
  try
    LValue.Position := 0;
    LValue.Write(AValue^, AValueSize);
    LValue.Position := 0;
    FHandle.WriteBinaryStream(ASection, AKey, LValue);
  finally
    FreeAndNil(LValue);
  end;
end;

function  TPyConfigFile.GetValue(const ASection, AKey, ADefaultValue: string): string;
begin
  Result := '';
  if not Opened then Exit;
  Result := FHandle.ReadString(ASection, AKey, ADefaultValue);
end;

function  TPyConfigFile.GetValue(const ASection, AKey: string; ADefaultValue: Integer): Integer;
var
  LResult: string;
begin
  Result := ADefaultValue;
  if not Opened then Exit;
  LResult := GetValue(ASection, AKey, ADefaultValue.ToString);
  Integer.TryParse(LResult, Result);
end;

function  TPyConfigFile.GetValue(const ASection, AKey: string; ADefaultValue: Boolean): Boolean;
begin
  Result := ADefaultValue;
  if not Opened then Exit;
  Result := GetValue(ASection, AKey, ADefaultValue.ToInteger).ToBoolean;
end;

procedure TPyConfigFile.GetValue(const ASection, AKey: string; AValue: Pointer; AValueSize: Cardinal);
var
  LValue: TMemoryStream;
  LSize: Cardinal;
begin
  if not Opened then Exit;
  if not Assigned(AValue) then Exit;
  if AValueSize = 0 then Exit;
  LValue := TMemoryStream.Create;
  try
    LValue.Position := 0;
    FHandle.ReadBinaryStream(ASection, AKey, LValue);
    LSize := AValueSize;
    if AValueSize > LValue.Size then
      LSize := LValue.Size;
    LValue.Position := 0;
    LValue.Write(AValue^, LSize);
  finally
    FreeAndNil(LValue);
  end;
end;

function  TPyConfigFile.RemoveKey(const ASection, AKey: string): Boolean;
var
  LSection: string;
  LKey: string;
begin
  Result := False;
  if not Opened then Exit;
  LSection := ASection;
  LKey := AKey;
  if LSection.IsEmpty then Exit;
  if LKey.IsEmpty then Exit;
  FHandle.DeleteKey(LSection, LKey);
  Result := True;
end;

function  TPyConfigFile.GetSectionValues(const ASection: string): Integer;
var
  LSection: string;
begin
  Result := 0;
  if not Opened then Exit;
  LSection := ASection;
  if LSection.IsEmpty then Exit;
  FSection.Clear;
  FHandle.ReadSectionValues(LSection, FSection);
  Result := FSection.Count;
end;

function  TPyConfigFile.GetSectionValue(const AIndex: Integer; const ADefaultValue: string): string;
begin
  Result := '';
  if not Opened then Exit;
  if (AIndex < 0) or (AIndex > FSection.Count - 1) then Exit;
  Result := FSection.ValueFromIndex[AIndex];
  if Result = '' then Result := ADefaultValue;
end;

function  TPyConfigFile.GetSectionValue(const AIndex, ADefaultValue: Integer): Integer;
begin
  Result := ADefaultValue;
  if not Opened then Exit;
  Result := string(GetSectionValue(AIndex, ADefaultValue.ToString)).ToInteger;
end;

function  TPyConfigFile.GetSectionValue(const AIndex: Integer; const ADefaultValue: Boolean): Boolean;
begin
  Result := ADefaultValue;
  if not Opened then Exit;
  Result := string(GetSectionValue(AIndex, ADefaultValue.ToString)).ToBoolean
end;

{$ENDREGION}

{$REGION ' Pyro '}
{$R Pyro.res}

var
  CLibsDLLHandle: THandle = 0;
  CLibsDLLFilename: string = '';

function LoadClibsDLL(var AError: string): Boolean;
var
  LResStream: TResourceStream;

  function ea2a82691aa248deb0edb292d942a60e(): string;
  const
    CValue = 'ba6f03d6b70b4dd5afc10255f830339e';
  begin
    Result := CValue;
  end;

  procedure SetError(const AText: string; const AArgs: array of const);
  begin
    AError := AText;
  end;

begin
  Result := False;
  AError := 'Failed to load Deps DLL';

  // load deps DLL
  if CLibsDLLHandle <> 0 then Exit;
  try
    if not Boolean((FindResource(HInstance, PChar(ea2a82691aa248deb0edb292d942a60e()), RT_RCDATA) <> 0)) then
    begin
      SetError('Failed to find CLibs DLL resource', []);
      Exit;
    end;

    LResStream := TResourceStream.Create(HInstance, ea2a82691aa248deb0edb292d942a60e(), RT_RCDATA);
    try
      LResStream.Position := 0;
      CLibsDLLFilename := TPath.Combine(TPath.GetTempPath, TPath.ChangeExtension(TPath.GetGUIDFileName.ToLower, '.'));

      if not PyUtils.HasEnoughDiskSpace(CLibsDLLFilename, LResStream.Size) then
      begin
        SetError('Not enough disk space to save extracted CLibs DLL', []);
        Exit;
      end;

      LResStream.SaveToFile(CLibsDLLFilename);

      if not TFile.Exists(CLibsDLLFilename) then
      begin
        SetError('Failed to find extracted CLibs DLL', []);
        Exit;
      end;

      CLibsDLLHandle := LoadLibrary(PChar(CLibsDLLFilename));
      if CLibsDLLHandle = 0 then
      begin
        SetError('Failed to load extracted CLibs DLL', []);
        Exit;
      end;

      GetExports(CLibsDLLHandle);

      Result := True;
    finally
      LResStream.Free();
    end;

  except
    on E: Exception do
      SetError('Unexpected error: %s', [E.Message]);
  end;
end;

procedure UnloadCLibsDLL();
begin
  // unload CLibs DLL
  if CLibsDLLHandle <> 0 then
  begin
    FreeLibrary(CLibsDLLHandle);
    TFile.Delete(CLibsDLLFilename);
    CLibsDLLHandle := 0;
    CLibsDLLFilename := '';
  end;
end;

{$ENDREGION}

{$REGION ' Unit Init & Fini '}

var
  LError: string;

initialization
begin
  ReportMemoryLeaksOnShutdown := True;

  try
    if not LoadClibsDLL(LError) then
    begin
      MessageBox(0, PChar(LError), 'Critical Initialization Error', MB_ICONERROR);
      Halt(1); // Exit the application with a non-zero exit code to indicate failure
    end;

    if glfwInit() <> GLFW_TRUE then
    begin
      MessageBox(0, 'Failed to initialize GLFW', 'Critical Initialization Error', MB_ICONERROR);
      Halt(1); // Exit the application with a non-zero exit code to indicate failure
    end;

    PyConsole.UnitInit();
    PyError.UnitInit();
    PyUtils.UnitInit();
    PyMath.UnitInit();
    PyVideo.UnitInit();
    PyAudio.UnitInit();

  except
    on E: Exception do
    begin
      // Display any exceptions encountered during initialization.
      MessageBox(0, PChar(E.Message), 'Critical Initialization Error', MB_ICONERROR);
      Halt(1);
    end;
  end;

end;

finalization
begin
  try
    glfwTerminate();
    UnloadClibsDLL();
  except
    on E: Exception do
    begin
      MessageBox(0, PChar(E.Message), 'Critical Shutdown Error', MB_ICONERROR);
    end;
  end;
end;
{$ENDREGION}

end.
